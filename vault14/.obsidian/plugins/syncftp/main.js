/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/asn1/lib/ber/errors.js
var require_errors = __commonJS({
  "node_modules/asn1/lib/ber/errors.js"(exports, module2) {
    module2.exports = {
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        e.name = "InvalidAsn1Error";
        e.message = msg || "";
        return e;
      }
    };
  }
});

// node_modules/asn1/lib/ber/types.js
var require_types = __commonJS({
  "node_modules/asn1/lib/ber/types.js"(exports, module2) {
    module2.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9,
      // float
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS({
  "node_modules/asn1/lib/ber/reader.js"(exports, module2) {
    var assert = require("assert");
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data) {
      if (!data || !Buffer2.isBuffer(data))
        throw new TypeError("data must be a node Buffer");
      this._buf = data;
      this._size = data.length;
      this._len = 0;
      this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "length", {
      enumerable: true,
      get: function() {
        return this._len;
      }
    });
    Object.defineProperty(Reader.prototype, "offset", {
      enumerable: true,
      get: function() {
        return this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "remain", {
      get: function() {
        return this._size - this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "buffer", {
      get: function() {
        return this._buf.slice(this._offset);
      }
    });
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1)
        return null;
      var b = this._buf[this._offset] & 255;
      if (!peek)
        this._offset += 1;
      return b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === void 0)
        offset = this._offset;
      if (offset >= this._size)
        return null;
      var lenB = this._buf[offset++] & 255;
      if (lenB === null)
        return null;
      if ((lenB & 128) === 128) {
        lenB &= 127;
        if (lenB === 0)
          throw newInvalidAsn1Error("Indefinite length not supported");
        if (lenB > 4)
          throw newInvalidAsn1Error("encoding too long");
        if (this._size - offset < lenB)
          return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 255);
      } else {
        this._len = lenB;
      }
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== void 0 && tag !== seq)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      this._offset = o;
      return seq;
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return this._readTag(ASN1.Boolean) === 0 ? false : true;
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      if (this.length === 0)
        return retbuf ? Buffer2.alloc(0) : "";
      var str = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
      return retbuf ? str : str.toString("utf8");
    };
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
      var b = this.readString(tag, true);
      if (b === null)
        return null;
      var values = [];
      var value = 0;
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 255;
        value <<= 7;
        value += byte & 127;
        if ((byte & 128) === 0) {
          values.push(value);
          value = 0;
        }
      }
      value = values.shift();
      values.unshift(value % 40);
      values.unshift(value / 40 >> 0);
      return values.join(".");
    };
    Reader.prototype._readTag = function(tag) {
      assert.ok(tag !== void 0);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > 4)
        throw newInvalidAsn1Error("Integer too long: " + this.length);
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      var fb = this._buf[this._offset];
      var value = 0;
      for (var i = 0; i < this.length; i++) {
        value <<= 8;
        value |= this._buf[this._offset++] & 255;
      }
      if ((fb & 128) === 128 && i !== 4)
        value -= 1 << i * 8;
      return value >> 0;
    };
    module2.exports = Reader;
  }
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS({
  "node_modules/asn1/lib/ber/writer.js"(exports, module2) {
    var assert = require("assert");
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge(from, to) {
      assert.ok(from);
      assert.equal(typeof from, "object");
      assert.ok(to);
      assert.equal(typeof to, "object");
      var keys = Object.getOwnPropertyNames(from);
      keys.forEach(function(key) {
        if (to[key])
          return;
        var value = Object.getOwnPropertyDescriptor(from, key);
        Object.defineProperty(to, key, value);
      });
      return to;
    }
    function Writer(options) {
      options = merge(DEFAULT_OPTS, options || {});
      this._buf = Buffer2.alloc(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
      this._seq = [];
    }
    Object.defineProperty(Writer.prototype, "buffer", {
      get: function() {
        if (this._seq.length)
          throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
        return this._buf.slice(0, this._offset);
      }
    });
    Writer.prototype.writeByte = function(b) {
      if (typeof b !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Integer;
      var sz = 4;
      while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
        sz--;
        i <<= 8;
      }
      if (sz > 4)
        throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
      while (sz-- > 0) {
        this._buf[this._offset++] = (i & 4278190080) >>> 24;
        i <<= 8;
      }
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Enumeration;
      return this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof b !== "boolean")
        throw new TypeError("argument must be a Boolean");
      if (typeof tag !== "number")
        tag = ASN1.Boolean;
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 1;
      this._buf[this._offset++] = b ? 255 : 0;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string (was: " + typeof s + ")");
      if (typeof tag !== "number")
        tag = ASN1.OctetString;
      var len = Buffer2.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof tag !== "number")
        throw new TypeError("tag must be a number");
      if (!Buffer2.isBuffer(buf))
        throw new TypeError("argument must be a buffer");
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if (!strings instanceof Array)
        throw new TypeError("argument must be an Array[String]");
      var self2 = this;
      strings.forEach(function(s) {
        self2.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string");
      if (typeof tag !== "number")
        tag = ASN1.OID;
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error("argument is not a valid OID string");
      function encodeOctet(bytes2, octet) {
        if (octet < 128) {
          bytes2.push(octet);
        } else if (octet < 16384) {
          bytes2.push(octet >>> 7 | 128);
          bytes2.push(octet & 127);
        } else if (octet < 2097152) {
          bytes2.push(octet >>> 14 | 128);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else if (octet < 268435456) {
          bytes2.push(octet >>> 21 | 128);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else {
          bytes2.push((octet >>> 28 | 128) & 255);
          bytes2.push((octet >>> 21 | 128) & 255);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        }
      }
      var tmp = s.split(".");
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self2 = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self2.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof len !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(4);
      if (len <= 127) {
        this._buf[this._offset++] = len;
      } else if (len <= 255) {
        this._buf[this._offset++] = 129;
        this._buf[this._offset++] = len;
      } else if (len <= 65535) {
        this._buf[this._offset++] = 130;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 16777215) {
        this._buf[this._offset++] = 131;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw newInvalidAsn1Error("Length too long (> 4 bytes)");
      }
    };
    Writer.prototype.startSequence = function(tag) {
      if (typeof tag !== "number")
        tag = ASN1.Sequence | ASN1.Constructor;
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
      if (len <= 127) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 255) {
        this._shift(start, len, -1);
        this._buf[seq] = 129;
        this._buf[seq + 1] = len;
      } else if (len <= 65535) {
        this._buf[seq] = 130;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 16777215) {
        this._shift(start, len, 1);
        this._buf[seq] = 131;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw newInvalidAsn1Error("Sequence too long");
      }
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert.ok(start !== void 0);
      assert.ok(len !== void 0);
      assert.ok(shift);
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      assert.ok(len);
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
        var buf = Buffer2.alloc(sz);
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    module2.exports = Writer;
  }
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS({
  "node_modules/asn1/lib/ber/index.js"(exports, module2) {
    var errors = require_errors();
    var types = require_types();
    var Reader = require_reader();
    var Writer = require_writer();
    module2.exports = {
      Reader,
      Writer
    };
    for (t in types) {
      if (types.hasOwnProperty(t))
        module2.exports[t] = types[t];
    }
    var t;
    for (e in errors) {
      if (errors.hasOwnProperty(e))
        module2.exports[e] = errors[e];
    }
    var e;
  }
});

// node_modules/asn1/lib/index.js
var require_lib = __commonJS({
  "node_modules/asn1/lib/index.js"(exports, module2) {
    var Ber = require_ber();
    module2.exports = {
      Ber,
      BerReader: Ber.Reader,
      BerWriter: Ber.Writer
    };
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module2) {
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++)
            r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        mlen = -1;
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        mlen = n;
        return mlen;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        var t, i;
        for (i = 0; i < arguments.length; i++) {
          if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
            throw new TypeError("unexpected type " + t + ", use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      if (!nacl.util) {
        nacl.util = {};
        nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
          throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
        };
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return false;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return false;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        if (arguments.length !== 2)
          throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof require !== "undefined") {
          crypto = require("crypto");
          if (crypto && crypto.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS({
  "node_modules/bcrypt-pbkdf/index.js"(exports, module2) {
    "use strict";
    var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
    var BLF_J = 0;
    var Blowfish = function() {
      this.S = [
        new Uint32Array([
          3509652390,
          2564797868,
          805139163,
          3491422135,
          3101798381,
          1780907670,
          3128725573,
          4046225305,
          614570311,
          3012652279,
          134345442,
          2240740374,
          1667834072,
          1901547113,
          2757295779,
          4103290238,
          227898511,
          1921955416,
          1904987480,
          2182433518,
          2069144605,
          3260701109,
          2620446009,
          720527379,
          3318853667,
          677414384,
          3393288472,
          3101374703,
          2390351024,
          1614419982,
          1822297739,
          2954791486,
          3608508353,
          3174124327,
          2024746970,
          1432378464,
          3864339955,
          2857741204,
          1464375394,
          1676153920,
          1439316330,
          715854006,
          3033291828,
          289532110,
          2706671279,
          2087905683,
          3018724369,
          1668267050,
          732546397,
          1947742710,
          3462151702,
          2609353502,
          2950085171,
          1814351708,
          2050118529,
          680887927,
          999245976,
          1800124847,
          3300911131,
          1713906067,
          1641548236,
          4213287313,
          1216130144,
          1575780402,
          4018429277,
          3917837745,
          3693486850,
          3949271944,
          596196993,
          3549867205,
          258830323,
          2213823033,
          772490370,
          2760122372,
          1774776394,
          2652871518,
          566650946,
          4142492826,
          1728879713,
          2882767088,
          1783734482,
          3629395816,
          2517608232,
          2874225571,
          1861159788,
          326777828,
          3124490320,
          2130389656,
          2716951837,
          967770486,
          1724537150,
          2185432712,
          2364442137,
          1164943284,
          2105845187,
          998989502,
          3765401048,
          2244026483,
          1075463327,
          1455516326,
          1322494562,
          910128902,
          469688178,
          1117454909,
          936433444,
          3490320968,
          3675253459,
          1240580251,
          122909385,
          2157517691,
          634681816,
          4142456567,
          3825094682,
          3061402683,
          2540495037,
          79693498,
          3249098678,
          1084186820,
          1583128258,
          426386531,
          1761308591,
          1047286709,
          322548459,
          995290223,
          1845252383,
          2603652396,
          3431023940,
          2942221577,
          3202600964,
          3727903485,
          1712269319,
          422464435,
          3234572375,
          1170764815,
          3523960633,
          3117677531,
          1434042557,
          442511882,
          3600875718,
          1076654713,
          1738483198,
          4213154764,
          2393238008,
          3677496056,
          1014306527,
          4251020053,
          793779912,
          2902807211,
          842905082,
          4246964064,
          1395751752,
          1040244610,
          2656851899,
          3396308128,
          445077038,
          3742853595,
          3577915638,
          679411651,
          2892444358,
          2354009459,
          1767581616,
          3150600392,
          3791627101,
          3102740896,
          284835224,
          4246832056,
          1258075500,
          768725851,
          2589189241,
          3069724005,
          3532540348,
          1274779536,
          3789419226,
          2764799539,
          1660621633,
          3471099624,
          4011903706,
          913787905,
          3497959166,
          737222580,
          2514213453,
          2928710040,
          3937242737,
          1804850592,
          3499020752,
          2949064160,
          2386320175,
          2390070455,
          2415321851,
          4061277028,
          2290661394,
          2416832540,
          1336762016,
          1754252060,
          3520065937,
          3014181293,
          791618072,
          3188594551,
          3933548030,
          2332172193,
          3852520463,
          3043980520,
          413987798,
          3465142937,
          3030929376,
          4245938359,
          2093235073,
          3534596313,
          375366246,
          2157278981,
          2479649556,
          555357303,
          3870105701,
          2008414854,
          3344188149,
          4221384143,
          3956125452,
          2067696032,
          3594591187,
          2921233993,
          2428461,
          544322398,
          577241275,
          1471733935,
          610547355,
          4027169054,
          1432588573,
          1507829418,
          2025931657,
          3646575487,
          545086370,
          48609733,
          2200306550,
          1653985193,
          298326376,
          1316178497,
          3007786442,
          2064951626,
          458293330,
          2589141269,
          3591329599,
          3164325604,
          727753846,
          2179363840,
          146436021,
          1461446943,
          4069977195,
          705550613,
          3059967265,
          3887724982,
          4281599278,
          3313849956,
          1404054877,
          2845806497,
          146425753,
          1854211946
        ]),
        new Uint32Array([
          1266315497,
          3048417604,
          3681880366,
          3289982499,
          290971e4,
          1235738493,
          2632868024,
          2414719590,
          3970600049,
          1771706367,
          1449415276,
          3266420449,
          422970021,
          1963543593,
          2690192192,
          3826793022,
          1062508698,
          1531092325,
          1804592342,
          2583117782,
          2714934279,
          4024971509,
          1294809318,
          4028980673,
          1289560198,
          2221992742,
          1669523910,
          35572830,
          157838143,
          1052438473,
          1016535060,
          1802137761,
          1753167236,
          1386275462,
          3080475397,
          2857371447,
          1040679964,
          2145300060,
          2390574316,
          1461121720,
          2956646967,
          4031777805,
          4028374788,
          33600511,
          2920084762,
          1018524850,
          629373528,
          3691585981,
          3515945977,
          2091462646,
          2486323059,
          586499841,
          988145025,
          935516892,
          3367335476,
          2599673255,
          2839830854,
          265290510,
          3972581182,
          2759138881,
          3795373465,
          1005194799,
          847297441,
          406762289,
          1314163512,
          1332590856,
          1866599683,
          4127851711,
          750260880,
          613907577,
          1450815602,
          3165620655,
          3734664991,
          3650291728,
          3012275730,
          3704569646,
          1427272223,
          778793252,
          1343938022,
          2676280711,
          2052605720,
          1946737175,
          3164576444,
          3914038668,
          3967478842,
          3682934266,
          1661551462,
          3294938066,
          4011595847,
          840292616,
          3712170807,
          616741398,
          312560963,
          711312465,
          1351876610,
          322626781,
          1910503582,
          271666773,
          2175563734,
          1594956187,
          70604529,
          3617834859,
          1007753275,
          1495573769,
          4069517037,
          2549218298,
          2663038764,
          504708206,
          2263041392,
          3941167025,
          2249088522,
          1514023603,
          1998579484,
          1312622330,
          694541497,
          2582060303,
          2151582166,
          1382467621,
          776784248,
          2618340202,
          3323268794,
          2497899128,
          2784771155,
          503983604,
          4076293799,
          907881277,
          423175695,
          432175456,
          1378068232,
          4145222326,
          3954048622,
          3938656102,
          3820766613,
          2793130115,
          2977904593,
          26017576,
          3274890735,
          3194772133,
          1700274565,
          1756076034,
          4006520079,
          3677328699,
          720338349,
          1533947780,
          354530856,
          688349552,
          3973924725,
          1637815568,
          332179504,
          3949051286,
          53804574,
          2852348879,
          3044236432,
          1282449977,
          3583942155,
          3416972820,
          4006381244,
          1617046695,
          2628476075,
          3002303598,
          1686838959,
          431878346,
          2686675385,
          1700445008,
          1080580658,
          1009431731,
          832498133,
          3223435511,
          2605976345,
          2271191193,
          2516031870,
          1648197032,
          4164389018,
          2548247927,
          300782431,
          375919233,
          238389289,
          3353747414,
          2531188641,
          2019080857,
          1475708069,
          455242339,
          2609103871,
          448939670,
          3451063019,
          1395535956,
          2413381860,
          1841049896,
          1491858159,
          885456874,
          4264095073,
          4001119347,
          1565136089,
          3898914787,
          1108368660,
          540939232,
          1173283510,
          2745871338,
          3681308437,
          4207628240,
          3343053890,
          4016749493,
          1699691293,
          1103962373,
          3625875870,
          2256883143,
          3830138730,
          1031889488,
          3479347698,
          1535977030,
          4236805024,
          3251091107,
          2132092099,
          1774941330,
          1199868427,
          1452454533,
          157007616,
          2904115357,
          342012276,
          595725824,
          1480756522,
          206960106,
          497939518,
          591360097,
          863170706,
          2375253569,
          3596610801,
          1814182875,
          2094937945,
          3421402208,
          1082520231,
          3463918190,
          2785509508,
          435703966,
          3908032597,
          1641649973,
          2842273706,
          3305899714,
          1510255612,
          2148256476,
          2655287854,
          3276092548,
          4258621189,
          236887753,
          3681803219,
          274041037,
          1734335097,
          3815195456,
          3317970021,
          1899903192,
          1026095262,
          4050517792,
          356393447,
          2410691914,
          3873677099,
          3682840055
        ]),
        new Uint32Array([
          3913112168,
          2491498743,
          4132185628,
          2489919796,
          1091903735,
          1979897079,
          3170134830,
          3567386728,
          3557303409,
          857797738,
          1136121015,
          1342202287,
          507115054,
          2535736646,
          337727348,
          3213592640,
          1301675037,
          2528481711,
          1895095763,
          1721773893,
          3216771564,
          62756741,
          2142006736,
          835421444,
          2531993523,
          1442658625,
          3659876326,
          2882144922,
          676362277,
          1392781812,
          170690266,
          3921047035,
          1759253602,
          3611846912,
          1745797284,
          664899054,
          1329594018,
          3901205900,
          3045908486,
          2062866102,
          2865634940,
          3543621612,
          3464012697,
          1080764994,
          553557557,
          3656615353,
          3996768171,
          991055499,
          499776247,
          1265440854,
          648242737,
          3940784050,
          980351604,
          3713745714,
          1749149687,
          3396870395,
          4211799374,
          3640570775,
          1161844396,
          3125318951,
          1431517754,
          545492359,
          4268468663,
          3499529547,
          1437099964,
          2702547544,
          3433638243,
          2581715763,
          2787789398,
          1060185593,
          1593081372,
          2418618748,
          4260947970,
          69676912,
          2159744348,
          86519011,
          2512459080,
          3838209314,
          1220612927,
          3339683548,
          133810670,
          1090789135,
          1078426020,
          1569222167,
          845107691,
          3583754449,
          4072456591,
          1091646820,
          628848692,
          1613405280,
          3757631651,
          526609435,
          236106946,
          48312990,
          2942717905,
          3402727701,
          1797494240,
          859738849,
          992217954,
          4005476642,
          2243076622,
          3870952857,
          3732016268,
          765654824,
          3490871365,
          2511836413,
          1685915746,
          3888969200,
          1414112111,
          2273134842,
          3281911079,
          4080962846,
          172450625,
          2569994100,
          980381355,
          4109958455,
          2819808352,
          2716589560,
          2568741196,
          3681446669,
          3329971472,
          1835478071,
          660984891,
          3704678404,
          4045999559,
          3422617507,
          3040415634,
          1762651403,
          1719377915,
          3470491036,
          2693910283,
          3642056355,
          3138596744,
          1364962596,
          2073328063,
          1983633131,
          926494387,
          3423689081,
          2150032023,
          4096667949,
          1749200295,
          3328846651,
          309677260,
          2016342300,
          1779581495,
          3079819751,
          111262694,
          1274766160,
          443224088,
          298511866,
          1025883608,
          3806446537,
          1145181785,
          168956806,
          3641502830,
          3584813610,
          1689216846,
          3666258015,
          3200248200,
          1692713982,
          2646376535,
          4042768518,
          1618508792,
          1610833997,
          3523052358,
          4130873264,
          2001055236,
          3610705100,
          2202168115,
          4028541809,
          2961195399,
          1006657119,
          2006996926,
          3186142756,
          1430667929,
          3210227297,
          1314452623,
          4074634658,
          4101304120,
          2273951170,
          1399257539,
          3367210612,
          3027628629,
          1190975929,
          2062231137,
          2333990788,
          2221543033,
          2438960610,
          1181637006,
          548689776,
          2362791313,
          3372408396,
          3104550113,
          3145860560,
          296247880,
          1970579870,
          3078560182,
          3769228297,
          1714227617,
          3291629107,
          3898220290,
          166772364,
          1251581989,
          493813264,
          448347421,
          195405023,
          2709975567,
          677966185,
          3703036547,
          1463355134,
          2715995803,
          1338867538,
          1343315457,
          2802222074,
          2684532164,
          233230375,
          2599980071,
          2000651841,
          3277868038,
          1638401717,
          4028070440,
          3237316320,
          6314154,
          819756386,
          300326615,
          590932579,
          1405279636,
          3267499572,
          3150704214,
          2428286686,
          3959192993,
          3461946742,
          1862657033,
          1266418056,
          963775037,
          2089974820,
          2263052895,
          1917689273,
          448879540,
          3550394620,
          3981727096,
          150775221,
          3627908307,
          1303187396,
          508620638,
          2975983352,
          2726630617,
          1817252668,
          1876281319,
          1457606340,
          908771278,
          3720792119,
          3617206836,
          2455994898,
          1729034894,
          1080033504
        ]),
        new Uint32Array([
          976866871,
          3556439503,
          2881648439,
          1522871579,
          1555064734,
          1336096578,
          3548522304,
          2579274686,
          3574697629,
          3205460757,
          3593280638,
          3338716283,
          3079412587,
          564236357,
          2993598910,
          1781952180,
          1464380207,
          3163844217,
          3332601554,
          1699332808,
          1393555694,
          1183702653,
          3581086237,
          1288719814,
          691649499,
          2847557200,
          2895455976,
          3193889540,
          2717570544,
          1781354906,
          1676643554,
          2592534050,
          3230253752,
          1126444790,
          2770207658,
          2633158820,
          2210423226,
          2615765581,
          2414155088,
          3127139286,
          673620729,
          2805611233,
          1269405062,
          4015350505,
          3341807571,
          4149409754,
          1057255273,
          2012875353,
          2162469141,
          2276492801,
          2601117357,
          993977747,
          3918593370,
          2654263191,
          753973209,
          36408145,
          2530585658,
          25011837,
          3520020182,
          2088578344,
          530523599,
          2918365339,
          1524020338,
          1518925132,
          3760827505,
          3759777254,
          1202760957,
          3985898139,
          3906192525,
          674977740,
          4174734889,
          2031300136,
          2019492241,
          3983892565,
          4153806404,
          3822280332,
          352677332,
          2297720250,
          60907813,
          90501309,
          3286998549,
          1016092578,
          2535922412,
          2839152426,
          457141659,
          509813237,
          4120667899,
          652014361,
          1966332200,
          2975202805,
          55981186,
          2327461051,
          676427537,
          3255491064,
          2882294119,
          3433927263,
          1307055953,
          942726286,
          933058658,
          2468411793,
          3933900994,
          4215176142,
          1361170020,
          2001714738,
          2830558078,
          3274259782,
          1222529897,
          1679025792,
          2729314320,
          3714953764,
          1770335741,
          151462246,
          3013232138,
          1682292957,
          1483529935,
          471910574,
          1539241949,
          458788160,
          3436315007,
          1807016891,
          3718408830,
          978976581,
          1043663428,
          3165965781,
          1927990952,
          4200891579,
          2372276910,
          3208408903,
          3533431907,
          1412390302,
          2931980059,
          4132332400,
          1947078029,
          3881505623,
          4168226417,
          2941484381,
          1077988104,
          1320477388,
          886195818,
          18198404,
          3786409e3,
          2509781533,
          112762804,
          3463356488,
          1866414978,
          891333506,
          18488651,
          661792760,
          1628790961,
          3885187036,
          3141171499,
          876946877,
          2693282273,
          1372485963,
          791857591,
          2686433993,
          3759982718,
          3167212022,
          3472953795,
          2716379847,
          445679433,
          3561995674,
          3504004811,
          3574258232,
          54117162,
          3331405415,
          2381918588,
          3769707343,
          4154350007,
          1140177722,
          4074052095,
          668550556,
          3214352940,
          367459370,
          261225585,
          2610173221,
          4209349473,
          3468074219,
          3265815641,
          314222801,
          3066103646,
          3808782860,
          282218597,
          3406013506,
          3773591054,
          379116347,
          1285071038,
          846784868,
          2669647154,
          3771962079,
          3550491691,
          2305946142,
          453669953,
          1268987020,
          3317592352,
          3279303384,
          3744833421,
          2610507566,
          3859509063,
          266596637,
          3847019092,
          517658769,
          3462560207,
          3443424879,
          370717030,
          4247526661,
          2224018117,
          4143653529,
          4112773975,
          2788324899,
          2477274417,
          1456262402,
          2901442914,
          1517677493,
          1846949527,
          2295493580,
          3734397586,
          2176403920,
          1280348187,
          1908823572,
          3871786941,
          846861322,
          1172426758,
          3287448474,
          3383383037,
          1655181056,
          3139813346,
          901632758,
          1897031941,
          2986607138,
          3066810236,
          3447102507,
          1393639104,
          373351379,
          950779232,
          625454576,
          3124240540,
          4148612726,
          2007998917,
          544563296,
          2244738638,
          2330496472,
          2058025392,
          1291430526,
          424198748,
          50039436,
          29584100,
          3605783033,
          2429876329,
          2791104160,
          1057563949,
          3255363231,
          3075367218,
          3463963227,
          1469046755,
          985887462
        ])
      ];
      this.P = new Uint32Array([
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ]);
    };
    function F(S, x8, i) {
      return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
    }
    Blowfish.prototype.encipher = function(x, x8) {
      if (x8 === void 0) {
        x8 = new Uint8Array(x.buffer);
        if (x.byteOffset !== 0)
          x8 = x8.subarray(x.byteOffset);
      }
      x[0] ^= this.P[0];
      for (var i = 1; i < 16; i += 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[17];
      x[1] = t;
    };
    Blowfish.prototype.decipher = function(x) {
      var x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0)
        x8 = x8.subarray(x.byteOffset);
      x[0] ^= this.P[17];
      for (var i = 16; i > 0; i -= 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[0];
      x[1] = t;
    };
    function stream2word(data, databytes) {
      var i, temp = 0;
      for (i = 0; i < 4; i++, BLF_J++) {
        if (BLF_J >= databytes)
          BLF_J = 0;
        temp = temp << 8 | data[BLF_J];
      }
      return temp;
    }
    Blowfish.prototype.expand0state = function(key, keybytes) {
      var d = new Uint32Array(2), i, k;
      var d8 = new Uint8Array(d.buffer);
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      BLF_J = 0;
      for (i = 0; i < 18; i += 2) {
        this.encipher(d, d8);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          this.encipher(d, d8);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
    };
    Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
      var d = new Uint32Array(2), i, k;
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      for (i = 0, BLF_J = 0; i < 18; i += 2) {
        d[0] ^= stream2word(data, databytes);
        d[1] ^= stream2word(data, databytes);
        this.encipher(d);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          d[0] ^= stream2word(data, databytes);
          d[1] ^= stream2word(data, databytes);
          this.encipher(d);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
      BLF_J = 0;
    };
    Blowfish.prototype.enc = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.encipher(data.subarray(i * 2));
      }
    };
    Blowfish.prototype.dec = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.decipher(data.subarray(i * 2));
      }
    };
    var BCRYPT_BLOCKS = 8;
    var BCRYPT_HASHSIZE = 32;
    function bcrypt_hash(sha2pass, sha2salt, out) {
      var state = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
        79,
        120,
        121,
        99,
        104,
        114,
        111,
        109,
        97,
        116,
        105,
        99,
        66,
        108,
        111,
        119,
        102,
        105,
        115,
        104,
        83,
        119,
        97,
        116,
        68,
        121,
        110,
        97,
        109,
        105,
        116,
        101
      ]);
      state.expandstate(sha2salt, 64, sha2pass, 64);
      for (i = 0; i < 64; i++) {
        state.expand0state(sha2salt, 64);
        state.expand0state(sha2pass, 64);
      }
      for (i = 0; i < BCRYPT_BLOCKS; i++)
        cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
      for (i = 0; i < 64; i++)
        state.enc(cdata, cdata.byteLength / 8);
      for (i = 0; i < BCRYPT_BLOCKS; i++) {
        out[4 * i + 3] = cdata[i] >>> 24;
        out[4 * i + 2] = cdata[i] >>> 16;
        out[4 * i + 1] = cdata[i] >>> 8;
        out[4 * i + 0] = cdata[i];
      }
    }
    function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
      var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
      if (rounds < 1)
        return -1;
      if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
        return -1;
      stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
      amt = Math.floor((keylen + stride - 1) / stride);
      for (i = 0; i < saltlen; i++)
        countsalt[i] = salt[i];
      crypto_hash_sha512(sha2pass, pass, passlen);
      for (count = 1; keylen > 0; count++) {
        countsalt[saltlen + 0] = count >>> 24;
        countsalt[saltlen + 1] = count >>> 16;
        countsalt[saltlen + 2] = count >>> 8;
        countsalt[saltlen + 3] = count;
        crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (i = out.byteLength; i--; )
          out[i] = tmpout[i];
        for (i = 1; i < rounds; i++) {
          crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
          bcrypt_hash(sha2pass, sha2salt, tmpout);
          for (j = 0; j < out.byteLength; j++)
            out[j] ^= tmpout[j];
        }
        amt = Math.min(amt, keylen);
        for (i = 0; i < amt; i++) {
          dest = i * stride + (count - 1);
          if (dest >= origkeylen)
            break;
          key[dest] = out[i];
        }
        keylen -= i;
      }
      return 0;
    }
    module2.exports = {
      BLOCKS: BCRYPT_BLOCKS,
      HASHSIZE: BCRYPT_HASHSIZE,
      hash: bcrypt_hash,
      pbkdf: bcrypt_pbkdf
    };
  }
});

// node_modules/cpu-features/build/Release/cpufeatures.node
var require_cpufeatures = __commonJS({
  "node_modules/cpu-features/build/Release/cpufeatures.node"(exports, module2) {
    module2.exports = "./cpufeatures-RNZ32ETZ.node";
  }
});

// node_modules/cpu-features/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/cpu-features/lib/index.js"(exports, module2) {
    "use strict";
    var binding = require_cpufeatures();
    module2.exports = binding.getCPUInfo;
  }
});

// node_modules/ssh2/lib/protocol/constants.js
var require_constants = __commonJS({
  "node_modules/ssh2/lib/protocol/constants.js"(exports, module2) {
    "use strict";
    var crypto = require("crypto");
    var cpuInfo;
    try {
      cpuInfo = require_lib2()();
    } catch {
    }
    var { bindingAvailable, CIPHER_INFO, MAC_INFO } = require_crypto();
    var eddsaSupported = (() => {
      if (typeof crypto.sign === "function" && typeof crypto.verify === "function") {
        const key = "-----BEGIN PRIVATE KEY-----\r\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\r\n-----END PRIVATE KEY-----";
        const data = Buffer.from("a");
        let sig;
        let verified;
        try {
          sig = crypto.sign(null, data, key);
          verified = crypto.verify(null, data, key, sig);
        } catch {
        }
        return Buffer.isBuffer(sig) && sig.length === 64 && verified === true;
      }
      return false;
    })();
    var curve25519Supported = typeof crypto.diffieHellman === "function" && typeof crypto.generateKeyPairSync === "function" && typeof crypto.createPublicKey === "function";
    var DEFAULT_KEX = [
      // https://tools.ietf.org/html/rfc5656#section-10.1
      "ecdh-sha2-nistp256",
      "ecdh-sha2-nistp384",
      "ecdh-sha2-nistp521",
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha256",
      // https://tools.ietf.org/html/rfc8268
      "diffie-hellman-group14-sha256",
      "diffie-hellman-group15-sha512",
      "diffie-hellman-group16-sha512",
      "diffie-hellman-group17-sha512",
      "diffie-hellman-group18-sha512"
    ];
    if (curve25519Supported) {
      DEFAULT_KEX.unshift("curve25519-sha256");
      DEFAULT_KEX.unshift("curve25519-sha256@libssh.org");
    }
    var SUPPORTED_KEX = DEFAULT_KEX.concat([
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha1",
      "diffie-hellman-group14-sha1",
      // REQUIRED
      "diffie-hellman-group1-sha1"
      // REQUIRED
    ]);
    var DEFAULT_SERVER_HOST_KEY = [
      "ecdsa-sha2-nistp256",
      "ecdsa-sha2-nistp384",
      "ecdsa-sha2-nistp521",
      "rsa-sha2-512",
      // RFC 8332
      "rsa-sha2-256",
      // RFC 8332
      "ssh-rsa"
    ];
    if (eddsaSupported)
      DEFAULT_SERVER_HOST_KEY.unshift("ssh-ed25519");
    var SUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat([
      "ssh-dss"
    ]);
    var canUseCipher = (() => {
      const ciphers = crypto.getCiphers();
      return (name) => ciphers.includes(CIPHER_INFO[name].sslName);
    })();
    var DEFAULT_CIPHER = [
      // http://tools.ietf.org/html/rfc5647
      "aes128-gcm@openssh.com",
      "aes256-gcm@openssh.com",
      // http://tools.ietf.org/html/rfc4344#section-4
      "aes128-ctr",
      "aes192-ctr",
      "aes256-ctr"
    ];
    if (cpuInfo && cpuInfo.flags && !cpuInfo.flags.aes) {
      if (bindingAvailable)
        DEFAULT_CIPHER.unshift("chacha20-poly1305@openssh.com");
      else
        DEFAULT_CIPHER.push("chacha20-poly1305@openssh.com");
    } else if (bindingAvailable && cpuInfo && cpuInfo.arch === "x86") {
      DEFAULT_CIPHER.splice(4, 0, "chacha20-poly1305@openssh.com");
    } else {
      DEFAULT_CIPHER.push("chacha20-poly1305@openssh.com");
    }
    DEFAULT_CIPHER = DEFAULT_CIPHER.filter(canUseCipher);
    var SUPPORTED_CIPHER = DEFAULT_CIPHER.concat([
      "aes256-cbc",
      "aes192-cbc",
      "aes128-cbc",
      "blowfish-cbc",
      "3des-cbc",
      "aes128-gcm",
      "aes256-gcm",
      // http://tools.ietf.org/html/rfc4345#section-4:
      "arcfour256",
      "arcfour128",
      "cast128-cbc",
      "arcfour"
    ].filter(canUseCipher));
    var canUseMAC = (() => {
      const hashes = crypto.getHashes();
      return (name) => hashes.includes(MAC_INFO[name].sslName);
    })();
    var DEFAULT_MAC = [
      "hmac-sha2-256-etm@openssh.com",
      "hmac-sha2-512-etm@openssh.com",
      "hmac-sha1-etm@openssh.com",
      "hmac-sha2-256",
      "hmac-sha2-512",
      "hmac-sha1"
    ].filter(canUseMAC);
    var SUPPORTED_MAC = DEFAULT_MAC.concat([
      "hmac-md5",
      "hmac-sha2-256-96",
      // first 96 bits of HMAC-SHA256
      "hmac-sha2-512-96",
      // first 96 bits of HMAC-SHA512
      "hmac-ripemd160",
      "hmac-sha1-96",
      // first 96 bits of HMAC-SHA1
      "hmac-md5-96"
      // first 96 bits of HMAC-MD5
    ].filter(canUseMAC));
    var DEFAULT_COMPRESSION = [
      "none",
      "zlib@openssh.com",
      // ZLIB (LZ77) compression, except
      // compression/decompression does not start until after
      // successful user authentication
      "zlib"
      // ZLIB (LZ77) compression
    ];
    var SUPPORTED_COMPRESSION = DEFAULT_COMPRESSION.concat([]);
    var COMPAT = {
      BAD_DHGEX: 1 << 0,
      OLD_EXIT: 1 << 1,
      DYN_RPORT_BUG: 1 << 2,
      BUG_DHGEX_LARGE: 1 << 3,
      IMPLY_RSA_SHA2_SIGALGS: 1 << 4
    };
    module2.exports = {
      MESSAGE: {
        // Transport layer protocol -- generic (1-19)
        DISCONNECT: 1,
        IGNORE: 2,
        UNIMPLEMENTED: 3,
        DEBUG: 4,
        SERVICE_REQUEST: 5,
        SERVICE_ACCEPT: 6,
        EXT_INFO: 7,
        // RFC 8308
        // Transport layer protocol -- algorithm negotiation (20-29)
        KEXINIT: 20,
        NEWKEYS: 21,
        // Transport layer protocol -- key exchange method-specific (30-49)
        KEXDH_INIT: 30,
        KEXDH_REPLY: 31,
        KEXDH_GEX_GROUP: 31,
        KEXDH_GEX_INIT: 32,
        KEXDH_GEX_REPLY: 33,
        KEXDH_GEX_REQUEST: 34,
        KEXECDH_INIT: 30,
        KEXECDH_REPLY: 31,
        // User auth protocol -- generic (50-59)
        USERAUTH_REQUEST: 50,
        USERAUTH_FAILURE: 51,
        USERAUTH_SUCCESS: 52,
        USERAUTH_BANNER: 53,
        // User auth protocol -- user auth method-specific (60-79)
        USERAUTH_PASSWD_CHANGEREQ: 60,
        USERAUTH_PK_OK: 60,
        USERAUTH_INFO_REQUEST: 60,
        USERAUTH_INFO_RESPONSE: 61,
        // Connection protocol -- generic (80-89)
        GLOBAL_REQUEST: 80,
        REQUEST_SUCCESS: 81,
        REQUEST_FAILURE: 82,
        // Connection protocol -- channel-related (90-127)
        CHANNEL_OPEN: 90,
        CHANNEL_OPEN_CONFIRMATION: 91,
        CHANNEL_OPEN_FAILURE: 92,
        CHANNEL_WINDOW_ADJUST: 93,
        CHANNEL_DATA: 94,
        CHANNEL_EXTENDED_DATA: 95,
        CHANNEL_EOF: 96,
        CHANNEL_CLOSE: 97,
        CHANNEL_REQUEST: 98,
        CHANNEL_SUCCESS: 99,
        CHANNEL_FAILURE: 100
        // Reserved for client protocols (128-191)
        // Local extensions (192-155)
      },
      DISCONNECT_REASON: {
        HOST_NOT_ALLOWED_TO_CONNECT: 1,
        PROTOCOL_ERROR: 2,
        KEY_EXCHANGE_FAILED: 3,
        RESERVED: 4,
        MAC_ERROR: 5,
        COMPRESSION_ERROR: 6,
        SERVICE_NOT_AVAILABLE: 7,
        PROTOCOL_VERSION_NOT_SUPPORTED: 8,
        HOST_KEY_NOT_VERIFIABLE: 9,
        CONNECTION_LOST: 10,
        BY_APPLICATION: 11,
        TOO_MANY_CONNECTIONS: 12,
        AUTH_CANCELED_BY_USER: 13,
        NO_MORE_AUTH_METHODS_AVAILABLE: 14,
        ILLEGAL_USER_NAME: 15
      },
      DISCONNECT_REASON_STR: void 0,
      CHANNEL_OPEN_FAILURE: {
        ADMINISTRATIVELY_PROHIBITED: 1,
        CONNECT_FAILED: 2,
        UNKNOWN_CHANNEL_TYPE: 3,
        RESOURCE_SHORTAGE: 4
      },
      TERMINAL_MODE: {
        TTY_OP_END: 0,
        // Indicates end of options.
        VINTR: 1,
        // Interrupt character; 255 if none. Similarly for the
        //  other characters.  Not all of these characters are
        //  supported on all systems.
        VQUIT: 2,
        // The quit character (sends SIGQUIT signal on POSIX
        //  systems).
        VERASE: 3,
        // Erase the character to left of the cursor.
        VKILL: 4,
        // Kill the current input line.
        VEOF: 5,
        // End-of-file character (sends EOF from the
        //  terminal).
        VEOL: 6,
        // End-of-line character in addition to carriage
        //  return and/or linefeed.
        VEOL2: 7,
        // Additional end-of-line character.
        VSTART: 8,
        // Continues paused output (normally control-Q).
        VSTOP: 9,
        // Pauses output (normally control-S).
        VSUSP: 10,
        // Suspends the current program.
        VDSUSP: 11,
        // Another suspend character.
        VREPRINT: 12,
        // Reprints the current input line.
        VWERASE: 13,
        // Erases a word left of cursor.
        VLNEXT: 14,
        // Enter the next character typed literally, even if
        //  it is a special character
        VFLUSH: 15,
        // Character to flush output.
        VSWTCH: 16,
        // Switch to a different shell layer.
        VSTATUS: 17,
        // Prints system status line (load, command, pid,
        //  etc).
        VDISCARD: 18,
        // Toggles the flushing of terminal output.
        IGNPAR: 30,
        // The ignore parity flag.  The parameter SHOULD be 0
        //  if this flag is FALSE, and 1 if it is TRUE.
        PARMRK: 31,
        // Mark parity and framing errors.
        INPCK: 32,
        // Enable checking of parity errors.
        ISTRIP: 33,
        // Strip 8th bit off characters.
        INLCR: 34,
        // Map NL into CR on input.
        IGNCR: 35,
        // Ignore CR on input.
        ICRNL: 36,
        // Map CR to NL on input.
        IUCLC: 37,
        // Translate uppercase characters to lowercase.
        IXON: 38,
        // Enable output flow control.
        IXANY: 39,
        // Any char will restart after stop.
        IXOFF: 40,
        // Enable input flow control.
        IMAXBEL: 41,
        // Ring bell on input queue full.
        ISIG: 50,
        // Enable signals INTR, QUIT, [D]SUSP.
        ICANON: 51,
        // Canonicalize input lines.
        XCASE: 52,
        // Enable input and output of uppercase characters by
        //  preceding their lowercase equivalents with "\".
        ECHO: 53,
        // Enable echoing.
        ECHOE: 54,
        // Visually erase chars.
        ECHOK: 55,
        // Kill character discards current line.
        ECHONL: 56,
        // Echo NL even if ECHO is off.
        NOFLSH: 57,
        // Don't flush after interrupt.
        TOSTOP: 58,
        // Stop background jobs from output.
        IEXTEN: 59,
        // Enable extensions.
        ECHOCTL: 60,
        // Echo control characters as ^(Char).
        ECHOKE: 61,
        // Visual erase for line kill.
        PENDIN: 62,
        // Retype pending input.
        OPOST: 70,
        // Enable output processing.
        OLCUC: 71,
        // Convert lowercase to uppercase.
        ONLCR: 72,
        // Map NL to CR-NL.
        OCRNL: 73,
        // Translate carriage return to newline (output).
        ONOCR: 74,
        // Translate newline to carriage return-newline
        //  (output).
        ONLRET: 75,
        // Newline performs a carriage return (output).
        CS7: 90,
        // 7 bit mode.
        CS8: 91,
        // 8 bit mode.
        PARENB: 92,
        // Parity enable.
        PARODD: 93,
        // Odd parity, else even.
        TTY_OP_ISPEED: 128,
        // Specifies the input baud rate in bits per second.
        TTY_OP_OSPEED: 129
        // Specifies the output baud rate in bits per second.
      },
      CHANNEL_EXTENDED_DATATYPE: {
        STDERR: 1
      },
      SIGNALS: [
        "ABRT",
        "ALRM",
        "FPE",
        "HUP",
        "ILL",
        "INT",
        "QUIT",
        "SEGV",
        "TERM",
        "USR1",
        "USR2",
        "KILL",
        "PIPE"
      ].reduce((cur, val) => ({ ...cur, [val]: 1 }), {}),
      COMPAT,
      COMPAT_CHECKS: [
        ["Cisco-1.25", COMPAT.BAD_DHGEX],
        [/^Cisco-1[.]/, COMPAT.BUG_DHGEX_LARGE],
        [/^[0-9.]+$/, COMPAT.OLD_EXIT],
        // old SSH.com implementations
        [/^OpenSSH_5[.][0-9]+/, COMPAT.DYN_RPORT_BUG],
        [/^OpenSSH_7[.]4/, COMPAT.IMPLY_RSA_SHA2_SIGALGS]
      ],
      // KEX proposal-related
      DEFAULT_KEX,
      SUPPORTED_KEX,
      DEFAULT_SERVER_HOST_KEY,
      SUPPORTED_SERVER_HOST_KEY,
      DEFAULT_CIPHER,
      SUPPORTED_CIPHER,
      DEFAULT_MAC,
      SUPPORTED_MAC,
      DEFAULT_COMPRESSION,
      SUPPORTED_COMPRESSION,
      curve25519Supported,
      eddsaSupported
    };
    module2.exports.DISCONNECT_REASON_BY_VALUE = Array.from(Object.entries(module2.exports.DISCONNECT_REASON)).reduce((obj, [key, value]) => ({ ...obj, [value]: key }), {});
  }
});

// node_modules/ssh2/lib/protocol/utils.js
var require_utils = __commonJS({
  "node_modules/ssh2/lib/protocol/utils.js"(exports, module2) {
    "use strict";
    var Ber = require_lib().Ber;
    var DISCONNECT_REASON;
    var FastBuffer = Buffer[Symbol.species];
    var TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;
    function readUInt32BE(buf, offset) {
      return buf[offset++] * 16777216 + buf[offset++] * 65536 + buf[offset++] * 256 + buf[offset];
    }
    function bufferCopy(src, dest, srcStart, srcEnd, destStart) {
      if (!destStart)
        destStart = 0;
      if (srcEnd > src.length)
        srcEnd = src.length;
      let nb = srcEnd - srcStart;
      const destLeft = dest.length - destStart;
      if (nb > destLeft)
        nb = destLeft;
      dest.set(
        new Uint8Array(src.buffer, src.byteOffset + srcStart, nb),
        destStart
      );
      return nb;
    }
    function bufferSlice(buf, start, end) {
      if (end === void 0)
        end = buf.length;
      return new FastBuffer(buf.buffer, buf.byteOffset + start, end - start);
    }
    function makeBufferParser() {
      let pos = 0;
      let buffer;
      const self2 = {
        init: (buf, start) => {
          buffer = buf;
          pos = typeof start === "number" ? start : 0;
        },
        pos: () => pos,
        length: () => buffer ? buffer.length : 0,
        avail: () => buffer && pos < buffer.length ? buffer.length - pos : 0,
        clear: () => {
          buffer = void 0;
        },
        readUInt32BE: () => {
          if (!buffer || pos + 3 >= buffer.length)
            return;
          return buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];
        },
        readUInt64BE: (behavior) => {
          if (!buffer || pos + 7 >= buffer.length)
            return;
          switch (behavior) {
            case "always":
              return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);
            case "maybe":
              if (buffer[pos] > 31)
                return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);
            default:
              return buffer[pos++] * 72057594037927940 + buffer[pos++] * 281474976710656 + buffer[pos++] * 1099511627776 + buffer[pos++] * 4294967296 + buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];
          }
        },
        skip: (n) => {
          if (buffer && n > 0)
            pos += n;
        },
        skipString: () => {
          const len = self2.readUInt32BE();
          if (len === void 0)
            return;
          pos += len;
          return pos <= buffer.length ? len : void 0;
        },
        readByte: () => {
          if (buffer && pos < buffer.length)
            return buffer[pos++];
        },
        readBool: () => {
          if (buffer && pos < buffer.length)
            return !!buffer[pos++];
        },
        readList: () => {
          const list = self2.readString(true);
          if (list === void 0)
            return;
          return list ? list.split(",") : [];
        },
        readString: (dest, maxLen) => {
          if (typeof dest === "number") {
            maxLen = dest;
            dest = void 0;
          }
          const len = self2.readUInt32BE();
          if (len === void 0)
            return;
          if (buffer.length - pos < len || typeof maxLen === "number" && len > maxLen) {
            return;
          }
          if (dest) {
            if (Buffer.isBuffer(dest))
              return bufferCopy(buffer, dest, pos, pos += len);
            return buffer.utf8Slice(pos, pos += len);
          }
          return bufferSlice(buffer, pos, pos += len);
        },
        readRaw: (len) => {
          if (!buffer)
            return;
          if (typeof len !== "number")
            return bufferSlice(buffer, pos, pos += buffer.length - pos);
          if (buffer.length - pos >= len)
            return bufferSlice(buffer, pos, pos += len);
        }
      };
      return self2;
    }
    function makeError(msg, level, fatal) {
      const err = new Error(msg);
      if (typeof level === "boolean") {
        fatal = level;
        err.level = "protocol";
      } else {
        err.level = level || "protocol";
      }
      err.fatal = !!fatal;
      return err;
    }
    function writeUInt32BE(buf, value, offset) {
      buf[offset++] = value >>> 24;
      buf[offset++] = value >>> 16;
      buf[offset++] = value >>> 8;
      buf[offset++] = value;
      return offset;
    }
    var utilBufferParser = makeBufferParser();
    module2.exports = {
      bufferCopy,
      bufferSlice,
      FastBuffer,
      bufferFill: (buf, value, start, end) => {
        return TypedArrayFill.call(buf, value, start, end);
      },
      makeError,
      doFatalError: (protocol, msg, level, reason) => {
        let err;
        if (DISCONNECT_REASON === void 0)
          ({ DISCONNECT_REASON } = require_constants());
        if (msg instanceof Error) {
          err = msg;
          if (typeof level !== "number")
            reason = DISCONNECT_REASON.PROTOCOL_ERROR;
          else
            reason = level;
        } else {
          err = makeError(msg, level, true);
        }
        if (typeof reason !== "number")
          reason = DISCONNECT_REASON.PROTOCOL_ERROR;
        protocol.disconnect(reason);
        protocol._destruct();
        protocol._onError(err);
        return Infinity;
      },
      readUInt32BE,
      writeUInt32BE,
      writeUInt32LE: (buf, value, offset) => {
        buf[offset++] = value;
        buf[offset++] = value >>> 8;
        buf[offset++] = value >>> 16;
        buf[offset++] = value >>> 24;
        return offset;
      },
      makeBufferParser,
      bufferParser: makeBufferParser(),
      readString: (buffer, start, dest, maxLen) => {
        if (typeof dest === "number") {
          maxLen = dest;
          dest = void 0;
        }
        if (start === void 0)
          start = 0;
        const left = buffer.length - start;
        if (start < 0 || start >= buffer.length || left < 4)
          return;
        const len = readUInt32BE(buffer, start);
        if (left < 4 + len || typeof maxLen === "number" && len > maxLen)
          return;
        start += 4;
        const end = start + len;
        buffer._pos = end;
        if (dest) {
          if (Buffer.isBuffer(dest))
            return bufferCopy(buffer, dest, start, end);
          return buffer.utf8Slice(start, end);
        }
        return bufferSlice(buffer, start, end);
      },
      sigSSHToASN1: (sig, type) => {
        switch (type) {
          case "ssh-dss": {
            if (sig.length > 40)
              return sig;
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            let r = sig.slice(0, 20);
            let s = sig.slice(20);
            if (r[0] & 128) {
              const rNew = Buffer.allocUnsafe(21);
              rNew[0] = 0;
              r.copy(rNew, 1);
              r = rNew;
            } else if (r[0] === 0 && !(r[1] & 128)) {
              r = r.slice(1);
            }
            if (s[0] & 128) {
              const sNew = Buffer.allocUnsafe(21);
              sNew[0] = 0;
              s.copy(sNew, 1);
              s = sNew;
            } else if (s[0] === 0 && !(s[1] & 128)) {
              s = s.slice(1);
            }
            asnWriter.writeBuffer(r, Ber.Integer);
            asnWriter.writeBuffer(s, Ber.Integer);
            asnWriter.endSequence();
            return asnWriter.buffer;
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            utilBufferParser.init(sig, 0);
            const r = utilBufferParser.readString();
            const s = utilBufferParser.readString();
            utilBufferParser.clear();
            if (r === void 0 || s === void 0)
              return;
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            asnWriter.writeBuffer(r, Ber.Integer);
            asnWriter.writeBuffer(s, Ber.Integer);
            asnWriter.endSequence();
            return asnWriter.buffer;
          }
          default:
            return sig;
        }
      },
      convertSignature: (signature, keyType) => {
        switch (keyType) {
          case "ssh-dss": {
            if (signature.length <= 40)
              return signature;
            const asnReader = new Ber.Reader(signature);
            asnReader.readSequence();
            let r = asnReader.readString(Ber.Integer, true);
            let s = asnReader.readString(Ber.Integer, true);
            let rOffset = 0;
            let sOffset = 0;
            if (r.length < 20) {
              const rNew = Buffer.allocUnsafe(20);
              rNew.set(r, 1);
              r = rNew;
              r[0] = 0;
            }
            if (s.length < 20) {
              const sNew = Buffer.allocUnsafe(20);
              sNew.set(s, 1);
              s = sNew;
              s[0] = 0;
            }
            if (r.length > 20 && r[0] === 0)
              rOffset = 1;
            if (s.length > 20 && s[0] === 0)
              sOffset = 1;
            const newSig = Buffer.allocUnsafe(r.length - rOffset + (s.length - sOffset));
            bufferCopy(r, newSig, rOffset, r.length, 0);
            bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset);
            return newSig;
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            if (signature[0] === 0)
              return signature;
            const asnReader = new Ber.Reader(signature);
            asnReader.readSequence();
            const r = asnReader.readString(Ber.Integer, true);
            const s = asnReader.readString(Ber.Integer, true);
            if (r === null || s === null)
              return;
            const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);
            writeUInt32BE(newSig, r.length, 0);
            newSig.set(r, 4);
            writeUInt32BE(newSig, s.length, 4 + r.length);
            newSig.set(s, 4 + 4 + r.length);
            return newSig;
          }
        }
        return signature;
      },
      sendPacket: (proto, packet, bypass) => {
        if (!bypass && proto._kexinit !== void 0) {
          if (proto._queue === void 0)
            proto._queue = [];
          proto._queue.push(packet);
          proto._debug && proto._debug("Outbound: ... packet queued");
          return false;
        }
        proto._cipher.encrypt(packet);
        return true;
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node
var require_sshcrypto = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node"(exports, module2) {
    module2.exports = "./sshcrypto-A3G2E7AR.node";
  }
});

// node_modules/ssh2/lib/protocol/crypto/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto/poly1305.js"(exports, module2) {
    var createPoly1305 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(createPoly13052) {
        createPoly13052 = createPoly13052 || {};
        var b;
        b || (b = typeof createPoly13052 !== "undefined" ? createPoly13052 : {});
        var q, r;
        b.ready = new Promise(function(a, c) {
          q = a;
          r = c;
        });
        var u = {}, w;
        for (w in b)
          b.hasOwnProperty(w) && (u[w] = b[w]);
        var x = "object" === typeof window, y = "function" === typeof importScripts, z = "object" === typeof process && "object" === typeof process.versions && "string" === typeof process.versions.node, B = "", C, D, E, F, G;
        if (z)
          B = y ? require("path").dirname(B) + "/" : __dirname + "/", C = function(a, c) {
            var d = H(a);
            if (d)
              return c ? d : d.toString();
            F || (F = require("fs"));
            G || (G = require("path"));
            a = G.normalize(a);
            return F.readFileSync(a, c ? null : "utf8");
          }, E = function(a) {
            a = C(a, true);
            a.buffer || (a = new Uint8Array(a));
            assert(a.buffer);
            return a;
          }, D = function(a, c, d) {
            var e = H(a);
            e && c(e);
            F || (F = require("fs"));
            G || (G = require("path"));
            a = G.normalize(a);
            F.readFile(a, function(f, l) {
              f ? d(f) : c(l.buffer);
            });
          }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), b.inspect = function() {
            return "[Emscripten Module object]";
          };
        else if (x || y)
          y ? B = self.location.href : "undefined" !== typeof document && document.currentScript && (B = document.currentScript.src), _scriptDir && (B = _scriptDir), 0 !== B.indexOf("blob:") ? B = B.substr(0, B.lastIndexOf("/") + 1) : B = "", C = function(a) {
            try {
              var c = new XMLHttpRequest();
              c.open("GET", a, false);
              c.send(null);
              return c.responseText;
            } catch (f) {
              if (a = H(a)) {
                c = [];
                for (var d = 0; d < a.length; d++) {
                  var e = a[d];
                  255 < e && (ba && assert(false, "Character code " + e + " (" + String.fromCharCode(e) + ")  at offset " + d + " not in 0x00-0xFF."), e &= 255);
                  c.push(String.fromCharCode(e));
                }
                return c.join("");
              }
              throw f;
            }
          }, y && (E = function(a) {
            try {
              var c = new XMLHttpRequest();
              c.open("GET", a, false);
              c.responseType = "arraybuffer";
              c.send(null);
              return new Uint8Array(c.response);
            } catch (d) {
              if (a = H(a))
                return a;
              throw d;
            }
          }), D = function(a, c, d) {
            var e = new XMLHttpRequest();
            e.open("GET", a, true);
            e.responseType = "arraybuffer";
            e.onload = function() {
              if (200 == e.status || 0 == e.status && e.response)
                c(e.response);
              else {
                var f = H(a);
                f ? c(f.buffer) : d();
              }
            };
            e.onerror = d;
            e.send(null);
          };
        b.print || console.log.bind(console);
        var I = b.printErr || console.warn.bind(console);
        for (w in u)
          u.hasOwnProperty(w) && (b[w] = u[w]);
        u = null;
        var J;
        b.wasmBinary && (J = b.wasmBinary);
        var noExitRuntime = b.noExitRuntime || true;
        "object" !== typeof WebAssembly && K("no native wasm support detected");
        var L, M = false;
        function assert(a, c) {
          a || K("Assertion failed: " + c);
        }
        function N(a) {
          var c = b["_" + a];
          assert(c, "Cannot call unknown function " + a + ", make sure it is exported");
          return c;
        }
        function ca(a, c, d, e) {
          var f = { string: function(g) {
            var p = 0;
            if (null !== g && void 0 !== g && 0 !== g) {
              var n = (g.length << 2) + 1;
              p = O(n);
              var k = p, h = P;
              if (0 < n) {
                n = k + n - 1;
                for (var v = 0; v < g.length; ++v) {
                  var m = g.charCodeAt(v);
                  if (55296 <= m && 57343 >= m) {
                    var oa = g.charCodeAt(++v);
                    m = 65536 + ((m & 1023) << 10) | oa & 1023;
                  }
                  if (127 >= m) {
                    if (k >= n)
                      break;
                    h[k++] = m;
                  } else {
                    if (2047 >= m) {
                      if (k + 1 >= n)
                        break;
                      h[k++] = 192 | m >> 6;
                    } else {
                      if (65535 >= m) {
                        if (k + 2 >= n)
                          break;
                        h[k++] = 224 | m >> 12;
                      } else {
                        if (k + 3 >= n)
                          break;
                        h[k++] = 240 | m >> 18;
                        h[k++] = 128 | m >> 12 & 63;
                      }
                      h[k++] = 128 | m >> 6 & 63;
                    }
                    h[k++] = 128 | m & 63;
                  }
                }
                h[k] = 0;
              }
            }
            return p;
          }, array: function(g) {
            var p = O(g.length);
            Q.set(g, p);
            return p;
          } }, l = N(a), A = [];
          a = 0;
          if (e)
            for (var t = 0; t < e.length; t++) {
              var aa = f[d[t]];
              aa ? (0 === a && (a = da()), A[t] = aa(e[t])) : A[t] = e[t];
            }
          d = l.apply(null, A);
          d = function(g) {
            if ("string" === c)
              if (g) {
                for (var p = P, n = g + NaN, k = g; p[k] && !(k >= n); )
                  ++k;
                if (16 < k - g && p.subarray && ea)
                  g = ea.decode(p.subarray(g, k));
                else {
                  for (n = ""; g < k; ) {
                    var h = p[g++];
                    if (h & 128) {
                      var v = p[g++] & 63;
                      if (192 == (h & 224))
                        n += String.fromCharCode((h & 31) << 6 | v);
                      else {
                        var m = p[g++] & 63;
                        h = 224 == (h & 240) ? (h & 15) << 12 | v << 6 | m : (h & 7) << 18 | v << 12 | m << 6 | p[g++] & 63;
                        65536 > h ? n += String.fromCharCode(h) : (h -= 65536, n += String.fromCharCode(55296 | h >> 10, 56320 | h & 1023));
                      }
                    } else
                      n += String.fromCharCode(h);
                  }
                  g = n;
                }
              } else
                g = "";
            else
              g = "boolean" === c ? !!g : g;
            return g;
          }(d);
          0 !== a && fa(a);
          return d;
        }
        var ea = "undefined" !== typeof TextDecoder ? new TextDecoder("utf8") : void 0, ha, Q, P;
        function ia() {
          var a = L.buffer;
          ha = a;
          b.HEAP8 = Q = new Int8Array(a);
          b.HEAP16 = new Int16Array(a);
          b.HEAP32 = new Int32Array(a);
          b.HEAPU8 = P = new Uint8Array(a);
          b.HEAPU16 = new Uint16Array(a);
          b.HEAPU32 = new Uint32Array(a);
          b.HEAPF32 = new Float32Array(a);
          b.HEAPF64 = new Float64Array(a);
        }
        var R, ja = [], ka = [], la = [];
        function ma() {
          var a = b.preRun.shift();
          ja.unshift(a);
        }
        var S = 0, T = null, U = null;
        b.preloadedImages = {};
        b.preloadedAudios = {};
        function K(a) {
          if (b.onAbort)
            b.onAbort(a);
          I(a);
          M = true;
          a = new WebAssembly.RuntimeError("abort(" + a + "). Build with -s ASSERTIONS=1 for more info.");
          r(a);
          throw a;
        }
        var V = "data:application/octet-stream;base64,", W;
        W = "data:application/octet-stream;base64,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";
        if (!W.startsWith(V)) {
          var na = W;
          W = b.locateFile ? b.locateFile(na, B) : B + na;
        }
        function pa() {
          var a = W;
          try {
            if (a == W && J)
              return new Uint8Array(J);
            var c = H(a);
            if (c)
              return c;
            if (E)
              return E(a);
            throw "both async and sync fetching of the wasm failed";
          } catch (d) {
            K(d);
          }
        }
        function qa() {
          if (!J && (x || y)) {
            if ("function" === typeof fetch && !W.startsWith("file://"))
              return fetch(W, { credentials: "same-origin" }).then(function(a) {
                if (!a.ok)
                  throw "failed to load wasm binary file at '" + W + "'";
                return a.arrayBuffer();
              }).catch(function() {
                return pa();
              });
            if (D)
              return new Promise(function(a, c) {
                D(W, function(d) {
                  a(new Uint8Array(d));
                }, c);
              });
          }
          return Promise.resolve().then(function() {
            return pa();
          });
        }
        function X(a) {
          for (; 0 < a.length; ) {
            var c = a.shift();
            if ("function" == typeof c)
              c(b);
            else {
              var d = c.m;
              "number" === typeof d ? void 0 === c.l ? R.get(d)() : R.get(d)(c.l) : d(void 0 === c.l ? null : c.l);
            }
          }
        }
        var ba = false, ra = "function" === typeof atob ? atob : function(a) {
          var c = "", d = 0;
          a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            e = e << 2 | f >> 4;
            f = (f & 15) << 4 | l >> 2;
            var t = (l & 3) << 6 | A;
            c += String.fromCharCode(e);
            64 !== l && (c += String.fromCharCode(f));
            64 !== A && (c += String.fromCharCode(t));
          } while (d < a.length);
          return c;
        };
        function H(a) {
          if (a.startsWith(V)) {
            a = a.slice(V.length);
            if ("boolean" === typeof z && z) {
              var c = Buffer.from(a, "base64");
              c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
            } else
              try {
                var d = ra(a), e = new Uint8Array(d.length);
                for (a = 0; a < d.length; ++a)
                  e[a] = d.charCodeAt(a);
                c = e;
              } catch (f) {
                throw Error("Converting base64 string to bytes failed.");
              }
            return c;
          }
        }
        var sa = { a: function(a) {
          var c = P.length;
          a >>>= 0;
          if (2147483648 < a)
            return false;
          for (var d = 1; 4 >= d; d *= 2) {
            var e = c * (1 + 0.2 / d);
            e = Math.min(e, a + 100663296);
            e = Math.max(a, e);
            0 < e % 65536 && (e += 65536 - e % 65536);
            a: {
              try {
                L.grow(Math.min(2147483648, e) - ha.byteLength + 65535 >>> 16);
                ia();
                var f = 1;
                break a;
              } catch (l) {
              }
              f = void 0;
            }
            if (f)
              return true;
          }
          return false;
        } };
        (function() {
          function a(f) {
            b.asm = f.exports;
            L = b.asm.b;
            ia();
            R = b.asm.j;
            ka.unshift(b.asm.c);
            S--;
            b.monitorRunDependencies && b.monitorRunDependencies(S);
            0 == S && (null !== T && (clearInterval(T), T = null), U && (f = U, U = null, f()));
          }
          function c(f) {
            a(f.instance);
          }
          function d(f) {
            return qa().then(function(l) {
              return WebAssembly.instantiate(l, e);
            }).then(f, function(l) {
              I("failed to asynchronously prepare wasm: " + l);
              K(l);
            });
          }
          var e = { a: sa };
          S++;
          b.monitorRunDependencies && b.monitorRunDependencies(S);
          if (b.instantiateWasm)
            try {
              return b.instantiateWasm(
                e,
                a
              );
            } catch (f) {
              return I("Module.instantiateWasm callback failed with error: " + f), false;
            }
          (function() {
            return J || "function" !== typeof WebAssembly.instantiateStreaming || W.startsWith(V) || W.startsWith("file://") || "function" !== typeof fetch ? d(c) : fetch(W, { credentials: "same-origin" }).then(function(f) {
              return WebAssembly.instantiateStreaming(f, e).then(c, function(l) {
                I("wasm streaming compile failed: " + l);
                I("falling back to ArrayBuffer instantiation");
                return d(c);
              });
            });
          })().catch(r);
          return {};
        })();
        b.___wasm_call_ctors = function() {
          return (b.___wasm_call_ctors = b.asm.c).apply(null, arguments);
        };
        b._poly1305_auth = function() {
          return (b._poly1305_auth = b.asm.d).apply(null, arguments);
        };
        var da = b.stackSave = function() {
          return (da = b.stackSave = b.asm.e).apply(null, arguments);
        }, fa = b.stackRestore = function() {
          return (fa = b.stackRestore = b.asm.f).apply(null, arguments);
        }, O = b.stackAlloc = function() {
          return (O = b.stackAlloc = b.asm.g).apply(null, arguments);
        };
        b._malloc = function() {
          return (b._malloc = b.asm.h).apply(null, arguments);
        };
        b._free = function() {
          return (b._free = b.asm.i).apply(null, arguments);
        };
        b.cwrap = function(a, c, d, e) {
          d = d || [];
          var f = d.every(function(l) {
            return "number" === l;
          });
          return "string" !== c && f && !e ? N(a) : function() {
            return ca(a, c, d, arguments);
          };
        };
        var Y;
        U = function ta() {
          Y || Z();
          Y || (U = ta);
        };
        function Z() {
          function a() {
            if (!Y && (Y = true, b.calledRun = true, !M)) {
              X(ka);
              q(b);
              if (b.onRuntimeInitialized)
                b.onRuntimeInitialized();
              if (b.postRun)
                for ("function" == typeof b.postRun && (b.postRun = [b.postRun]); b.postRun.length; ) {
                  var c = b.postRun.shift();
                  la.unshift(c);
                }
              X(la);
            }
          }
          if (!(0 < S)) {
            if (b.preRun)
              for ("function" == typeof b.preRun && (b.preRun = [b.preRun]); b.preRun.length; )
                ma();
            X(ja);
            0 < S || (b.setStatus ? (b.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                b.setStatus("");
              }, 1);
              a();
            }, 1)) : a());
          }
        }
        b.run = Z;
        if (b.preInit)
          for ("function" == typeof b.preInit && (b.preInit = [b.preInit]); 0 < b.preInit.length; )
            b.preInit.pop()();
        Z();
        return createPoly13052.ready;
      };
    }();
    if (typeof exports === "object" && typeof module2 === "object")
      module2.exports = createPoly1305;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return createPoly1305;
      });
    else if (typeof exports === "object")
      exports["createPoly1305"] = createPoly1305;
  }
});

// node_modules/ssh2/lib/protocol/crypto.js
var require_crypto = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto.js"(exports, module2) {
    "use strict";
    var {
      createCipheriv,
      createDecipheriv,
      createHmac,
      randomFillSync,
      timingSafeEqual
    } = require("crypto");
    var { readUInt32BE, writeUInt32BE } = require_utils();
    var FastBuffer = Buffer[Symbol.species];
    var MAX_SEQNO = 2 ** 32 - 1;
    var EMPTY_BUFFER = Buffer.alloc(0);
    var BUF_INT = Buffer.alloc(4);
    var DISCARD_CACHE = /* @__PURE__ */ new Map();
    var MAX_PACKET_SIZE = 35e3;
    var binding;
    var AESGCMCipher;
    var ChaChaPolyCipher;
    var GenericCipher;
    var AESGCMDecipher;
    var ChaChaPolyDecipher;
    var GenericDecipher;
    try {
      binding = require_sshcrypto();
      ({
        AESGCMCipher,
        ChaChaPolyCipher,
        GenericCipher,
        AESGCMDecipher,
        ChaChaPolyDecipher,
        GenericDecipher
      } = binding);
    } catch {
    }
    var CIPHER_STREAM = 1 << 0;
    var CIPHER_INFO = (() => {
      function info(sslName, blockLen, keyLen, ivLen, authLen, discardLen, flags) {
        return {
          sslName,
          blockLen,
          keyLen,
          ivLen: ivLen !== 0 || flags & CIPHER_STREAM ? ivLen : blockLen,
          authLen,
          discardLen,
          stream: !!(flags & CIPHER_STREAM)
        };
      }
      return {
        "chacha20-poly1305@openssh.com": info("chacha20", 8, 64, 0, 16, 0, CIPHER_STREAM),
        "aes128-gcm": info("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
        "aes256-gcm": info("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
        "aes128-gcm@openssh.com": info("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
        "aes256-gcm@openssh.com": info("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
        "aes128-cbc": info("aes-128-cbc", 16, 16, 0, 0, 0, 0),
        "aes192-cbc": info("aes-192-cbc", 16, 24, 0, 0, 0, 0),
        "aes256-cbc": info("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "rijndael-cbc@lysator.liu.se": info("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "3des-cbc": info("des-ede3-cbc", 8, 24, 0, 0, 0, 0),
        "blowfish-cbc": info("bf-cbc", 8, 16, 0, 0, 0, 0),
        "idea-cbc": info("idea-cbc", 8, 16, 0, 0, 0, 0),
        "cast128-cbc": info("cast-cbc", 8, 16, 0, 0, 0, 0),
        "aes128-ctr": info("aes-128-ctr", 16, 16, 16, 0, 0, CIPHER_STREAM),
        "aes192-ctr": info("aes-192-ctr", 16, 24, 16, 0, 0, CIPHER_STREAM),
        "aes256-ctr": info("aes-256-ctr", 16, 32, 16, 0, 0, CIPHER_STREAM),
        "3des-ctr": info("des-ede3", 8, 24, 8, 0, 0, CIPHER_STREAM),
        "blowfish-ctr": info("bf-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
        "cast128-ctr": info("cast5-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
        /* The "arcfour128" algorithm is the RC4 cipher, as described in
               [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream
               generated by the cipher MUST be discarded, and the first byte of the
               first encrypted packet MUST be encrypted using the 1537th byte of
               keystream.
        
               -- http://tools.ietf.org/html/rfc4345#section-4 */
        "arcfour": info("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
        "arcfour128": info("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
        "arcfour256": info("rc4", 8, 32, 0, 0, 1536, CIPHER_STREAM),
        "arcfour512": info("rc4", 8, 64, 0, 0, 1536, CIPHER_STREAM)
      };
    })();
    var MAC_INFO = (() => {
      function info(sslName, len, actualLen, isETM) {
        return {
          sslName,
          len,
          actualLen,
          isETM
        };
      }
      return {
        "hmac-md5": info("md5", 16, 16, false),
        "hmac-md5-96": info("md5", 16, 12, false),
        "hmac-ripemd160": info("ripemd160", 20, 20, false),
        "hmac-sha1": info("sha1", 20, 20, false),
        "hmac-sha1-etm@openssh.com": info("sha1", 20, 20, true),
        "hmac-sha1-96": info("sha1", 20, 12, false),
        "hmac-sha2-256": info("sha256", 32, 32, false),
        "hmac-sha2-256-etm@openssh.com": info("sha256", 32, 32, true),
        "hmac-sha2-256-96": info("sha256", 32, 12, false),
        "hmac-sha2-512": info("sha512", 64, 64, false),
        "hmac-sha2-512-etm@openssh.com": info("sha512", 64, 64, true),
        "hmac-sha2-512-96": info("sha512", 64, 12, false)
      };
    })();
    var NullCipher = class {
      constructor(seqno, onWrite) {
        this.outSeqno = seqno;
        this._onWrite = onWrite;
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen & 8 - 1);
        if (padLen < 4)
          padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var POLY1305_ZEROS = Buffer.alloc(32);
    var POLY1305_OUT_COMPUTE = Buffer.alloc(16);
    var POLY1305_WASM_MODULE;
    var POLY1305_RESULT_MALLOC;
    var poly1305_auth;
    var ChaChaPolyCipherNative = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encKeyMain = enc.cipherKey.slice(0, 32);
        this._encKeyPktLen = enc.cipherKey.slice(32);
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen - 4 & 8 - 1);
        if (padLen < 4)
          padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        POLY1305_OUT_COMPUTE[0] = 0;
        writeUInt32BE(POLY1305_OUT_COMPUTE, this.outSeqno, 12);
        const polyKey = createCipheriv("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
        const pktLenEnc = createCipheriv("chacha20", this._encKeyPktLen, POLY1305_OUT_COMPUTE).update(packet.slice(0, 4));
        this._onWrite(pktLenEnc);
        POLY1305_OUT_COMPUTE[0] = 1;
        const payloadEnc = createCipheriv("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(packet.slice(4));
        this._onWrite(payloadEnc);
        poly1305_auth(
          POLY1305_RESULT_MALLOC,
          pktLenEnc,
          pktLenEnc.length,
          payloadEnc,
          payloadEnc.length,
          polyKey
        );
        const mac = Buffer.allocUnsafe(16);
        mac.set(
          new Uint8Array(
            POLY1305_WASM_MODULE.HEAPU8.buffer,
            POLY1305_RESULT_MALLOC,
            16
          ),
          0
        );
        this._onWrite(mac);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var ChaChaPolyCipherBinding = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._instance = new ChaChaPolyCipher(enc.cipherKey);
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen - 4 & 8 - 1);
        if (padLen < 4)
          padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(
          pktLen + 16
          /* MAC */
        );
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._instance.encrypt(packet, this.outSeqno);
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var AESGCMCipherNative = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encSSLName = enc.cipherInfo.sslName;
        this._encKey = enc.cipherKey;
        this._encIV = enc.cipherIV;
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 16 - (pktLen - 4 & 16 - 1);
        if (padLen < 4)
          padLen += 16;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        const cipher = createCipheriv(this._encSSLName, this._encKey, this._encIV);
        cipher.setAutoPadding(false);
        const lenData = packet.slice(0, 4);
        cipher.setAAD(lenData);
        this._onWrite(lenData);
        const encrypted = cipher.update(packet.slice(4));
        this._onWrite(encrypted);
        const final = cipher.final();
        if (final.length)
          this._onWrite(final);
        const tag = cipher.getAuthTag();
        this._onWrite(tag);
        ivIncrement(this._encIV);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var AESGCMCipherBinding = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._instance = new AESGCMCipher(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV
        );
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 16 - (pktLen - 4 & 16 - 1);
        if (padLen < 4)
          padLen += 16;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(
          pktLen + 16
          /* authTag */
        );
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._instance.encrypt(packet);
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var GenericCipherNative = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encBlockLen = enc.cipherInfo.blockLen;
        this._cipherInstance = createCipheriv(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV
        );
        this._macSSLName = enc.macInfo.sslName;
        this._macKey = enc.macKey;
        this._macActualLen = enc.macInfo.actualLen;
        this._macETM = enc.macInfo.isETM;
        this._aadLen = this._macETM ? 4 : 0;
        this._dead = false;
        const discardLen = enc.cipherInfo.discardLen;
        if (discardLen) {
          let discard = DISCARD_CACHE.get(discardLen);
          if (discard === void 0) {
            discard = Buffer.alloc(discardLen);
            DISCARD_CACHE.set(discardLen, discard);
          }
          this._cipherInstance.update(discard);
        }
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        const blockLen = this._encBlockLen;
        let pktLen = 4 + 1 + payloadLen;
        let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
        if (padLen < 4)
          padLen += blockLen;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        let mac;
        if (this._macETM) {
          const lenBytes = new Uint8Array(packet.buffer, packet.byteOffset, 4);
          const encrypted = this._cipherInstance.update(
            new Uint8Array(
              packet.buffer,
              packet.byteOffset + 4,
              packet.length - 4
            )
          );
          this._onWrite(lenBytes);
          this._onWrite(encrypted);
          mac = createHmac(this._macSSLName, this._macKey);
          writeUInt32BE(BUF_INT, this.outSeqno, 0);
          mac.update(BUF_INT);
          mac.update(lenBytes);
          mac.update(encrypted);
        } else {
          const encrypted = this._cipherInstance.update(packet);
          this._onWrite(encrypted);
          mac = createHmac(this._macSSLName, this._macKey);
          writeUInt32BE(BUF_INT, this.outSeqno, 0);
          mac.update(BUF_INT);
          mac.update(packet);
        }
        let digest = mac.digest();
        if (digest.length > this._macActualLen)
          digest = digest.slice(0, this._macActualLen);
        this._onWrite(digest);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var GenericCipherBinding = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encBlockLen = enc.cipherInfo.blockLen;
        this._macLen = enc.macInfo.len;
        this._macActualLen = enc.macInfo.actualLen;
        this._aadLen = enc.macInfo.isETM ? 4 : 0;
        this._instance = new GenericCipher(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV,
          enc.macInfo.sslName,
          enc.macKey,
          enc.macInfo.isETM
        );
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        const blockLen = this._encBlockLen;
        let pktLen = 4 + 1 + payloadLen;
        let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
        if (padLen < 4)
          padLen += blockLen;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen + this._macLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._instance.encrypt(packet, this.outSeqno);
        if (this._macActualLen < this._macLen) {
          packet = new FastBuffer(
            packet.buffer,
            packet.byteOffset,
            packet.length - (this._macLen - this._macActualLen)
          );
        }
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var NullDecipher = class {
      constructor(seqno, onPayload) {
        this.inSeqno = seqno;
        this._onPayload = onPayload;
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._packetPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--)
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (4 + this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
            if (p >= dataLen)
              return;
          }
          if (this._packetPos < this._len) {
            const nb = Math.min(this._len - this._packetPos, dataLen - p);
            let chunk;
            if (p !== 0 || nb !== dataLen)
              chunk = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              chunk = data;
            if (nb === this._len) {
              this._packet = chunk;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(chunk, this._packetPos);
            }
            p += nb;
            this._packetPos += nb;
            if (this._packetPos < this._len)
              return;
          }
          const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._packetPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var ChaChaPolyDecipherNative = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decKeyMain = dec.decipherKey.slice(0, 32);
        this._decKeyPktLen = dec.decipherKey.slice(32);
        this._len = 0;
        this._lenBuf = Buffer.alloc(4);
        this._lenPos = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(16);
        this._calcMac = Buffer.allocUnsafe(16);
        this._macPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenPos < 4) {
            let nb = Math.min(4 - this._lenPos, dataLen - p);
            while (nb--)
              this._lenBuf[this._lenPos++] = data[p++];
            if (this._lenPos < 4)
              return;
            POLY1305_OUT_COMPUTE[0] = 0;
            writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
            const decLenBytes = createDecipheriv("chacha20", this._decKeyPktLen, POLY1305_OUT_COMPUTE).update(this._lenBuf);
            this._len = readUInt32BE(decLenBytes, 0);
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < 16)
              return;
          }
          POLY1305_OUT_COMPUTE[0] = 0;
          writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
          const polyKey = createCipheriv("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
          poly1305_auth(
            POLY1305_RESULT_MALLOC,
            this._lenBuf,
            4,
            this._packet,
            this._packet.length,
            polyKey
          );
          this._calcMac.set(
            new Uint8Array(
              POLY1305_WASM_MODULE.HEAPU8.buffer,
              POLY1305_RESULT_MALLOC,
              16
            ),
            0
          );
          if (!timingSafeEqual(this._calcMac, this._mac))
            throw new Error("Invalid MAC");
          POLY1305_OUT_COMPUTE[0] = 1;
          const packet = createDecipheriv("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(this._packet);
          const payload = new FastBuffer(
            packet.buffer,
            packet.byteOffset + 1,
            packet.length - packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenPos = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var ChaChaPolyDecipherBinding = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new ChaChaPolyDecipher(dec.decipherKey);
        this._len = 0;
        this._lenBuf = Buffer.alloc(4);
        this._lenPos = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(16);
        this._macPos = 0;
      }
      free() {
        this._instance.free();
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenPos < 4) {
            let nb = Math.min(4 - this._lenPos, dataLen - p);
            while (nb--)
              this._lenBuf[this._lenPos++] = data[p++];
            if (this._lenPos < 4)
              return;
            this._len = this._instance.decryptLen(this._lenBuf, this.inSeqno);
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
            if (p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < 16)
              return;
          }
          this._instance.decrypt(this._packet, this._mac, this.inSeqno);
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenPos = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var AESGCMDecipherNative = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decipherInstance = null;
        this._decipherSSLName = dec.decipherInfo.sslName;
        this._decipherKey = dec.decipherKey;
        this._decipherIV = dec.decipherIV;
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._packetPos = 0;
        this._pktLen = 0;
        this._tag = Buffer.allocUnsafe(16);
        this._tagPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--)
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {
              throw new Error("Bad packet length");
            }
            this._decipherInstance = createDecipheriv(
              this._decipherSSLName,
              this._decipherKey,
              this._decipherIV
            );
            this._decipherInstance.setAutoPadding(false);
            this._decipherInstance.setAAD(intToBytes(this._len));
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let decrypted;
            if (p !== 0 || nb !== dataLen) {
              decrypted = this._decipherInstance.update(
                new Uint8Array(data.buffer, data.byteOffset + p, nb)
              );
            } else {
              decrypted = this._decipherInstance.update(data);
            }
            if (decrypted.length) {
              if (nb === this._len) {
                this._packet = decrypted;
              } else {
                if (!this._packet)
                  this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(decrypted, this._packetPos);
              }
              this._packetPos += decrypted.length;
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._tagPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._tag.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._tagPos
              );
            } else {
              this._tag.set(data, this._tagPos);
            }
            p += nb;
            this._tagPos += nb;
            if (this._tagPos < 16)
              return;
          }
          {
            this._decipherInstance.setAuthTag(this._tag);
            const decrypted = this._decipherInstance.final();
            if (decrypted.length) {
              if (this._packet)
                this._packet.set(decrypted, this._packetPos);
              else
                this._packet = decrypted;
            }
          }
          const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          ivIncrement(this._decipherIV);
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._packetPos = 0;
          this._pktLen = 0;
          this._tagPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var AESGCMDecipherBinding = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new AESGCMDecipher(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV
        );
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._pktLen = 0;
        this._tag = Buffer.allocUnsafe(16);
        this._tagPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--)
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {
              throw new Error(`Bad packet length: ${this._len}`);
            }
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._tagPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._tag.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._tagPos
              );
            } else {
              this._tag.set(data, this._tagPos);
            }
            p += nb;
            this._tagPos += nb;
            if (this._tagPos < 16)
              return;
          }
          this._instance.decrypt(this._packet, this._len, this._tag);
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._pktLen = 0;
          this._tagPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var GenericDecipherNative = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decipherInstance = createDecipheriv(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV
        );
        this._decipherInstance.setAutoPadding(false);
        this._block = Buffer.allocUnsafe(
          dec.macInfo.isETM ? 4 : dec.decipherInfo.blockLen
        );
        this._blockSize = dec.decipherInfo.blockLen;
        this._blockPos = 0;
        this._len = 0;
        this._packet = null;
        this._packetPos = 0;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);
        this._macPos = 0;
        this._macSSLName = dec.macInfo.sslName;
        this._macKey = dec.macKey;
        this._macActualLen = dec.macInfo.actualLen;
        this._macETM = dec.macInfo.isETM;
        this._macInstance = null;
        const discardLen = dec.decipherInfo.discardLen;
        if (discardLen) {
          let discard = DISCARD_CACHE.get(discardLen);
          if (discard === void 0) {
            discard = Buffer.alloc(discardLen);
            DISCARD_CACHE.set(discardLen, discard);
          }
          this._decipherInstance.update(discard);
        }
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._blockPos < this._block.length) {
            const nb = Math.min(this._block.length - this._blockPos, dataLen - p);
            if (p !== 0 || nb !== dataLen || nb < data.length) {
              this._block.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._blockPos
              );
            } else {
              this._block.set(data, this._blockPos);
            }
            p += nb;
            this._blockPos += nb;
            if (this._blockPos < this._block.length)
              return;
            let decrypted;
            let need;
            if (this._macETM) {
              this._len = need = readUInt32BE(this._block, 0);
            } else {
              decrypted = this._decipherInstance.update(this._block);
              this._len = readUInt32BE(decrypted, 0);
              need = 4 + this._len - this._blockSize;
            }
            if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._blockSize - 1) !== 0) {
              throw new Error("Bad packet length");
            }
            this._macInstance = createHmac(this._macSSLName, this._macKey);
            writeUInt32BE(BUF_INT, this.inSeqno, 0);
            this._macInstance.update(BUF_INT);
            if (this._macETM) {
              this._macInstance.update(this._block);
            } else {
              this._macInstance.update(new Uint8Array(
                decrypted.buffer,
                decrypted.byteOffset,
                4
              ));
              this._pktLen = decrypted.length - 4;
              this._packetPos = this._pktLen;
              this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(
                new Uint8Array(
                  decrypted.buffer,
                  decrypted.byteOffset + 4,
                  this._packetPos
                ),
                0
              );
            }
            if (p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (this._macETM)
              this._macInstance.update(encrypted);
            const decrypted = this._decipherInstance.update(encrypted);
            if (decrypted.length) {
              if (nb === this._len) {
                this._packet = decrypted;
              } else {
                if (!this._packet)
                  this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(decrypted, this._packetPos);
              }
              this._packetPos += decrypted.length;
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < this._macActualLen)
              return;
          }
          if (!this._macETM)
            this._macInstance.update(this._packet);
          let calculated = this._macInstance.digest();
          if (this._macActualLen < calculated.length) {
            calculated = new Uint8Array(
              calculated.buffer,
              calculated.byteOffset,
              this._macActualLen
            );
          }
          if (!timingSafeEquals(calculated, this._mac))
            throw new Error("Invalid MAC");
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._blockPos = 0;
          this._len = 0;
          this._packet = null;
          this._packetPos = 0;
          this._pktLen = 0;
          this._macPos = 0;
          this._macInstance = null;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var GenericDecipherBinding = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new GenericDecipher(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV,
          dec.macInfo.sslName,
          dec.macKey,
          dec.macInfo.isETM,
          dec.macInfo.actualLen
        );
        this._block = Buffer.allocUnsafe(
          dec.macInfo.isETM || dec.decipherInfo.stream ? 4 : dec.decipherInfo.blockLen
        );
        this._blockPos = 0;
        this._len = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);
        this._macPos = 0;
        this._macActualLen = dec.macInfo.actualLen;
        this._macETM = dec.macInfo.isETM;
      }
      free() {
        this._instance.free();
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._blockPos < this._block.length) {
            const nb = Math.min(this._block.length - this._blockPos, dataLen - p);
            if (p !== 0 || nb !== dataLen || nb < data.length) {
              this._block.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._blockPos
              );
            } else {
              this._block.set(data, this._blockPos);
            }
            p += nb;
            this._blockPos += nb;
            if (this._blockPos < this._block.length)
              return;
            let need;
            if (this._macETM) {
              this._len = need = readUInt32BE(this._block, 0);
            } else {
              this._instance.decryptBlock(this._block);
              this._len = readUInt32BE(this._block, 0);
              need = 4 + this._len - this._block.length;
            }
            if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._block.length - 1) !== 0) {
              throw new Error("Bad packet length");
            }
            if (!this._macETM) {
              this._pktLen = this._block.length - 4;
              if (this._pktLen) {
                this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(
                  new Uint8Array(
                    this._block.buffer,
                    this._block.byteOffset + 4,
                    this._pktLen
                  ),
                  0
                );
              }
            }
            if (p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < this._macActualLen)
              return;
          }
          this._instance.decrypt(
            this._packet,
            this.inSeqno,
            this._block,
            this._mac
          );
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._blockPos = 0;
          this._len = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          this._macInstance = null;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    function ivIncrement(iv) {
      ++iv[11] >>> 8 && ++iv[10] >>> 8 && ++iv[9] >>> 8 && ++iv[8] >>> 8 && ++iv[7] >>> 8 && ++iv[6] >>> 8 && ++iv[5] >>> 8 && ++iv[4] >>> 8;
    }
    var intToBytes = (() => {
      const ret = Buffer.alloc(4);
      return (n) => {
        ret[0] = n >>> 24;
        ret[1] = n >>> 16;
        ret[2] = n >>> 8;
        ret[3] = n;
        return ret;
      };
    })();
    function timingSafeEquals(a, b) {
      if (a.length !== b.length) {
        timingSafeEqual(a, a);
        return false;
      }
      return timingSafeEqual(a, b);
    }
    function createCipher(config) {
      if (typeof config !== "object" || config === null)
        throw new Error("Invalid config");
      if (typeof config.outbound !== "object" || config.outbound === null)
        throw new Error("Invalid outbound");
      const outbound = config.outbound;
      if (typeof outbound.onWrite !== "function")
        throw new Error("Invalid outbound.onWrite");
      if (typeof outbound.cipherInfo !== "object" || outbound.cipherInfo === null)
        throw new Error("Invalid outbound.cipherInfo");
      if (!Buffer.isBuffer(outbound.cipherKey) || outbound.cipherKey.length !== outbound.cipherInfo.keyLen) {
        throw new Error("Invalid outbound.cipherKey");
      }
      if (outbound.cipherInfo.ivLen && (!Buffer.isBuffer(outbound.cipherIV) || outbound.cipherIV.length !== outbound.cipherInfo.ivLen)) {
        throw new Error("Invalid outbound.cipherIV");
      }
      if (typeof outbound.seqno !== "number" || outbound.seqno < 0 || outbound.seqno > MAX_SEQNO) {
        throw new Error("Invalid outbound.seqno");
      }
      const forceNative = !!outbound.forceNative;
      switch (outbound.cipherInfo.sslName) {
        case "aes-128-gcm":
        case "aes-256-gcm":
          return AESGCMCipher && !forceNative ? new AESGCMCipherBinding(config) : new AESGCMCipherNative(config);
        case "chacha20":
          return ChaChaPolyCipher && !forceNative ? new ChaChaPolyCipherBinding(config) : new ChaChaPolyCipherNative(config);
        default: {
          if (typeof outbound.macInfo !== "object" || outbound.macInfo === null)
            throw new Error("Invalid outbound.macInfo");
          if (!Buffer.isBuffer(outbound.macKey) || outbound.macKey.length !== outbound.macInfo.len) {
            throw new Error("Invalid outbound.macKey");
          }
          return GenericCipher && !forceNative ? new GenericCipherBinding(config) : new GenericCipherNative(config);
        }
      }
    }
    function createDecipher(config) {
      if (typeof config !== "object" || config === null)
        throw new Error("Invalid config");
      if (typeof config.inbound !== "object" || config.inbound === null)
        throw new Error("Invalid inbound");
      const inbound = config.inbound;
      if (typeof inbound.onPayload !== "function")
        throw new Error("Invalid inbound.onPayload");
      if (typeof inbound.decipherInfo !== "object" || inbound.decipherInfo === null) {
        throw new Error("Invalid inbound.decipherInfo");
      }
      if (!Buffer.isBuffer(inbound.decipherKey) || inbound.decipherKey.length !== inbound.decipherInfo.keyLen) {
        throw new Error("Invalid inbound.decipherKey");
      }
      if (inbound.decipherInfo.ivLen && (!Buffer.isBuffer(inbound.decipherIV) || inbound.decipherIV.length !== inbound.decipherInfo.ivLen)) {
        throw new Error("Invalid inbound.decipherIV");
      }
      if (typeof inbound.seqno !== "number" || inbound.seqno < 0 || inbound.seqno > MAX_SEQNO) {
        throw new Error("Invalid inbound.seqno");
      }
      const forceNative = !!inbound.forceNative;
      switch (inbound.decipherInfo.sslName) {
        case "aes-128-gcm":
        case "aes-256-gcm":
          return AESGCMDecipher && !forceNative ? new AESGCMDecipherBinding(config) : new AESGCMDecipherNative(config);
        case "chacha20":
          return ChaChaPolyDecipher && !forceNative ? new ChaChaPolyDecipherBinding(config) : new ChaChaPolyDecipherNative(config);
        default: {
          if (typeof inbound.macInfo !== "object" || inbound.macInfo === null)
            throw new Error("Invalid inbound.macInfo");
          if (!Buffer.isBuffer(inbound.macKey) || inbound.macKey.length !== inbound.macInfo.len) {
            throw new Error("Invalid inbound.macKey");
          }
          return GenericDecipher && !forceNative ? new GenericDecipherBinding(config) : new GenericDecipherNative(config);
        }
      }
    }
    module2.exports = {
      CIPHER_INFO,
      MAC_INFO,
      bindingAvailable: !!binding,
      init: (() => {
        return new Promise(async (resolve, reject) => {
          try {
            POLY1305_WASM_MODULE = await require_poly1305()();
            POLY1305_RESULT_MALLOC = POLY1305_WASM_MODULE._malloc(16);
            poly1305_auth = POLY1305_WASM_MODULE.cwrap(
              "poly1305_auth",
              null,
              ["number", "array", "number", "array", "number", "array"]
            );
          } catch (ex) {
            return reject(ex);
          }
          resolve();
        });
      })(),
      NullCipher,
      createCipher,
      NullDecipher,
      createDecipher
    };
  }
});

// node_modules/ssh2/lib/protocol/keyParser.js
var require_keyParser = __commonJS({
  "node_modules/ssh2/lib/protocol/keyParser.js"(exports, module2) {
    "use strict";
    var {
      createDecipheriv,
      createECDH,
      createHash,
      createHmac,
      createSign,
      createVerify,
      getCiphers,
      sign: sign_,
      verify: verify_
    } = require("crypto");
    var supportedOpenSSLCiphers = getCiphers();
    var { Ber } = require_lib();
    var bcrypt_pbkdf = require_bcrypt_pbkdf().pbkdf;
    var { CIPHER_INFO } = require_crypto();
    var { eddsaSupported, SUPPORTED_CIPHER } = require_constants();
    var {
      bufferSlice,
      makeBufferParser,
      readString,
      readUInt32BE,
      writeUInt32BE
    } = require_utils();
    var SYM_HASH_ALGO = Symbol("Hash Algorithm");
    var SYM_PRIV_PEM = Symbol("Private key PEM");
    var SYM_PUB_PEM = Symbol("Public key PEM");
    var SYM_PUB_SSH = Symbol("Public key SSH");
    var SYM_DECRYPTED = Symbol("Decrypted Key");
    var CIPHER_INFO_OPENSSL = /* @__PURE__ */ Object.create(null);
    {
      const keys = Object.keys(CIPHER_INFO);
      for (let i = 0; i < keys.length; ++i) {
        const cipherName = CIPHER_INFO[keys[i]].sslName;
        if (!cipherName || CIPHER_INFO_OPENSSL[cipherName])
          continue;
        CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]];
      }
    }
    var binaryKeyParser = makeBufferParser();
    function makePEM(type, data) {
      data = data.base64Slice(0, data.length);
      let formatted = data.replace(/.{64}/g, "$&\n");
      if (data.length & 63)
        formatted += "\n";
      return `-----BEGIN ${type} KEY-----
${formatted}-----END ${type} KEY-----`;
    }
    function combineBuffers(buf1, buf2) {
      const result = Buffer.allocUnsafe(buf1.length + buf2.length);
      result.set(buf1, 0);
      result.set(buf2, buf1.length);
      return result;
    }
    function skipFields(buf, nfields) {
      const bufLen = buf.length;
      let pos = buf._pos || 0;
      for (let i = 0; i < nfields; ++i) {
        const left = bufLen - pos;
        if (pos >= bufLen || left < 4)
          return false;
        const len = readUInt32BE(buf, pos);
        if (left < 4 + len)
          return false;
        pos += 4 + len;
      }
      buf._pos = pos;
      return true;
    }
    function genOpenSSLRSAPub(n, e) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.113549.1.1.1");
      asnWriter.writeNull();
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter.startSequence();
      asnWriter.writeBuffer(n, Ber.Integer);
      asnWriter.writeBuffer(e, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHRSAPub(n, e) {
      const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);
      writeUInt32BE(publicKey, 7, 0);
      publicKey.utf8Write("ssh-rsa", 4, 7);
      let i = 4 + 7;
      writeUInt32BE(publicKey, e.length, i);
      publicKey.set(e, i += 4);
      writeUInt32BE(publicKey, n.length, i += e.length);
      publicKey.set(n, i + 4);
      return publicKey;
    }
    var genOpenSSLRSAPriv = (() => {
      function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {
        const asnWriter = new Ber.Writer();
        asnWriter.startSequence();
        asnWriter.writeInt(0, Ber.Integer);
        asnWriter.writeBuffer(n, Ber.Integer);
        asnWriter.writeBuffer(e, Ber.Integer);
        asnWriter.writeBuffer(d, Ber.Integer);
        asnWriter.writeBuffer(p, Ber.Integer);
        asnWriter.writeBuffer(q, Ber.Integer);
        asnWriter.writeBuffer(dmp1, Ber.Integer);
        asnWriter.writeBuffer(dmq1, Ber.Integer);
        asnWriter.writeBuffer(iqmp, Ber.Integer);
        asnWriter.endSequence();
        return asnWriter.buffer;
      }
      function bigIntFromBuffer(buf) {
        return BigInt(`0x${buf.hexSlice(0, buf.length)}`);
      }
      function bigIntToBuffer(bn) {
        let hex = bn.toString(16);
        if ((hex.length & 1) !== 0) {
          hex = `0${hex}`;
        } else {
          const sigbit = hex.charCodeAt(0);
          if (sigbit === 56 || sigbit === 57 || sigbit >= 97 && sigbit <= 102) {
            hex = `00${hex}`;
          }
        }
        return Buffer.from(hex, "hex");
      }
      return function genOpenSSLRSAPriv2(n, e, d, iqmp, p, q) {
        const bn_d = bigIntFromBuffer(d);
        const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));
        const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));
        return makePEM(
          "RSA PRIVATE",
          genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp)
        );
      };
    })();
    function genOpenSSLDSAPub(p, q, g, y) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.10040.4.1");
      asnWriter.startSequence();
      asnWriter.writeBuffer(p, Ber.Integer);
      asnWriter.writeBuffer(q, Ber.Integer);
      asnWriter.writeBuffer(g, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter.writeBuffer(y, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHDSAPub(p, q, g, y) {
      const publicKey = Buffer.allocUnsafe(
        4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length
      );
      writeUInt32BE(publicKey, 7, 0);
      publicKey.utf8Write("ssh-dss", 4, 7);
      let i = 4 + 7;
      writeUInt32BE(publicKey, p.length, i);
      publicKey.set(p, i += 4);
      writeUInt32BE(publicKey, q.length, i += p.length);
      publicKey.set(q, i += 4);
      writeUInt32BE(publicKey, g.length, i += q.length);
      publicKey.set(g, i += 4);
      writeUInt32BE(publicKey, y.length, i += g.length);
      publicKey.set(y, i + 4);
      return publicKey;
    }
    function genOpenSSLDSAPriv(p, q, g, y, x) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(0, Ber.Integer);
      asnWriter.writeBuffer(p, Ber.Integer);
      asnWriter.writeBuffer(q, Ber.Integer);
      asnWriter.writeBuffer(g, Ber.Integer);
      asnWriter.writeBuffer(y, Ber.Integer);
      asnWriter.writeBuffer(x, Ber.Integer);
      asnWriter.endSequence();
      return makePEM("DSA PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLEdPub(pub) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.3.101.112");
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(pub.length);
      asnWriter._buf.set(pub, asnWriter._offset);
      asnWriter._offset += pub.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHEdPub(pub) {
      const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);
      writeUInt32BE(publicKey, 11, 0);
      publicKey.utf8Write("ssh-ed25519", 4, 11);
      writeUInt32BE(publicKey, pub.length, 15);
      publicKey.set(pub, 19);
      return publicKey;
    }
    function genOpenSSLEdPriv(priv) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(0, Ber.Integer);
      asnWriter.startSequence();
      asnWriter.writeOID("1.3.101.112");
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.OctetString);
      asnWriter.writeBuffer(priv, Ber.OctetString);
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLECDSAPub(oid, Q) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.10045.2.1");
      asnWriter.writeOID(oid);
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(Q.length);
      asnWriter._buf.set(Q, asnWriter._offset);
      asnWriter._offset += Q.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHECDSAPub(oid, Q) {
      let curveName;
      switch (oid) {
        case "1.2.840.10045.3.1.7":
          curveName = "nistp256";
          break;
        case "1.3.132.0.34":
          curveName = "nistp384";
          break;
        case "1.3.132.0.35":
          curveName = "nistp521";
          break;
        default:
          return;
      }
      const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);
      writeUInt32BE(publicKey, 19, 0);
      publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);
      writeUInt32BE(publicKey, 8, 23);
      publicKey.utf8Write(curveName, 27, 8);
      writeUInt32BE(publicKey, Q.length, 35);
      publicKey.set(Q, 39);
      return publicKey;
    }
    function genOpenSSLECDSAPriv(oid, pub, priv) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(1, Ber.Integer);
      asnWriter.writeBuffer(priv, Ber.OctetString);
      asnWriter.startSequence(160);
      asnWriter.writeOID(oid);
      asnWriter.endSequence();
      asnWriter.startSequence(161);
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(pub.length);
      asnWriter._buf.set(pub, asnWriter._offset);
      asnWriter._offset += pub.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("EC PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLECDSAPubFromPriv(curveName, priv) {
      const tempECDH = createECDH(curveName);
      tempECDH.setPrivateKey(priv);
      return tempECDH.getPublicKey();
    }
    var BaseKey = {
      sign: (() => {
        if (typeof sign_ === "function") {
          return function sign(data, algo) {
            const pem = this[SYM_PRIV_PEM];
            if (pem === null)
              return new Error("No private key available");
            if (!algo || typeof algo !== "string")
              algo = this[SYM_HASH_ALGO];
            try {
              return sign_(algo, data, pem);
            } catch (ex) {
              return ex;
            }
          };
        }
        return function sign(data, algo) {
          const pem = this[SYM_PRIV_PEM];
          if (pem === null)
            return new Error("No private key available");
          if (!algo || typeof algo !== "string")
            algo = this[SYM_HASH_ALGO];
          const signature = createSign(algo);
          signature.update(data);
          try {
            return signature.sign(pem);
          } catch (ex) {
            return ex;
          }
        };
      })(),
      verify: (() => {
        if (typeof verify_ === "function") {
          return function verify(data, signature, algo) {
            const pem = this[SYM_PUB_PEM];
            if (pem === null)
              return new Error("No public key available");
            if (!algo || typeof algo !== "string")
              algo = this[SYM_HASH_ALGO];
            try {
              return verify_(algo, data, pem, signature);
            } catch (ex) {
              return ex;
            }
          };
        }
        return function verify(data, signature, algo) {
          const pem = this[SYM_PUB_PEM];
          if (pem === null)
            return new Error("No public key available");
          if (!algo || typeof algo !== "string")
            algo = this[SYM_HASH_ALGO];
          const verifier = createVerify(algo);
          verifier.update(data);
          try {
            return verifier.verify(pem, signature);
          } catch (ex) {
            return ex;
          }
        };
      })(),
      isPrivateKey: function isPrivateKey() {
        return this[SYM_PRIV_PEM] !== null;
      },
      getPrivatePEM: function getPrivatePEM() {
        return this[SYM_PRIV_PEM];
      },
      getPublicPEM: function getPublicPEM() {
        return this[SYM_PUB_PEM];
      },
      getPublicSSH: function getPublicSSH() {
        return this[SYM_PUB_SSH];
      },
      equals: function equals(key) {
        const parsed = parseKey(key);
        if (parsed instanceof Error)
          return false;
        return this.type === parsed.type && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM] && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM] && this[SYM_PUB_SSH] === parsed[SYM_PUB_SSH];
      }
    };
    function OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    OpenSSH_Private.prototype = BaseKey;
    {
      let parseOpenSSHPrivKeys = function(data, nkeys, decrypted) {
        const keys = [];
        if (data.length < 8)
          return new Error("Malformed OpenSSH private key");
        const check1 = readUInt32BE(data, 0);
        const check2 = readUInt32BE(data, 4);
        if (check1 !== check2) {
          if (decrypted) {
            return new Error(
              "OpenSSH key integrity check failed -- bad passphrase?"
            );
          }
          return new Error("OpenSSH key integrity check failed");
        }
        data._pos = 8;
        let i;
        let oid;
        for (i = 0; i < nkeys; ++i) {
          let algo;
          let privPEM;
          let pubPEM;
          let pubSSH;
          const type = readString(data, data._pos, true);
          if (type === void 0)
            return new Error("Malformed OpenSSH private key");
          switch (type) {
            case "ssh-rsa": {
              const n = readString(data, data._pos);
              if (n === void 0)
                return new Error("Malformed OpenSSH private key");
              const e = readString(data, data._pos);
              if (e === void 0)
                return new Error("Malformed OpenSSH private key");
              const d = readString(data, data._pos);
              if (d === void 0)
                return new Error("Malformed OpenSSH private key");
              const iqmp = readString(data, data._pos);
              if (iqmp === void 0)
                return new Error("Malformed OpenSSH private key");
              const p = readString(data, data._pos);
              if (p === void 0)
                return new Error("Malformed OpenSSH private key");
              const q = readString(data, data._pos);
              if (q === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLRSAPub(n, e);
              pubSSH = genOpenSSHRSAPub(n, e);
              privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);
              algo = "sha1";
              break;
            }
            case "ssh-dss": {
              const p = readString(data, data._pos);
              if (p === void 0)
                return new Error("Malformed OpenSSH private key");
              const q = readString(data, data._pos);
              if (q === void 0)
                return new Error("Malformed OpenSSH private key");
              const g = readString(data, data._pos);
              if (g === void 0)
                return new Error("Malformed OpenSSH private key");
              const y = readString(data, data._pos);
              if (y === void 0)
                return new Error("Malformed OpenSSH private key");
              const x = readString(data, data._pos);
              if (x === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLDSAPub(p, q, g, y);
              pubSSH = genOpenSSHDSAPub(p, q, g, y);
              privPEM = genOpenSSLDSAPriv(p, q, g, y, x);
              algo = "sha1";
              break;
            }
            case "ssh-ed25519": {
              if (!eddsaSupported)
                return new Error(`Unsupported OpenSSH private key type: ${type}`);
              const edpub = readString(data, data._pos);
              if (edpub === void 0 || edpub.length !== 32)
                return new Error("Malformed OpenSSH private key");
              const edpriv = readString(data, data._pos);
              if (edpriv === void 0 || edpriv.length !== 64)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLEdPub(edpub);
              pubSSH = genOpenSSHEdPub(edpub);
              privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32));
              algo = null;
              break;
            }
            case "ecdsa-sha2-nistp256":
              algo = "sha256";
              oid = "1.2.840.10045.3.1.7";
            case "ecdsa-sha2-nistp384":
              if (algo === void 0) {
                algo = "sha384";
                oid = "1.3.132.0.34";
              }
            case "ecdsa-sha2-nistp521": {
              if (algo === void 0) {
                algo = "sha512";
                oid = "1.3.132.0.35";
              }
              if (!skipFields(data, 1))
                return new Error("Malformed OpenSSH private key");
              const ecpub = readString(data, data._pos);
              if (ecpub === void 0)
                return new Error("Malformed OpenSSH private key");
              const ecpriv = readString(data, data._pos);
              if (ecpriv === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLECDSAPub(oid, ecpub);
              pubSSH = genOpenSSHECDSAPub(oid, ecpub);
              privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);
              break;
            }
            default:
              return new Error(`Unsupported OpenSSH private key type: ${type}`);
          }
          const privComment = readString(data, data._pos, true);
          if (privComment === void 0)
            return new Error("Malformed OpenSSH private key");
          keys.push(
            new OpenSSH_Private(
              type,
              privComment,
              privPEM,
              pubPEM,
              pubSSH,
              algo,
              decrypted
            )
          );
        }
        let cnt = 0;
        for (i = data._pos; i < data.length; ++i) {
          if (data[i] !== ++cnt % 255)
            return new Error("Malformed OpenSSH private key");
        }
        return keys;
      };
      const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\r\n|\n)([\s\S]+)(?:\r\n|\n)-----END OPENSSH PRIVATE KEY-----$/;
      OpenSSH_Private.parse = (str, passphrase) => {
        const m = regexp.exec(str);
        if (m === null)
          return null;
        let ret;
        const data = Buffer.from(m[1], "base64");
        if (data.length < 31)
          return new Error("Malformed OpenSSH private key");
        const magic = data.utf8Slice(0, 15);
        if (magic !== "openssh-key-v1\0")
          return new Error(`Unsupported OpenSSH key magic: ${magic}`);
        const cipherName = readString(data, 15, true);
        if (cipherName === void 0)
          return new Error("Malformed OpenSSH private key");
        if (cipherName !== "none" && SUPPORTED_CIPHER.indexOf(cipherName) === -1)
          return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);
        const kdfName = readString(data, data._pos, true);
        if (kdfName === void 0)
          return new Error("Malformed OpenSSH private key");
        if (kdfName !== "none") {
          if (cipherName === "none")
            return new Error("Malformed OpenSSH private key");
          if (kdfName !== "bcrypt")
            return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);
          if (!passphrase) {
            return new Error(
              "Encrypted private OpenSSH key detected, but no passphrase given"
            );
          }
        } else if (cipherName !== "none") {
          return new Error("Malformed OpenSSH private key");
        }
        let encInfo;
        let cipherKey;
        let cipherIV;
        if (cipherName !== "none")
          encInfo = CIPHER_INFO[cipherName];
        const kdfOptions = readString(data, data._pos);
        if (kdfOptions === void 0)
          return new Error("Malformed OpenSSH private key");
        if (kdfOptions.length) {
          switch (kdfName) {
            case "none":
              return new Error("Malformed OpenSSH private key");
            case "bcrypt": {
              const salt = readString(kdfOptions, 0);
              if (salt === void 0 || kdfOptions._pos + 4 > kdfOptions.length)
                return new Error("Malformed OpenSSH private key");
              const rounds = readUInt32BE(kdfOptions, kdfOptions._pos);
              const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);
              const r = bcrypt_pbkdf(
                passphrase,
                passphrase.length,
                salt,
                salt.length,
                gen,
                gen.length,
                rounds
              );
              if (r !== 0)
                return new Error("Failed to generate information to decrypt key");
              cipherKey = bufferSlice(gen, 0, encInfo.keyLen);
              cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);
              break;
            }
          }
        } else if (kdfName !== "none") {
          return new Error("Malformed OpenSSH private key");
        }
        if (data._pos + 3 >= data.length)
          return new Error("Malformed OpenSSH private key");
        const keyCount = readUInt32BE(data, data._pos);
        data._pos += 4;
        if (keyCount > 0) {
          for (let i = 0; i < keyCount; ++i) {
            const pubData = readString(data, data._pos);
            if (pubData === void 0)
              return new Error("Malformed OpenSSH private key");
            const type = readString(pubData, 0, true);
            if (type === void 0)
              return new Error("Malformed OpenSSH private key");
          }
          let privBlob = readString(data, data._pos);
          if (privBlob === void 0)
            return new Error("Malformed OpenSSH private key");
          if (cipherKey !== void 0) {
            if (privBlob.length < encInfo.blockLen || privBlob.length % encInfo.blockLen !== 0) {
              return new Error("Malformed OpenSSH private key");
            }
            try {
              const options = { authTagLength: encInfo.authLen };
              const decipher = createDecipheriv(
                encInfo.sslName,
                cipherKey,
                cipherIV,
                options
              );
              decipher.setAutoPadding(false);
              if (encInfo.authLen > 0) {
                if (data.length - data._pos < encInfo.authLen)
                  return new Error("Malformed OpenSSH private key");
                decipher.setAuthTag(
                  bufferSlice(data, data._pos, data._pos += encInfo.authLen)
                );
              }
              privBlob = combineBuffers(
                decipher.update(privBlob),
                decipher.final()
              );
            } catch (ex) {
              return ex;
            }
          }
          if (data._pos !== data.length)
            return new Error("Malformed OpenSSH private key");
          ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== void 0);
        } else {
          ret = [];
        }
        if (ret instanceof Error)
          return ret;
        return ret[0];
      };
    }
    function OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    OpenSSH_Old_Private.prototype = BaseKey;
    {
      const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\r\n|\n)((?:[^:]+:\s*[\S].*(?:\r\n|\n))*)([\s\S]+)(?:\r\n|\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;
      OpenSSH_Old_Private.parse = (str, passphrase) => {
        const m = regexp.exec(str);
        if (m === null)
          return null;
        let privBlob = Buffer.from(m[3], "base64");
        let headers = m[2];
        let decrypted = false;
        if (headers !== void 0) {
          headers = headers.split(/\r\n|\n/g);
          for (let i = 0; i < headers.length; ++i) {
            const header = headers[i];
            let sepIdx = header.indexOf(":");
            if (header.slice(0, sepIdx) === "DEK-Info") {
              const val = header.slice(sepIdx + 2);
              sepIdx = val.indexOf(",");
              if (sepIdx === -1)
                continue;
              const cipherName = val.slice(0, sepIdx).toLowerCase();
              if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {
                return new Error(
                  `Cipher (${cipherName}) not supported for encrypted OpenSSH private key`
                );
              }
              const encInfo = CIPHER_INFO_OPENSSL[cipherName];
              if (!encInfo) {
                return new Error(
                  `Cipher (${cipherName}) not supported for encrypted OpenSSH private key`
                );
              }
              const cipherIV = Buffer.from(val.slice(sepIdx + 1), "hex");
              if (cipherIV.length !== encInfo.ivLen)
                return new Error("Malformed encrypted OpenSSH private key");
              if (!passphrase) {
                return new Error(
                  "Encrypted OpenSSH private key detected, but no passphrase given"
                );
              }
              const ivSlice = bufferSlice(cipherIV, 0, 8);
              let cipherKey = createHash("md5").update(passphrase).update(ivSlice).digest();
              while (cipherKey.length < encInfo.keyLen) {
                cipherKey = combineBuffers(
                  cipherKey,
                  createHash("md5").update(cipherKey).update(passphrase).update(ivSlice).digest()
                );
              }
              if (cipherKey.length > encInfo.keyLen)
                cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);
              try {
                const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);
                decipher.setAutoPadding(false);
                privBlob = combineBuffers(
                  decipher.update(privBlob),
                  decipher.final()
                );
                decrypted = true;
              } catch (ex) {
                return ex;
              }
            }
          }
        }
        let type;
        let privPEM;
        let pubPEM;
        let pubSSH;
        let algo;
        let reader;
        let errMsg = "Malformed OpenSSH private key";
        if (decrypted)
          errMsg += ". Bad passphrase?";
        switch (m[1]) {
          case "RSA":
            type = "ssh-rsa";
            privPEM = makePEM("RSA PRIVATE", privBlob);
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              const n = reader.readString(Ber.Integer, true);
              if (n === null)
                return new Error(errMsg);
              const e = reader.readString(Ber.Integer, true);
              if (e === null)
                return new Error(errMsg);
              pubPEM = genOpenSSLRSAPub(n, e);
              pubSSH = genOpenSSHRSAPub(n, e);
            } catch {
              return new Error(errMsg);
            }
            algo = "sha1";
            break;
          case "DSA":
            type = "ssh-dss";
            privPEM = makePEM("DSA PRIVATE", privBlob);
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              const p = reader.readString(Ber.Integer, true);
              if (p === null)
                return new Error(errMsg);
              const q = reader.readString(Ber.Integer, true);
              if (q === null)
                return new Error(errMsg);
              const g = reader.readString(Ber.Integer, true);
              if (g === null)
                return new Error(errMsg);
              const y = reader.readString(Ber.Integer, true);
              if (y === null)
                return new Error(errMsg);
              pubPEM = genOpenSSLDSAPub(p, q, g, y);
              pubSSH = genOpenSSHDSAPub(p, q, g, y);
            } catch {
              return new Error(errMsg);
            }
            algo = "sha1";
            break;
          case "EC": {
            let ecSSLName;
            let ecPriv;
            let ecOID;
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              ecPriv = reader.readString(Ber.OctetString, true);
              reader.readByte();
              const offset = reader.readLength();
              if (offset !== null) {
                reader._offset = offset;
                ecOID = reader.readOID();
                if (ecOID === null)
                  return new Error(errMsg);
                switch (ecOID) {
                  case "1.2.840.10045.3.1.7":
                    ecSSLName = "prime256v1";
                    type = "ecdsa-sha2-nistp256";
                    algo = "sha256";
                    break;
                  case "1.3.132.0.34":
                    ecSSLName = "secp384r1";
                    type = "ecdsa-sha2-nistp384";
                    algo = "sha384";
                    break;
                  case "1.3.132.0.35":
                    ecSSLName = "secp521r1";
                    type = "ecdsa-sha2-nistp521";
                    algo = "sha512";
                    break;
                  default:
                    return new Error(`Unsupported private key EC OID: ${ecOID}`);
                }
              } else {
                return new Error(errMsg);
              }
            } catch {
              return new Error(errMsg);
            }
            privPEM = makePEM("EC PRIVATE", privBlob);
            const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);
            pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);
            pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);
            break;
          }
        }
        return new OpenSSH_Old_Private(
          type,
          "",
          privPEM,
          pubPEM,
          pubSSH,
          algo,
          decrypted
        );
      };
    }
    function PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    PPK_Private.prototype = BaseKey;
    {
      const EMPTY_PASSPHRASE = Buffer.alloc(0);
      const PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      const PPK_PP1 = Buffer.from([0, 0, 0, 0]);
      const PPK_PP2 = Buffer.from([0, 0, 0, 1]);
      const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\r?\nEncryption: (aes256-cbc|none)\r?\nComment: ([^\r\n]*)\r?\nPublic-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-MAC: ([^\r\n]+)/;
      PPK_Private.parse = (str, passphrase) => {
        const m = regexp.exec(str);
        if (m === null)
          return null;
        const cipherName = m[2];
        const encrypted = cipherName !== "none";
        if (encrypted && !passphrase) {
          return new Error(
            "Encrypted PPK private key detected, but no passphrase given"
          );
        }
        let privBlob = Buffer.from(m[5], "base64");
        if (encrypted) {
          const encInfo = CIPHER_INFO[cipherName];
          let cipherKey = combineBuffers(
            createHash("sha1").update(PPK_PP1).update(passphrase).digest(),
            createHash("sha1").update(PPK_PP2).update(passphrase).digest()
          );
          if (cipherKey.length > encInfo.keyLen)
            cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);
          try {
            const decipher = createDecipheriv(encInfo.sslName, cipherKey, PPK_IV);
            decipher.setAutoPadding(false);
            privBlob = combineBuffers(
              decipher.update(privBlob),
              decipher.final()
            );
          } catch (ex) {
            return ex;
          }
        }
        const type = m[1];
        const comment = m[3];
        const pubBlob = Buffer.from(m[4], "base64");
        const mac = m[6];
        const typeLen = type.length;
        const cipherNameLen = cipherName.length;
        const commentLen = Buffer.byteLength(comment);
        const pubLen = pubBlob.length;
        const privLen = privBlob.length;
        const macData = Buffer.allocUnsafe(4 + typeLen + 4 + cipherNameLen + 4 + commentLen + 4 + pubLen + 4 + privLen);
        let p = 0;
        writeUInt32BE(macData, typeLen, p);
        macData.utf8Write(type, p += 4, typeLen);
        writeUInt32BE(macData, cipherNameLen, p += typeLen);
        macData.utf8Write(cipherName, p += 4, cipherNameLen);
        writeUInt32BE(macData, commentLen, p += cipherNameLen);
        macData.utf8Write(comment, p += 4, commentLen);
        writeUInt32BE(macData, pubLen, p += commentLen);
        macData.set(pubBlob, p += 4);
        writeUInt32BE(macData, privLen, p += pubLen);
        macData.set(privBlob, p + 4);
        if (!passphrase)
          passphrase = EMPTY_PASSPHRASE;
        const calcMAC = createHmac(
          "sha1",
          createHash("sha1").update("putty-private-key-file-mac-key").update(passphrase).digest()
        ).update(macData).digest("hex");
        if (calcMAC !== mac) {
          if (encrypted) {
            return new Error(
              "PPK private key integrity check failed -- bad passphrase?"
            );
          }
          return new Error("PPK private key integrity check failed");
        }
        let pubPEM;
        let pubSSH;
        let privPEM;
        pubBlob._pos = 0;
        skipFields(pubBlob, 1);
        switch (type) {
          case "ssh-rsa": {
            const e = readString(pubBlob, pubBlob._pos);
            if (e === void 0)
              return new Error("Malformed PPK public key");
            const n = readString(pubBlob, pubBlob._pos);
            if (n === void 0)
              return new Error("Malformed PPK public key");
            const d = readString(privBlob, 0);
            if (d === void 0)
              return new Error("Malformed PPK private key");
            const p2 = readString(privBlob, privBlob._pos);
            if (p2 === void 0)
              return new Error("Malformed PPK private key");
            const q = readString(privBlob, privBlob._pos);
            if (q === void 0)
              return new Error("Malformed PPK private key");
            const iqmp = readString(privBlob, privBlob._pos);
            if (iqmp === void 0)
              return new Error("Malformed PPK private key");
            pubPEM = genOpenSSLRSAPub(n, e);
            pubSSH = genOpenSSHRSAPub(n, e);
            privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p2, q);
            break;
          }
          case "ssh-dss": {
            const p2 = readString(pubBlob, pubBlob._pos);
            if (p2 === void 0)
              return new Error("Malformed PPK public key");
            const q = readString(pubBlob, pubBlob._pos);
            if (q === void 0)
              return new Error("Malformed PPK public key");
            const g = readString(pubBlob, pubBlob._pos);
            if (g === void 0)
              return new Error("Malformed PPK public key");
            const y = readString(pubBlob, pubBlob._pos);
            if (y === void 0)
              return new Error("Malformed PPK public key");
            const x = readString(privBlob, 0);
            if (x === void 0)
              return new Error("Malformed PPK private key");
            pubPEM = genOpenSSLDSAPub(p2, q, g, y);
            pubSSH = genOpenSSHDSAPub(p2, q, g, y);
            privPEM = genOpenSSLDSAPriv(p2, q, g, y, x);
            break;
          }
        }
        return new PPK_Private(
          type,
          comment,
          privPEM,
          pubPEM,
          pubSSH,
          "sha1",
          encrypted
        );
      };
    }
    function OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {
      this.type = type;
      this.comment = comment;
      this[SYM_PRIV_PEM] = null;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = false;
    }
    OpenSSH_Public.prototype = BaseKey;
    {
      let regexp;
      if (eddsaSupported)
        regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;
      else
        regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;
      OpenSSH_Public.parse = (str) => {
        const m = regexp.exec(str);
        if (m === null)
          return null;
        const fullType = m[1];
        const baseType = m[2];
        const data = Buffer.from(m[3], "base64");
        const comment = m[4] || "";
        const type = readString(data, data._pos, true);
        if (type === void 0 || type.indexOf(baseType) !== 0)
          return new Error("Malformed OpenSSH public key");
        return parseDER(data, baseType, comment, fullType);
      };
    }
    function RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {
      this.type = type;
      this.comment = comment;
      this[SYM_PRIV_PEM] = null;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = false;
    }
    RFC4716_Public.prototype = BaseKey;
    {
      const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\r?\n)((?:.{0,72}\r?\n)+)---- END SSH2 PUBLIC KEY ----$/;
      const RE_DATA = /^[A-Z0-9a-z/+=\r\n]+$/;
      const RE_HEADER = /^([\x21-\x39\x3B-\x7E]{1,64}): ((?:[^\\]*\\\r?\n)*[^\r\n]+)\r?\n/gm;
      const RE_HEADER_ENDS = /\\\r?\n/g;
      RFC4716_Public.parse = (str) => {
        let m = regexp.exec(str);
        if (m === null)
          return null;
        const body = m[1];
        let dataStart = 0;
        let comment = "";
        while (m = RE_HEADER.exec(body)) {
          const headerName = m[1];
          const headerValue = m[2].replace(RE_HEADER_ENDS, "");
          if (headerValue.length > 1024) {
            RE_HEADER.lastIndex = 0;
            return new Error("Malformed RFC4716 public key");
          }
          dataStart = RE_HEADER.lastIndex;
          if (headerName.toLowerCase() === "comment") {
            comment = headerValue;
            if (comment.length > 1 && comment.charCodeAt(0) === 34 && comment.charCodeAt(comment.length - 1) === 34) {
              comment = comment.slice(1, -1);
            }
          }
        }
        let data = body.slice(dataStart);
        if (!RE_DATA.test(data))
          return new Error("Malformed RFC4716 public key");
        data = Buffer.from(data, "base64");
        const type = readString(data, 0, true);
        if (type === void 0)
          return new Error("Malformed RFC4716 public key");
        let pubPEM = null;
        let pubSSH = null;
        switch (type) {
          case "ssh-rsa": {
            const e = readString(data, data._pos);
            if (e === void 0)
              return new Error("Malformed RFC4716 public key");
            const n = readString(data, data._pos);
            if (n === void 0)
              return new Error("Malformed RFC4716 public key");
            pubPEM = genOpenSSLRSAPub(n, e);
            pubSSH = genOpenSSHRSAPub(n, e);
            break;
          }
          case "ssh-dss": {
            const p = readString(data, data._pos);
            if (p === void 0)
              return new Error("Malformed RFC4716 public key");
            const q = readString(data, data._pos);
            if (q === void 0)
              return new Error("Malformed RFC4716 public key");
            const g = readString(data, data._pos);
            if (g === void 0)
              return new Error("Malformed RFC4716 public key");
            const y = readString(data, data._pos);
            if (y === void 0)
              return new Error("Malformed RFC4716 public key");
            pubPEM = genOpenSSLDSAPub(p, q, g, y);
            pubSSH = genOpenSSHDSAPub(p, q, g, y);
            break;
          }
          default:
            return new Error("Malformed RFC4716 public key");
        }
        return new RFC4716_Public(type, comment, pubPEM, pubSSH, "sha1");
      };
    }
    function parseDER(data, baseType, comment, fullType) {
      if (!isSupportedKeyType(baseType))
        return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
      let algo;
      let oid;
      let pubPEM = null;
      let pubSSH = null;
      switch (baseType) {
        case "ssh-rsa": {
          const e = readString(data, data._pos || 0);
          if (e === void 0)
            return new Error("Malformed OpenSSH public key");
          const n = readString(data, data._pos);
          if (n === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLRSAPub(n, e);
          pubSSH = genOpenSSHRSAPub(n, e);
          algo = "sha1";
          break;
        }
        case "ssh-dss": {
          const p = readString(data, data._pos || 0);
          if (p === void 0)
            return new Error("Malformed OpenSSH public key");
          const q = readString(data, data._pos);
          if (q === void 0)
            return new Error("Malformed OpenSSH public key");
          const g = readString(data, data._pos);
          if (g === void 0)
            return new Error("Malformed OpenSSH public key");
          const y = readString(data, data._pos);
          if (y === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLDSAPub(p, q, g, y);
          pubSSH = genOpenSSHDSAPub(p, q, g, y);
          algo = "sha1";
          break;
        }
        case "ssh-ed25519": {
          const edpub = readString(data, data._pos || 0);
          if (edpub === void 0 || edpub.length !== 32)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLEdPub(edpub);
          pubSSH = genOpenSSHEdPub(edpub);
          algo = null;
          break;
        }
        case "ecdsa-sha2-nistp256":
          algo = "sha256";
          oid = "1.2.840.10045.3.1.7";
        case "ecdsa-sha2-nistp384":
          if (algo === void 0) {
            algo = "sha384";
            oid = "1.3.132.0.34";
          }
        case "ecdsa-sha2-nistp521": {
          if (algo === void 0) {
            algo = "sha512";
            oid = "1.3.132.0.35";
          }
          if (!skipFields(data, 1))
            return new Error("Malformed OpenSSH public key");
          const ecpub = readString(data, data._pos || 0);
          if (ecpub === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLECDSAPub(oid, ecpub);
          pubSSH = genOpenSSHECDSAPub(oid, ecpub);
          break;
        }
        default:
          return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
      }
      return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);
    }
    function isSupportedKeyType(type) {
      switch (type) {
        case "ssh-rsa":
        case "ssh-dss":
        case "ecdsa-sha2-nistp256":
        case "ecdsa-sha2-nistp384":
        case "ecdsa-sha2-nistp521":
          return true;
        case "ssh-ed25519":
          if (eddsaSupported)
            return true;
        default:
          return false;
      }
    }
    function isParsedKey(val) {
      if (!val)
        return false;
      return typeof val[SYM_DECRYPTED] === "boolean";
    }
    function parseKey(data, passphrase) {
      if (isParsedKey(data))
        return data;
      let origBuffer;
      if (Buffer.isBuffer(data)) {
        origBuffer = data;
        data = data.utf8Slice(0, data.length).trim();
      } else if (typeof data === "string") {
        data = data.trim();
      } else {
        return new Error("Key data must be a Buffer or string");
      }
      if (passphrase != void 0) {
        if (typeof passphrase === "string")
          passphrase = Buffer.from(passphrase);
        else if (!Buffer.isBuffer(passphrase))
          return new Error("Passphrase must be a string or Buffer when supplied");
      }
      let ret;
      if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null)
        return ret;
      if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null)
        return ret;
      if ((ret = PPK_Private.parse(data, passphrase)) !== null)
        return ret;
      if ((ret = OpenSSH_Public.parse(data)) !== null)
        return ret;
      if ((ret = RFC4716_Public.parse(data)) !== null)
        return ret;
      if (origBuffer) {
        binaryKeyParser.init(origBuffer, 0);
        const type = binaryKeyParser.readString(true);
        if (type !== void 0) {
          data = binaryKeyParser.readRaw();
          if (data !== void 0) {
            ret = parseDER(data, type, "", type);
            if (ret instanceof Error)
              ret = null;
          }
        }
        binaryKeyParser.clear();
      }
      if (ret)
        return ret;
      return new Error("Unsupported key format");
    }
    module2.exports = {
      isParsedKey,
      isSupportedKeyType,
      parseDERKey: (data, type) => parseDER(data, type, "", type),
      parseKey
    };
  }
});

// node_modules/ssh2/lib/agent.js
var require_agent = __commonJS({
  "node_modules/ssh2/lib/agent.js"(exports, module2) {
    "use strict";
    var { Socket } = require("net");
    var { Duplex } = require("stream");
    var { resolve } = require("path");
    var { readFile } = require("fs");
    var { execFile, spawn } = require("child_process");
    var { isParsedKey, parseKey } = require_keyParser();
    var {
      makeBufferParser,
      readUInt32BE,
      writeUInt32BE,
      writeUInt32LE
    } = require_utils();
    function once(cb) {
      let called = false;
      return (...args) => {
        if (called)
          return;
        called = true;
        cb(...args);
      };
    }
    function concat(buf1, buf2) {
      const combined = Buffer.allocUnsafe(buf1.length + buf2.length);
      buf1.copy(combined, 0);
      buf2.copy(combined, buf1.length);
      return combined;
    }
    function noop() {
    }
    var EMPTY_BUF = Buffer.alloc(0);
    var binaryParser = makeBufferParser();
    var BaseAgent = class {
      getIdentities(cb) {
        cb(new Error("Missing getIdentities() implementation"));
      }
      sign(pubKey, data, options, cb) {
        if (typeof options === "function")
          cb = options;
        cb(new Error("Missing sign() implementation"));
      }
    };
    var OpenSSHAgent = class extends BaseAgent {
      constructor(socketPath) {
        super();
        this.socketPath = socketPath;
      }
      getStream(cb) {
        cb = once(cb);
        const sock = new Socket();
        sock.on("connect", () => {
          cb(null, sock);
        });
        sock.on("close", onFail).on("end", onFail).on("error", onFail);
        sock.connect(this.socketPath);
        function onFail() {
          try {
            sock.destroy();
          } catch {
          }
          cb(new Error("Failed to connect to agent"));
        }
      }
      getIdentities(cb) {
        cb = once(cb);
        this.getStream((err, stream) => {
          function onFail(err2) {
            if (stream) {
              try {
                stream.destroy();
              } catch {
              }
            }
            if (!err2)
              err2 = new Error("Failed to retrieve identities from agent");
            cb(err2);
          }
          if (err)
            return onFail(err);
          const protocol = new AgentProtocol(true);
          protocol.on("error", onFail);
          protocol.pipe(stream).pipe(protocol);
          stream.on("close", onFail).on("end", onFail).on("error", onFail);
          protocol.getIdentities((err2, keys) => {
            if (err2)
              return onFail(err2);
            try {
              stream.destroy();
            } catch {
            }
            cb(null, keys);
          });
        });
      }
      sign(pubKey, data, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = void 0;
        } else if (typeof options !== "object" || options === null) {
          options = void 0;
        }
        cb = once(cb);
        this.getStream((err, stream) => {
          function onFail(err2) {
            if (stream) {
              try {
                stream.destroy();
              } catch {
              }
            }
            if (!err2)
              err2 = new Error("Failed to sign data with agent");
            cb(err2);
          }
          if (err)
            return onFail(err);
          const protocol = new AgentProtocol(true);
          protocol.on("error", onFail);
          protocol.pipe(stream).pipe(protocol);
          stream.on("close", onFail).on("end", onFail).on("error", onFail);
          protocol.sign(pubKey, data, options, (err2, sig) => {
            if (err2)
              return onFail(err2);
            try {
              stream.destroy();
            } catch {
            }
            cb(null, sig);
          });
        });
      }
    };
    var PageantAgent = (() => {
      const RET_ERR_BADARGS = 10;
      const RET_ERR_UNAVAILABLE = 11;
      const RET_ERR_NOMAP = 12;
      const RET_ERR_BINSTDIN = 13;
      const RET_ERR_BINSTDOUT = 14;
      const RET_ERR_BADLEN = 15;
      const EXEPATH = resolve(__dirname, "..", "util/pagent.exe");
      const ERROR = {
        [RET_ERR_BADARGS]: new Error("Invalid pagent.exe arguments"),
        [RET_ERR_UNAVAILABLE]: new Error("Pageant is not running"),
        [RET_ERR_NOMAP]: new Error("pagent.exe could not create an mmap"),
        [RET_ERR_BINSTDIN]: new Error("pagent.exe could not set mode for stdin"),
        [RET_ERR_BINSTDOUT]: new Error("pagent.exe could not set mode for stdout"),
        [RET_ERR_BADLEN]: new Error("pagent.exe did not get expected input payload")
      };
      function destroy(stream) {
        stream.buffer = null;
        if (stream.proc) {
          stream.proc.kill();
          stream.proc = void 0;
        }
      }
      class PageantSocket extends Duplex {
        constructor() {
          super();
          this.proc = void 0;
          this.buffer = null;
        }
        _read(n) {
        }
        _write(data, encoding, cb) {
          if (this.buffer === null) {
            this.buffer = data;
          } else {
            const newBuffer = Buffer.allocUnsafe(this.buffer.length + data.length);
            this.buffer.copy(newBuffer, 0);
            data.copy(newBuffer, this.buffer.length);
            this.buffer = newBuffer;
          }
          if (this.buffer.length < 4)
            return cb();
          const len = readUInt32BE(this.buffer, 0);
          if (this.buffer.length - 4 < len)
            return cb();
          data = this.buffer.slice(0, 4 + len);
          if (this.buffer.length > 4 + len)
            return cb(new Error("Unexpected multiple agent requests"));
          this.buffer = null;
          let error;
          const proc = this.proc = spawn(EXEPATH, [data.length]);
          proc.stdout.on("data", (data2) => {
            this.push(data2);
          });
          proc.on("error", (err) => {
            error = err;
            cb(error);
          });
          proc.on("close", (code) => {
            this.proc = void 0;
            if (!error) {
              if (error = ERROR[code])
                return cb(error);
              cb();
            }
          });
          proc.stdin.end(data);
        }
        _final(cb) {
          destroy(this);
          cb();
        }
        _destroy(err, cb) {
          destroy(this);
          cb();
        }
      }
      return class PageantAgent extends OpenSSHAgent {
        getStream(cb) {
          cb(null, new PageantSocket());
        }
      };
    })();
    var CygwinAgent = (() => {
      const RE_CYGWIN_SOCK = /^!<socket >(\d+) s ([A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8})/;
      return class CygwinAgent extends OpenSSHAgent {
        getStream(cb) {
          cb = once(cb);
          let socketPath = this.socketPath;
          let triedCygpath = false;
          readFile(socketPath, function readCygsocket(err, data) {
            if (err) {
              if (triedCygpath)
                return cb(new Error("Invalid cygwin unix socket path"));
              execFile("cygpath", ["-w", socketPath], (err2, stdout, stderr) => {
                if (err2 || stdout.length === 0)
                  return cb(new Error("Invalid cygwin unix socket path"));
                triedCygpath = true;
                socketPath = stdout.toString().replace(/[\r\n]/g, "");
                readFile(socketPath, readCygsocket);
              });
              return;
            }
            const m = RE_CYGWIN_SOCK.exec(data.toString("ascii"));
            if (!m)
              return cb(new Error("Malformed cygwin unix socket file"));
            let state;
            let bc = 0;
            let isRetrying = false;
            const inBuf = [];
            let sock;
            let credsBuf = Buffer.alloc(12);
            const port = parseInt(m[1], 10);
            const secret = m[2].replace(/-/g, "");
            const secretBuf = Buffer.allocUnsafe(16);
            for (let i = 0, j = 0; j < 32; ++i, j += 2)
              secretBuf[i] = parseInt(secret.substring(j, j + 2), 16);
            for (let i = 0; i < 16; i += 4)
              writeUInt32LE(secretBuf, readUInt32BE(secretBuf, i), i);
            tryConnect();
            function _onconnect() {
              bc = 0;
              state = "secret";
              sock.write(secretBuf);
            }
            function _ondata(data2) {
              bc += data2.length;
              if (state === "secret") {
                if (bc === 16) {
                  bc = 0;
                  state = "creds";
                  sock.write(credsBuf);
                }
                return;
              }
              if (state === "creds") {
                if (!isRetrying)
                  inBuf.push(data2);
                if (bc === 12) {
                  sock.removeListener("connect", _onconnect);
                  sock.removeListener("data", _ondata);
                  sock.removeListener("error", onFail);
                  sock.removeListener("end", onFail);
                  sock.removeListener("close", onFail);
                  if (isRetrying)
                    return cb(null, sock);
                  isRetrying = true;
                  credsBuf = Buffer.concat(inBuf);
                  writeUInt32LE(credsBuf, process.pid, 0);
                  sock.on("error", () => {
                  });
                  sock.destroy();
                  tryConnect();
                }
              }
            }
            function onFail() {
              cb(new Error("Problem negotiating cygwin unix socket security"));
            }
            function tryConnect() {
              sock = new Socket();
              sock.on("connect", _onconnect);
              sock.on("data", _ondata);
              sock.on("error", onFail);
              sock.on("end", onFail);
              sock.on("close", onFail);
              sock.connect(port);
            }
          });
        }
      };
    })();
    var WINDOWS_PIPE_REGEX = /^[/\\][/\\]\.[/\\]pipe[/\\].+/;
    function createAgent(path) {
      if (process.platform === "win32" && !WINDOWS_PIPE_REGEX.test(path)) {
        return path === "pageant" ? new PageantAgent() : new CygwinAgent(path);
      }
      return new OpenSSHAgent(path);
    }
    var AgentProtocol = (() => {
      const SSH_AGENTC_REQUEST_IDENTITIES = 11;
      const SSH_AGENTC_SIGN_REQUEST = 13;
      const SSH_AGENT_FAILURE = 5;
      const SSH_AGENT_IDENTITIES_ANSWER = 12;
      const SSH_AGENT_SIGN_RESPONSE = 14;
      const SSH_AGENT_RSA_SHA2_256 = 1 << 1;
      const SSH_AGENT_RSA_SHA2_512 = 1 << 2;
      const ROLE_CLIENT = 0;
      const ROLE_SERVER = 1;
      function processResponses(protocol) {
        let ret;
        while (protocol[SYM_REQS].length) {
          const nextResponse = protocol[SYM_REQS][0][SYM_RESP];
          if (nextResponse === void 0)
            break;
          protocol[SYM_REQS].shift();
          ret = protocol.push(nextResponse);
        }
        return ret;
      }
      const SYM_TYPE = Symbol("Inbound Request Type");
      const SYM_RESP = Symbol("Inbound Request Response");
      const SYM_CTX = Symbol("Inbound Request Context");
      class AgentInboundRequest {
        constructor(type, ctx) {
          this[SYM_TYPE] = type;
          this[SYM_RESP] = void 0;
          this[SYM_CTX] = ctx;
        }
        hasResponded() {
          return this[SYM_RESP] !== void 0;
        }
        getType() {
          return this[SYM_TYPE];
        }
        getContext() {
          return this[SYM_CTX];
        }
      }
      function respond(protocol, req, data) {
        req[SYM_RESP] = data;
        return processResponses(protocol);
      }
      function cleanup(protocol) {
        protocol[SYM_BUFFER] = null;
        if (protocol[SYM_MODE] === ROLE_CLIENT) {
          const reqs = protocol[SYM_REQS];
          if (reqs && reqs.length) {
            protocol[SYM_REQS] = [];
            for (const req of reqs)
              req.cb(new Error("No reply from server"));
          }
        }
        try {
          protocol.end();
        } catch {
        }
        setImmediate(() => {
          if (!protocol[SYM_ENDED])
            protocol.emit("end");
          if (!protocol[SYM_CLOSED])
            protocol.emit("close");
        });
      }
      function onClose() {
        this[SYM_CLOSED] = true;
      }
      function onEnd() {
        this[SYM_ENDED] = true;
      }
      const SYM_REQS = Symbol("Requests");
      const SYM_MODE = Symbol("Agent Protocol Role");
      const SYM_BUFFER = Symbol("Agent Protocol Buffer");
      const SYM_MSGLEN = Symbol("Agent Protocol Current Message Length");
      const SYM_CLOSED = Symbol("Agent Protocol Closed");
      const SYM_ENDED = Symbol("Agent Protocol Ended");
      return class AgentProtocol extends Duplex {
        /*
            Notes:
              - `constraint` type consists of:
                   byte                    constraint_type
                   byte[]                  constraint_data
                where `constraint_type` is one of:
                  * SSH_AGENT_CONSTRAIN_LIFETIME
                    - `constraint_data` consists of:
                         uint32                  seconds
                  * SSH_AGENT_CONSTRAIN_CONFIRM
                    - `constraint_data` N/A
                  * SSH_AGENT_CONSTRAIN_EXTENSION
                    - `constraint_data` consists of:
                         string                  extension name
                         byte[]                  extension-specific details
        */
        constructor(isClient) {
          super({ autoDestroy: true, emitClose: false });
          this[SYM_MODE] = isClient ? ROLE_CLIENT : ROLE_SERVER;
          this[SYM_REQS] = [];
          this[SYM_BUFFER] = null;
          this[SYM_MSGLEN] = -1;
          this.once("end", onEnd);
          this.once("close", onClose);
        }
        _read(n) {
        }
        _write(data, encoding, cb) {
          if (this[SYM_BUFFER] === null)
            this[SYM_BUFFER] = data;
          else
            this[SYM_BUFFER] = concat(this[SYM_BUFFER], data);
          let buffer = this[SYM_BUFFER];
          let bufferLen = buffer.length;
          let p = 0;
          while (p < bufferLen) {
            if (bufferLen < 5)
              break;
            if (this[SYM_MSGLEN] === -1)
              this[SYM_MSGLEN] = readUInt32BE(buffer, p);
            if (bufferLen < 4 + this[SYM_MSGLEN])
              break;
            const msgType = buffer[p += 4];
            ++p;
            if (this[SYM_MODE] === ROLE_CLIENT) {
              if (this[SYM_REQS].length === 0)
                return cb(new Error("Received unexpected message from server"));
              const req = this[SYM_REQS].shift();
              switch (msgType) {
                case SSH_AGENT_FAILURE:
                  req.cb(new Error("Agent responded with failure"));
                  break;
                case SSH_AGENT_IDENTITIES_ANSWER: {
                  if (req.type !== SSH_AGENTC_REQUEST_IDENTITIES)
                    return cb(new Error("Agent responded with wrong message type"));
                  binaryParser.init(buffer, p);
                  const numKeys = binaryParser.readUInt32BE();
                  if (numKeys === void 0) {
                    binaryParser.clear();
                    return cb(new Error("Malformed agent response"));
                  }
                  const keys = [];
                  for (let i = 0; i < numKeys; ++i) {
                    let pubKey = binaryParser.readString();
                    if (pubKey === void 0) {
                      binaryParser.clear();
                      return cb(new Error("Malformed agent response"));
                    }
                    const comment = binaryParser.readString(true);
                    if (comment === void 0) {
                      binaryParser.clear();
                      return cb(new Error("Malformed agent response"));
                    }
                    pubKey = parseKey(pubKey);
                    if (pubKey instanceof Error)
                      continue;
                    pubKey.comment = pubKey.comment || comment;
                    keys.push(pubKey);
                  }
                  p = binaryParser.pos();
                  binaryParser.clear();
                  req.cb(null, keys);
                  break;
                }
                case SSH_AGENT_SIGN_RESPONSE: {
                  if (req.type !== SSH_AGENTC_SIGN_REQUEST)
                    return cb(new Error("Agent responded with wrong message type"));
                  binaryParser.init(buffer, p);
                  let signature = binaryParser.readString();
                  p = binaryParser.pos();
                  binaryParser.clear();
                  if (signature === void 0)
                    return cb(new Error("Malformed agent response"));
                  binaryParser.init(signature, 0);
                  binaryParser.readString(true);
                  signature = binaryParser.readString();
                  binaryParser.clear();
                  if (signature === void 0)
                    return cb(new Error("Malformed OpenSSH signature format"));
                  req.cb(null, signature);
                  break;
                }
                default:
                  return cb(
                    new Error("Agent responded with unsupported message type")
                  );
              }
            } else {
              switch (msgType) {
                case SSH_AGENTC_REQUEST_IDENTITIES: {
                  const req = new AgentInboundRequest(msgType);
                  this[SYM_REQS].push(req);
                  this.emit("identities", req);
                  break;
                }
                case SSH_AGENTC_SIGN_REQUEST: {
                  binaryParser.init(buffer, p);
                  let pubKey = binaryParser.readString();
                  const data2 = binaryParser.readString();
                  const flagsVal = binaryParser.readUInt32BE();
                  p = binaryParser.pos();
                  binaryParser.clear();
                  if (flagsVal === void 0) {
                    const req2 = new AgentInboundRequest(msgType);
                    this[SYM_REQS].push(req2);
                    return this.failureReply(req2);
                  }
                  pubKey = parseKey(pubKey);
                  if (pubKey instanceof Error) {
                    const req2 = new AgentInboundRequest(msgType);
                    this[SYM_REQS].push(req2);
                    return this.failureReply(req2);
                  }
                  const flags = {
                    hash: void 0
                  };
                  let ctx;
                  if (pubKey.type === "ssh-rsa") {
                    if (flagsVal & SSH_AGENT_RSA_SHA2_256) {
                      ctx = "rsa-sha2-256";
                      flags.hash = "sha256";
                    } else if (flagsVal & SSH_AGENT_RSA_SHA2_512) {
                      ctx = "rsa-sha2-512";
                      flags.hash = "sha512";
                    }
                  }
                  if (ctx === void 0)
                    ctx = pubKey.type;
                  const req = new AgentInboundRequest(msgType, ctx);
                  this[SYM_REQS].push(req);
                  this.emit("sign", req, pubKey, data2, flags);
                  break;
                }
                default: {
                  const req = new AgentInboundRequest(msgType);
                  this[SYM_REQS].push(req);
                  this.failureReply(req);
                }
              }
            }
            this[SYM_MSGLEN] = -1;
            if (p === bufferLen) {
              this[SYM_BUFFER] = null;
              break;
            } else {
              this[SYM_BUFFER] = buffer = buffer.slice(p);
              bufferLen = buffer.length;
              p = 0;
            }
          }
          cb();
        }
        _destroy(err, cb) {
          cleanup(this);
          cb();
        }
        _final(cb) {
          cleanup(this);
          cb();
        }
        // Client->Server messages =================================================
        sign(pubKey, data, options, cb) {
          if (this[SYM_MODE] !== ROLE_CLIENT)
            throw new Error("Client-only method called with server role");
          if (typeof options === "function") {
            cb = options;
            options = void 0;
          } else if (typeof options !== "object" || options === null) {
            options = void 0;
          }
          let flags = 0;
          pubKey = parseKey(pubKey);
          if (pubKey instanceof Error)
            throw new Error("Invalid public key argument");
          if (pubKey.type === "ssh-rsa" && options) {
            switch (options.hash) {
              case "sha256":
                flags = SSH_AGENT_RSA_SHA2_256;
                break;
              case "sha512":
                flags = SSH_AGENT_RSA_SHA2_512;
                break;
            }
          }
          pubKey = pubKey.getPublicSSH();
          const type = SSH_AGENTC_SIGN_REQUEST;
          const keyLen = pubKey.length;
          const dataLen = data.length;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1 + 4 + keyLen + 4 + dataLen + 4);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = type;
          writeUInt32BE(buf, keyLen, ++p);
          pubKey.copy(buf, p += 4);
          writeUInt32BE(buf, dataLen, p += keyLen);
          data.copy(buf, p += 4);
          writeUInt32BE(buf, flags, p += dataLen);
          if (typeof cb !== "function")
            cb = noop;
          this[SYM_REQS].push({ type, cb });
          return this.push(buf);
        }
        getIdentities(cb) {
          if (this[SYM_MODE] !== ROLE_CLIENT)
            throw new Error("Client-only method called with server role");
          const type = SSH_AGENTC_REQUEST_IDENTITIES;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = type;
          if (typeof cb !== "function")
            cb = noop;
          this[SYM_REQS].push({ type, cb });
          return this.push(buf);
        }
        // Server->Client messages =================================================
        failureReply(req) {
          if (this[SYM_MODE] !== ROLE_SERVER)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return true;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_FAILURE;
          return respond(this, req, buf);
        }
        getIdentitiesReply(req, keys) {
          if (this[SYM_MODE] !== ROLE_SERVER)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return true;
          if (req.getType() !== SSH_AGENTC_REQUEST_IDENTITIES)
            throw new Error("Invalid response to request");
          if (!Array.isArray(keys))
            throw new Error("Keys argument must be an array");
          let totalKeysLen = 4;
          const newKeys = [];
          for (let i = 0; i < keys.length; ++i) {
            const entry = keys[i];
            if (typeof entry !== "object" || entry === null)
              throw new Error(`Invalid key entry: ${entry}`);
            let pubKey;
            let comment;
            if (isParsedKey(entry)) {
              pubKey = entry;
            } else if (isParsedKey(entry.pubKey)) {
              pubKey = entry.pubKey;
            } else {
              if (typeof entry.pubKey !== "object" || entry.pubKey === null)
                continue;
              ({ pubKey, comment } = entry.pubKey);
              pubKey = parseKey(pubKey);
              if (pubKey instanceof Error)
                continue;
            }
            comment = pubKey.comment || comment;
            pubKey = pubKey.getPublicSSH();
            totalKeysLen += 4 + pubKey.length;
            if (comment && typeof comment === "string")
              comment = Buffer.from(comment);
            else if (!Buffer.isBuffer(comment))
              comment = EMPTY_BUF;
            totalKeysLen += 4 + comment.length;
            newKeys.push({ pubKey, comment });
          }
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1 + totalKeysLen);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_IDENTITIES_ANSWER;
          writeUInt32BE(buf, newKeys.length, ++p);
          p += 4;
          for (let i = 0; i < newKeys.length; ++i) {
            const { pubKey, comment } = newKeys[i];
            writeUInt32BE(buf, pubKey.length, p);
            pubKey.copy(buf, p += 4);
            writeUInt32BE(buf, comment.length, p += pubKey.length);
            p += 4;
            if (comment.length) {
              comment.copy(buf, p);
              p += comment.length;
            }
          }
          return respond(this, req, buf);
        }
        signReply(req, signature) {
          if (this[SYM_MODE] !== ROLE_SERVER)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return true;
          if (req.getType() !== SSH_AGENTC_SIGN_REQUEST)
            throw new Error("Invalid response to request");
          if (!Buffer.isBuffer(signature))
            throw new Error("Signature argument must be a Buffer");
          if (signature.length === 0)
            throw new Error("Signature argument must be non-empty");
          let p = 0;
          const sigFormat = req.getContext();
          const sigFormatLen = Buffer.byteLength(sigFormat);
          const buf = Buffer.allocUnsafe(
            4 + 1 + 4 + 4 + sigFormatLen + 4 + signature.length
          );
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_SIGN_RESPONSE;
          writeUInt32BE(buf, 4 + sigFormatLen + 4 + signature.length, ++p);
          writeUInt32BE(buf, sigFormatLen, p += 4);
          buf.utf8Write(sigFormat, p += 4, sigFormatLen);
          writeUInt32BE(buf, signature.length, p += sigFormatLen);
          signature.copy(buf, p += 4);
          return respond(this, req, buf);
        }
      };
    })();
    var SYM_AGENT = Symbol("Agent");
    var SYM_AGENT_KEYS = Symbol("Agent Keys");
    var SYM_AGENT_KEYS_IDX = Symbol("Agent Keys Index");
    var SYM_AGENT_CBS = Symbol("Agent Init Callbacks");
    var AgentContext = class {
      constructor(agent) {
        if (typeof agent === "string")
          agent = createAgent(agent);
        else if (!isAgent(agent))
          throw new Error("Invalid agent argument");
        this[SYM_AGENT] = agent;
        this[SYM_AGENT_KEYS] = null;
        this[SYM_AGENT_KEYS_IDX] = -1;
        this[SYM_AGENT_CBS] = null;
      }
      init(cb) {
        if (typeof cb !== "function")
          cb = noop;
        if (this[SYM_AGENT_KEYS] === null) {
          if (this[SYM_AGENT_CBS] === null) {
            this[SYM_AGENT_CBS] = [cb];
            const doCbs = (...args) => {
              process.nextTick(() => {
                const cbs = this[SYM_AGENT_CBS];
                this[SYM_AGENT_CBS] = null;
                for (const cb2 of cbs)
                  cb2(...args);
              });
            };
            this[SYM_AGENT].getIdentities(once((err, keys) => {
              if (err)
                return doCbs(err);
              if (!Array.isArray(keys)) {
                return doCbs(new Error(
                  "Agent implementation failed to provide keys"
                ));
              }
              const newKeys = [];
              for (let key of keys) {
                key = parseKey(key);
                if (key instanceof Error) {
                  continue;
                }
                newKeys.push(key);
              }
              this[SYM_AGENT_KEYS] = newKeys;
              this[SYM_AGENT_KEYS_IDX] = -1;
              doCbs();
            }));
          } else {
            this[SYM_AGENT_CBS].push(cb);
          }
        } else {
          process.nextTick(cb);
        }
      }
      nextKey() {
        if (this[SYM_AGENT_KEYS] === null || ++this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return false;
        }
        return this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
      }
      currentKey() {
        if (this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return null;
        }
        return this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
      }
      pos() {
        if (this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return -1;
        }
        return this[SYM_AGENT_KEYS_IDX];
      }
      reset() {
        this[SYM_AGENT_KEYS_IDX] = -1;
      }
      sign(...args) {
        this[SYM_AGENT].sign(...args);
      }
    };
    function isAgent(val) {
      return val instanceof BaseAgent;
    }
    module2.exports = {
      AgentContext,
      AgentProtocol,
      BaseAgent,
      createAgent,
      CygwinAgent,
      isAgent,
      OpenSSHAgent,
      PageantAgent
    };
  }
});

// node_modules/ssh2/lib/protocol/zlib.js
var require_zlib = __commonJS({
  "node_modules/ssh2/lib/protocol/zlib.js"(exports, module2) {
    "use strict";
    var { kMaxLength } = require("buffer");
    var {
      createInflate,
      constants: {
        DEFLATE,
        INFLATE,
        Z_DEFAULT_CHUNK,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_MEMLEVEL,
        Z_DEFAULT_STRATEGY,
        Z_DEFAULT_WINDOWBITS,
        Z_PARTIAL_FLUSH
      }
    } = require("zlib");
    var ZlibHandle = createInflate()._handle.constructor;
    function processCallback() {
      throw new Error("Should not get here");
    }
    function zlibOnError(message, errno, code) {
      const self2 = this._owner;
      const error = new Error(message);
      error.errno = errno;
      error.code = code;
      self2._err = error;
    }
    function _close(engine) {
      if (!engine._handle)
        return;
      engine._handle.close();
      engine._handle = null;
    }
    var Zlib = class {
      constructor(mode) {
        const windowBits = Z_DEFAULT_WINDOWBITS;
        const level = Z_DEFAULT_COMPRESSION;
        const memLevel = Z_DEFAULT_MEMLEVEL;
        const strategy = Z_DEFAULT_STRATEGY;
        const dictionary = void 0;
        this._err = void 0;
        this._writeState = new Uint32Array(2);
        this._chunkSize = Z_DEFAULT_CHUNK;
        this._maxOutputLength = kMaxLength;
        this._outBuffer = Buffer.allocUnsafe(this._chunkSize);
        this._outOffset = 0;
        this._handle = new ZlibHandle(mode);
        this._handle._owner = this;
        this._handle.onerror = zlibOnError;
        this._handle.init(
          windowBits,
          level,
          memLevel,
          strategy,
          this._writeState,
          processCallback,
          dictionary
        );
      }
      writeSync(chunk, retChunks) {
        const handle = this._handle;
        if (!handle)
          throw new Error("Invalid Zlib instance");
        let availInBefore = chunk.length;
        let availOutBefore = this._chunkSize - this._outOffset;
        let inOff = 0;
        let availOutAfter;
        let availInAfter;
        let buffers;
        let nread = 0;
        const state = this._writeState;
        let buffer = this._outBuffer;
        let offset = this._outOffset;
        const chunkSize = this._chunkSize;
        while (true) {
          handle.writeSync(
            Z_PARTIAL_FLUSH,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            buffer,
            // out
            offset,
            // out_off
            availOutBefore
          );
          if (this._err)
            throw this._err;
          availOutAfter = state[0];
          availInAfter = state[1];
          const inDelta = availInBefore - availInAfter;
          const have = availOutBefore - availOutAfter;
          if (have > 0) {
            const out = offset === 0 && have === buffer.length ? buffer : buffer.slice(offset, offset + have);
            offset += have;
            if (!buffers)
              buffers = out;
            else if (buffers.push === void 0)
              buffers = [buffers, out];
            else
              buffers.push(out);
            nread += out.byteLength;
            if (nread > this._maxOutputLength) {
              _close(this);
              throw new Error(
                `Output length exceeded maximum of ${this._maxOutputLength}`
              );
            }
          } else if (have !== 0) {
            throw new Error("have should not go down");
          }
          if (availOutAfter === 0 || offset >= chunkSize) {
            availOutBefore = chunkSize;
            offset = 0;
            buffer = Buffer.allocUnsafe(chunkSize);
          }
          if (availOutAfter === 0) {
            inOff += inDelta;
            availInBefore = availInAfter;
          } else {
            break;
          }
        }
        this._outBuffer = buffer;
        this._outOffset = offset;
        if (nread === 0)
          buffers = Buffer.alloc(0);
        if (retChunks) {
          buffers.totalLen = nread;
          return buffers;
        }
        if (buffers.push === void 0)
          return buffers;
        const output = Buffer.allocUnsafe(nread);
        for (let i = 0, p = 0; i < buffers.length; ++i) {
          const buf = buffers[i];
          output.set(buf, p);
          p += buf.length;
        }
        return output;
      }
    };
    var ZlibPacketWriter = class {
      constructor(protocol) {
        this.allocStart = 0;
        this.allocStartKEX = 0;
        this._protocol = protocol;
        this._zlib = new Zlib(DEFLATE);
      }
      cleanup() {
        if (this._zlib)
          _close(this._zlib);
      }
      alloc(payloadSize, force) {
        return Buffer.allocUnsafe(payloadSize);
      }
      finalize(payload, force) {
        if (this._protocol._kexinit === void 0 || force) {
          const output = this._zlib.writeSync(payload, true);
          const packet = this._protocol._cipher.allocPacket(output.totalLen);
          if (output.push === void 0) {
            packet.set(output, 5);
          } else {
            for (let i = 0, p = 5; i < output.length; ++i) {
              const chunk = output[i];
              packet.set(chunk, p);
              p += chunk.length;
            }
          }
          return packet;
        }
        return payload;
      }
    };
    var PacketWriter = class {
      constructor(protocol) {
        this.allocStart = 5;
        this.allocStartKEX = 5;
        this._protocol = protocol;
      }
      cleanup() {
      }
      alloc(payloadSize, force) {
        if (this._protocol._kexinit === void 0 || force)
          return this._protocol._cipher.allocPacket(payloadSize);
        return Buffer.allocUnsafe(payloadSize);
      }
      finalize(packet, force) {
        return packet;
      }
    };
    var ZlibPacketReader = class {
      constructor() {
        this._zlib = new Zlib(INFLATE);
      }
      cleanup() {
        if (this._zlib)
          _close(this._zlib);
      }
      read(data) {
        return this._zlib.writeSync(data, false);
      }
    };
    var PacketReader = class {
      cleanup() {
      }
      read(data) {
        return data;
      }
    };
    module2.exports = {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    };
  }
});

// node_modules/ssh2/lib/protocol/handlers.misc.js
var require_handlers_misc = __commonJS({
  "node_modules/ssh2/lib/protocol/handlers.misc.js"(exports, module2) {
    "use strict";
    var {
      bufferSlice,
      bufferParser,
      doFatalError,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils();
    var {
      CHANNEL_OPEN_FAILURE,
      COMPAT,
      MESSAGE,
      TERMINAL_MODE
    } = require_constants();
    var {
      parseKey
    } = require_keyParser();
    var TERMINAL_MODE_BY_VALUE = Array.from(Object.entries(TERMINAL_MODE)).reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});
    module2.exports = {
      // Transport layer protocol ==================================================
      [MESSAGE.DISCONNECT]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const reason = bufferParser.readUInt32BE();
        const desc = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed DISCONNECT packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: Received DISCONNECT (${reason}, "${desc}")`
        );
        const handler = self2._handlers.DISCONNECT;
        handler && handler(self2, reason, desc);
      },
      [MESSAGE.IGNORE]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received IGNORE");
      },
      [MESSAGE.UNIMPLEMENTED]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const seqno = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (seqno === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed UNIMPLEMENTED packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received UNIMPLEMENTED (seqno ${seqno})`);
      },
      [MESSAGE.DEBUG]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const display = bufferParser.readBool();
        const msg = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed DEBUG packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received DEBUG");
        const handler = self2._handlers.DEBUG;
        handler && handler(self2, display, msg);
      },
      [MESSAGE.SERVICE_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name = bufferParser.readString(true);
        bufferParser.clear();
        if (name === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed SERVICE_REQUEST packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received SERVICE_REQUEST (${name})`);
        const handler = self2._handlers.SERVICE_REQUEST;
        handler && handler(self2, name);
      },
      [MESSAGE.SERVICE_ACCEPT]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name = bufferParser.readString(true);
        bufferParser.clear();
        if (name === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed SERVICE_ACCEPT packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received SERVICE_ACCEPT (${name})`);
        const handler = self2._handlers.SERVICE_ACCEPT;
        handler && handler(self2, name);
      },
      [MESSAGE.EXT_INFO]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const numExts = bufferParser.readUInt32BE();
        let exts;
        if (numExts !== void 0) {
          exts = [];
          for (let i = 0; i < numExts; ++i) {
            const name = bufferParser.readString(true);
            const data = bufferParser.readString();
            if (data !== void 0) {
              switch (name) {
                case "server-sig-algs": {
                  const algs = data.latin1Slice(0, data.length).split(",");
                  exts.push({ name, algs });
                  continue;
                }
                default:
                  continue;
              }
            }
            exts = void 0;
            break;
          }
        }
        bufferParser.clear();
        if (exts === void 0)
          return doFatalError(self2, "Inbound: Malformed EXT_INFO packet");
        self2._debug && self2._debug("Inbound: Received EXT_INFO");
        const handler = self2._handlers.EXT_INFO;
        handler && handler(self2, exts);
      },
      // User auth protocol -- generic =============================================
      [MESSAGE.USERAUTH_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const user = bufferParser.readString(true);
        const service = bufferParser.readString(true);
        const method = bufferParser.readString(true);
        let methodData;
        let methodDesc;
        switch (method) {
          case "none":
            methodData = null;
            break;
          case "password": {
            const isChange = bufferParser.readBool();
            if (isChange !== void 0) {
              methodData = bufferParser.readString(true);
              if (methodData !== void 0 && isChange) {
                const newPassword = bufferParser.readString(true);
                if (newPassword !== void 0)
                  methodData = { oldPassword: methodData, newPassword };
                else
                  methodData = void 0;
              }
            }
            break;
          }
          case "publickey": {
            const hasSig = bufferParser.readBool();
            if (hasSig !== void 0) {
              const keyAlgo = bufferParser.readString(true);
              let realKeyAlgo = keyAlgo;
              const key = bufferParser.readString();
              let hashAlgo;
              switch (keyAlgo) {
                case "rsa-sha2-256":
                  realKeyAlgo = "ssh-rsa";
                  hashAlgo = "sha256";
                  break;
                case "rsa-sha2-512":
                  realKeyAlgo = "ssh-rsa";
                  hashAlgo = "sha512";
                  break;
              }
              if (hasSig) {
                const blobEnd = bufferParser.pos();
                let signature = bufferParser.readString();
                if (signature !== void 0) {
                  if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {
                    signature = bufferSlice(signature, 4 + keyAlgo.length + 4);
                  }
                  signature = sigSSHToASN1(signature, realKeyAlgo);
                  if (signature) {
                    const sessionID = self2._kex.sessionID;
                    const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
                    writeUInt32BE(blob, sessionID.length, 0);
                    blob.set(sessionID, 4);
                    blob.set(
                      new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),
                      4 + sessionID.length
                    );
                    methodData = {
                      keyAlgo: realKeyAlgo,
                      key,
                      signature,
                      blob,
                      hashAlgo
                    };
                  }
                }
              } else {
                methodData = { keyAlgo: realKeyAlgo, key, hashAlgo };
                methodDesc = "publickey -- check";
              }
            }
            break;
          }
          case "hostbased": {
            const keyAlgo = bufferParser.readString(true);
            let realKeyAlgo = keyAlgo;
            const key = bufferParser.readString();
            const localHostname = bufferParser.readString(true);
            const localUsername = bufferParser.readString(true);
            let hashAlgo;
            switch (keyAlgo) {
              case "rsa-sha2-256":
                realKeyAlgo = "ssh-rsa";
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                realKeyAlgo = "ssh-rsa";
                hashAlgo = "sha512";
                break;
            }
            const blobEnd = bufferParser.pos();
            let signature = bufferParser.readString();
            if (signature !== void 0) {
              if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {
                signature = bufferSlice(signature, 4 + keyAlgo.length + 4);
              }
              signature = sigSSHToASN1(signature, realKeyAlgo);
              if (signature !== void 0) {
                const sessionID = self2._kex.sessionID;
                const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
                writeUInt32BE(blob, sessionID.length, 0);
                blob.set(sessionID, 4);
                blob.set(
                  new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),
                  4 + sessionID.length
                );
                methodData = {
                  keyAlgo: realKeyAlgo,
                  key,
                  signature,
                  blob,
                  localHostname,
                  localUsername,
                  hashAlgo
                };
              }
            }
            break;
          }
          case "keyboard-interactive":
            bufferParser.skipString();
            methodData = bufferParser.readList();
            break;
          default:
            if (method !== void 0)
              methodData = bufferParser.readRaw();
        }
        bufferParser.clear();
        if (methodData === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_REQUEST packet"
          );
        }
        if (methodDesc === void 0)
          methodDesc = method;
        self2._authsQueue.push(method);
        self2._debug && self2._debug(`Inbound: Received USERAUTH_REQUEST (${methodDesc})`);
        const handler = self2._handlers.USERAUTH_REQUEST;
        handler && handler(self2, user, service, method, methodData);
      },
      [MESSAGE.USERAUTH_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const authMethods = bufferParser.readList();
        const partialSuccess = bufferParser.readBool();
        bufferParser.clear();
        if (partialSuccess === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_FAILURE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received USERAUTH_FAILURE (${authMethods})`);
        self2._authsQueue.shift();
        const handler = self2._handlers.USERAUTH_FAILURE;
        handler && handler(self2, authMethods, partialSuccess);
      },
      [MESSAGE.USERAUTH_SUCCESS]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received USERAUTH_SUCCESS");
        self2._authsQueue.shift();
        const handler = self2._handlers.USERAUTH_SUCCESS;
        handler && handler(self2);
      },
      [MESSAGE.USERAUTH_BANNER]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const msg = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_BANNER packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_BANNER");
        const handler = self2._handlers.USERAUTH_BANNER;
        handler && handler(self2, msg);
      },
      // User auth protocol -- method-specific =====================================
      60: (self2, payload) => {
        if (!self2._authsQueue.length) {
          self2._debug && self2._debug("Inbound: Received payload type 60 without auth");
          return;
        }
        switch (self2._authsQueue[0]) {
          case "password": {
            bufferParser.init(payload, 1);
            const prompt = bufferParser.readString(true);
            const lang = bufferParser.readString();
            bufferParser.clear();
            if (lang === void 0) {
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet"
              );
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_PASSWD_CHANGEREQ");
            const handler = self2._handlers.USERAUTH_PASSWD_CHANGEREQ;
            handler && handler(self2, prompt);
            break;
          }
          case "publickey": {
            bufferParser.init(payload, 1);
            const keyAlgo = bufferParser.readString(true);
            const key = bufferParser.readString();
            bufferParser.clear();
            if (key === void 0) {
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_PK_OK packet"
              );
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_PK_OK");
            self2._authsQueue.shift();
            const handler = self2._handlers.USERAUTH_PK_OK;
            handler && handler(self2, keyAlgo, key);
            break;
          }
          case "keyboard-interactive": {
            bufferParser.init(payload, 1);
            const name = bufferParser.readString(true);
            const instructions = bufferParser.readString(true);
            bufferParser.readString();
            const numPrompts = bufferParser.readUInt32BE();
            let prompts;
            if (numPrompts !== void 0) {
              prompts = new Array(numPrompts);
              let i;
              for (i = 0; i < numPrompts; ++i) {
                const prompt = bufferParser.readString(true);
                const echo = bufferParser.readBool();
                if (echo === void 0)
                  break;
                prompts[i] = { prompt, echo };
              }
              if (i !== numPrompts)
                prompts = void 0;
            }
            bufferParser.clear();
            if (prompts === void 0) {
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_INFO_REQUEST packet"
              );
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_REQUEST");
            const handler = self2._handlers.USERAUTH_INFO_REQUEST;
            handler && handler(self2, name, instructions, prompts);
            break;
          }
          default:
            self2._debug && self2._debug("Inbound: Received unexpected payload type 60");
        }
      },
      61: (self2, payload) => {
        if (!self2._authsQueue.length) {
          self2._debug && self2._debug("Inbound: Received payload type 61 without auth");
          return;
        }
        if (self2._authsQueue[0] !== "keyboard-interactive") {
          return doFatalError(
            self2,
            "Inbound: Received unexpected payload type 61"
          );
        }
        bufferParser.init(payload, 1);
        const numResponses = bufferParser.readUInt32BE();
        let responses;
        if (numResponses !== void 0) {
          responses = new Array(numResponses);
          let i;
          for (i = 0; i < numResponses; ++i) {
            const response = bufferParser.readString(true);
            if (response === void 0)
              break;
            responses[i] = response;
          }
          if (i !== numResponses)
            responses = void 0;
        }
        bufferParser.clear();
        if (responses === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_INFO_RESPONSE packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_RESPONSE");
        const handler = self2._handlers.USERAUTH_INFO_RESPONSE;
        handler && handler(self2, responses);
      },
      // Connection protocol -- generic ============================================
      [MESSAGE.GLOBAL_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name = bufferParser.readString(true);
        const wantReply = bufferParser.readBool();
        let data;
        if (wantReply !== void 0) {
          switch (name) {
            case "tcpip-forward":
            case "cancel-tcpip-forward": {
              const bindAddr = bufferParser.readString(true);
              const bindPort = bufferParser.readUInt32BE();
              if (bindPort !== void 0)
                data = { bindAddr, bindPort };
              break;
            }
            case "streamlocal-forward@openssh.com":
            case "cancel-streamlocal-forward@openssh.com": {
              const socketPath = bufferParser.readString(true);
              if (socketPath !== void 0)
                data = { socketPath };
              break;
            }
            case "no-more-sessions@openssh.com":
              data = null;
              break;
            case "hostkeys-00@openssh.com": {
              data = [];
              while (bufferParser.avail() > 0) {
                const keyRaw = bufferParser.readString();
                if (keyRaw === void 0) {
                  data = void 0;
                  break;
                }
                const key = parseKey(keyRaw);
                if (!(key instanceof Error))
                  data.push(key);
              }
              break;
            }
            default:
              data = bufferParser.readRaw();
          }
        }
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed GLOBAL_REQUEST packet"
          );
        }
        self2._debug && self2._debug(`Inbound: GLOBAL_REQUEST (${name})`);
        const handler = self2._handlers.GLOBAL_REQUEST;
        if (handler)
          handler(self2, name, wantReply, data);
        else
          self2.requestFailure();
      },
      [MESSAGE.REQUEST_SUCCESS]: (self2, payload) => {
        const data = payload.length > 1 ? bufferSlice(payload, 1) : null;
        self2._debug && self2._debug("Inbound: REQUEST_SUCCESS");
        const handler = self2._handlers.REQUEST_SUCCESS;
        handler && handler(self2, data);
      },
      [MESSAGE.REQUEST_FAILURE]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received REQUEST_FAILURE");
        const handler = self2._handlers.REQUEST_FAILURE;
        handler && handler(self2);
      },
      // Connection protocol -- channel-related ====================================
      [MESSAGE.CHANNEL_OPEN]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const type = bufferParser.readString(true);
        const sender = bufferParser.readUInt32BE();
        const window2 = bufferParser.readUInt32BE();
        const packetSize = bufferParser.readUInt32BE();
        let channelInfo;
        switch (type) {
          case "forwarded-tcpip":
          case "direct-tcpip": {
            const destIP = bufferParser.readString(true);
            const destPort = bufferParser.readUInt32BE();
            const srcIP = bufferParser.readString(true);
            const srcPort = bufferParser.readUInt32BE();
            if (srcPort !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: { destIP, destPort, srcIP, srcPort }
              };
            }
            break;
          }
          case "forwarded-streamlocal@openssh.com":
          case "direct-streamlocal@openssh.com": {
            const socketPath = bufferParser.readString(true);
            if (socketPath !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: { socketPath }
              };
            }
            break;
          }
          case "x11": {
            const srcIP = bufferParser.readString(true);
            const srcPort = bufferParser.readUInt32BE();
            if (srcPort !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: { srcIP, srcPort }
              };
            }
            break;
          }
          default:
            channelInfo = {
              type,
              sender,
              window: window2,
              packetSize,
              data: {}
            };
        }
        bufferParser.clear();
        if (channelInfo === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN (s:${sender}, ${type})`);
        const handler = self2._handlers.CHANNEL_OPEN;
        if (handler) {
          handler(self2, channelInfo);
        } else {
          self2.channelOpenFail(
            channelInfo.sender,
            CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED,
            "",
            ""
          );
        }
      },
      [MESSAGE.CHANNEL_OPEN_CONFIRMATION]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const sender = bufferParser.readUInt32BE();
        const window2 = bufferParser.readUInt32BE();
        const packetSize = bufferParser.readUInt32BE();
        const data = bufferParser.avail() ? bufferParser.readRaw() : void 0;
        bufferParser.clear();
        if (packetSize === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: CHANNEL_OPEN_CONFIRMATION (r:${recipient}, s:${sender})`
        );
        const handler = self2._handlers.CHANNEL_OPEN_CONFIRMATION;
        if (handler)
          handler(self2, { recipient, sender, window: window2, packetSize, data });
      },
      [MESSAGE.CHANNEL_OPEN_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const reason = bufferParser.readUInt32BE();
        const description = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN_FAILURE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_OPEN_FAILURE;
        handler && handler(self2, recipient, reason, description);
      },
      [MESSAGE.CHANNEL_WINDOW_ADJUST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const bytesToAdd = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (bytesToAdd === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_WINDOW_ADJUST packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: CHANNEL_WINDOW_ADJUST (r:${recipient}, ${bytesToAdd})`
        );
        const handler = self2._handlers.CHANNEL_WINDOW_ADJUST;
        handler && handler(self2, recipient, bytesToAdd);
      },
      [MESSAGE.CHANNEL_DATA]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_DATA packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_DATA (r:${recipient}, ${data.length})`);
        const handler = self2._handlers.CHANNEL_DATA;
        handler && handler(self2, recipient, data);
      },
      [MESSAGE.CHANNEL_EXTENDED_DATA]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const type = bufferParser.readUInt32BE();
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_EXTENDED_DATA packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: CHANNEL_EXTENDED_DATA (r:${recipient}, ${data.length})`
        );
        const handler = self2._handlers.CHANNEL_EXTENDED_DATA;
        handler && handler(self2, recipient, data, type);
      },
      [MESSAGE.CHANNEL_EOF]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_EOF packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_EOF (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_EOF;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_CLOSE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_CLOSE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_CLOSE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_CLOSE;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const type = bufferParser.readString(true);
        const wantReply = bufferParser.readBool();
        let data;
        if (wantReply !== void 0) {
          switch (type) {
            case "exit-status":
              data = bufferParser.readUInt32BE();
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "exit-signal": {
              let signal;
              let coreDumped;
              if (self2._compatFlags & COMPAT.OLD_EXIT) {
                const num = bufferParser.readUInt32BE();
                switch (num) {
                  case 1:
                    signal = "HUP";
                    break;
                  case 2:
                    signal = "INT";
                    break;
                  case 3:
                    signal = "QUIT";
                    break;
                  case 6:
                    signal = "ABRT";
                    break;
                  case 9:
                    signal = "KILL";
                    break;
                  case 14:
                    signal = "ALRM";
                    break;
                  case 15:
                    signal = "TERM";
                    break;
                  default:
                    if (num !== void 0) {
                      signal = `UNKNOWN (${num})`;
                    }
                }
                coreDumped = false;
              } else {
                signal = bufferParser.readString(true);
                coreDumped = bufferParser.readBool();
                if (coreDumped === void 0)
                  signal = void 0;
              }
              const errorMessage = bufferParser.readString(true);
              if (bufferParser.skipString() !== void 0)
                data = { signal, coreDumped, errorMessage };
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${signal})`
              );
              break;
            }
            case "pty-req": {
              const term = bufferParser.readString(true);
              const cols = bufferParser.readUInt32BE();
              const rows = bufferParser.readUInt32BE();
              const width = bufferParser.readUInt32BE();
              const height = bufferParser.readUInt32BE();
              const modesBinary = bufferParser.readString();
              if (modesBinary !== void 0) {
                bufferParser.init(modesBinary, 1);
                let modes = {};
                while (bufferParser.avail()) {
                  const opcode = bufferParser.readByte();
                  if (opcode === TERMINAL_MODE.TTY_OP_END)
                    break;
                  const name = TERMINAL_MODE_BY_VALUE[opcode];
                  const value = bufferParser.readUInt32BE();
                  if (opcode === void 0 || name === void 0 || value === void 0) {
                    modes = void 0;
                    break;
                  }
                  modes[name] = value;
                }
                if (modes !== void 0)
                  data = { term, cols, rows, width, height, modes };
              }
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "window-change": {
              const cols = bufferParser.readUInt32BE();
              const rows = bufferParser.readUInt32BE();
              const width = bufferParser.readUInt32BE();
              const height = bufferParser.readUInt32BE();
              if (height !== void 0)
                data = { cols, rows, width, height };
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "x11-req": {
              const single = bufferParser.readBool();
              const protocol = bufferParser.readString(true);
              const cookie = bufferParser.readString();
              const screen = bufferParser.readUInt32BE();
              if (screen !== void 0)
                data = { single, protocol, cookie, screen };
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "env": {
              const name = bufferParser.readString(true);
              const value = bufferParser.readString(true);
              if (value !== void 0)
                data = { name, value };
              if (self2._debug) {
                self2._debug(
                  `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${name}=${value})`
                );
              }
              break;
            }
            case "shell":
              data = null;
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            case "exec":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "subsystem":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "signal":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "xon-xoff":
              data = bufferParser.readBool();
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "auth-agent-req@openssh.com":
              data = null;
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            default:
              data = bufferParser.avail() ? bufferParser.readRaw() : null;
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
          }
        }
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_REQUEST packet"
          );
        }
        const handler = self2._handlers.CHANNEL_REQUEST;
        handler && handler(self2, recipient, type, wantReply, data);
      },
      [MESSAGE.CHANNEL_SUCCESS]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_SUCCESS packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_SUCCESS (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_SUCCESS;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_FAILURE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_FAILURE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_FAILURE;
        handler && handler(self2, recipient);
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/handlers.js
var require_handlers = __commonJS({
  "node_modules/ssh2/lib/protocol/handlers.js"(exports, module2) {
    "use strict";
    var MESSAGE_HANDLERS = new Array(256);
    [
      require_kex().HANDLERS,
      require_handlers_misc()
    ].forEach((handlers) => {
      for (let [type, handler] of Object.entries(handlers)) {
        type = +type;
        if (isFinite(type) && type >= 0 && type < MESSAGE_HANDLERS.length)
          MESSAGE_HANDLERS[type] = handler;
      }
    });
    module2.exports = MESSAGE_HANDLERS;
  }
});

// node_modules/ssh2/lib/protocol/kex.js
var require_kex = __commonJS({
  "node_modules/ssh2/lib/protocol/kex.js"(exports, module2) {
    "use strict";
    var {
      createDiffieHellman,
      createDiffieHellmanGroup,
      createECDH,
      createHash,
      createPublicKey,
      diffieHellman,
      generateKeyPairSync,
      randomFillSync
    } = require("crypto");
    var { Ber } = require_lib();
    var {
      COMPAT,
      curve25519Supported,
      DEFAULT_KEX,
      DEFAULT_SERVER_HOST_KEY,
      DEFAULT_CIPHER,
      DEFAULT_MAC,
      DEFAULT_COMPRESSION,
      DISCONNECT_REASON,
      MESSAGE
    } = require_constants();
    var {
      CIPHER_INFO,
      createCipher,
      createDecipher,
      MAC_INFO
    } = require_crypto();
    var { parseDERKey } = require_keyParser();
    var {
      bufferFill,
      bufferParser,
      convertSignature,
      doFatalError,
      FastBuffer,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils();
    var {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    } = require_zlib();
    var MESSAGE_HANDLERS;
    var GEX_MIN_BITS = 2048;
    var GEX_MAX_BITS = 8192;
    var EMPTY_BUFFER = Buffer.alloc(0);
    function kexinit(self2) {
      let payload;
      if (self2._compatFlags & COMPAT.BAD_DHGEX) {
        const entry = self2._offer.lists.kex;
        let kex = entry.array;
        let found = false;
        for (let i = 0; i < kex.length; ++i) {
          if (kex[i].includes("group-exchange")) {
            if (!found) {
              found = true;
              kex = kex.slice();
            }
            kex.splice(i--, 1);
          }
        }
        if (found) {
          let len = 1 + 16 + self2._offer.totalSize + 1 + 4;
          const newKexBuf = Buffer.from(kex.join(","));
          len -= entry.buffer.length - newKexBuf.length;
          const all = self2._offer.lists.all;
          const rest = new Uint8Array(
            all.buffer,
            all.byteOffset + 4 + entry.buffer.length,
            all.length - (4 + entry.buffer.length)
          );
          payload = Buffer.allocUnsafe(len);
          writeUInt32BE(payload, newKexBuf.length, 17);
          payload.set(newKexBuf, 17 + 4);
          payload.set(rest, 17 + 4 + newKexBuf.length);
        }
      }
      if (payload === void 0) {
        payload = Buffer.allocUnsafe(1 + 16 + self2._offer.totalSize + 1 + 4);
        self2._offer.copyAllTo(payload, 17);
      }
      self2._debug && self2._debug("Outbound: Sending KEXINIT");
      payload[0] = MESSAGE.KEXINIT;
      randomFillSync(payload, 1, 16);
      bufferFill(payload, 0, payload.length - 5);
      self2._kexinit = payload;
      self2._packetRW.write.allocStart = 0;
      {
        const p = self2._packetRW.write.allocStartKEX;
        const packet = self2._packetRW.write.alloc(payload.length, true);
        packet.set(payload, p);
        self2._cipher.encrypt(self2._packetRW.write.finalize(packet, true));
      }
    }
    function handleKexInit(self2, payload) {
      const init = {
        kex: void 0,
        serverHostKey: void 0,
        cs: {
          cipher: void 0,
          mac: void 0,
          compress: void 0,
          lang: void 0
        },
        sc: {
          cipher: void 0,
          mac: void 0,
          compress: void 0,
          lang: void 0
        }
      };
      bufferParser.init(payload, 17);
      if ((init.kex = bufferParser.readList()) === void 0 || (init.serverHostKey = bufferParser.readList()) === void 0 || (init.cs.cipher = bufferParser.readList()) === void 0 || (init.sc.cipher = bufferParser.readList()) === void 0 || (init.cs.mac = bufferParser.readList()) === void 0 || (init.sc.mac = bufferParser.readList()) === void 0 || (init.cs.compress = bufferParser.readList()) === void 0 || (init.sc.compress = bufferParser.readList()) === void 0 || (init.cs.lang = bufferParser.readList()) === void 0 || (init.sc.lang = bufferParser.readList()) === void 0) {
        bufferParser.clear();
        return doFatalError(
          self2,
          "Received malformed KEXINIT",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      const pos = bufferParser.pos();
      const firstFollows = pos < payload.length && payload[pos] === 1;
      bufferParser.clear();
      const local = self2._offer;
      const remote = init;
      let localKex = local.lists.kex.array;
      if (self2._compatFlags & COMPAT.BAD_DHGEX) {
        let found = false;
        for (let i2 = 0; i2 < localKex.length; ++i2) {
          if (localKex[i2].indexOf("group-exchange") !== -1) {
            if (!found) {
              found = true;
              localKex = localKex.slice();
            }
            localKex.splice(i2--, 1);
          }
        }
      }
      let clientList;
      let serverList;
      let i;
      const debug = self2._debug;
      debug && debug("Inbound: Handshake in progress");
      debug && debug(`Handshake: (local) KEX method: ${localKex}`);
      debug && debug(`Handshake: (remote) KEX method: ${remote.kex}`);
      let remoteExtInfoEnabled;
      if (self2._server) {
        serverList = localKex;
        clientList = remote.kex;
        remoteExtInfoEnabled = clientList.indexOf("ext-info-c") !== -1;
      } else {
        serverList = remote.kex;
        clientList = localKex;
        remoteExtInfoEnabled = serverList.indexOf("ext-info-s") !== -1;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug && debug("Handshake: No matching key exchange algorithm");
        return doFatalError(
          self2,
          "Handshake failed: no matching key exchange algorithm",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init.kex = clientList[i];
      debug && debug(`Handshake: KEX algorithm: ${clientList[i]}`);
      if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {
        self2._skipNextInboundPacket = true;
      }
      const localSrvHostKey = local.lists.serverHostKey.array;
      debug && debug(`Handshake: (local) Host key format: ${localSrvHostKey}`);
      debug && debug(
        `Handshake: (remote) Host key format: ${remote.serverHostKey}`
      );
      if (self2._server) {
        serverList = localSrvHostKey;
        clientList = remote.serverHostKey;
      } else {
        serverList = remote.serverHostKey;
        clientList = localSrvHostKey;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug && debug("Handshake: No matching host key format");
        return doFatalError(
          self2,
          "Handshake failed: no matching host key format",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init.serverHostKey = clientList[i];
      debug && debug(`Handshake: Host key format: ${clientList[i]}`);
      const localCSCipher = local.lists.cs.cipher.array;
      debug && debug(`Handshake: (local) C->S cipher: ${localCSCipher}`);
      debug && debug(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);
      if (self2._server) {
        serverList = localCSCipher;
        clientList = remote.cs.cipher;
      } else {
        serverList = remote.cs.cipher;
        clientList = localCSCipher;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug && debug("Handshake: No matching C->S cipher");
        return doFatalError(
          self2,
          "Handshake failed: no matching C->S cipher",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init.cs.cipher = clientList[i];
      debug && debug(`Handshake: C->S Cipher: ${clientList[i]}`);
      const localSCCipher = local.lists.sc.cipher.array;
      debug && debug(`Handshake: (local) S->C cipher: ${localSCCipher}`);
      debug && debug(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);
      if (self2._server) {
        serverList = localSCCipher;
        clientList = remote.sc.cipher;
      } else {
        serverList = remote.sc.cipher;
        clientList = localSCCipher;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug && debug("Handshake: No matching S->C cipher");
        return doFatalError(
          self2,
          "Handshake failed: no matching S->C cipher",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init.sc.cipher = clientList[i];
      debug && debug(`Handshake: S->C cipher: ${clientList[i]}`);
      const localCSMAC = local.lists.cs.mac.array;
      debug && debug(`Handshake: (local) C->S MAC: ${localCSMAC}`);
      debug && debug(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);
      if (CIPHER_INFO[init.cs.cipher].authLen > 0) {
        init.cs.mac = "";
        debug && debug("Handshake: C->S MAC: <implicit>");
      } else {
        if (self2._server) {
          serverList = localCSMAC;
          clientList = remote.cs.mac;
        } else {
          serverList = remote.cs.mac;
          clientList = localCSMAC;
        }
        for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
          ;
        if (i === clientList.length) {
          debug && debug("Handshake: No matching C->S MAC");
          return doFatalError(
            self2,
            "Handshake failed: no matching C->S MAC",
            "handshake",
            DISCONNECT_REASON.KEY_EXCHANGE_FAILED
          );
        }
        init.cs.mac = clientList[i];
        debug && debug(`Handshake: C->S MAC: ${clientList[i]}`);
      }
      const localSCMAC = local.lists.sc.mac.array;
      debug && debug(`Handshake: (local) S->C MAC: ${localSCMAC}`);
      debug && debug(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);
      if (CIPHER_INFO[init.sc.cipher].authLen > 0) {
        init.sc.mac = "";
        debug && debug("Handshake: S->C MAC: <implicit>");
      } else {
        if (self2._server) {
          serverList = localSCMAC;
          clientList = remote.sc.mac;
        } else {
          serverList = remote.sc.mac;
          clientList = localSCMAC;
        }
        for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
          ;
        if (i === clientList.length) {
          debug && debug("Handshake: No matching S->C MAC");
          return doFatalError(
            self2,
            "Handshake failed: no matching S->C MAC",
            "handshake",
            DISCONNECT_REASON.KEY_EXCHANGE_FAILED
          );
        }
        init.sc.mac = clientList[i];
        debug && debug(`Handshake: S->C MAC: ${clientList[i]}`);
      }
      const localCSCompress = local.lists.cs.compress.array;
      debug && debug(`Handshake: (local) C->S compression: ${localCSCompress}`);
      debug && debug(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);
      if (self2._server) {
        serverList = localCSCompress;
        clientList = remote.cs.compress;
      } else {
        serverList = remote.cs.compress;
        clientList = localCSCompress;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug && debug("Handshake: No matching C->S compression");
        return doFatalError(
          self2,
          "Handshake failed: no matching C->S compression",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init.cs.compress = clientList[i];
      debug && debug(`Handshake: C->S compression: ${clientList[i]}`);
      const localSCCompress = local.lists.sc.compress.array;
      debug && debug(`Handshake: (local) S->C compression: ${localSCCompress}`);
      debug && debug(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);
      if (self2._server) {
        serverList = localSCCompress;
        clientList = remote.sc.compress;
      } else {
        serverList = remote.sc.compress;
        clientList = localSCCompress;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug && debug("Handshake: No matching S->C compression");
        return doFatalError(
          self2,
          "Handshake failed: no matching S->C compression",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init.sc.compress = clientList[i];
      debug && debug(`Handshake: S->C compression: ${clientList[i]}`);
      init.cs.lang = "";
      init.sc.lang = "";
      if (self2._kex) {
        if (!self2._kexinit) {
          kexinit(self2);
        }
        self2._decipher._onPayload = onKEXPayload.bind(self2, { firstPacket: false });
      }
      self2._kex = createKeyExchange(init, self2, payload);
      self2._kex.remoteExtInfoEnabled = remoteExtInfoEnabled;
      self2._kex.start();
    }
    var createKeyExchange = (() => {
      function convertToMpint(buf) {
        let idx = 0;
        let length = buf.length;
        while (buf[idx] === 0) {
          ++idx;
          --length;
        }
        let newBuf;
        if (buf[idx] & 128) {
          newBuf = Buffer.allocUnsafe(1 + length);
          newBuf[0] = 0;
          buf.copy(newBuf, 1, idx);
          buf = newBuf;
        } else if (length !== buf.length) {
          newBuf = Buffer.allocUnsafe(length);
          buf.copy(newBuf, 0, idx);
          buf = newBuf;
        }
        return buf;
      }
      class KeyExchange {
        constructor(negotiated, protocol, remoteKexinit) {
          this._protocol = protocol;
          this.sessionID = protocol._kex ? protocol._kex.sessionID : void 0;
          this.negotiated = negotiated;
          this.remoteExtInfoEnabled = false;
          this._step = 1;
          this._public = null;
          this._dh = null;
          this._sentNEWKEYS = false;
          this._receivedNEWKEYS = false;
          this._finished = false;
          this._hostVerified = false;
          this._kexinit = protocol._kexinit;
          this._remoteKexinit = remoteKexinit;
          this._identRaw = protocol._identRaw;
          this._remoteIdentRaw = protocol._remoteIdentRaw;
          this._hostKey = void 0;
          this._dhData = void 0;
          this._sig = void 0;
        }
        finish() {
          if (this._finished)
            return false;
          this._finished = true;
          const isServer = this._protocol._server;
          const negotiated = this.negotiated;
          const pubKey = this.convertPublicKey(this._dhData);
          let secret = this.computeSecret(this._dhData);
          if (secret instanceof Error) {
            secret.message = `Error while computing DH secret (${this.type}): ${secret.message}`;
            secret.level = "handshake";
            return doFatalError(
              this._protocol,
              secret,
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          }
          const hash = createHash(this.hashName);
          hashString(hash, isServer ? this._remoteIdentRaw : this._identRaw);
          hashString(hash, isServer ? this._identRaw : this._remoteIdentRaw);
          hashString(hash, isServer ? this._remoteKexinit : this._kexinit);
          hashString(hash, isServer ? this._kexinit : this._remoteKexinit);
          const serverPublicHostKey = isServer ? this._hostKey.getPublicSSH() : this._hostKey;
          hashString(hash, serverPublicHostKey);
          if (this.type === "groupex") {
            const params = this.getDHParams();
            const num = Buffer.allocUnsafe(4);
            writeUInt32BE(num, this._minBits, 0);
            hash.update(num);
            writeUInt32BE(num, this._prefBits, 0);
            hash.update(num);
            writeUInt32BE(num, this._maxBits, 0);
            hash.update(num);
            hashString(hash, params.prime);
            hashString(hash, params.generator);
          }
          hashString(hash, isServer ? pubKey : this.getPublicKey());
          const serverPublicKey = isServer ? this.getPublicKey() : pubKey;
          hashString(hash, serverPublicKey);
          hashString(hash, secret);
          const exchangeHash = hash.digest();
          if (!isServer) {
            bufferParser.init(this._sig, 0);
            const sigType = bufferParser.readString(true);
            if (!sigType) {
              return doFatalError(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            if (sigType !== negotiated.serverHostKey) {
              return doFatalError(
                this._protocol,
                `Wrong signature type: ${sigType}, expected: ${negotiated.serverHostKey}`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            let sigValue = bufferParser.readString();
            bufferParser.clear();
            if (sigValue === void 0) {
              return doFatalError(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            if (!(sigValue = sigSSHToASN1(sigValue, sigType))) {
              return doFatalError(
                this._protocol,
                "Malformed signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            let parsedHostKey;
            {
              bufferParser.init(this._hostKey, 0);
              const name = bufferParser.readString(true);
              const hostKey = this._hostKey.slice(bufferParser.pos());
              bufferParser.clear();
              parsedHostKey = parseDERKey(hostKey, name);
              if (parsedHostKey instanceof Error) {
                parsedHostKey.level = "handshake";
                return doFatalError(
                  this._protocol,
                  parsedHostKey,
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
            }
            let hashAlgo;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                hashAlgo = "sha512";
                break;
            }
            this._protocol._debug && this._protocol._debug("Verifying signature ...");
            const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);
            if (verified !== true) {
              if (verified instanceof Error) {
                this._protocol._debug && this._protocol._debug(
                  `Signature verification failed: ${verified.stack}`
                );
              } else {
                this._protocol._debug && this._protocol._debug(
                  "Signature verification failed"
                );
              }
              return doFatalError(
                this._protocol,
                "Handshake failed: signature verification failed",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            this._protocol._debug && this._protocol._debug("Verified signature");
          } else {
            let hashAlgo;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                hashAlgo = "sha512";
                break;
            }
            this._protocol._debug && this._protocol._debug(
              "Generating signature ..."
            );
            let signature = this._hostKey.sign(exchangeHash, hashAlgo);
            if (signature instanceof Error) {
              return doFatalError(
                this._protocol,
                `Handshake failed: signature generation failed for ${this._hostKey.type} host key: ${signature.message}`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            signature = convertSignature(signature, this._hostKey.type);
            if (signature === false) {
              return doFatalError(
                this._protocol,
                `Handshake failed: signature conversion failed for ${this._hostKey.type} host key`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            const sigType = this.negotiated.serverHostKey;
            const sigTypeLen = Buffer.byteLength(sigType);
            const sigLen = 4 + sigTypeLen + 4 + signature.length;
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(
              1 + 4 + serverPublicHostKey.length + 4 + serverPublicKey.length + 4 + sigLen,
              true
            );
            packet[p] = MESSAGE.KEXDH_REPLY;
            writeUInt32BE(packet, serverPublicHostKey.length, ++p);
            packet.set(serverPublicHostKey, p += 4);
            writeUInt32BE(
              packet,
              serverPublicKey.length,
              p += serverPublicHostKey.length
            );
            packet.set(serverPublicKey, p += 4);
            writeUInt32BE(packet, sigLen, p += serverPublicKey.length);
            writeUInt32BE(packet, sigTypeLen, p += 4);
            packet.utf8Write(sigType, p += 4, sigTypeLen);
            writeUInt32BE(packet, signature.length, p += sigTypeLen);
            packet.set(signature, p += 4);
            if (this._protocol._debug) {
              let type;
              switch (this.type) {
                case "group":
                  type = "KEXDH_REPLY";
                  break;
                case "groupex":
                  type = "KEXDH_GEX_REPLY";
                  break;
                default:
                  type = "KEXECDH_REPLY";
              }
              this._protocol._debug(`Outbound: Sending ${type}`);
            }
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, true)
            );
          }
          trySendNEWKEYS(this);
          const completeHandshake = () => {
            if (!this.sessionID)
              this.sessionID = exchangeHash;
            {
              const newSecret = Buffer.allocUnsafe(4 + secret.length);
              writeUInt32BE(newSecret, secret.length, 0);
              newSecret.set(secret, 4);
              secret = newSecret;
            }
            const csCipherInfo = CIPHER_INFO[negotiated.cs.cipher];
            const scCipherInfo = CIPHER_INFO[negotiated.sc.cipher];
            const csIV = generateKEXVal(
              csCipherInfo.ivLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "A"
            );
            const scIV = generateKEXVal(
              scCipherInfo.ivLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "B"
            );
            const csKey = generateKEXVal(
              csCipherInfo.keyLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "C"
            );
            const scKey = generateKEXVal(
              scCipherInfo.keyLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "D"
            );
            let csMacInfo;
            let csMacKey;
            if (!csCipherInfo.authLen) {
              csMacInfo = MAC_INFO[negotiated.cs.mac];
              csMacKey = generateKEXVal(
                csMacInfo.len,
                this.hashName,
                secret,
                exchangeHash,
                this.sessionID,
                "E"
              );
            }
            let scMacInfo;
            let scMacKey;
            if (!scCipherInfo.authLen) {
              scMacInfo = MAC_INFO[negotiated.sc.mac];
              scMacKey = generateKEXVal(
                scMacInfo.len,
                this.hashName,
                secret,
                exchangeHash,
                this.sessionID,
                "F"
              );
            }
            const config = {
              inbound: {
                onPayload: this._protocol._onPayload,
                seqno: this._protocol._decipher.inSeqno,
                decipherInfo: !isServer ? scCipherInfo : csCipherInfo,
                decipherIV: !isServer ? scIV : csIV,
                decipherKey: !isServer ? scKey : csKey,
                macInfo: !isServer ? scMacInfo : csMacInfo,
                macKey: !isServer ? scMacKey : csMacKey
              },
              outbound: {
                onWrite: this._protocol._onWrite,
                seqno: this._protocol._cipher.outSeqno,
                cipherInfo: isServer ? scCipherInfo : csCipherInfo,
                cipherIV: isServer ? scIV : csIV,
                cipherKey: isServer ? scKey : csKey,
                macInfo: isServer ? scMacInfo : csMacInfo,
                macKey: isServer ? scMacKey : csMacKey
              }
            };
            this._protocol._cipher && this._protocol._cipher.free();
            this._protocol._decipher && this._protocol._decipher.free();
            this._protocol._cipher = createCipher(config);
            this._protocol._decipher = createDecipher(config);
            const rw = {
              read: void 0,
              write: void 0
            };
            switch (negotiated.cs.compress) {
              case "zlib":
                if (isServer)
                  rw.read = new ZlibPacketReader();
                else
                  rw.write = new ZlibPacketWriter(this._protocol);
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  if (isServer)
                    rw.read = new ZlibPacketReader();
                  else
                    rw.write = new ZlibPacketWriter(this._protocol);
                  break;
                }
              default:
                if (isServer)
                  rw.read = new PacketReader();
                else
                  rw.write = new PacketWriter(this._protocol);
            }
            switch (negotiated.sc.compress) {
              case "zlib":
                if (isServer)
                  rw.write = new ZlibPacketWriter(this._protocol);
                else
                  rw.read = new ZlibPacketReader();
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  if (isServer)
                    rw.write = new ZlibPacketWriter(this._protocol);
                  else
                    rw.read = new ZlibPacketReader();
                  break;
                }
              default:
                if (isServer)
                  rw.write = new PacketWriter(this._protocol);
                else
                  rw.read = new PacketReader();
            }
            this._protocol._packetRW.read.cleanup();
            this._protocol._packetRW.write.cleanup();
            this._protocol._packetRW = rw;
            this._public = null;
            this._dh = null;
            this._kexinit = this._protocol._kexinit = void 0;
            this._remoteKexinit = void 0;
            this._identRaw = void 0;
            this._remoteIdentRaw = void 0;
            this._hostKey = void 0;
            this._dhData = void 0;
            this._sig = void 0;
            this._protocol._onHandshakeComplete(negotiated);
            return false;
          };
          if (!isServer)
            return completeHandshake();
          this.finish = completeHandshake;
        }
        start() {
          if (!this._protocol._server) {
            if (this._protocol._debug) {
              let type;
              switch (this.type) {
                case "group":
                  type = "KEXDH_INIT";
                  break;
                default:
                  type = "KEXECDH_INIT";
              }
              this._protocol._debug(`Outbound: Sending ${type}`);
            }
            const pubKey = this.getPublicKey();
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(
              1 + 4 + pubKey.length,
              true
            );
            packet[p] = MESSAGE.KEXDH_INIT;
            writeUInt32BE(packet, pubKey.length, ++p);
            packet.set(pubKey, p += 4);
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, true)
            );
          }
        }
        getPublicKey() {
          this.generateKeys();
          const key = this._public;
          if (key)
            return this.convertPublicKey(key);
        }
        convertPublicKey(key) {
          let newKey;
          let idx = 0;
          let len = key.length;
          while (key[idx] === 0) {
            ++idx;
            --len;
          }
          if (key[idx] & 128) {
            newKey = Buffer.allocUnsafe(1 + len);
            newKey[0] = 0;
            key.copy(newKey, 1, idx);
            return newKey;
          }
          if (len !== key.length) {
            newKey = Buffer.allocUnsafe(len);
            key.copy(newKey, 0, idx);
            key = newKey;
          }
          return key;
        }
        computeSecret(otherPublicKey) {
          this.generateKeys();
          try {
            return convertToMpint(this._dh.computeSecret(otherPublicKey));
          } catch (ex) {
            return ex;
          }
        }
        parse(payload) {
          const type = payload[0];
          switch (this._step) {
            case 1:
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_INIT) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Received DH Init"
                );
                bufferParser.init(payload, 1);
                const dhData = bufferParser.readString();
                bufferParser.clear();
                if (dhData === void 0) {
                  return doFatalError(
                    this._protocol,
                    "Received malformed KEX*_INIT",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._dhData = dhData;
                let hostKey = this._protocol._hostKeys[this.negotiated.serverHostKey];
                if (Array.isArray(hostKey))
                  hostKey = hostKey[0];
                this._hostKey = hostKey;
                this.finish();
              } else {
                if (type !== MESSAGE.KEXDH_REPLY) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Received DH Reply"
                );
                bufferParser.init(payload, 1);
                let hostPubKey;
                let dhData;
                let sig;
                if ((hostPubKey = bufferParser.readString()) === void 0 || (dhData = bufferParser.readString()) === void 0 || (sig = bufferParser.readString()) === void 0) {
                  bufferParser.clear();
                  return doFatalError(
                    this._protocol,
                    "Received malformed KEX*_REPLY",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                bufferParser.clear();
                bufferParser.init(hostPubKey, 0);
                const hostPubKeyType = bufferParser.readString(true);
                bufferParser.clear();
                if (hostPubKeyType === void 0) {
                  return doFatalError(
                    this._protocol,
                    "Received malformed host public key",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                if (hostPubKeyType !== this.negotiated.serverHostKey) {
                  switch (this.negotiated.serverHostKey) {
                    case "rsa-sha2-256":
                    case "rsa-sha2-512":
                      if (hostPubKeyType === "ssh-rsa")
                        break;
                    default:
                      return doFatalError(
                        this._protocol,
                        "Host key does not match negotiated type",
                        "handshake",
                        DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                      );
                  }
                }
                this._hostKey = hostPubKey;
                this._dhData = dhData;
                this._sig = sig;
                let checked = false;
                let ret;
                if (this._protocol._hostVerifier === void 0) {
                  ret = true;
                  this._protocol._debug && this._protocol._debug(
                    "Host accepted by default (no verification)"
                  );
                } else {
                  ret = this._protocol._hostVerifier(hostPubKey, (permitted) => {
                    if (checked)
                      return;
                    checked = true;
                    if (permitted === false) {
                      this._protocol._debug && this._protocol._debug(
                        "Host denied (verification failed)"
                      );
                      return doFatalError(
                        this._protocol,
                        "Host denied (verification failed)",
                        "handshake",
                        DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                      );
                    }
                    this._protocol._debug && this._protocol._debug(
                      "Host accepted (verified)"
                    );
                    this._hostVerified = true;
                    if (this._receivedNEWKEYS)
                      this.finish();
                    else
                      trySendNEWKEYS(this);
                  });
                }
                if (ret === void 0) {
                  ++this._step;
                  return;
                }
                checked = true;
                if (ret === false) {
                  this._protocol._debug && this._protocol._debug(
                    "Host denied (verification failed)"
                  );
                  return doFatalError(
                    this._protocol,
                    "Host denied (verification failed)",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Host accepted (verified)"
                );
                this._hostVerified = true;
                trySendNEWKEYS(this);
              }
              ++this._step;
              break;
            case 2:
              if (type !== MESSAGE.NEWKEYS) {
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Inbound: NEWKEYS"
              );
              this._receivedNEWKEYS = true;
              ++this._step;
              if (this._protocol._server || this._hostVerified)
                return this.finish();
              return false;
            default:
              return doFatalError(
                this._protocol,
                `Received unexpected packet ${type} after NEWKEYS`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
          }
        }
      }
      class Curve25519Exchange extends KeyExchange {
        constructor(hashName, ...args) {
          super(...args);
          this.type = "25519";
          this.hashName = hashName;
          this._keys = null;
        }
        generateKeys() {
          if (!this._keys)
            this._keys = generateKeyPairSync("x25519");
        }
        getPublicKey() {
          this.generateKeys();
          const key = this._keys.publicKey.export({ type: "spki", format: "der" });
          return key.slice(-32);
        }
        convertPublicKey(key) {
          let newKey;
          let idx = 0;
          let len = key.length;
          while (key[idx] === 0) {
            ++idx;
            --len;
          }
          if (key.length === 32)
            return key;
          if (len !== key.length) {
            newKey = Buffer.allocUnsafe(len);
            key.copy(newKey, 0, idx);
            key = newKey;
          }
          return key;
        }
        computeSecret(otherPublicKey) {
          this.generateKeys();
          try {
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            asnWriter.startSequence();
            asnWriter.writeOID("1.3.101.110");
            asnWriter.endSequence();
            asnWriter.startSequence(Ber.BitString);
            asnWriter.writeByte(0);
            asnWriter._ensure(otherPublicKey.length);
            otherPublicKey.copy(
              asnWriter._buf,
              asnWriter._offset,
              0,
              otherPublicKey.length
            );
            asnWriter._offset += otherPublicKey.length;
            asnWriter.endSequence();
            asnWriter.endSequence();
            return convertToMpint(diffieHellman({
              privateKey: this._keys.privateKey,
              publicKey: createPublicKey({
                key: asnWriter.buffer,
                type: "spki",
                format: "der"
              })
            }));
          } catch (ex) {
            return ex;
          }
        }
      }
      class ECDHExchange extends KeyExchange {
        constructor(curveName, hashName, ...args) {
          super(...args);
          this.type = "ecdh";
          this.curveName = curveName;
          this.hashName = hashName;
        }
        generateKeys() {
          if (!this._dh) {
            this._dh = createECDH(this.curveName);
            this._public = this._dh.generateKeys();
          }
        }
      }
      class DHGroupExchange extends KeyExchange {
        constructor(hashName, ...args) {
          super(...args);
          this.type = "groupex";
          this.hashName = hashName;
          this._prime = null;
          this._generator = null;
          this._minBits = GEX_MIN_BITS;
          this._prefBits = dhEstimate(this.negotiated);
          if (this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE)
            this._prefBits = Math.min(this._prefBits, 4096);
          this._maxBits = GEX_MAX_BITS;
        }
        start() {
          if (this._protocol._server)
            return;
          this._protocol._debug && this._protocol._debug(
            "Outbound: Sending KEXDH_GEX_REQUEST"
          );
          let p = this._protocol._packetRW.write.allocStartKEX;
          const packet = this._protocol._packetRW.write.alloc(
            1 + 4 + 4 + 4,
            true
          );
          packet[p] = MESSAGE.KEXDH_GEX_REQUEST;
          writeUInt32BE(packet, this._minBits, ++p);
          writeUInt32BE(packet, this._prefBits, p += 4);
          writeUInt32BE(packet, this._maxBits, p += 4);
          this._protocol._cipher.encrypt(
            this._protocol._packetRW.write.finalize(packet, true)
          );
        }
        generateKeys() {
          if (!this._dh && this._prime && this._generator) {
            this._dh = createDiffieHellman(this._prime, this._generator);
            this._public = this._dh.generateKeys();
          }
        }
        setDHParams(prime, generator) {
          if (!Buffer.isBuffer(prime))
            throw new Error("Invalid prime value");
          if (!Buffer.isBuffer(generator))
            throw new Error("Invalid generator value");
          this._prime = prime;
          this._generator = generator;
        }
        getDHParams() {
          if (this._dh) {
            return {
              prime: convertToMpint(this._dh.getPrime()),
              generator: convertToMpint(this._dh.getGenerator())
            };
          }
        }
        parse(payload) {
          const type = payload[0];
          switch (this._step) {
            case 1: {
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_GEX_REQUEST) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ` + MESSAGE.KEXDH_GEX_REQUEST,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                return doFatalError(
                  this._protocol,
                  "Group exchange not implemented for server",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              if (type !== MESSAGE.KEXDH_GEX_GROUP) {
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Received DH GEX Group"
              );
              bufferParser.init(payload, 1);
              let prime;
              let gen;
              if ((prime = bufferParser.readString()) === void 0 || (gen = bufferParser.readString()) === void 0) {
                bufferParser.clear();
                return doFatalError(
                  this._protocol,
                  "Received malformed KEXDH_GEX_GROUP",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              bufferParser.clear();
              this.setDHParams(prime, gen);
              this.generateKeys();
              const pubkey = this.getPublicKey();
              this._protocol._debug && this._protocol._debug(
                "Outbound: Sending KEXDH_GEX_INIT"
              );
              let p = this._protocol._packetRW.write.allocStartKEX;
              const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);
              packet[p] = MESSAGE.KEXDH_GEX_INIT;
              writeUInt32BE(packet, pubkey.length, ++p);
              packet.set(pubkey, p += 4);
              this._protocol._cipher.encrypt(
                this._protocol._packetRW.write.finalize(packet, true)
              );
              ++this._step;
              break;
            }
            case 2:
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_GEX_INIT) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Received DH GEX Init"
                );
                return doFatalError(
                  this._protocol,
                  "Group exchange not implemented for server",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              } else if (type !== MESSAGE.KEXDH_GEX_REPLY) {
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Received DH GEX Reply"
              );
              this._step = 1;
              payload[0] = MESSAGE.KEXDH_REPLY;
              this.parse = KeyExchange.prototype.parse;
              this.parse(payload);
          }
        }
      }
      class DHExchange extends KeyExchange {
        constructor(groupName, hashName, ...args) {
          super(...args);
          this.type = "group";
          this.groupName = groupName;
          this.hashName = hashName;
        }
        start() {
          if (!this._protocol._server) {
            this._protocol._debug && this._protocol._debug(
              "Outbound: Sending KEXDH_INIT"
            );
            const pubKey = this.getPublicKey();
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);
            packet[p] = MESSAGE.KEXDH_INIT;
            writeUInt32BE(packet, pubKey.length, ++p);
            packet.set(pubKey, p += 4);
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, true)
            );
          }
        }
        generateKeys() {
          if (!this._dh) {
            this._dh = createDiffieHellmanGroup(this.groupName);
            this._public = this._dh.generateKeys();
          }
        }
        getDHParams() {
          if (this._dh) {
            return {
              prime: convertToMpint(this._dh.getPrime()),
              generator: convertToMpint(this._dh.getGenerator())
            };
          }
        }
      }
      return (negotiated, ...args) => {
        if (typeof negotiated !== "object" || negotiated === null)
          throw new Error("Invalid negotiated argument");
        const kexType = negotiated.kex;
        if (typeof kexType === "string") {
          args = [negotiated, ...args];
          switch (kexType) {
            case "curve25519-sha256":
            case "curve25519-sha256@libssh.org":
              if (!curve25519Supported)
                break;
              return new Curve25519Exchange("sha256", ...args);
            case "ecdh-sha2-nistp256":
              return new ECDHExchange("prime256v1", "sha256", ...args);
            case "ecdh-sha2-nistp384":
              return new ECDHExchange("secp384r1", "sha384", ...args);
            case "ecdh-sha2-nistp521":
              return new ECDHExchange("secp521r1", "sha512", ...args);
            case "diffie-hellman-group1-sha1":
              return new DHExchange("modp2", "sha1", ...args);
            case "diffie-hellman-group14-sha1":
              return new DHExchange("modp14", "sha1", ...args);
            case "diffie-hellman-group14-sha256":
              return new DHExchange("modp14", "sha256", ...args);
            case "diffie-hellman-group15-sha512":
              return new DHExchange("modp15", "sha512", ...args);
            case "diffie-hellman-group16-sha512":
              return new DHExchange("modp16", "sha512", ...args);
            case "diffie-hellman-group17-sha512":
              return new DHExchange("modp17", "sha512", ...args);
            case "diffie-hellman-group18-sha512":
              return new DHExchange("modp18", "sha512", ...args);
            case "diffie-hellman-group-exchange-sha1":
              return new DHGroupExchange("sha1", ...args);
            case "diffie-hellman-group-exchange-sha256":
              return new DHGroupExchange("sha256", ...args);
          }
          throw new Error(`Unsupported key exchange algorithm: ${kexType}`);
        }
        throw new Error(`Invalid key exchange type: ${kexType}`);
      };
    })();
    var KexInit = (() => {
      const KEX_PROPERTY_NAMES = [
        "kex",
        "serverHostKey",
        ["cs", "cipher"],
        ["sc", "cipher"],
        ["cs", "mac"],
        ["sc", "mac"],
        ["cs", "compress"],
        ["sc", "compress"],
        ["cs", "lang"],
        ["sc", "lang"]
      ];
      return class KexInit {
        constructor(obj) {
          if (typeof obj !== "object" || obj === null)
            throw new TypeError("Argument must be an object");
          const lists = {
            kex: void 0,
            serverHostKey: void 0,
            cs: {
              cipher: void 0,
              mac: void 0,
              compress: void 0,
              lang: void 0
            },
            sc: {
              cipher: void 0,
              mac: void 0,
              compress: void 0,
              lang: void 0
            },
            all: void 0
          };
          let totalSize = 0;
          for (const prop of KEX_PROPERTY_NAMES) {
            let base;
            let val;
            let desc;
            let key;
            if (typeof prop === "string") {
              base = lists;
              val = obj[prop];
              desc = key = prop;
            } else {
              const parent = prop[0];
              base = lists[parent];
              key = prop[1];
              val = obj[parent][key];
              desc = `${parent}.${key}`;
            }
            const entry = { array: void 0, buffer: void 0 };
            if (Buffer.isBuffer(val)) {
              entry.array = ("" + val).split(",");
              entry.buffer = val;
              totalSize += 4 + val.length;
            } else {
              if (typeof val === "string")
                val = val.split(",");
              if (Array.isArray(val)) {
                entry.array = val;
                entry.buffer = Buffer.from(val.join(","));
              } else {
                throw new TypeError(`Invalid \`${desc}\` type: ${typeof val}`);
              }
              totalSize += 4 + entry.buffer.length;
            }
            base[key] = entry;
          }
          const all = Buffer.allocUnsafe(totalSize);
          lists.all = all;
          let allPos = 0;
          for (const prop of KEX_PROPERTY_NAMES) {
            let data;
            if (typeof prop === "string")
              data = lists[prop].buffer;
            else
              data = lists[prop[0]][prop[1]].buffer;
            allPos = writeUInt32BE(all, data.length, allPos);
            all.set(data, allPos);
            allPos += data.length;
          }
          this.totalSize = totalSize;
          this.lists = lists;
        }
        copyAllTo(buf, offset) {
          const src = this.lists.all;
          if (typeof offset !== "number")
            throw new TypeError(`Invalid offset value: ${typeof offset}`);
          if (buf.length - offset < src.length)
            throw new Error("Insufficient space to copy list");
          buf.set(src, offset);
          return src.length;
        }
      };
    })();
    var hashString = (() => {
      const LEN = Buffer.allocUnsafe(4);
      return (hash, buf) => {
        writeUInt32BE(LEN, buf.length, 0);
        hash.update(LEN);
        hash.update(buf);
      };
    })();
    function generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char) {
      let ret;
      if (len) {
        let digest = createHash(hashName).update(secret).update(exchangeHash).update(char).update(sessionID).digest();
        while (digest.length < len) {
          const chunk = createHash(hashName).update(secret).update(exchangeHash).update(digest).digest();
          const extended = Buffer.allocUnsafe(digest.length + chunk.length);
          extended.set(digest, 0);
          extended.set(chunk, digest.length);
          digest = extended;
        }
        if (digest.length === len)
          ret = digest;
        else
          ret = new FastBuffer(digest.buffer, digest.byteOffset, len);
      } else {
        ret = EMPTY_BUFFER;
      }
      return ret;
    }
    function onKEXPayload(state, payload) {
      if (payload.length === 0) {
        this._debug && this._debug("Inbound: Skipping empty packet payload");
        return;
      }
      if (this._skipNextInboundPacket) {
        this._skipNextInboundPacket = false;
        return;
      }
      payload = this._packetRW.read.read(payload);
      const type = payload[0];
      switch (type) {
        case MESSAGE.DISCONNECT:
        case MESSAGE.IGNORE:
        case MESSAGE.UNIMPLEMENTED:
        case MESSAGE.DEBUG:
          if (!MESSAGE_HANDLERS)
            MESSAGE_HANDLERS = require_handlers();
          return MESSAGE_HANDLERS[type](this, payload);
        case MESSAGE.KEXINIT:
          if (!state.firstPacket) {
            return doFatalError(
              this,
              "Received extra KEXINIT during handshake",
              "handshake",
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          }
          state.firstPacket = false;
          return handleKexInit(this, payload);
        default:
          if (type < 20 || type > 49) {
            return doFatalError(
              this,
              `Received unexpected packet type ${type}`,
              "handshake",
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          }
      }
      return this._kex.parse(payload);
    }
    function dhEstimate(neg) {
      const csCipher = CIPHER_INFO[neg.cs.cipher];
      const scCipher = CIPHER_INFO[neg.sc.cipher];
      const bits = Math.max(
        0,
        csCipher.sslName === "des-ede3-cbc" ? 14 : csCipher.keyLen,
        csCipher.blockLen,
        csCipher.ivLen,
        scCipher.sslName === "des-ede3-cbc" ? 14 : scCipher.keyLen,
        scCipher.blockLen,
        scCipher.ivLen
      ) * 8;
      if (bits <= 112)
        return 2048;
      if (bits <= 128)
        return 3072;
      if (bits <= 192)
        return 7680;
      return 8192;
    }
    function trySendNEWKEYS(kex) {
      if (!kex._sentNEWKEYS) {
        kex._protocol._debug && kex._protocol._debug(
          "Outbound: Sending NEWKEYS"
        );
        const p = kex._protocol._packetRW.write.allocStartKEX;
        const packet = kex._protocol._packetRW.write.alloc(1, true);
        packet[p] = MESSAGE.NEWKEYS;
        kex._protocol._cipher.encrypt(
          kex._protocol._packetRW.write.finalize(packet, true)
        );
        kex._sentNEWKEYS = true;
      }
    }
    module2.exports = {
      KexInit,
      kexinit,
      onKEXPayload,
      DEFAULT_KEXINIT_CLIENT: new KexInit({
        kex: DEFAULT_KEX.concat(["ext-info-c"]),
        serverHostKey: DEFAULT_SERVER_HOST_KEY,
        cs: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        },
        sc: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        }
      }),
      DEFAULT_KEXINIT_SERVER: new KexInit({
        kex: DEFAULT_KEX,
        serverHostKey: DEFAULT_SERVER_HOST_KEY,
        cs: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        },
        sc: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        }
      }),
      HANDLERS: {
        [MESSAGE.KEXINIT]: handleKexInit
      }
    };
  }
});

// node_modules/ssh2/package.json
var require_package = __commonJS({
  "node_modules/ssh2/package.json"(exports, module2) {
    module2.exports = {
      name: "ssh2",
      version: "1.13.0",
      author: "Brian White <mscdex@mscdex.net>",
      description: "SSH2 client and server modules written in pure JavaScript for node.js",
      main: "./lib/index.js",
      engines: {
        node: ">=10.16.0"
      },
      dependencies: {
        asn1: "^0.2.6",
        "bcrypt-pbkdf": "^1.0.2"
      },
      devDependencies: {
        "@mscdex/eslint-config": "^1.1.0",
        eslint: "^7.32.0"
      },
      optionalDependencies: {
        "cpu-features": "~0.0.7",
        nan: "^2.17.0"
      },
      scripts: {
        install: "node install.js",
        rebuild: "node install.js",
        test: "node test/test.js",
        lint: "eslint --cache --report-unused-disable-directives --ext=.js .eslintrc.js examples lib test",
        "lint:fix": "npm run lint -- --fix"
      },
      keywords: [
        "ssh",
        "ssh2",
        "sftp",
        "secure",
        "shell",
        "exec",
        "remote",
        "client"
      ],
      licenses: [
        {
          type: "MIT",
          url: "http://github.com/mscdex/ssh2/raw/master/LICENSE"
        }
      ],
      repository: {
        type: "git",
        url: "http://github.com/mscdex/ssh2.git"
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/Protocol.js
var require_Protocol = __commonJS({
  "node_modules/ssh2/lib/protocol/Protocol.js"(exports, module2) {
    "use strict";
    var { inspect } = require("util");
    var { bindingAvailable, NullCipher, NullDecipher } = require_crypto();
    var {
      COMPAT_CHECKS,
      DISCONNECT_REASON,
      eddsaSupported,
      MESSAGE,
      SIGNALS,
      TERMINAL_MODE
    } = require_constants();
    var {
      DEFAULT_KEXINIT_CLIENT,
      DEFAULT_KEXINIT_SERVER,
      KexInit,
      kexinit,
      onKEXPayload
    } = require_kex();
    var {
      parseKey
    } = require_keyParser();
    var MESSAGE_HANDLERS = require_handlers();
    var {
      bufferCopy,
      bufferFill,
      bufferSlice,
      convertSignature,
      sendPacket,
      writeUInt32BE
    } = require_utils();
    var {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    } = require_zlib();
    var MODULE_VER = require_package().version;
    var VALID_DISCONNECT_REASONS = new Map(
      Object.values(DISCONNECT_REASON).map((n) => [n, 1])
    );
    var IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);
    var IDENT = Buffer.from(`${IDENT_RAW}\r
`);
    var MAX_LINE_LEN = 8192;
    var MAX_LINES = 1024;
    var PING_PAYLOAD = Buffer.from([
      MESSAGE.GLOBAL_REQUEST,
      // "keepalive@openssh.com"
      0,
      0,
      0,
      21,
      107,
      101,
      101,
      112,
      97,
      108,
      105,
      118,
      101,
      64,
      111,
      112,
      101,
      110,
      115,
      115,
      104,
      46,
      99,
      111,
      109,
      // Request a reply
      1
    ]);
    var NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);
    function noop() {
    }
    var Protocol = class {
      constructor(config) {
        const onWrite = config.onWrite;
        if (typeof onWrite !== "function")
          throw new Error("Missing onWrite function");
        this._onWrite = (data) => {
          onWrite(data);
        };
        const onError = config.onError;
        if (typeof onError !== "function")
          throw new Error("Missing onError function");
        this._onError = (err) => {
          onError(err);
        };
        const debug = config.debug;
        this._debug = typeof debug === "function" ? (msg) => {
          debug(msg);
        } : void 0;
        const onHeader = config.onHeader;
        this._onHeader = typeof onHeader === "function" ? (...args) => {
          onHeader(...args);
        } : noop;
        const onPacket = config.onPacket;
        this._onPacket = typeof onPacket === "function" ? () => {
          onPacket();
        } : noop;
        let onHandshakeComplete = config.onHandshakeComplete;
        if (typeof onHandshakeComplete !== "function")
          onHandshakeComplete = noop;
        let firstHandshake;
        this._onHandshakeComplete = (...args) => {
          this._debug && this._debug("Handshake completed");
          if (firstHandshake === void 0)
            firstHandshake = true;
          else
            firstHandshake = false;
          const oldQueue = this._queue;
          if (oldQueue) {
            this._queue = void 0;
            this._debug && this._debug(
              `Draining outbound queue (${oldQueue.length}) ...`
            );
            for (let i = 0; i < oldQueue.length; ++i) {
              const data = oldQueue[i];
              let finalized = this._packetRW.write.finalize(data);
              if (finalized === data) {
                const packet = this._cipher.allocPacket(data.length);
                packet.set(data, 5);
                finalized = packet;
              }
              sendPacket(this, finalized);
            }
            this._debug && this._debug("... finished draining outbound queue");
          }
          if (firstHandshake && this._server && this._kex.remoteExtInfoEnabled)
            sendExtInfo(this);
          onHandshakeComplete(...args);
        };
        this._queue = void 0;
        const messageHandlers = config.messageHandlers;
        if (typeof messageHandlers === "object" && messageHandlers !== null)
          this._handlers = messageHandlers;
        else
          this._handlers = {};
        this._onPayload = onPayload.bind(this);
        this._server = !!config.server;
        this._banner = void 0;
        let greeting;
        if (this._server) {
          if (typeof config.hostKeys !== "object" || config.hostKeys === null)
            throw new Error("Missing server host key(s)");
          this._hostKeys = config.hostKeys;
          if (typeof config.greeting === "string" && config.greeting.length) {
            greeting = config.greeting.slice(-2) === "\r\n" ? config.greeting : `${config.greeting}\r
`;
          }
          if (typeof config.banner === "string" && config.banner.length) {
            this._banner = config.banner.slice(-2) === "\r\n" ? config.banner : `${config.banner}\r
`;
          }
        } else {
          this._hostKeys = void 0;
        }
        let offer = config.offer;
        if (typeof offer !== "object" || offer === null) {
          offer = this._server ? DEFAULT_KEXINIT_SERVER : DEFAULT_KEXINIT_CLIENT;
        } else if (offer.constructor !== KexInit) {
          if (!this._server)
            offer.kex = offer.kex.concat(["ext-info-c"]);
          offer = new KexInit(offer);
        }
        this._kex = void 0;
        this._kexinit = void 0;
        this._offer = offer;
        this._cipher = new NullCipher(0, this._onWrite);
        this._decipher = void 0;
        this._skipNextInboundPacket = false;
        this._packetRW = {
          read: new PacketReader(),
          write: new PacketWriter(this)
        };
        this._hostVerifier = !this._server && typeof config.hostVerifier === "function" ? config.hostVerifier : void 0;
        this._parse = parseHeader;
        this._buffer = void 0;
        this._authsQueue = [];
        this._authenticated = false;
        this._remoteIdentRaw = void 0;
        let sentIdent;
        if (typeof config.ident === "string") {
          this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);
          sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);
          sentIdent.set(this._identRaw, 0);
          sentIdent[sentIdent.length - 2] = 13;
          sentIdent[sentIdent.length - 1] = 10;
        } else if (Buffer.isBuffer(config.ident)) {
          const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);
          fullIdent.latin1Write("SSH-2.0-", 0, 8);
          fullIdent.set(config.ident, 8);
          this._identRaw = fullIdent;
          sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);
          sentIdent.set(fullIdent, 0);
          sentIdent[sentIdent.length - 2] = 13;
          sentIdent[sentIdent.length - 1] = 10;
        } else {
          this._identRaw = IDENT_RAW;
          sentIdent = IDENT;
        }
        this._compatFlags = 0;
        if (this._debug) {
          if (bindingAvailable)
            this._debug("Custom crypto binding available");
          else
            this._debug("Custom crypto binding not available");
        }
        this._debug && this._debug(
          `Local ident: ${inspect(this._identRaw.toString())}`
        );
        this.start = () => {
          this.start = void 0;
          if (greeting)
            this._onWrite(greeting);
          this._onWrite(sentIdent);
        };
      }
      _destruct(reason) {
        this._packetRW.read.cleanup();
        this._packetRW.write.cleanup();
        this._cipher && this._cipher.free();
        this._decipher && this._decipher.free();
        if (typeof reason !== "string" || reason.length === 0)
          reason = "fatal error";
        this.parse = () => {
          throw new Error(`Instance unusable after ${reason}`);
        };
        this._onWrite = () => {
          throw new Error(`Instance unusable after ${reason}`);
        };
        this._destruct = void 0;
      }
      cleanup() {
        this._destruct && this._destruct();
      }
      parse(chunk, i, len) {
        while (i < len)
          i = this._parse(chunk, i, len);
      }
      // Protocol message API
      // ===========================================================================
      // Common/Shared =============================================================
      // ===========================================================================
      // Global
      // ------
      disconnect(reason) {
        const pktLen = 1 + 4 + 4 + 4;
        let p = this._packetRW.write.allocStartKEX;
        const packet = this._packetRW.write.alloc(pktLen, true);
        const end = p + pktLen;
        if (!VALID_DISCONNECT_REASONS.has(reason))
          reason = DISCONNECT_REASON.PROTOCOL_ERROR;
        packet[p] = MESSAGE.DISCONNECT;
        writeUInt32BE(packet, reason, ++p);
        packet.fill(0, p += 4, end);
        this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);
        sendPacket(this, this._packetRW.write.finalize(packet, true), true);
      }
      ping() {
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);
        packet.set(PING_PAYLOAD, p);
        this._debug && this._debug(
          "Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      rekey() {
        if (this._kexinit === void 0) {
          this._debug && this._debug("Outbound: Initiated explicit rekey");
          this._queue = [];
          kexinit(this);
        } else {
          this._debug && this._debug("Outbound: Ignoring rekey during handshake");
        }
      }
      // 'ssh-connection' service-specific
      // ---------------------------------
      requestSuccess(data) {
        let p = this._packetRW.write.allocStart;
        let packet;
        if (Buffer.isBuffer(data)) {
          packet = this._packetRW.write.alloc(1 + data.length);
          packet[p] = MESSAGE.REQUEST_SUCCESS;
          packet.set(data, ++p);
        } else {
          packet = this._packetRW.write.alloc(1);
          packet[p] = MESSAGE.REQUEST_SUCCESS;
        }
        this._debug && this._debug("Outbound: Sending REQUEST_SUCCESS");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      requestFailure() {
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1);
        packet[p] = MESSAGE.REQUEST_FAILURE;
        this._debug && this._debug("Outbound: Sending REQUEST_FAILURE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelSuccess(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_SUCCESS;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelFailure(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_FAILURE;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelEOF(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_EOF;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelClose(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_CLOSE;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelWindowAdjust(chan, amount) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, amount, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelData(chan, data) {
        const isBuffer = Buffer.isBuffer(data);
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);
        packet[p] = MESSAGE.CHANNEL_DATA;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, dataLen, p += 4);
        if (isBuffer)
          packet.set(data, p += 4);
        else
          packet.utf8Write(data, p += 4, dataLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelExtData(chan, data, type) {
        const isBuffer = Buffer.isBuffer(data);
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);
        packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, type, p += 4);
        writeUInt32BE(packet, dataLen, p += 4);
        if (isBuffer)
          packet.set(data, p += 4);
        else
          packet.utf8Write(data, p += 4, dataLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelOpenConfirm(remote, local, initWindow, maxPacket) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;
        writeUInt32BE(packet, remote, ++p);
        writeUInt32BE(packet, local, p += 4);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelOpenFail(remote, reason, desc) {
        if (typeof desc !== "string")
          desc = "";
        const descLen = Buffer.byteLength(desc);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;
        writeUInt32BE(packet, remote, ++p);
        writeUInt32BE(packet, reason, p += 4);
        writeUInt32BE(packet, descLen, p += 4);
        p += 4;
        if (descLen) {
          packet.utf8Write(desc, p, descLen);
          p += descLen;
        }
        writeUInt32BE(packet, 0, p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // ===========================================================================
      // Client-specific ===========================================================
      // ===========================================================================
      // Global
      // ------
      service(name) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const nameLen = Buffer.byteLength(name);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + nameLen);
        packet[p] = MESSAGE.SERVICE_REQUEST;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(name, p += 4, nameLen);
        this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-userauth' service-specific
      // -------------------------------
      authPassword(username, password, newPassword) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        const passLen = Buffer.byteLength(password);
        const newPassLen = newPassword ? Buffer.byteLength(newPassword) : 0;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen + (newPassword ? 4 + newPassLen : 0)
        );
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 8, p += 14);
        packet.utf8Write("password", p += 4, 8);
        packet[p += 8] = newPassword ? 1 : 0;
        writeUInt32BE(packet, passLen, ++p);
        if (Buffer.isBuffer(password))
          bufferCopy(password, packet, 0, passLen, p += 4);
        else
          packet.utf8Write(password, p += 4, passLen);
        if (newPassword) {
          writeUInt32BE(packet, newPassLen, p += passLen);
          if (Buffer.isBuffer(newPassword))
            bufferCopy(newPassword, packet, 0, newPassLen, p += 4);
          else
            packet.utf8Write(newPassword, p += 4, newPassLen);
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (changed password)"
          );
        } else {
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (password)"
          );
        }
        this._authsQueue.push("password");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authPK(username, pubKey, keyAlgo, cbSign) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        pubKey = parseKey(pubKey);
        if (pubKey instanceof Error)
          throw new Error("Invalid key");
        const keyType = pubKey.type;
        pubKey = pubKey.getPublicSSH();
        if (typeof keyAlgo === "function") {
          cbSign = keyAlgo;
          keyAlgo = void 0;
        }
        if (!keyAlgo)
          keyAlgo = keyType;
        const userLen = Buffer.byteLength(username);
        const algoLen = Buffer.byteLength(keyAlgo);
        const pubKeyLen = pubKey.length;
        const sessionID = this._kex.sessionID;
        const sesLen = sessionID.length;
        const payloadLen = (cbSign ? 4 + sesLen : 0) + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;
        let packet;
        let p;
        if (cbSign) {
          packet = Buffer.allocUnsafe(payloadLen);
          p = 0;
          writeUInt32BE(packet, sesLen, p);
          packet.set(sessionID, p += 4);
          p += sesLen;
        } else {
          packet = this._packetRW.write.alloc(payloadLen);
          p = this._packetRW.write.allocStart;
        }
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 9, p += 14);
        packet.utf8Write("publickey", p += 4, 9);
        packet[p += 9] = cbSign ? 1 : 0;
        writeUInt32BE(packet, algoLen, ++p);
        packet.utf8Write(keyAlgo, p += 4, algoLen);
        writeUInt32BE(packet, pubKeyLen, p += algoLen);
        packet.set(pubKey, p += 4);
        if (!cbSign) {
          this._authsQueue.push("publickey");
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (publickey -- check)"
          );
          sendPacket(this, this._packetRW.write.finalize(packet));
          return;
        }
        cbSign(packet, (signature) => {
          signature = convertSignature(signature, keyType);
          if (signature === false)
            throw new Error("Error while converting handshake signature");
          const sigLen = signature.length;
          p = this._packetRW.write.allocStart;
          packet = this._packetRW.write.alloc(
            1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4 + 4 + algoLen + 4 + sigLen
          );
          packet[p] = MESSAGE.USERAUTH_REQUEST;
          writeUInt32BE(packet, userLen, ++p);
          packet.utf8Write(username, p += 4, userLen);
          writeUInt32BE(packet, 14, p += userLen);
          packet.utf8Write("ssh-connection", p += 4, 14);
          writeUInt32BE(packet, 9, p += 14);
          packet.utf8Write("publickey", p += 4, 9);
          packet[p += 9] = 1;
          writeUInt32BE(packet, algoLen, ++p);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, pubKeyLen, p += algoLen);
          packet.set(pubKey, p += 4);
          writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);
          writeUInt32BE(packet, algoLen, p += 4);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, sigLen, p += algoLen);
          packet.set(signature, p += 4);
          this._authsQueue.push("publickey");
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (publickey)"
          );
          sendPacket(this, this._packetRW.write.finalize(packet));
        });
      }
      authHostbased(username, pubKey, hostname, userlocal, keyAlgo, cbSign) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        pubKey = parseKey(pubKey);
        if (pubKey instanceof Error)
          throw new Error("Invalid key");
        const keyType = pubKey.type;
        pubKey = pubKey.getPublicSSH();
        if (typeof keyAlgo === "function") {
          cbSign = keyAlgo;
          keyAlgo = void 0;
        }
        if (!keyAlgo)
          keyAlgo = keyType;
        const userLen = Buffer.byteLength(username);
        const algoLen = Buffer.byteLength(keyAlgo);
        const pubKeyLen = pubKey.length;
        const sessionID = this._kex.sessionID;
        const sesLen = sessionID.length;
        const hostnameLen = Buffer.byteLength(hostname);
        const userlocalLen = Buffer.byteLength(userlocal);
        const data = Buffer.allocUnsafe(
          4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen
        );
        let p = 0;
        writeUInt32BE(data, sesLen, p);
        data.set(sessionID, p += 4);
        data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(data, userLen, ++p);
        data.utf8Write(username, p += 4, userLen);
        writeUInt32BE(data, 14, p += userLen);
        data.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(data, 9, p += 14);
        data.utf8Write("hostbased", p += 4, 9);
        writeUInt32BE(data, algoLen, p += 9);
        data.utf8Write(keyAlgo, p += 4, algoLen);
        writeUInt32BE(data, pubKeyLen, p += algoLen);
        data.set(pubKey, p += 4);
        writeUInt32BE(data, hostnameLen, p += pubKeyLen);
        data.utf8Write(hostname, p += 4, hostnameLen);
        writeUInt32BE(data, userlocalLen, p += hostnameLen);
        data.utf8Write(userlocal, p += 4, userlocalLen);
        cbSign(data, (signature) => {
          signature = convertSignature(signature, keyType);
          if (!signature)
            throw new Error("Error while converting handshake signature");
          const sigLen = signature.length;
          const reqDataLen = data.length - sesLen - 4;
          p = this._packetRW.write.allocStart;
          const packet = this._packetRW.write.alloc(
            reqDataLen + 4 + 4 + algoLen + 4 + sigLen
          );
          bufferCopy(data, packet, 4 + sesLen, data.length, p);
          writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);
          writeUInt32BE(packet, algoLen, p += 4);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, sigLen, p += algoLen);
          packet.set(signature, p += 4);
          this._authsQueue.push("hostbased");
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (hostbased)"
          );
          sendPacket(this, this._packetRW.write.finalize(packet));
        });
      }
      authKeyboard(username) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4
        );
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 20, p += 14);
        packet.utf8Write("keyboard-interactive", p += 4, 20);
        writeUInt32BE(packet, 0, p += 20);
        writeUInt32BE(packet, 0, p += 4);
        this._authsQueue.push("keyboard-interactive");
        this._debug && this._debug(
          "Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authNone(username) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 4, p += 14);
        packet.utf8Write("none", p += 4, 4);
        this._authsQueue.push("none");
        this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (none)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authInfoRes(responses) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let responsesTotalLen = 0;
        let responseLens;
        if (responses) {
          responseLens = new Array(responses.length);
          for (let i = 0; i < responses.length; ++i) {
            const len = Buffer.byteLength(responses[i]);
            responseLens[i] = len;
            responsesTotalLen += 4 + len;
          }
        }
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);
        packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;
        if (responses) {
          writeUInt32BE(packet, responses.length, ++p);
          p += 4;
          for (let i = 0; i < responses.length; ++i) {
            const len = responseLens[i];
            writeUInt32BE(packet, len, p);
            p += 4;
            if (len) {
              packet.utf8Write(responses[i], p, len);
              p += len;
            }
          }
        } else {
          writeUInt32BE(packet, 0, ++p);
        }
        this._debug && this._debug("Outbound: Sending USERAUTH_INFO_RESPONSE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-connection' service-specific
      // ---------------------------------
      tcpipForward(bindAddr, bindPort, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const addrLen = Buffer.byteLength(bindAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 13, ++p);
        packet.utf8Write("tcpip-forward", p += 4, 13);
        packet[p += 13] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, addrLen, ++p);
        packet.utf8Write(bindAddr, p += 4, addrLen);
        writeUInt32BE(packet, bindPort, p += addrLen);
        this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (tcpip-forward)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      cancelTcpipForward(bindAddr, bindPort, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const addrLen = Buffer.byteLength(bindAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 20, ++p);
        packet.utf8Write("cancel-tcpip-forward", p += 4, 20);
        packet[p += 20] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, addrLen, ++p);
        packet.utf8Write(bindAddr, p += 4, addrLen);
        writeUInt32BE(packet, bindPort, p += addrLen);
        this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_streamLocalForward(socketPath, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const socketPathLen = Buffer.byteLength(socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 31 + 1 + 4 + socketPathLen
        );
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 31, ++p);
        packet.utf8Write("streamlocal-forward@openssh.com", p += 4, 31);
        packet[p += 31] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, socketPathLen, ++p);
        packet.utf8Write(socketPath, p += 4, socketPathLen);
        this._debug && this._debug(
          "Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_cancelStreamLocalForward(socketPath, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const socketPathLen = Buffer.byteLength(socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 38 + 1 + 4 + socketPathLen
        );
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 38, ++p);
        packet.utf8Write("cancel-streamlocal-forward@openssh.com", p += 4, 38);
        packet[p += 38] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, socketPathLen, ++p);
        packet.utf8Write(socketPath, p += 4, socketPathLen);
        if (this._debug) {
          this._debug(
            "Outbound: Sending GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)"
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      directTcpip(chan, initWindow, maxPacket, cfg) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const srcLen = Buffer.byteLength(cfg.srcIP);
        const dstLen = Buffer.byteLength(cfg.dstIP);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 12, ++p);
        packet.utf8Write("direct-tcpip", p += 4, 12);
        writeUInt32BE(packet, chan, p += 12);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, dstLen, p += 4);
        packet.utf8Write(cfg.dstIP, p += 4, dstLen);
        writeUInt32BE(packet, cfg.dstPort, p += dstLen);
        writeUInt32BE(packet, srcLen, p += 4);
        packet.utf8Write(cfg.srcIP, p += 4, srcLen);
        writeUInt32BE(packet, cfg.srcPort, p += srcLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(cfg.socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 30, ++p);
        packet.utf8Write("direct-streamlocal@openssh.com", p += 4, 30);
        writeUInt32BE(packet, chan, p += 30);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, pathLen, p += 4);
        packet.utf8Write(cfg.socketPath, p += 4, pathLen);
        bufferFill(packet, 0, p += pathLen, p + 8);
        if (this._debug) {
          this._debug(
            `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-streamlocal@openssh.com)`
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_noMoreSessions(wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 28, ++p);
        packet.utf8Write("no-more-sessions@openssh.com", p += 4, 28);
        packet[p += 28] = wantReply === void 0 || wantReply === true ? 1 : 0;
        this._debug && this._debug(
          "Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      session(chan, initWindow, maxPacket) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 7, ++p);
        packet.utf8Write("session", p += 4, 7);
        writeUInt32BE(packet, chan, p += 7);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      windowChange(chan, rows, cols, height, width) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 13, p += 4);
        packet.utf8Write("window-change", p += 4, 13);
        packet[p += 13] = 0;
        writeUInt32BE(packet, cols, ++p);
        writeUInt32BE(packet, rows, p += 4);
        writeUInt32BE(packet, width, p += 4);
        writeUInt32BE(packet, height, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      pty(chan, rows, cols, height, width, term, modes, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        if (!term || !term.length)
          term = "vt100";
        if (modes && !Buffer.isBuffer(modes) && !Array.isArray(modes) && typeof modes === "object" && modes !== null) {
          modes = modesToBytes(modes);
        }
        if (!modes || !modes.length)
          modes = NO_TERMINAL_MODES_BUFFER;
        const termLen = term.length;
        const modesLen = modes.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 7, p += 4);
        packet.utf8Write("pty-req", p += 4, 7);
        packet[p += 7] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, termLen, ++p);
        packet.utf8Write(term, p += 4, termLen);
        writeUInt32BE(packet, cols, p += termLen);
        writeUInt32BE(packet, rows, p += 4);
        writeUInt32BE(packet, width, p += 4);
        writeUInt32BE(packet, height, p += 4);
        writeUInt32BE(packet, modesLen, p += 4);
        p += 4;
        if (Array.isArray(modes)) {
          for (let i = 0; i < modesLen; ++i)
            packet[p++] = modes[i];
        } else if (Buffer.isBuffer(modes)) {
          packet.set(modes, p);
        }
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      shell(chan, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 5, p += 4);
        packet.utf8Write("shell", p += 4, 5);
        packet[p += 5] = wantReply === void 0 || wantReply === true ? 1 : 0;
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exec(chan, cmd, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const isBuf = Buffer.isBuffer(cmd);
        const cmdLen = isBuf ? cmd.length : Buffer.byteLength(cmd);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 4, p += 4);
        packet.utf8Write("exec", p += 4, 4);
        packet[p += 4] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, cmdLen, ++p);
        if (isBuf)
          packet.set(cmd, p += 4);
        else
          packet.utf8Write(cmd, p += 4, cmdLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      signal(chan, signal) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const origSignal = signal;
        signal = signal.toUpperCase();
        if (signal.slice(0, 3) === "SIG")
          signal = signal.slice(3);
        if (SIGNALS[signal] !== 1)
          throw new Error(`Invalid signal: ${origSignal}`);
        const signalLen = signal.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 6 + 1 + 4 + signalLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 6, p += 4);
        packet.utf8Write("signal", p += 4, 6);
        packet[p += 6] = 0;
        writeUInt32BE(packet, signalLen, ++p);
        packet.utf8Write(signal, p += 4, signalLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      env(chan, key, val, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const keyLen = Buffer.byteLength(key);
        const isBuf = Buffer.isBuffer(val);
        const valLen = isBuf ? val.length : Buffer.byteLength(val);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 3, p += 4);
        packet.utf8Write("env", p += 4, 3);
        packet[p += 3] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, keyLen, ++p);
        packet.utf8Write(key, p += 4, keyLen);
        writeUInt32BE(packet, valLen, p += keyLen);
        if (isBuf)
          packet.set(val, p += 4);
        else
          packet.utf8Write(val, p += 4, valLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      x11Forward(chan, cfg, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const protocol = cfg.protocol;
        const cookie = cfg.cookie;
        const isBufProto = Buffer.isBuffer(protocol);
        const protoLen = isBufProto ? protocol.length : Buffer.byteLength(protocol);
        const isBufCookie = Buffer.isBuffer(cookie);
        const cookieLen = isBufCookie ? cookie.length : Buffer.byteLength(cookie);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 7, p += 4);
        packet.utf8Write("x11-req", p += 4, 7);
        packet[p += 7] = wantReply === void 0 || wantReply === true ? 1 : 0;
        packet[++p] = cfg.single ? 1 : 0;
        writeUInt32BE(packet, protoLen, ++p);
        if (isBufProto)
          packet.set(protocol, p += 4);
        else
          packet.utf8Write(protocol, p += 4, protoLen);
        writeUInt32BE(packet, cookieLen, p += protoLen);
        if (isBufCookie)
          packet.set(cookie, p += 4);
        else
          packet.latin1Write(cookie, p += 4, cookieLen);
        writeUInt32BE(packet, cfg.screen || 0, p += cookieLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      subsystem(chan, name, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const nameLen = Buffer.byteLength(name);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 9, p += 4);
        packet.utf8Write("subsystem", p += 4, 9);
        packet[p += 9] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(name, p += 4, nameLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_agentForward(chan, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 26, p += 4);
        packet.utf8Write("auth-agent-req@openssh.com", p += 4, 26);
        packet[p += 26] = wantReply === void 0 || wantReply === true ? 1 : 0;
        if (this._debug) {
          this._debug(
            `Outbound: Sending CHANNEL_REQUEST (r:${chan}, auth-agent-req@openssh.com)`
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_hostKeysProve(keys) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let keysTotal = 0;
        const publicKeys = [];
        for (const key of keys) {
          const publicKey = key.getPublicSSH();
          keysTotal += 4 + publicKey.length;
          publicKeys.push(publicKey);
        }
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 29, ++p);
        packet.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29);
        packet[p += 29] = 1;
        ++p;
        for (const buf of publicKeys) {
          writeUInt32BE(packet, buf.length, p);
          bufferCopy(buf, packet, 0, buf.length, p += 4);
          p += buf.length;
        }
        if (this._debug) {
          this._debug(
            "Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)"
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // ===========================================================================
      // Server-specific ===========================================================
      // ===========================================================================
      // Global
      // ------
      serviceAccept(svcName) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const svcNameLen = Buffer.byteLength(svcName);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);
        packet[p] = MESSAGE.SERVICE_ACCEPT;
        writeUInt32BE(packet, svcNameLen, ++p);
        packet.utf8Write(svcName, p += 4, svcNameLen);
        this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
        if (this._server && this._banner && svcName === "ssh-userauth") {
          const banner = this._banner;
          this._banner = void 0;
          const bannerLen = Buffer.byteLength(banner);
          p = this._packetRW.write.allocStart;
          const packet2 = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);
          packet2[p] = MESSAGE.USERAUTH_BANNER;
          writeUInt32BE(packet2, bannerLen, ++p);
          packet2.utf8Write(banner, p += 4, bannerLen);
          writeUInt32BE(packet2, 0, p += bannerLen);
          this._debug && this._debug("Outbound: Sending USERAUTH_BANNER");
          sendPacket(this, this._packetRW.write.finalize(packet2));
        }
      }
      // 'ssh-connection' service-specific
      forwardedTcpip(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const boundAddrLen = Buffer.byteLength(cfg.boundAddr);
        const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 15, ++p);
        packet.utf8Write("forwarded-tcpip", p += 4, 15);
        writeUInt32BE(packet, chan, p += 15);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, boundAddrLen, p += 4);
        packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);
        writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);
        writeUInt32BE(packet, remoteAddrLen, p += 4);
        packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);
        writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      x11(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const addrLen = Buffer.byteLength(cfg.originAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 3, ++p);
        packet.utf8Write("x11", p += 4, 3);
        writeUInt32BE(packet, chan, p += 3);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, addrLen, p += 4);
        packet.utf8Write(cfg.originAddr, p += 4, addrLen);
        writeUInt32BE(packet, cfg.originPort, p += addrLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_authAgent(chan, initWindow, maxPacket) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 22, ++p);
        packet.utf8Write("auth-agent@openssh.com", p += 4, 22);
        writeUInt32BE(packet, chan, p += 22);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const pathLen = Buffer.byteLength(cfg.socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 33, ++p);
        packet.utf8Write("forwarded-streamlocal@openssh.com", p += 4, 33);
        writeUInt32BE(packet, chan, p += 33);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, pathLen, p += 4);
        packet.utf8Write(cfg.socketPath, p += 4, pathLen);
        writeUInt32BE(packet, 0, p += pathLen);
        if (this._debug) {
          this._debug(
            `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-streamlocal@openssh.com)`
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exitStatus(chan, status) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 11, p += 4);
        packet.utf8Write("exit-status", p += 4, 11);
        packet[p += 11] = 0;
        writeUInt32BE(packet, status, ++p);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exitSignal(chan, name, coreDumped, msg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const origSignal = name;
        if (typeof origSignal !== "string" || !origSignal)
          throw new Error(`Invalid signal: ${origSignal}`);
        let signal = name.toUpperCase();
        if (signal.slice(0, 3) === "SIG")
          signal = signal.slice(3);
        if (SIGNALS[signal] !== 1)
          throw new Error(`Invalid signal: ${origSignal}`);
        const nameLen = Buffer.byteLength(signal);
        const msgLen = msg ? Buffer.byteLength(msg) : 0;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 11, p += 4);
        packet.utf8Write("exit-signal", p += 4, 11);
        packet[p += 11] = 0;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(signal, p += 4, nameLen);
        packet[p += nameLen] = coreDumped ? 1 : 0;
        writeUInt32BE(packet, msgLen, ++p);
        p += 4;
        if (msgLen) {
          packet.utf8Write(msg, p, msgLen);
          p += msgLen;
        }
        writeUInt32BE(packet, 0, p);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-userauth' service-specific
      authFailure(authMethods, isPartial) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0)
          throw new Error("No auth in progress");
        let methods;
        if (typeof authMethods === "boolean") {
          isPartial = authMethods;
          authMethods = void 0;
        }
        if (authMethods) {
          methods = [];
          for (let i = 0; i < authMethods.length; ++i) {
            if (authMethods[i].toLowerCase() === "none")
              continue;
            methods.push(authMethods[i]);
          }
          methods = methods.join(",");
        } else {
          methods = "";
        }
        const methodsLen = methods.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);
        packet[p] = MESSAGE.USERAUTH_FAILURE;
        writeUInt32BE(packet, methodsLen, ++p);
        packet.utf8Write(methods, p += 4, methodsLen);
        packet[p += methodsLen] = isPartial === true ? 1 : 0;
        this._authsQueue.shift();
        this._debug && this._debug("Outbound: Sending USERAUTH_FAILURE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authSuccess() {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0)
          throw new Error("No auth in progress");
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1);
        packet[p] = MESSAGE.USERAUTH_SUCCESS;
        this._authsQueue.shift();
        this._authenticated = true;
        this._debug && this._debug("Outbound: Sending USERAUTH_SUCCESS");
        sendPacket(this, this._packetRW.write.finalize(packet));
        if (this._kex.negotiated.cs.compress === "zlib@openssh.com")
          this._packetRW.read = new ZlibPacketReader();
        if (this._kex.negotiated.sc.compress === "zlib@openssh.com")
          this._packetRW.write = new ZlibPacketWriter(this);
      }
      authPKOK(keyAlgo, key) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0 || this._authsQueue[0] !== "publickey")
          throw new Error('"publickey" auth not in progress');
        const keyAlgoLen = Buffer.byteLength(keyAlgo);
        const keyLen = key.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);
        packet[p] = MESSAGE.USERAUTH_PK_OK;
        writeUInt32BE(packet, keyAlgoLen, ++p);
        packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);
        writeUInt32BE(packet, keyLen, p += keyAlgoLen);
        packet.set(key, p += 4);
        this._authsQueue.shift();
        this._debug && this._debug("Outbound: Sending USERAUTH_PK_OK");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authPasswdChg(prompt) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const promptLen = Buffer.byteLength(prompt);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);
        packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;
        writeUInt32BE(packet, promptLen, ++p);
        packet.utf8Write(prompt, p += 4, promptLen);
        writeUInt32BE(packet, 0, p += promptLen);
        this._debug && this._debug("Outbound: Sending USERAUTH_PASSWD_CHANGEREQ");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authInfoReq(name, instructions, prompts) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let promptsLen = 0;
        const nameLen = name ? Buffer.byteLength(name) : 0;
        const instrLen = instructions ? Buffer.byteLength(instructions) : 0;
        for (let i = 0; i < prompts.length; ++i)
          promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen
        );
        packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;
        writeUInt32BE(packet, nameLen, ++p);
        p += 4;
        if (name) {
          packet.utf8Write(name, p, nameLen);
          p += nameLen;
        }
        writeUInt32BE(packet, instrLen, p);
        p += 4;
        if (instructions) {
          packet.utf8Write(instructions, p, instrLen);
          p += instrLen;
        }
        writeUInt32BE(packet, 0, p);
        writeUInt32BE(packet, prompts.length, p += 4);
        p += 4;
        for (let i = 0; i < prompts.length; ++i) {
          const prompt = prompts[i];
          const promptLen = Buffer.byteLength(prompt.prompt);
          writeUInt32BE(packet, promptLen, p);
          p += 4;
          if (promptLen) {
            packet.utf8Write(prompt.prompt, p, promptLen);
            p += promptLen;
          }
          packet[p++] = prompt.echo ? 1 : 0;
        }
        this._debug && this._debug("Outbound: Sending USERAUTH_INFO_REQUEST");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
    };
    var RE_IDENT = /^SSH-(2\.0|1\.99)-([^ ]+)(?: (.*))?$/;
    function parseHeader(chunk, p, len) {
      let data;
      let chunkOffset;
      if (this._buffer) {
        data = Buffer.allocUnsafe(this._buffer.length + (len - p));
        data.set(this._buffer, 0);
        if (p === 0) {
          data.set(chunk, this._buffer.length);
        } else {
          data.set(
            new Uint8Array(
              chunk.buffer,
              chunk.byteOffset + p,
              len - p
            ),
            this._buffer.length
          );
        }
        chunkOffset = this._buffer.length;
        p = 0;
      } else {
        data = chunk;
        chunkOffset = 0;
      }
      const op = p;
      let start = p;
      let end = p;
      let needNL = false;
      let lineLen = 0;
      let lines = 0;
      for (; p < data.length; ++p) {
        const ch = data[p];
        if (ch === 13) {
          needNL = true;
          continue;
        }
        if (ch === 10) {
          if (end > start && end - start > 4 && data[start] === 83 && data[start + 1] === 83 && data[start + 2] === 72 && data[start + 3] === 45) {
            const full = data.latin1Slice(op, end + 1);
            const identRaw = start === op ? full : full.slice(start - op);
            const m = RE_IDENT.exec(identRaw);
            if (!m)
              throw new Error("Invalid identification string");
            const header = {
              greeting: start === op ? "" : full.slice(0, start - op),
              identRaw,
              versions: {
                protocol: m[1],
                software: m[2]
              },
              comments: m[3]
            };
            this._remoteIdentRaw = Buffer.from(identRaw);
            this._debug && this._debug(`Remote ident: ${inspect(identRaw)}`);
            this._compatFlags = getCompatFlags(header);
            this._buffer = void 0;
            this._decipher = new NullDecipher(0, onKEXPayload.bind(this, { firstPacket: true }));
            this._parse = parsePacket;
            this._onHeader(header);
            if (!this._destruct) {
              return len;
            }
            kexinit(this);
            return p + 1 - chunkOffset;
          }
          if (this._server)
            throw new Error("Greetings from clients not permitted");
          if (++lines > MAX_LINES)
            throw new Error("Max greeting lines exceeded");
          needNL = false;
          start = p + 1;
          lineLen = 0;
        } else if (needNL) {
          throw new Error("Invalid header: expected newline");
        } else if (++lineLen >= MAX_LINE_LEN) {
          throw new Error("Header line too long");
        }
        end = p;
      }
      if (!this._buffer)
        this._buffer = bufferSlice(data, op);
      return p - chunkOffset;
    }
    function parsePacket(chunk, p, len) {
      return this._decipher.decrypt(chunk, p, len);
    }
    function onPayload(payload) {
      this._onPacket();
      if (payload.length === 0) {
        this._debug && this._debug("Inbound: Skipping empty packet payload");
        return;
      }
      payload = this._packetRW.read.read(payload);
      const type = payload[0];
      if (type === MESSAGE.USERAUTH_SUCCESS && !this._server && !this._authenticated) {
        this._authenticated = true;
        if (this._kex.negotiated.cs.compress === "zlib@openssh.com")
          this._packetRW.write = new ZlibPacketWriter(this);
        if (this._kex.negotiated.sc.compress === "zlib@openssh.com")
          this._packetRW.read = new ZlibPacketReader();
      }
      const handler = MESSAGE_HANDLERS[type];
      if (handler === void 0) {
        this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);
        return;
      }
      return handler(this, payload);
    }
    function getCompatFlags(header) {
      const software = header.versions.software;
      let flags = 0;
      for (const rule of COMPAT_CHECKS) {
        if (typeof rule[0] === "string") {
          if (software === rule[0])
            flags |= rule[1];
        } else if (rule[0].test(software)) {
          flags |= rule[1];
        }
      }
      return flags;
    }
    function modesToBytes(modes) {
      const keys = Object.keys(modes);
      const bytes = Buffer.allocUnsafe(5 * keys.length + 1);
      let b = 0;
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === "TTY_OP_END")
          continue;
        const opcode = TERMINAL_MODE[key];
        if (opcode === void 0)
          continue;
        const val = modes[key];
        if (typeof val === "number" && isFinite(val)) {
          bytes[b++] = opcode;
          bytes[b++] = val >>> 24;
          bytes[b++] = val >>> 16;
          bytes[b++] = val >>> 8;
          bytes[b++] = val;
        }
      }
      bytes[b++] = TERMINAL_MODE.TTY_OP_END;
      if (b < bytes.length)
        return bufferSlice(bytes, 0, b);
      return bytes;
    }
    function sendExtInfo(proto) {
      let serverSigAlgs = "ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss";
      if (eddsaSupported)
        serverSigAlgs = `ssh-ed25519,${serverSigAlgs}`;
      const algsLen = Buffer.byteLength(serverSigAlgs);
      let p = proto._packetRW.write.allocStart;
      const packet = proto._packetRW.write.alloc(1 + 4 + 4 + 15 + 4 + algsLen);
      packet[p] = MESSAGE.EXT_INFO;
      writeUInt32BE(packet, 1, ++p);
      writeUInt32BE(packet, 15, p += 4);
      packet.utf8Write("server-sig-algs", p += 4, 15);
      writeUInt32BE(packet, algsLen, p += 15);
      packet.utf8Write(serverSigAlgs, p += 4, algsLen);
      proto._debug && proto._debug("Outbound: Sending EXT_INFO");
      sendPacket(proto, proto._packetRW.write.finalize(packet));
    }
    module2.exports = Protocol;
  }
});

// node_modules/ssh2/lib/protocol/node-fs-compat.js
var require_node_fs_compat = __commonJS({
  "node_modules/ssh2/lib/protocol/node-fs-compat.js"(exports) {
    "use strict";
    var assert = require("assert");
    var { inspect } = require("util");
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3)
        res = `_${val.slice(i - 3, i)}${res}`;
      return `${val.slice(0, i)}${res}`;
    }
    function oneOf(expected, thing) {
      assert(typeof thing === "string", "`thing` has to be of type string");
      if (Array.isArray(expected)) {
        const len = expected.length;
        assert(len > 0, "At least one expected value needs to be specified");
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        }
        return `of ${thing} ${expected[0]}`;
      }
      return `of ${thing} ${String(expected)}`;
    }
    exports.ERR_INTERNAL_ASSERTION = class ERR_INTERNAL_ASSERTION extends Error {
      constructor(message) {
        super();
        Error.captureStackTrace(this, ERR_INTERNAL_ASSERTION);
        const suffix = "This is caused by either a bug in ssh2 or incorrect usage of ssh2 internals.\nPlease open an issue with this stack trace at https://github.com/mscdex/ssh2/issues\n";
        this.message = message === void 0 ? suffix : `${message}
${suffix}`;
      }
    };
    var MAX_32BIT_INT = 2 ** 32;
    var MAX_32BIT_BIGINT = (() => {
      try {
        return new Function("return 2n ** 32n")();
      } catch {
      }
    })();
    exports.ERR_OUT_OF_RANGE = class ERR_OUT_OF_RANGE extends RangeError {
      constructor(str, range, input, replaceDefaultBoolean) {
        super();
        Error.captureStackTrace(this, ERR_OUT_OF_RANGE);
        assert(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > MAX_32BIT_INT) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > MAX_32BIT_BIGINT || input < -MAX_32BIT_BIGINT)
            received = addNumericalSeparator(received);
          received += "n";
        } else {
          received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        this.message = msg;
      }
    };
    var ERR_INVALID_ARG_TYPE = class extends TypeError {
      constructor(name, expected, actual) {
        super();
        Error.captureStackTrace(this, ERR_INVALID_ARG_TYPE);
        assert(typeof name === "string", `'name' must be a string`);
        let determiner;
        if (typeof expected === "string" && expected.startsWith("not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        let msg;
        if (name.endsWith(" argument")) {
          msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
        } else {
          const type = name.includes(".") ? "property" : "argument";
          msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
        }
        msg += `. Received type ${typeof actual}`;
        this.message = msg;
      }
    };
    exports.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
    exports.validateNumber = function validateNumber(value, name) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    };
  }
});

// node_modules/ssh2/lib/protocol/SFTP.js
var require_SFTP = __commonJS({
  "node_modules/ssh2/lib/protocol/SFTP.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var fs = require("fs");
    var { constants } = fs;
    var {
      Readable: ReadableStream,
      Writable: WritableStream
    } = require("stream");
    var { inherits, isDate } = require("util");
    var FastBuffer = Buffer[Symbol.species];
    var {
      bufferCopy,
      bufferSlice,
      makeBufferParser,
      writeUInt32BE
    } = require_utils();
    var ATTR = {
      SIZE: 1,
      UIDGID: 2,
      PERMISSIONS: 4,
      ACMODTIME: 8,
      EXTENDED: 2147483648
    };
    var ATTRS_BUF = Buffer.alloc(28);
    var STATUS_CODE = {
      OK: 0,
      EOF: 1,
      NO_SUCH_FILE: 2,
      PERMISSION_DENIED: 3,
      FAILURE: 4,
      BAD_MESSAGE: 5,
      NO_CONNECTION: 6,
      CONNECTION_LOST: 7,
      OP_UNSUPPORTED: 8
    };
    var VALID_STATUS_CODES = new Map(
      Object.values(STATUS_CODE).map((n) => [n, 1])
    );
    var STATUS_CODE_STR = {
      [STATUS_CODE.OK]: "No error",
      [STATUS_CODE.EOF]: "End of file",
      [STATUS_CODE.NO_SUCH_FILE]: "No such file or directory",
      [STATUS_CODE.PERMISSION_DENIED]: "Permission denied",
      [STATUS_CODE.FAILURE]: "Failure",
      [STATUS_CODE.BAD_MESSAGE]: "Bad message",
      [STATUS_CODE.NO_CONNECTION]: "No connection",
      [STATUS_CODE.CONNECTION_LOST]: "Connection lost",
      [STATUS_CODE.OP_UNSUPPORTED]: "Operation unsupported"
    };
    var REQUEST = {
      INIT: 1,
      OPEN: 3,
      CLOSE: 4,
      READ: 5,
      WRITE: 6,
      LSTAT: 7,
      FSTAT: 8,
      SETSTAT: 9,
      FSETSTAT: 10,
      OPENDIR: 11,
      READDIR: 12,
      REMOVE: 13,
      MKDIR: 14,
      RMDIR: 15,
      REALPATH: 16,
      STAT: 17,
      RENAME: 18,
      READLINK: 19,
      SYMLINK: 20,
      EXTENDED: 200
    };
    var RESPONSE = {
      VERSION: 2,
      STATUS: 101,
      HANDLE: 102,
      DATA: 103,
      NAME: 104,
      ATTRS: 105,
      EXTENDED: 201
    };
    var OPEN_MODE = {
      READ: 1,
      WRITE: 2,
      APPEND: 4,
      CREAT: 8,
      TRUNC: 16,
      EXCL: 32
    };
    var PKT_RW_OVERHEAD = 2 * 1024;
    var MAX_REQID = 2 ** 32 - 1;
    var CLIENT_VERSION_BUFFER = Buffer.from([
      0,
      0,
      0,
      5,
      REQUEST.INIT,
      0,
      0,
      0,
      3
      /* version */
    ]);
    var SERVER_VERSION_BUFFER = Buffer.from([
      0,
      0,
      0,
      5,
      RESPONSE.VERSION,
      0,
      0,
      0,
      3
      /* version */
    ]);
    var RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;
    var OPENSSH_MAX_PKT_LEN = 256 * 1024;
    var bufferParser = makeBufferParser();
    var fakeStderr = {
      readable: false,
      writable: false,
      push: (data) => {
      },
      once: () => {
      },
      on: () => {
      },
      emit: () => {
      },
      end: () => {
      }
    };
    function noop() {
    }
    var SFTP = class extends EventEmitter {
      constructor(client, chanInfo, cfg) {
        super();
        if (typeof cfg !== "object" || !cfg)
          cfg = {};
        const remoteIdentRaw = client._protocol._remoteIdentRaw;
        this.server = !!cfg.server;
        this._debug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        this._isOpenSSH = remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw);
        this._version = -1;
        this._extensions = {};
        this._biOpt = cfg.biOpt;
        this._pktLenBytes = 0;
        this._pktLen = 0;
        this._pktPos = 0;
        this._pktType = 0;
        this._pktData = void 0;
        this._writeReqid = -1;
        this._requests = {};
        this._maxInPktLen = OPENSSH_MAX_PKT_LEN;
        this._maxOutPktLen = 34e3;
        this._maxReadLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD;
        this._maxWriteLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD;
        this.maxOpenHandles = void 0;
        this._client = client;
        this._protocol = client._protocol;
        this._callbacks = [];
        this._hasX11 = false;
        this._exit = {
          code: void 0,
          signal: void 0,
          dump: void 0,
          desc: void 0
        };
        this._waitWindow = false;
        this._chunkcb = void 0;
        this._buffer = [];
        this.type = chanInfo.type;
        this.subtype = void 0;
        this.incoming = chanInfo.incoming;
        this.outgoing = chanInfo.outgoing;
        this.stderr = fakeStderr;
        this.readable = true;
      }
      // This handles incoming data to parse
      push(data) {
        if (data === null) {
          cleanupRequests(this);
          if (!this.readable)
            return;
          this.readable = false;
          this.emit("end");
          return;
        }
        let p = 0;
        while (p < data.length) {
          if (this._pktLenBytes < 4) {
            let nb = Math.min(4 - this._pktLenBytes, data.length - p);
            this._pktLenBytes += nb;
            while (nb--)
              this._pktLen = (this._pktLen << 8) + data[p++];
            if (this._pktLenBytes < 4)
              return;
            if (this._pktLen === 0)
              return doFatalSFTPError(this, "Invalid packet length");
            if (this._pktLen > this._maxInPktLen) {
              const max = this._maxInPktLen;
              return doFatalSFTPError(
                this,
                `Packet length ${this._pktLen} exceeds max length of ${max}`
              );
            }
            if (p >= data.length)
              return;
          }
          if (this._pktPos < this._pktLen) {
            const nb = Math.min(this._pktLen - this._pktPos, data.length - p);
            if (p !== 0 || nb !== data.length) {
              if (nb === this._pktLen) {
                this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);
              } else {
                if (!this._pkt)
                  this._pkt = Buffer.allocUnsafe(this._pktLen);
                this._pkt.set(
                  new Uint8Array(data.buffer, data.byteOffset + p, nb),
                  this._pktPos
                );
              }
            } else if (nb === this._pktLen) {
              this._pkt = data;
            } else {
              if (!this._pkt)
                this._pkt = Buffer.allocUnsafe(this._pktLen);
              this._pkt.set(data, this._pktPos);
            }
            p += nb;
            this._pktPos += nb;
            if (this._pktPos < this._pktLen)
              return;
          }
          const type = this._pkt[0];
          const payload = this._pkt;
          this._pktLen = 0;
          this._pktLenBytes = 0;
          this._pkt = void 0;
          this._pktPos = 0;
          const handler = this.server ? SERVER_HANDLERS[type] : CLIENT_HANDLERS[type];
          if (!handler)
            return doFatalSFTPError(this, `Unknown packet type ${type}`);
          if (this._version === -1) {
            if (this.server) {
              if (type !== REQUEST.INIT)
                return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);
            } else if (type !== RESPONSE.VERSION) {
              return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);
            }
          }
          if (handler(this, payload) === false)
            return;
        }
      }
      end() {
        this.destroy();
      }
      destroy() {
        if (this.outgoing.state === "open" || this.outgoing.state === "eof") {
          this.outgoing.state = "closing";
          this._protocol.channelClose(this.outgoing.id);
        }
      }
      _init() {
        this._init = noop;
        if (!this.server)
          sendOrBuffer(this, CLIENT_VERSION_BUFFER);
      }
      // ===========================================================================
      // Client-specific ===========================================================
      // ===========================================================================
      createReadStream(path, options) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        return new ReadStream(this, path, options);
      }
      createWriteStream(path, options) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        return new WriteStream(this, path, options);
      }
      open(path, flags_, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (typeof attrs === "function") {
          cb = attrs;
          attrs = void 0;
        }
        const flags = typeof flags_ === "number" ? flags_ : stringToFlags(flags_);
        if (flags === null)
          throw new Error(`Unknown flags string: ${flags_}`);
        let attrsFlags = 0;
        let attrsLen = 0;
        if (typeof attrs === "string" || typeof attrs === "number")
          attrs = { mode: attrs };
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          attrsFlags = attrs.flags;
          attrsLen = attrs.nb;
        }
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.OPEN;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        writeUInt32BE(buf, attrsFlags, p += 4);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPEN`
        );
      }
      close(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.CLOSE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} CLOSE`
        );
      }
      read(handle, buf, off, len, position, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        if (!Buffer.isBuffer(buf))
          throw new Error("buffer is not a Buffer");
        if (off >= buf.length)
          throw new Error("offset is out of bounds");
        if (off + len > buf.length)
          throw new Error("length extends beyond buffer");
        if (position === null)
          throw new Error("null position currently unsupported");
        read_(this, handle, buf, off, len, position, cb);
      }
      readData(handle, buf, off, len, position, cb) {
        this.read(handle, buf, off, len, position, cb);
      }
      write(handle, buf, off, len, position, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        if (!Buffer.isBuffer(buf))
          throw new Error("buffer is not a Buffer");
        if (off > buf.length)
          throw new Error("offset is out of bounds");
        if (off + len > buf.length)
          throw new Error("length extends beyond buffer");
        if (position === null)
          throw new Error("null position currently unsupported");
        if (!len) {
          cb && process.nextTick(cb, void 0, 0);
          return;
        }
        const maxDataLen = this._maxWriteLen;
        const overflow = Math.max(len - maxDataLen, 0);
        const origPosition = position;
        if (overflow)
          len = maxDataLen;
        const handleLen = handle.length;
        let p = 9;
        const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);
        writeUInt32BE(out, out.length - 4, 0);
        out[4] = REQUEST.WRITE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(out, reqid, 5);
        writeUInt32BE(out, handleLen, p);
        out.set(handle, p += 4);
        p += handleLen;
        for (let i = 7; i >= 0; --i) {
          out[p + i] = position & 255;
          position /= 256;
        }
        writeUInt32BE(out, len, p += 8);
        bufferCopy(buf, out, off, off + len, p += 4);
        this._requests[reqid] = {
          cb: (err) => {
            if (err) {
              if (typeof cb === "function")
                cb(err);
            } else if (overflow) {
              this.write(
                handle,
                buf,
                off + len,
                overflow,
                origPosition + len,
                cb
              );
            } else if (typeof cb === "function") {
              cb(void 0, off + len);
            }
          }
        };
        const isSent = sendOrBuffer(this, out);
        if (this._debug) {
          const how = isSent ? "Sent" : "Buffered";
          this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);
        }
      }
      writeData(handle, buf, off, len, position, cb) {
        this.write(handle, buf, off, len, position, cb);
      }
      fastGet(remotePath, localPath, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        fastXfer(this, fs, remotePath, localPath, opts, cb);
      }
      fastPut(localPath, remotePath, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        fastXfer(fs, this, localPath, remotePath, opts, cb);
      }
      readFile(path, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string")
          options = { encoding: options, flag: "r" };
        else if (!options)
          options = { encoding: null, flag: "r" };
        else if (typeof options !== "object")
          throw new TypeError("Bad arguments");
        const encoding = options.encoding;
        if (encoding && !Buffer.isEncoding(encoding))
          throw new Error(`Unknown encoding: ${encoding}`);
        let size;
        let buffer;
        let buffers;
        let pos = 0;
        let handle;
        let bytesRead = 0;
        const flag = options.flag || "r";
        const read = () => {
          if (size === 0) {
            buffer = Buffer.allocUnsafe(8192);
            this.read(handle, buffer, 0, 8192, bytesRead, afterRead);
          } else {
            this.read(handle, buffer, pos, size - pos, bytesRead, afterRead);
          }
        };
        const afterRead = (er, nbytes) => {
          let eof;
          if (er) {
            eof = er.code === STATUS_CODE.EOF;
            if (!eof) {
              return this.close(handle, () => {
                return callback && callback(er);
              });
            }
          } else {
            eof = false;
          }
          if (eof || size === 0 && nbytes === 0)
            return close();
          bytesRead += nbytes;
          pos += nbytes;
          if (size !== 0) {
            if (pos === size)
              close();
            else
              read();
          } else {
            buffers.push(bufferSlice(buffer, 0, nbytes));
            read();
          }
        };
        afterRead._wantEOFError = true;
        const close = () => {
          this.close(handle, (er) => {
            if (size === 0) {
              buffer = Buffer.concat(buffers, pos);
            } else if (pos < size) {
              buffer = bufferSlice(buffer, 0, pos);
            }
            if (encoding)
              buffer = buffer.toString(encoding);
            return callback && callback(er, buffer);
          });
        };
        this.open(path, flag, 438, (er, handle_) => {
          if (er)
            return callback && callback(er);
          handle = handle_;
          const tryStat = (er2, st) => {
            if (er2) {
              this.stat(path, (er_, st_) => {
                if (er_) {
                  return this.close(handle, () => {
                    callback && callback(er2);
                  });
                }
                tryStat(null, st_);
              });
              return;
            }
            size = st.size || 0;
            if (size === 0) {
              buffers = [];
              return read();
            }
            buffer = Buffer.allocUnsafe(size);
            read();
          };
          this.fstat(handle, tryStat);
        });
      }
      writeFile(path, data, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string")
          options = { encoding: options, mode: 438, flag: "w" };
        else if (!options)
          options = { encoding: "utf8", mode: 438, flag: "w" };
        else if (typeof options !== "object")
          throw new TypeError("Bad arguments");
        if (options.encoding && !Buffer.isEncoding(options.encoding))
          throw new Error(`Unknown encoding: ${options.encoding}`);
        const flag = options.flag || "w";
        this.open(path, flag, options.mode, (openErr, handle) => {
          if (openErr) {
            callback && callback(openErr);
          } else {
            const buffer = Buffer.isBuffer(data) ? data : Buffer.from("" + data, options.encoding || "utf8");
            const position = /a/.test(flag) ? null : 0;
            if (position === null) {
              const tryStat = (er, st) => {
                if (er) {
                  this.stat(path, (er_, st_) => {
                    if (er_) {
                      return this.close(handle, () => {
                        callback && callback(er);
                      });
                    }
                    tryStat(null, st_);
                  });
                  return;
                }
                writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);
              };
              this.fstat(handle, tryStat);
              return;
            }
            writeAll(this, handle, buffer, 0, buffer.length, position, callback);
          }
        });
      }
      appendFile(path, data, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string")
          options = { encoding: options, mode: 438, flag: "a" };
        else if (!options)
          options = { encoding: "utf8", mode: 438, flag: "a" };
        else if (typeof options !== "object")
          throw new TypeError("Bad arguments");
        if (!options.flag)
          options = Object.assign({ flag: "a" }, options);
        this.writeFile(path, data, options, callback);
      }
      exists(path, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        this.stat(path, (err) => {
          cb && cb(err ? false : true);
        });
      }
      unlink(filename, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const fnameLen = Buffer.byteLength(filename);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.REMOVE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, fnameLen, p);
        buf.utf8Write(filename, p += 4, fnameLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REMOVE`
        );
      }
      rename(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.RENAME;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, oldLen, p);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RENAME`
        );
      }
      mkdir(path, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "function") {
          cb = attrs;
          attrs = void 0;
        }
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        }
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.MKDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} MKDIR`
        );
      }
      rmdir(path, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.RMDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RMDIR`
        );
      }
      readdir(where, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        if (typeof opts !== "object" || opts === null)
          opts = {};
        const doFilter = opts && opts.full ? false : true;
        if (!Buffer.isBuffer(where) && typeof where !== "string")
          throw new Error("missing directory handle or path");
        if (typeof where === "string") {
          const entries = [];
          let e = 0;
          const reread = (err, handle) => {
            if (err)
              return cb(err);
            this.readdir(handle, opts, (err2, list) => {
              const eof = err2 && err2.code === STATUS_CODE.EOF;
              if (err2 && !eof)
                return this.close(handle, () => cb(err2));
              if (eof) {
                return this.close(handle, (err3) => {
                  if (err3)
                    return cb(err3);
                  cb(void 0, entries);
                });
              }
              for (let i = 0; i < list.length; ++i, ++e)
                entries[e] = list[i];
              reread(void 0, handle);
            });
          };
          return this.opendir(where, reread);
        }
        const handleLen = where.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.READDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(where, p += 4);
        this._requests[reqid] = {
          cb: doFilter ? (err, list) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            for (let i = list.length - 1; i >= 0; --i) {
              if (list[i].filename === "." || list[i].filename === "..")
                list.splice(i, 1);
            }
            cb(void 0, list);
          } : cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READDIR`
        );
      }
      fstat(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.FSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSTAT`
        );
      }
      stat(path, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.STAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STAT`
        );
      }
      lstat(path, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.LSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} LSTAT`
        );
      }
      opendir(path, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.OPENDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPENDIR`
        );
      }
      setstat(path, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.SETSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SETSTAT`
        );
      }
      fsetstat(handle, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.FSETSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        writeUInt32BE(buf, flags, p += handleLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSETSTAT`
        );
      }
      futimes(handle, atime, mtime, cb) {
        return this.fsetstat(handle, {
          atime: toUnixTimestamp(atime),
          mtime: toUnixTimestamp(mtime)
        }, cb);
      }
      utimes(path, atime, mtime, cb) {
        return this.setstat(path, {
          atime: toUnixTimestamp(atime),
          mtime: toUnixTimestamp(mtime)
        }, cb);
      }
      fchown(handle, uid, gid, cb) {
        return this.fsetstat(handle, {
          uid,
          gid
        }, cb);
      }
      chown(path, uid, gid, cb) {
        return this.setstat(path, {
          uid,
          gid
        }, cb);
      }
      fchmod(handle, mode, cb) {
        return this.fsetstat(handle, {
          mode
        }, cb);
      }
      chmod(path, mode, cb) {
        return this.setstat(path, {
          mode
        }, cb);
      }
      readlink(path, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.READLINK;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing link info"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READLINK`
        );
      }
      symlink(targetPath, linkPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const linkLen = Buffer.byteLength(linkPath);
        const targetLen = Buffer.byteLength(targetPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.SYMLINK;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        if (this._isOpenSSH) {
          writeUInt32BE(buf, targetLen, p);
          buf.utf8Write(targetPath, p += 4, targetLen);
          writeUInt32BE(buf, linkLen, p += targetLen);
          buf.utf8Write(linkPath, p += 4, linkLen);
        } else {
          writeUInt32BE(buf, linkLen, p);
          buf.utf8Write(linkPath, p += 4, linkLen);
          writeUInt32BE(buf, targetLen, p += linkLen);
          buf.utf8Write(targetPath, p += 4, targetLen);
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SYMLINK`
        );
      }
      realpath(path, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.REALPATH;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing path info"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REALPATH`
        );
      }
      // extended requests
      ext_openssh_rename(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["posix-rename@openssh.com"];
        if (!ext || ext !== "1")
          throw new Error("Server does not support this extended request");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 24, p);
        buf.utf8Write("posix-rename@openssh.com", p += 4, 24);
        writeUInt32BE(buf, oldLen, p += 24);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);
        }
      }
      ext_openssh_statvfs(path, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["statvfs@openssh.com"];
        if (!ext || ext !== "2")
          throw new Error("Server does not support this extended request");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 19, p);
        buf.utf8Write("statvfs@openssh.com", p += 4, 19);
        writeUInt32BE(buf, pathLen, p += 19);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = { extended: "statvfs@openssh.com", cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);
        }
      }
      ext_openssh_fstatvfs(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["fstatvfs@openssh.com"];
        if (!ext || ext !== "2")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("fstatvfs@openssh.com", p += 4, 20);
        writeUInt32BE(buf, handleLen, p += 20);
        buf.set(handle, p += 4);
        this._requests[reqid] = { extended: "fstatvfs@openssh.com", cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);
        }
      }
      ext_openssh_hardlink(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["hardlink@openssh.com"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("hardlink@openssh.com", p += 4, 20);
        writeUInt32BE(buf, oldLen, p += 20);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);
        }
      }
      ext_openssh_fsync(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["fsync@openssh.com"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 17, p);
        buf.utf8Write("fsync@openssh.com", p += 4, 17);
        writeUInt32BE(buf, handleLen, p += 17);
        buf.set(handle, p += 4);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} fsync@openssh.com`
        );
      }
      ext_openssh_lsetstat(path, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["lsetstat@openssh.com"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("lsetstat@openssh.com", p += 4, 20);
        writeUInt32BE(buf, pathLen, p += 20);
        buf.utf8Write(path, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} lsetstat@openssh.com`);
        }
      }
      ext_openssh_expandPath(path, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["expand-path@openssh.com"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 23, p);
        buf.utf8Write("expand-path@openssh.com", p += 4, 23);
        writeUInt32BE(buf, pathLen, p += 20);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing expanded path"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} expand-path@openssh.com`);
        }
      }
      ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["copy-data"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(srcHandle))
          throw new Error("Source handle is not a Buffer");
        if (!Buffer.isBuffer(dstHandle))
          throw new Error("Destination handle is not a Buffer");
        let p = 0;
        const buf = Buffer.allocUnsafe(
          4 + 1 + 4 + 4 + 9 + 4 + srcHandle.length + 8 + 8 + 4 + dstHandle.length + 8
        );
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 9, p);
        p += 4;
        buf.utf8Write("copy-data", p, 9);
        p += 9;
        writeUInt32BE(buf, srcHandle.length, p);
        p += 4;
        buf.set(srcHandle, p);
        p += srcHandle.length;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = srcOffset & 255;
          srcOffset /= 256;
        }
        p += 8;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = len & 255;
          len /= 256;
        }
        p += 8;
        writeUInt32BE(buf, dstHandle.length, p);
        p += 4;
        buf.set(dstHandle, p);
        p += dstHandle.length;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = dstOffset & 255;
          dstOffset /= 256;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} copy-data`);
        }
      }
      ext_home_dir(username, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["home-directory"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        if (typeof username !== "string")
          throw new TypeError("username is not a string");
        let p = 0;
        const usernameLen = Buffer.byteLength(username);
        const buf = Buffer.allocUnsafe(
          4 + 1 + 4 + 4 + 14 + 4 + usernameLen
        );
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 14, p);
        p += 4;
        buf.utf8Write("home-directory", p, 14);
        p += 14;
        writeUInt32BE(buf, usernameLen, p);
        p += 4;
        buf.utf8Write(username, p, usernameLen);
        p += usernameLen;
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing home directory"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} home-directory`);
        }
      }
      ext_users_groups(uids, gids, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["users-groups-by-id@openssh.com"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        if (!Array.isArray(uids))
          throw new TypeError("uids is not an array");
        for (const val of uids) {
          if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1)
            throw new Error("uid values must all be 32-bit unsigned integers");
        }
        if (!Array.isArray(gids))
          throw new TypeError("gids is not an array");
        for (const val of gids) {
          if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1)
            throw new Error("gid values must all be 32-bit unsigned integers");
        }
        let p = 0;
        const buf = Buffer.allocUnsafe(
          4 + 1 + 4 + 4 + 30 + 4 + 4 * uids.length + 4 + 4 * gids.length
        );
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 30, p);
        p += 4;
        buf.utf8Write("users-groups-by-id@openssh.com", p, 30);
        p += 30;
        writeUInt32BE(buf, 4 * uids.length, p);
        p += 4;
        for (const val of uids) {
          writeUInt32BE(buf, val, p);
          p += 4;
        }
        writeUInt32BE(buf, 4 * gids.length, p);
        p += 4;
        for (const val of gids) {
          writeUInt32BE(buf, val, p);
          p += 4;
        }
        this._requests[reqid] = { extended: "users-groups-by-id@openssh.com", cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} users-groups-by-id@openssh.com`);
        }
      }
      // ===========================================================================
      // Server-specific ===========================================================
      // ===========================================================================
      handle(reqid, handle) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        if (handleLen > 256)
          throw new Error("handle too large (> 256 bytes)");
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.HANDLE;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        if (handleLen)
          buf.set(handle, p += 4);
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} HANDLE`
        );
      }
      status(reqid, code, message) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!VALID_STATUS_CODES.has(code))
          throw new Error(`Bad status code: ${code}`);
        message || (message = "");
        const msgLen = Buffer.byteLength(message);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.STATUS;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, code, p);
        writeUInt32BE(buf, msgLen, p += 4);
        p += 4;
        if (msgLen) {
          buf.utf8Write(message, p, msgLen);
          p += msgLen;
        }
        writeUInt32BE(buf, 0, p);
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STATUS`
        );
      }
      data(reqid, data, encoding) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        const isBuffer = Buffer.isBuffer(data);
        if (!isBuffer && typeof data !== "string")
          throw new Error("data is not a Buffer or string");
        let isUTF8;
        if (!isBuffer && !encoding) {
          encoding = void 0;
          isUTF8 = true;
        }
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data, encoding);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.DATA;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, dataLen, p);
        if (dataLen) {
          if (isBuffer)
            buf.set(data, p += 4);
          else if (isUTF8)
            buf.utf8Write(data, p += 4, dataLen);
          else
            buf.write(data, p += 4, dataLen, encoding);
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} DATA`
        );
      }
      name(reqid, names) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!Array.isArray(names)) {
          if (typeof names !== "object" || names === null)
            throw new Error("names is not an object or array");
          names = [names];
        }
        const count = names.length;
        let namesLen = 0;
        let nameAttrs;
        const attrs = [];
        for (let i = 0; i < count; ++i) {
          const name = names[i];
          const filename = !name || !name.filename || typeof name.filename !== "string" ? "" : name.filename;
          namesLen += 4 + Buffer.byteLength(filename);
          const longname = !name || !name.longname || typeof name.longname !== "string" ? "" : name.longname;
          namesLen += 4 + Buffer.byteLength(longname);
          if (typeof name.attrs === "object" && name.attrs !== null) {
            nameAttrs = attrsToBytes(name.attrs);
            namesLen += 4 + nameAttrs.nb;
            if (nameAttrs.nb) {
              let bytes;
              if (nameAttrs.nb === ATTRS_BUF.length) {
                bytes = new Uint8Array(ATTRS_BUF);
              } else {
                bytes = new Uint8Array(nameAttrs.nb);
                bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);
              }
              nameAttrs.bytes = bytes;
            }
            attrs.push(nameAttrs);
          } else {
            namesLen += 4;
            attrs.push(null);
          }
        }
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.NAME;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, count, p);
        p += 4;
        for (let i = 0; i < count; ++i) {
          const name = names[i];
          {
            const filename = !name || !name.filename || typeof name.filename !== "string" ? "" : name.filename;
            const len = Buffer.byteLength(filename);
            writeUInt32BE(buf, len, p);
            p += 4;
            if (len) {
              buf.utf8Write(filename, p, len);
              p += len;
            }
          }
          {
            const longname = !name || !name.longname || typeof name.longname !== "string" ? "" : name.longname;
            const len = Buffer.byteLength(longname);
            writeUInt32BE(buf, len, p);
            p += 4;
            if (len) {
              buf.utf8Write(longname, p, len);
              p += len;
            }
          }
          const attr = attrs[i];
          if (attr) {
            writeUInt32BE(buf, attr.flags, p);
            p += 4;
            if (attr.flags && attr.bytes) {
              buf.set(attr.bytes, p);
              p += attr.nb;
            }
          } else {
            writeUInt32BE(buf, 0, p);
            p += 4;
          }
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} NAME`
        );
      }
      attrs(reqid, attrs) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (typeof attrs !== "object" || attrs === null)
          throw new Error("attrs is not an object");
        attrs = attrsToBytes(attrs);
        const flags = attrs.flags;
        const attrsLen = attrs.nb;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.ATTRS;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, flags, p);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} ATTRS`
        );
      }
    };
    function tryCreateBuffer(size) {
      try {
        return Buffer.allocUnsafe(size);
      } catch (ex) {
        return ex;
      }
    }
    function read_(self2, handle, buf, off, len, position, cb, req_) {
      const maxDataLen = self2._maxReadLen;
      const overflow = Math.max(len - maxDataLen, 0);
      if (overflow)
        len = maxDataLen;
      const handleLen = handle.length;
      let p = 9;
      let pos = position;
      const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);
      writeUInt32BE(out, out.length - 4, 0);
      out[4] = REQUEST.READ;
      const reqid = self2._writeReqid = self2._writeReqid + 1 & MAX_REQID;
      writeUInt32BE(out, reqid, 5);
      writeUInt32BE(out, handleLen, p);
      out.set(handle, p += 4);
      p += handleLen;
      for (let i = 7; i >= 0; --i) {
        out[p + i] = pos & 255;
        pos /= 256;
      }
      writeUInt32BE(out, len, p += 8);
      if (typeof cb !== "function")
        cb = noop;
      const req = req_ || {
        nb: 0,
        position,
        off,
        origOff: off,
        len: void 0,
        overflow: void 0,
        cb: (err, data, nb) => {
          const len2 = req.len;
          const overflow2 = req.overflow;
          if (err) {
            if (cb._wantEOFError || err.code !== STATUS_CODE.EOF)
              return cb(err);
          } else if (nb > len2) {
            return cb(new Error("Received more data than requested"));
          } else if (nb === len2 && overflow2) {
            req.nb += nb;
            req.position += nb;
            req.off += nb;
            read_(self2, handle, buf, req.off, overflow2, req.position, cb, req);
            return;
          }
          nb = nb || 0;
          if (req.origOff === 0 && buf.length === req.nb)
            data = buf;
          else
            data = bufferSlice(buf, req.origOff, req.origOff + req.nb + nb);
          cb(void 0, req.nb + nb, data, req.position);
        },
        buffer: void 0
      };
      req.len = len;
      req.overflow = overflow;
      req.buffer = bufferSlice(buf, off, off + len);
      self2._requests[reqid] = req;
      const isBuffered = sendOrBuffer(self2, out);
      self2._debug && self2._debug(
        `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READ`
      );
    }
    function fastXfer(src, dst, srcPath, dstPath, opts, cb) {
      let concurrency = 64;
      let chunkSize = 32768;
      let onstep;
      let mode;
      let fileSize;
      if (typeof opts === "function") {
        cb = opts;
      } else if (typeof opts === "object" && opts !== null) {
        if (typeof opts.concurrency === "number" && opts.concurrency > 0 && !isNaN(opts.concurrency)) {
          concurrency = opts.concurrency;
        }
        if (typeof opts.chunkSize === "number" && opts.chunkSize > 0 && !isNaN(opts.chunkSize)) {
          chunkSize = opts.chunkSize;
        }
        if (typeof opts.fileSize === "number" && opts.fileSize > 0 && !isNaN(opts.fileSize)) {
          fileSize = opts.fileSize;
        }
        if (typeof opts.step === "function")
          onstep = opts.step;
        if (typeof opts.mode === "string" || typeof opts.mode === "number")
          mode = modeNum(opts.mode);
      }
      let fsize;
      let pdst = 0;
      let total = 0;
      let hadError = false;
      let srcHandle;
      let dstHandle;
      let readbuf;
      let bufsize = chunkSize * concurrency;
      function onerror(err) {
        if (hadError)
          return;
        hadError = true;
        let left = 0;
        let cbfinal;
        if (srcHandle || dstHandle) {
          cbfinal = () => {
            if (--left === 0)
              cb(err);
          };
          if (srcHandle && (src === fs || src.outgoing.state === "open"))
            ++left;
          if (dstHandle && (dst === fs || dst.outgoing.state === "open"))
            ++left;
          if (srcHandle && (src === fs || src.outgoing.state === "open"))
            src.close(srcHandle, cbfinal);
          if (dstHandle && (dst === fs || dst.outgoing.state === "open"))
            dst.close(dstHandle, cbfinal);
        } else {
          cb(err);
        }
      }
      src.open(srcPath, "r", (err, sourceHandle) => {
        if (err)
          return onerror(err);
        srcHandle = sourceHandle;
        if (fileSize === void 0)
          src.fstat(srcHandle, tryStat);
        else
          tryStat(null, { size: fileSize });
        function tryStat(err2, attrs) {
          if (err2) {
            if (src !== fs) {
              src.stat(srcPath, (err_, attrs_) => {
                if (err_)
                  return onerror(err2);
                tryStat(null, attrs_);
              });
              return;
            }
            return onerror(err2);
          }
          fsize = attrs.size;
          dst.open(dstPath, "w", (err3, destHandle) => {
            if (err3)
              return onerror(err3);
            dstHandle = destHandle;
            if (fsize <= 0)
              return onerror();
            while (bufsize > fsize) {
              if (concurrency === 1) {
                bufsize = fsize;
                break;
              }
              bufsize -= chunkSize;
              --concurrency;
            }
            readbuf = tryCreateBuffer(bufsize);
            if (readbuf instanceof Error)
              return onerror(readbuf);
            if (mode !== void 0) {
              dst.fchmod(dstHandle, mode, function tryAgain(err4) {
                if (err4) {
                  dst.chmod(dstPath, mode, (err_) => tryAgain());
                  return;
                }
                startReads();
              });
            } else {
              startReads();
            }
            function onread(err4, nb, data, dstpos, datapos, origChunkLen) {
              if (err4)
                return onerror(err4);
              datapos = datapos || 0;
              dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);
              function writeCb(err5) {
                if (err5)
                  return onerror(err5);
                total += nb;
                onstep && onstep(total, nb, fsize);
                if (nb < origChunkLen)
                  return singleRead(datapos, dstpos + nb, origChunkLen - nb);
                if (total === fsize) {
                  dst.close(dstHandle, (err6) => {
                    dstHandle = void 0;
                    if (err6)
                      return onerror(err6);
                    src.close(srcHandle, (err7) => {
                      srcHandle = void 0;
                      if (err7)
                        return onerror(err7);
                      cb();
                    });
                  });
                  return;
                }
                if (pdst >= fsize)
                  return;
                const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
                singleRead(datapos, pdst, chunk);
                pdst += chunk;
              }
            }
            function makeCb(psrc, pdst2, chunk) {
              return (err4, nb, data) => {
                onread(err4, nb, data, pdst2, psrc, chunk);
              };
            }
            function singleRead(psrc, pdst2, chunk) {
              src.read(
                srcHandle,
                readbuf,
                psrc,
                chunk,
                pdst2,
                makeCb(psrc, pdst2, chunk)
              );
            }
            function startReads() {
              let reads = 0;
              let psrc = 0;
              while (pdst < fsize && reads < concurrency) {
                const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
                singleRead(psrc, pdst, chunk);
                psrc += chunk;
                pdst += chunk;
                ++reads;
              }
            }
          });
        }
      });
    }
    function writeAll(sftp, handle, buffer, offset, length, position, callback_) {
      const callback = typeof callback_ === "function" ? callback_ : void 0;
      sftp.write(
        handle,
        buffer,
        offset,
        length,
        position,
        (writeErr, written) => {
          if (writeErr) {
            return sftp.close(handle, () => {
              callback && callback(writeErr);
            });
          }
          if (written === length) {
            sftp.close(handle, callback);
          } else {
            offset += written;
            length -= written;
            position += written;
            writeAll(sftp, handle, buffer, offset, length, position, callback);
          }
        }
      );
    }
    var Stats = class {
      constructor(initial) {
        this.mode = initial && initial.mode;
        this.uid = initial && initial.uid;
        this.gid = initial && initial.gid;
        this.size = initial && initial.size;
        this.atime = initial && initial.atime;
        this.mtime = initial && initial.mtime;
        this.extended = initial && initial.extended;
      }
      isDirectory() {
        return (this.mode & constants.S_IFMT) === constants.S_IFDIR;
      }
      isFile() {
        return (this.mode & constants.S_IFMT) === constants.S_IFREG;
      }
      isBlockDevice() {
        return (this.mode & constants.S_IFMT) === constants.S_IFBLK;
      }
      isCharacterDevice() {
        return (this.mode & constants.S_IFMT) === constants.S_IFCHR;
      }
      isSymbolicLink() {
        return (this.mode & constants.S_IFMT) === constants.S_IFLNK;
      }
      isFIFO() {
        return (this.mode & constants.S_IFMT) === constants.S_IFIFO;
      }
      isSocket() {
        return (this.mode & constants.S_IFMT) === constants.S_IFSOCK;
      }
    };
    function attrsToBytes(attrs) {
      let flags = 0;
      let nb = 0;
      if (typeof attrs === "object" && attrs !== null) {
        if (typeof attrs.size === "number") {
          flags |= ATTR.SIZE;
          const val = attrs.size;
          ATTRS_BUF[nb++] = val / 72057594037927940;
          ATTRS_BUF[nb++] = val / 281474976710656;
          ATTRS_BUF[nb++] = val / 1099511627776;
          ATTRS_BUF[nb++] = val / 4294967296;
          ATTRS_BUF[nb++] = val / 16777216;
          ATTRS_BUF[nb++] = val / 65536;
          ATTRS_BUF[nb++] = val / 256;
          ATTRS_BUF[nb++] = val;
        }
        if (typeof attrs.uid === "number" && typeof attrs.gid === "number") {
          flags |= ATTR.UIDGID;
          const uid = attrs.uid;
          const gid = attrs.gid;
          ATTRS_BUF[nb++] = uid >>> 24;
          ATTRS_BUF[nb++] = uid >>> 16;
          ATTRS_BUF[nb++] = uid >>> 8;
          ATTRS_BUF[nb++] = uid;
          ATTRS_BUF[nb++] = gid >>> 24;
          ATTRS_BUF[nb++] = gid >>> 16;
          ATTRS_BUF[nb++] = gid >>> 8;
          ATTRS_BUF[nb++] = gid;
        }
        if (typeof attrs.mode === "number" || typeof attrs.mode === "string") {
          const mode = modeNum(attrs.mode);
          flags |= ATTR.PERMISSIONS;
          ATTRS_BUF[nb++] = mode >>> 24;
          ATTRS_BUF[nb++] = mode >>> 16;
          ATTRS_BUF[nb++] = mode >>> 8;
          ATTRS_BUF[nb++] = mode;
        }
        if ((typeof attrs.atime === "number" || isDate(attrs.atime)) && (typeof attrs.mtime === "number" || isDate(attrs.mtime))) {
          const atime = toUnixTimestamp(attrs.atime);
          const mtime = toUnixTimestamp(attrs.mtime);
          flags |= ATTR.ACMODTIME;
          ATTRS_BUF[nb++] = atime >>> 24;
          ATTRS_BUF[nb++] = atime >>> 16;
          ATTRS_BUF[nb++] = atime >>> 8;
          ATTRS_BUF[nb++] = atime;
          ATTRS_BUF[nb++] = mtime >>> 24;
          ATTRS_BUF[nb++] = mtime >>> 16;
          ATTRS_BUF[nb++] = mtime >>> 8;
          ATTRS_BUF[nb++] = mtime;
        }
      }
      return { flags, nb };
    }
    function toUnixTimestamp(time) {
      if (typeof time === "number" && time === time)
        return time;
      if (isDate(time))
        return parseInt(time.getTime() / 1e3, 10);
      throw new Error(`Cannot parse time: ${time}`);
    }
    function modeNum(mode) {
      if (typeof mode === "number" && mode === mode)
        return mode;
      if (typeof mode === "string")
        return modeNum(parseInt(mode, 8));
      throw new Error(`Cannot parse mode: ${mode}`);
    }
    var stringFlagMap = {
      "r": OPEN_MODE.READ,
      "r+": OPEN_MODE.READ | OPEN_MODE.WRITE,
      "w": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,
      "wx": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xw": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "w+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,
      "wx+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xw+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "a": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,
      "ax": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xa": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "a+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,
      "ax+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xa+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL
    };
    function stringToFlags(str) {
      const flags = stringFlagMap[str];
      return flags !== void 0 ? flags : null;
    }
    var flagsToString = (() => {
      const stringFlagMapKeys = Object.keys(stringFlagMap);
      return (flags) => {
        for (let i = 0; i < stringFlagMapKeys.length; ++i) {
          const key = stringFlagMapKeys[i];
          if (stringFlagMap[key] === flags)
            return key;
        }
        return null;
      };
    })();
    function readAttrs(biOpt) {
      const flags = bufferParser.readUInt32BE();
      if (flags === void 0)
        return;
      const attrs = new Stats();
      if (flags & ATTR.SIZE) {
        const size = bufferParser.readUInt64BE(biOpt);
        if (size === void 0)
          return;
        attrs.size = size;
      }
      if (flags & ATTR.UIDGID) {
        const uid = bufferParser.readUInt32BE();
        const gid = bufferParser.readUInt32BE();
        if (gid === void 0)
          return;
        attrs.uid = uid;
        attrs.gid = gid;
      }
      if (flags & ATTR.PERMISSIONS) {
        const mode = bufferParser.readUInt32BE();
        if (mode === void 0)
          return;
        attrs.mode = mode;
      }
      if (flags & ATTR.ACMODTIME) {
        const atime = bufferParser.readUInt32BE();
        const mtime = bufferParser.readUInt32BE();
        if (mtime === void 0)
          return;
        attrs.atime = atime;
        attrs.mtime = mtime;
      }
      if (flags & ATTR.EXTENDED) {
        const count = bufferParser.readUInt32BE();
        if (count === void 0)
          return;
        const extended = {};
        for (let i = 0; i < count; ++i) {
          const type = bufferParser.readString(true);
          const data = bufferParser.readString();
          if (data === void 0)
            return;
          extended[type] = data;
        }
        attrs.extended = extended;
      }
      return attrs;
    }
    function sendOrBuffer(sftp, payload) {
      const ret = tryWritePayload(sftp, payload);
      if (ret !== void 0) {
        sftp._buffer.push(ret);
        return false;
      }
      return true;
    }
    function tryWritePayload(sftp, payload) {
      const outgoing = sftp.outgoing;
      if (outgoing.state !== "open")
        return;
      if (outgoing.window === 0) {
        sftp._waitWindow = true;
        sftp._chunkcb = drainBuffer;
        return payload;
      }
      let ret;
      const len = payload.length;
      let p = 0;
      while (len - p > 0 && outgoing.window > 0) {
        const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);
        outgoing.window -= actualLen;
        if (outgoing.window === 0) {
          sftp._waitWindow = true;
          sftp._chunkcb = drainBuffer;
        }
        if (p === 0 && actualLen === len) {
          sftp._protocol.channelData(sftp.outgoing.id, payload);
        } else {
          sftp._protocol.channelData(
            sftp.outgoing.id,
            bufferSlice(payload, p, p + actualLen)
          );
        }
        p += actualLen;
      }
      if (len - p > 0) {
        if (p > 0)
          ret = bufferSlice(payload, p, len);
        else
          ret = payload;
      }
      return ret;
    }
    function drainBuffer() {
      this._chunkcb = void 0;
      const buffer = this._buffer;
      let i = 0;
      while (i < buffer.length) {
        const payload = buffer[i];
        const ret = tryWritePayload(this, payload);
        if (ret !== void 0) {
          if (ret !== payload)
            buffer[i] = ret;
          if (i > 0)
            this._buffer = buffer.slice(i);
          return;
        }
        ++i;
      }
      if (i > 0)
        this._buffer = [];
    }
    function doFatalSFTPError(sftp, msg, noDebug) {
      const err = new Error(msg);
      err.level = "sftp-protocol";
      if (!noDebug && sftp._debug)
        sftp._debug(`SFTP: Inbound: ${msg}`);
      sftp.emit("error", err);
      sftp.destroy();
      cleanupRequests(sftp);
      return false;
    }
    function cleanupRequests(sftp) {
      const keys = Object.keys(sftp._requests);
      if (keys.length === 0)
        return;
      const reqs = sftp._requests;
      sftp._requests = {};
      const err = new Error("No response from server");
      for (let i = 0; i < keys.length; ++i) {
        const req = reqs[keys[i]];
        if (typeof req.cb === "function")
          req.cb(err);
      }
    }
    function requestLimits(sftp, cb) {
      let p = 9;
      const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);
      writeUInt32BE(buf, buf.length - 4, 0);
      buf[4] = REQUEST.EXTENDED;
      const reqid = sftp._writeReqid = sftp._writeReqid + 1 & MAX_REQID;
      writeUInt32BE(buf, reqid, 5);
      writeUInt32BE(buf, 18, p);
      buf.utf8Write("limits@openssh.com", p += 4, 18);
      sftp._requests[reqid] = { extended: "limits@openssh.com", cb };
      const isBuffered = sendOrBuffer(sftp, buf);
      if (sftp._debug) {
        const which = isBuffered ? "Buffered" : "Sending";
        sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);
      }
    }
    var CLIENT_HANDLERS = {
      [RESPONSE.VERSION]: (sftp, payload) => {
        if (sftp._version !== -1)
          return doFatalSFTPError(sftp, "Duplicate VERSION packet");
        const extensions = {};
        bufferParser.init(payload, 1);
        let version = bufferParser.readUInt32BE();
        while (bufferParser.avail()) {
          const extName = bufferParser.readString(true);
          const extData = bufferParser.readString(true);
          if (extData === void 0) {
            version = void 0;
            break;
          }
          extensions[extName] = extData;
        }
        bufferParser.clear();
        if (version === void 0)
          return doFatalSFTPError(sftp, "Malformed VERSION packet");
        if (sftp._debug) {
          const names = Object.keys(extensions);
          if (names.length) {
            sftp._debug(
              `SFTP: Inbound: Received VERSION (v${version}, exts:${names})`
            );
          } else {
            sftp._debug(`SFTP: Inbound: Received VERSION (v${version})`);
          }
        }
        sftp._version = version;
        sftp._extensions = extensions;
        if (extensions["limits@openssh.com"] === "1") {
          return requestLimits(sftp, (err, limits) => {
            if (!err) {
              if (limits.maxPktLen > 0)
                sftp._maxOutPktLen = limits.maxPktLen;
              if (limits.maxReadLen > 0)
                sftp._maxReadLen = limits.maxReadLen;
              if (limits.maxWriteLen > 0)
                sftp._maxWriteLen = limits.maxWriteLen;
              sftp.maxOpenHandles = limits.maxOpenHandles > 0 ? limits.maxOpenHandles : Infinity;
            }
            sftp.emit("ready");
          });
        }
        sftp.emit("ready");
      },
      [RESPONSE.STATUS]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const errorCode = bufferParser.readUInt32BE();
        const errorMsg = bufferParser.readString(true);
        bufferParser.clear();
        if (sftp._debug) {
          const jsonMsg = JSON.stringify(errorMsg);
          sftp._debug(
            `SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`
          );
        }
        const req = sftp._requests[reqID];
        delete sftp._requests[reqID];
        if (req && typeof req.cb === "function") {
          if (errorCode === STATUS_CODE.OK) {
            req.cb();
            return;
          }
          const err = new Error(errorMsg || STATUS_CODE_STR[errorCode] || "Unknown status");
          err.code = errorCode;
          req.cb(err);
        }
      },
      [RESPONSE.HANDLE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0) {
          if (reqID !== void 0)
            delete sftp._requests[reqID];
          return doFatalSFTPError(sftp, "Malformed HANDLE packet");
        }
        sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);
        const req = sftp._requests[reqID];
        delete sftp._requests[reqID];
        if (req && typeof req.cb === "function")
          req.cb(void 0, handle);
      },
      [RESPONSE.DATA]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        if (req && typeof req.cb === "function") {
          if (req.buffer) {
            const nb = bufferParser.readString(req.buffer);
            bufferParser.clear();
            if (nb !== void 0) {
              sftp._debug && sftp._debug(
                `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`
              );
              req.cb(void 0, req.buffer, nb);
              return;
            }
          } else {
            const data = bufferParser.readString();
            bufferParser.clear();
            if (data !== void 0) {
              sftp._debug && sftp._debug(
                `SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`
              );
              req.cb(void 0, data);
              return;
            }
          }
        } else {
          const nb = bufferParser.skipString();
          bufferParser.clear();
          if (nb !== void 0) {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`
            );
            return;
          }
        }
        return doFatalSFTPError(sftp, "Malformed DATA packet");
      },
      [RESPONSE.NAME]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        const count = bufferParser.readUInt32BE();
        if (count !== void 0) {
          let names = [];
          for (let i = 0; i < count; ++i) {
            const filename = bufferParser.readString(true);
            const longname = bufferParser.readString(true);
            const attrs = readAttrs(sftp._biOpt);
            if (attrs === void 0) {
              names = void 0;
              break;
            }
            names.push({ filename, longname, attrs });
          }
          if (names !== void 0) {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`
            );
            bufferParser.clear();
            if (req && typeof req.cb === "function")
              req.cb(void 0, names);
            return;
          }
        }
        bufferParser.clear();
        return doFatalSFTPError(sftp, "Malformed NAME packet");
      },
      [RESPONSE.ATTRS]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs !== void 0) {
          sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);
          if (req && typeof req.cb === "function")
            req.cb(void 0, attrs);
          return;
        }
        return doFatalSFTPError(sftp, "Malformed ATTRS packet");
      },
      [RESPONSE.EXTENDED]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        if (reqID !== void 0) {
          const req = sftp._requests[reqID];
          if (req) {
            delete sftp._requests[reqID];
            switch (req.extended) {
              case "statvfs@openssh.com":
              case "fstatvfs@openssh.com": {
                const biOpt = sftp._biOpt;
                const stats = {
                  f_bsize: bufferParser.readUInt64BE(biOpt),
                  f_frsize: bufferParser.readUInt64BE(biOpt),
                  f_blocks: bufferParser.readUInt64BE(biOpt),
                  f_bfree: bufferParser.readUInt64BE(biOpt),
                  f_bavail: bufferParser.readUInt64BE(biOpt),
                  f_files: bufferParser.readUInt64BE(biOpt),
                  f_ffree: bufferParser.readUInt64BE(biOpt),
                  f_favail: bufferParser.readUInt64BE(biOpt),
                  f_sid: bufferParser.readUInt64BE(biOpt),
                  f_flag: bufferParser.readUInt64BE(biOpt),
                  f_namemax: bufferParser.readUInt64BE(biOpt)
                };
                if (stats.f_namemax === void 0)
                  break;
                if (sftp._debug) {
                  sftp._debug(
                    `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                  );
                }
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb(void 0, stats);
                return;
              }
              case "limits@openssh.com": {
                const limits = {
                  maxPktLen: bufferParser.readUInt64BE(),
                  maxReadLen: bufferParser.readUInt64BE(),
                  maxWriteLen: bufferParser.readUInt64BE(),
                  maxOpenHandles: bufferParser.readUInt64BE()
                };
                if (limits.maxOpenHandles === void 0)
                  break;
                if (sftp._debug) {
                  sftp._debug(
                    `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                  );
                }
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb(void 0, limits);
                return;
              }
              case "users-groups-by-id@openssh.com": {
                const usernameCount = bufferParser.readUInt32BE();
                if (usernameCount === void 0)
                  break;
                const usernames = new Array(usernameCount);
                for (let i = 0; i < usernames.length; ++i)
                  usernames[i] = bufferParser.readString(true);
                const groupnameCount = bufferParser.readUInt32BE();
                if (groupnameCount === void 0)
                  break;
                const groupnames = new Array(groupnameCount);
                for (let i = 0; i < groupnames.length; ++i)
                  groupnames[i] = bufferParser.readString(true);
                if (groupnames.length > 0 && groupnames[groupnames.length - 1] === void 0) {
                  break;
                }
                if (sftp._debug) {
                  sftp._debug(
                    `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                  );
                }
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb(void 0, usernames, groupnames);
                return;
              }
              default:
                sftp._debug && sftp._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`
                );
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb();
                return;
            }
          } else {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`
            );
            bufferParser.clear();
            return;
          }
        }
        bufferParser.clear();
        return doFatalSFTPError(sftp, "Malformed EXTENDED_REPLY packet");
      }
    };
    var SERVER_HANDLERS = {
      [REQUEST.INIT]: (sftp, payload) => {
        if (sftp._version !== -1)
          return doFatalSFTPError(sftp, "Duplicate INIT packet");
        const extensions = {};
        bufferParser.init(payload, 1);
        let version = bufferParser.readUInt32BE();
        while (bufferParser.avail()) {
          const extName = bufferParser.readString(true);
          const extData = bufferParser.readString(true);
          if (extData === void 0) {
            version = void 0;
            break;
          }
          extensions[extName] = extData;
        }
        bufferParser.clear();
        if (version === void 0)
          return doFatalSFTPError(sftp, "Malformed INIT packet");
        if (sftp._debug) {
          const names = Object.keys(extensions);
          if (names.length) {
            sftp._debug(
              `SFTP: Inbound: Received INIT (v${version}, exts:${names})`
            );
          } else {
            sftp._debug(`SFTP: Inbound: Received INIT (v${version})`);
          }
        }
        sendOrBuffer(sftp, SERVER_VERSION_BUFFER);
        sftp._version = version;
        sftp._extensions = extensions;
        sftp.emit("ready");
      },
      [REQUEST.OPEN]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const filename = bufferParser.readString(true);
        const pflags = bufferParser.readUInt32BE();
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed OPEN packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);
        if (!sftp.emit("OPEN", reqID, filename, pflags, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.CLOSE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed CLOSE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);
        if (!sftp.emit("CLOSE", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READ]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const offset = bufferParser.readUInt64BE(sftp._biOpt);
        const len = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (len === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed READ packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);
        if (!sftp.emit("READ", reqID, handle, offset, len)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.WRITE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const offset = bufferParser.readUInt64BE(sftp._biOpt);
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed WRITE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);
        if (!sftp.emit("WRITE", reqID, handle, offset, data)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.LSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0)
          return doFatalSFTPError(sftp, "Malformed LSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);
        if (!sftp.emit("LSTAT", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.FSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed FSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);
        if (!sftp.emit("FSTAT", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.SETSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed SETSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);
        if (!sftp.emit("SETSTAT", reqID, path, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.FSETSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed FSETSTAT packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received FSETSTAT (id:${reqID})`
        );
        if (!sftp.emit("FSETSTAT", reqID, handle, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.OPENDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0)
          return doFatalSFTPError(sftp, "Malformed OPENDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);
        if (!sftp.emit("OPENDIR", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed READDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);
        if (!sftp.emit("READDIR", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.REMOVE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0)
          return doFatalSFTPError(sftp, "Malformed REMOVE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);
        if (!sftp.emit("REMOVE", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.MKDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed MKDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);
        if (!sftp.emit("MKDIR", reqID, path, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.RMDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0)
          return doFatalSFTPError(sftp, "Malformed RMDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);
        if (!sftp.emit("RMDIR", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.REALPATH]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0)
          return doFatalSFTPError(sftp, "Malformed REALPATH packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received REALPATH (id:${reqID})`
        );
        if (!sftp.emit("REALPATH", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.STAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0)
          return doFatalSFTPError(sftp, "Malformed STAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);
        if (!sftp.emit("STAT", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.RENAME]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const oldPath = bufferParser.readString(true);
        const newPath = bufferParser.readString(true);
        bufferParser.clear();
        if (newPath === void 0)
          return doFatalSFTPError(sftp, "Malformed RENAME packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);
        if (!sftp.emit("RENAME", reqID, oldPath, newPath)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READLINK]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0)
          return doFatalSFTPError(sftp, "Malformed READLINK packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received READLINK (id:${reqID})`
        );
        if (!sftp.emit("READLINK", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.SYMLINK]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const linkPath = bufferParser.readString(true);
        const targetPath = bufferParser.readString(true);
        bufferParser.clear();
        if (targetPath === void 0)
          return doFatalSFTPError(sftp, "Malformed SYMLINK packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);
        let handled;
        if (sftp._isOpenSSH) {
          handled = sftp.emit("SYMLINK", reqID, targetPath, linkPath);
        } else {
          handled = sftp.emit("SYMLINK", reqID, linkPath, targetPath);
        }
        if (!handled) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.EXTENDED]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const extName = bufferParser.readString(true);
        if (extName === void 0) {
          bufferParser.clear();
          return doFatalSFTPError(sftp, "Malformed EXTENDED packet");
        }
        let extData;
        if (bufferParser.avail())
          extData = bufferParser.readRaw();
        bufferParser.clear();
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received EXTENDED (id:${reqID})`
        );
        if (!sftp.emit("EXTENDED", reqID, extName, extData)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      }
    };
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_OUT_OF_RANGE,
      validateNumber
    } = require_node_fs_compat();
    var kMinPoolSpace = 128;
    var pool;
    var poolFragments = [];
    function allocNewPool(poolSize) {
      if (poolFragments.length > 0)
        pool = poolFragments.pop();
      else
        pool = Buffer.allocUnsafe(poolSize);
      pool.used = 0;
    }
    function checkPosition(pos, name) {
      if (!Number.isSafeInteger(pos)) {
        validateNumber(pos, name);
        if (!Number.isInteger(pos))
          throw new ERR_OUT_OF_RANGE(name, "an integer", pos);
        throw new ERR_OUT_OF_RANGE(name, ">= 0 and <= 2 ** 53 - 1", pos);
      }
      if (pos < 0)
        throw new ERR_OUT_OF_RANGE(name, ">= 0 and <= 2 ** 53 - 1", pos);
    }
    function roundUpToMultipleOf8(n) {
      return n + 7 & ~7;
    }
    function ReadStream(sftp, path, options) {
      if (options === void 0)
        options = {};
      else if (typeof options === "string")
        options = { encoding: options };
      else if (options === null || typeof options !== "object")
        throw new TypeError('"options" argument must be a string or an object');
      else
        options = Object.create(options);
      if (options.highWaterMark === void 0)
        options.highWaterMark = 64 * 1024;
      options.emitClose = false;
      options.autoDestroy = false;
      ReadableStream.call(this, options);
      this.path = path;
      this.flags = options.flags === void 0 ? "r" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.end = options.end;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = 0;
      this.bytesRead = 0;
      this.isClosed = false;
      this.handle = options.handle === void 0 ? null : options.handle;
      this.sftp = sftp;
      this._opening = false;
      if (this.start !== void 0) {
        checkPosition(this.start, "start");
        this.pos = this.start;
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (this.end !== Infinity) {
        checkPosition(this.end, "end");
        if (this.start !== void 0 && this.start > this.end) {
          throw new ERR_OUT_OF_RANGE(
            "start",
            `<= "end" (here: ${this.end})`,
            this.start
          );
        }
      }
      this.on("end", function() {
        if (this.autoClose)
          this.destroy();
      });
      if (!Buffer.isBuffer(this.handle))
        this.open();
    }
    inherits(ReadStream, ReadableStream);
    ReadStream.prototype.open = function() {
      if (this._opening)
        return;
      this._opening = true;
      this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
        this._opening = false;
        if (er) {
          this.emit("error", er);
          if (this.autoClose)
            this.destroy();
          return;
        }
        this.handle = handle;
        this.emit("open", handle);
        this.emit("ready");
        this.read();
      });
    };
    ReadStream.prototype._read = function(n) {
      if (!Buffer.isBuffer(this.handle))
        return this.once("open", () => this._read(n));
      if (this.destroyed)
        return;
      if (!pool || pool.length - pool.used < kMinPoolSpace) {
        allocNewPool(this.readableHighWaterMark || this._readableState.highWaterMark);
      }
      const thisPool = pool;
      let toRead = Math.min(pool.length - pool.used, n);
      const start = pool.used;
      if (this.end !== void 0)
        toRead = Math.min(this.end - this.pos + 1, toRead);
      if (toRead <= 0)
        return this.push(null);
      this.sftp.read(
        this.handle,
        pool,
        pool.used,
        toRead,
        this.pos,
        (er, bytesRead) => {
          if (er) {
            this.emit("error", er);
            if (this.autoClose)
              this.destroy();
            return;
          }
          let b = null;
          if (start + toRead === thisPool.used && thisPool === pool) {
            thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);
          } else {
            const alignedEnd = start + toRead & ~7;
            const alignedStart = roundUpToMultipleOf8(start + bytesRead);
            if (alignedEnd - alignedStart >= kMinPoolSpace)
              poolFragments.push(thisPool.slice(alignedStart, alignedEnd));
          }
          if (bytesRead > 0) {
            this.bytesRead += bytesRead;
            b = thisPool.slice(start, start + bytesRead);
          }
          this.pos += bytesRead;
          this.push(b);
        }
      );
      pool.used = roundUpToMultipleOf8(pool.used + toRead);
    };
    ReadStream.prototype._destroy = function(err, cb) {
      if (this._opening && !Buffer.isBuffer(this.handle)) {
        this.once("open", closeStream.bind(null, this, cb, err));
        return;
      }
      closeStream(this, cb, err);
      this.handle = null;
      this._opening = false;
    };
    function closeStream(stream, cb, err) {
      if (!stream.handle)
        return onclose();
      stream.sftp.close(stream.handle, onclose);
      function onclose(er) {
        er = er || err;
        cb(er);
        stream.isClosed = true;
        if (!er)
          stream.emit("close");
      }
    }
    ReadStream.prototype.close = function(cb) {
      this.destroy(null, cb);
    };
    Object.defineProperty(ReadStream.prototype, "pending", {
      get() {
        return this.handle === null;
      },
      configurable: true
    });
    function WriteStream(sftp, path, options) {
      if (options === void 0)
        options = {};
      else if (typeof options === "string")
        options = { encoding: options };
      else if (options === null || typeof options !== "object")
        throw new TypeError('"options" argument must be a string or an object');
      else
        options = Object.create(options);
      options.emitClose = false;
      options.autoDestroy = false;
      WritableStream.call(this, options);
      this.path = path;
      this.flags = options.flags === void 0 ? "w" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = 0;
      this.bytesWritten = 0;
      this.isClosed = false;
      this.handle = options.handle === void 0 ? null : options.handle;
      this.sftp = sftp;
      this._opening = false;
      if (this.start !== void 0) {
        checkPosition(this.start, "start");
        this.pos = this.start;
      }
      if (options.encoding)
        this.setDefaultEncoding(options.encoding);
      this.on("finish", function() {
        if (this._writableState.finalCalled)
          return;
        if (this.autoClose)
          this.destroy();
      });
      if (!Buffer.isBuffer(this.handle))
        this.open();
    }
    inherits(WriteStream, WritableStream);
    WriteStream.prototype._final = function(cb) {
      if (this.autoClose)
        this.destroy();
      cb();
    };
    WriteStream.prototype.open = function() {
      if (this._opening)
        return;
      this._opening = true;
      this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
        this._opening = false;
        if (er) {
          this.emit("error", er);
          if (this.autoClose)
            this.destroy();
          return;
        }
        this.handle = handle;
        const tryAgain = (err) => {
          if (err) {
            this.sftp.chmod(this.path, this.mode, (err_) => tryAgain());
            return;
          }
          if (this.flags[0] === "a") {
            const tryStat = (err2, st) => {
              if (err2) {
                this.sftp.stat(this.path, (err_, st_) => {
                  if (err_) {
                    this.destroy();
                    this.emit("error", err2);
                    return;
                  }
                  tryStat(null, st_);
                });
                return;
              }
              this.pos = st.size;
              this.emit("open", handle);
              this.emit("ready");
            };
            this.sftp.fstat(handle, tryStat);
            return;
          }
          this.emit("open", handle);
          this.emit("ready");
        };
        this.sftp.fchmod(handle, this.mode, tryAgain);
      });
    };
    WriteStream.prototype._write = function(data, encoding, cb) {
      if (!Buffer.isBuffer(data)) {
        const err = new ERR_INVALID_ARG_TYPE("data", "Buffer", data);
        return this.emit("error", err);
      }
      if (!Buffer.isBuffer(this.handle)) {
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      }
      this.sftp.write(
        this.handle,
        data,
        0,
        data.length,
        this.pos,
        (er, bytes) => {
          if (er) {
            if (this.autoClose)
              this.destroy();
            return cb(er);
          }
          this.bytesWritten += bytes;
          cb();
        }
      );
      this.pos += data.length;
    };
    WriteStream.prototype._writev = function(data, cb) {
      if (!Buffer.isBuffer(this.handle)) {
        return this.once("open", function() {
          this._writev(data, cb);
        });
      }
      const sftp = this.sftp;
      const handle = this.handle;
      let writesLeft = data.length;
      const onwrite = (er, bytes) => {
        if (er) {
          this.destroy();
          return cb(er);
        }
        this.bytesWritten += bytes;
        if (--writesLeft === 0)
          cb();
      };
      for (let i = 0; i < data.length; ++i) {
        const chunk = data[i].chunk;
        sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);
        this.pos += chunk.length;
      }
    };
    if (typeof WritableStream.prototype.destroy !== "function")
      WriteStream.prototype.destroy = ReadStream.prototype.destroy;
    WriteStream.prototype._destroy = ReadStream.prototype._destroy;
    WriteStream.prototype.close = function(cb) {
      if (cb) {
        if (this.isClosed) {
          process.nextTick(cb);
          return;
        }
        this.on("close", cb);
      }
      if (!this.autoClose)
        this.on("finish", this.destroy.bind(this));
      this.end();
    };
    WriteStream.prototype.destroySoon = WriteStream.prototype.end;
    Object.defineProperty(WriteStream.prototype, "pending", {
      get() {
        return this.handle === null;
      },
      configurable: true
    });
    module2.exports = {
      flagsToString,
      OPEN_MODE,
      SFTP,
      Stats,
      STATUS_CODE,
      stringToFlags
    };
  }
});

// node_modules/ssh2/lib/Channel.js
var require_Channel = __commonJS({
  "node_modules/ssh2/lib/Channel.js"(exports, module2) {
    "use strict";
    var {
      Duplex: DuplexStream,
      Readable: ReadableStream,
      Writable: WritableStream
    } = require("stream");
    var {
      CHANNEL_EXTENDED_DATATYPE: { STDERR }
    } = require_constants();
    var { bufferSlice } = require_utils();
    var PACKET_SIZE = 32 * 1024;
    var MAX_WINDOW = 2 * 1024 * 1024;
    var WINDOW_THRESHOLD = MAX_WINDOW / 2;
    var ClientStderr = class extends ReadableStream {
      constructor(channel, streamOpts) {
        super(streamOpts);
        this._channel = channel;
      }
      _read(n) {
        if (this._channel._waitChanDrain) {
          this._channel._waitChanDrain = false;
          if (this._channel.incoming.window <= WINDOW_THRESHOLD)
            windowAdjust(this._channel);
        }
      }
    };
    var ServerStderr = class extends WritableStream {
      constructor(channel) {
        super({ highWaterMark: MAX_WINDOW });
        this._channel = channel;
      }
      _write(data, encoding, cb) {
        const channel = this._channel;
        const protocol = channel._client._protocol;
        const outgoing = channel.outgoing;
        const packetSize = outgoing.packetSize;
        const id = outgoing.id;
        let window2 = outgoing.window;
        const len = data.length;
        let p = 0;
        if (outgoing.state !== "open")
          return;
        while (len - p > 0 && window2 > 0) {
          let sliceLen = len - p;
          if (sliceLen > window2)
            sliceLen = window2;
          if (sliceLen > packetSize)
            sliceLen = packetSize;
          if (p === 0 && sliceLen === len)
            protocol.channelExtData(id, data, STDERR);
          else
            protocol.channelExtData(id, bufferSlice(data, p, p + sliceLen), STDERR);
          p += sliceLen;
          window2 -= sliceLen;
        }
        outgoing.window = window2;
        if (len - p > 0) {
          if (window2 === 0)
            channel._waitWindow = true;
          if (p > 0)
            channel._chunkErr = bufferSlice(data, p, len);
          else
            channel._chunkErr = data;
          channel._chunkcbErr = cb;
          return;
        }
        cb();
      }
    };
    var Channel = class extends DuplexStream {
      constructor(client, info, opts) {
        const streamOpts = {
          highWaterMark: MAX_WINDOW,
          allowHalfOpen: !opts || opts && opts.allowHalfOpen !== false,
          emitClose: false
        };
        super(streamOpts);
        this.allowHalfOpen = streamOpts.allowHalfOpen;
        const server = !!(opts && opts.server);
        this.server = server;
        this.type = info.type;
        this.subtype = void 0;
        this.incoming = info.incoming;
        this.outgoing = info.outgoing;
        this._callbacks = [];
        this._client = client;
        this._hasX11 = false;
        this._exit = {
          code: void 0,
          signal: void 0,
          dump: void 0,
          desc: void 0
        };
        this.stdin = this.stdout = this;
        if (server)
          this.stderr = new ServerStderr(this);
        else
          this.stderr = new ClientStderr(this, streamOpts);
        this._waitWindow = false;
        this._waitChanDrain = false;
        this._chunk = void 0;
        this._chunkcb = void 0;
        this._chunkErr = void 0;
        this._chunkcbErr = void 0;
        this.on("finish", onFinish).on("prefinish", onFinish);
        this.on("end", onEnd).on("close", onEnd);
      }
      _read(n) {
        if (this._waitChanDrain) {
          this._waitChanDrain = false;
          if (this.incoming.window <= WINDOW_THRESHOLD)
            windowAdjust(this);
        }
      }
      _write(data, encoding, cb) {
        const protocol = this._client._protocol;
        const outgoing = this.outgoing;
        const packetSize = outgoing.packetSize;
        const id = outgoing.id;
        let window2 = outgoing.window;
        const len = data.length;
        let p = 0;
        if (outgoing.state !== "open")
          return;
        while (len - p > 0 && window2 > 0) {
          let sliceLen = len - p;
          if (sliceLen > window2)
            sliceLen = window2;
          if (sliceLen > packetSize)
            sliceLen = packetSize;
          if (p === 0 && sliceLen === len)
            protocol.channelData(id, data);
          else
            protocol.channelData(id, bufferSlice(data, p, p + sliceLen));
          p += sliceLen;
          window2 -= sliceLen;
        }
        outgoing.window = window2;
        if (len - p > 0) {
          if (window2 === 0)
            this._waitWindow = true;
          if (p > 0)
            this._chunk = bufferSlice(data, p, len);
          else
            this._chunk = data;
          this._chunkcb = cb;
          return;
        }
        cb();
      }
      eof() {
        if (this.outgoing.state === "open") {
          this.outgoing.state = "eof";
          this._client._protocol.channelEOF(this.outgoing.id);
        }
      }
      close() {
        if (this.outgoing.state === "open" || this.outgoing.state === "eof") {
          this.outgoing.state = "closing";
          this._client._protocol.channelClose(this.outgoing.id);
        }
      }
      destroy() {
        this.end();
        this.close();
        return this;
      }
      // Session type-specific methods =============================================
      setWindow(rows, cols, height, width) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this.type === "session" && (this.subtype === "shell" || this.subtype === "exec") && this.writable && this.outgoing.state === "open") {
          this._client._protocol.windowChange(
            this.outgoing.id,
            rows,
            cols,
            height,
            width
          );
        }
      }
      signal(signalName) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this.type === "session" && this.writable && this.outgoing.state === "open") {
          this._client._protocol.signal(this.outgoing.id, signalName);
        }
      }
      exit(statusOrSignal, coreDumped, msg) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (this.type === "session" && this.writable && this.outgoing.state === "open") {
          if (typeof statusOrSignal === "number") {
            this._client._protocol.exitStatus(this.outgoing.id, statusOrSignal);
          } else {
            this._client._protocol.exitSignal(
              this.outgoing.id,
              statusOrSignal,
              coreDumped,
              msg
            );
          }
        }
      }
    };
    function onFinish() {
      this.eof();
      if (this.server || !this.allowHalfOpen)
        this.close();
      this.writable = false;
    }
    function onEnd() {
      this.readable = false;
    }
    function windowAdjust(self2) {
      if (self2.outgoing.state === "closed")
        return;
      const amt = MAX_WINDOW - self2.incoming.window;
      if (amt <= 0)
        return;
      self2.incoming.window += amt;
      self2._client._protocol.channelWindowAdjust(self2.outgoing.id, amt);
    }
    module2.exports = {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    };
  }
});

// node_modules/ssh2/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/ssh2/lib/utils.js"(exports, module2) {
    "use strict";
    var { SFTP } = require_SFTP();
    var MAX_CHANNEL = 2 ** 32 - 1;
    function onChannelOpenFailure(self2, recipient, info, cb) {
      self2._chanMgr.remove(recipient);
      if (typeof cb !== "function")
        return;
      let err;
      if (info instanceof Error) {
        err = info;
      } else if (typeof info === "object" && info !== null) {
        err = new Error(`(SSH) Channel open failure: ${info.description}`);
        err.reason = info.reason;
      } else {
        err = new Error(
          "(SSH) Channel open failure: server closed channel unexpectedly"
        );
        err.reason = "";
      }
      cb(err);
    }
    function onCHANNEL_CLOSE(self2, recipient, channel, err, dead) {
      if (typeof channel === "function") {
        onChannelOpenFailure(self2, recipient, err, channel);
        return;
      }
      if (typeof channel !== "object" || channel === null)
        return;
      if (channel.incoming && channel.incoming.state === "closed")
        return;
      self2._chanMgr.remove(recipient);
      if (channel.server && channel.constructor.name === "Session")
        return;
      channel.incoming.state = "closed";
      if (channel.readable)
        channel.push(null);
      if (channel.server) {
        if (channel.stderr.writable)
          channel.stderr.end();
      } else if (channel.stderr.readable) {
        channel.stderr.push(null);
      }
      if (channel.constructor !== SFTP && (channel.outgoing.state === "open" || channel.outgoing.state === "eof") && !dead) {
        channel.close();
      }
      if (channel.outgoing.state === "closing")
        channel.outgoing.state = "closed";
      const readState = channel._readableState;
      const writeState = channel._writableState;
      if (writeState && !writeState.ending && !writeState.finished && !dead)
        channel.end();
      const chanCallbacks = channel._callbacks;
      channel._callbacks = [];
      for (let i = 0; i < chanCallbacks.length; ++i)
        chanCallbacks[i](true);
      if (channel.server) {
        if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {
          channel.emit("close");
        } else {
          channel.once("end", () => channel.emit("close"));
        }
      } else {
        let doClose;
        switch (channel.type) {
          case "direct-streamlocal@openssh.com":
          case "direct-tcpip":
            doClose = () => channel.emit("close");
            break;
          default: {
            const exit = channel._exit;
            doClose = () => {
              if (exit.code === null)
                channel.emit("close", exit.code, exit.signal, exit.dump, exit.desc);
              else
                channel.emit("close", exit.code);
            };
          }
        }
        if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {
          doClose();
        } else {
          channel.once("end", doClose);
        }
        const errReadState = channel.stderr._readableState;
        if (!channel.stderr.readable || channel.stderr.destroyed || errReadState && errReadState.endEmitted) {
          channel.stderr.emit("close");
        } else {
          channel.stderr.once("end", () => channel.stderr.emit("close"));
        }
      }
    }
    var ChannelManager = class {
      constructor(client) {
        this._client = client;
        this._channels = {};
        this._cur = -1;
        this._count = 0;
      }
      add(val) {
        let id;
        if (this._cur < MAX_CHANNEL) {
          id = ++this._cur;
        } else if (this._count === 0) {
          this._cur = 0;
          id = 0;
        } else {
          const channels = this._channels;
          for (let i = 0; i < MAX_CHANNEL; ++i) {
            if (channels[i] === void 0) {
              id = i;
              break;
            }
          }
        }
        if (id === void 0)
          return -1;
        this._channels[id] = val || true;
        ++this._count;
        return id;
      }
      update(id, val) {
        if (typeof id !== "number" || id < 0 || id >= MAX_CHANNEL || !isFinite(id))
          throw new Error(`Invalid channel id: ${id}`);
        if (val && this._channels[id])
          this._channels[id] = val;
      }
      get(id) {
        if (typeof id !== "number" || id < 0 || id >= MAX_CHANNEL || !isFinite(id))
          throw new Error(`Invalid channel id: ${id}`);
        return this._channels[id];
      }
      remove(id) {
        if (typeof id !== "number" || id < 0 || id >= MAX_CHANNEL || !isFinite(id))
          throw new Error(`Invalid channel id: ${id}`);
        if (this._channels[id]) {
          delete this._channels[id];
          if (this._count)
            --this._count;
        }
      }
      cleanup(err) {
        const channels = this._channels;
        this._channels = {};
        this._cur = -1;
        this._count = 0;
        const chanIDs = Object.keys(channels);
        const client = this._client;
        for (let i = 0; i < chanIDs.length; ++i) {
          const id = +chanIDs[i];
          const channel = channels[id];
          onCHANNEL_CLOSE(client, id, channel._channel || channel, err, true);
        }
      }
    };
    var isRegExp = (() => {
      const toString = Object.prototype.toString;
      return (val) => toString.call(val) === "[object RegExp]";
    })();
    function generateAlgorithmList(algoList, defaultList, supportedList) {
      if (Array.isArray(algoList) && algoList.length > 0) {
        for (let i = 0; i < algoList.length; ++i) {
          if (supportedList.indexOf(algoList[i]) === -1)
            throw new Error(`Unsupported algorithm: ${algoList[i]}`);
        }
        return algoList;
      }
      if (typeof algoList === "object" && algoList !== null) {
        const keys = Object.keys(algoList);
        let list = defaultList;
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          let val = algoList[key];
          switch (key) {
            case "append":
              if (!Array.isArray(val))
                val = [val];
              if (Array.isArray(val)) {
                for (let j = 0; j < val.length; ++j) {
                  const append = val[j];
                  if (typeof append === "string") {
                    if (!append || list.indexOf(append) !== -1)
                      continue;
                    if (supportedList.indexOf(append) === -1)
                      throw new Error(`Unsupported algorithm: ${append}`);
                    if (list === defaultList)
                      list = list.slice();
                    list.push(append);
                  } else if (isRegExp(append)) {
                    for (let k = 0; k < supportedList.length; ++k) {
                      const algo = supportedList[k];
                      if (append.test(algo)) {
                        if (list.indexOf(algo) !== -1)
                          continue;
                        if (list === defaultList)
                          list = list.slice();
                        list.push(algo);
                      }
                    }
                  }
                }
              }
              break;
            case "prepend":
              if (!Array.isArray(val))
                val = [val];
              if (Array.isArray(val)) {
                for (let j = val.length; j >= 0; --j) {
                  const prepend = val[j];
                  if (typeof prepend === "string") {
                    if (!prepend || list.indexOf(prepend) !== -1)
                      continue;
                    if (supportedList.indexOf(prepend) === -1)
                      throw new Error(`Unsupported algorithm: ${prepend}`);
                    if (list === defaultList)
                      list = list.slice();
                    list.unshift(prepend);
                  } else if (isRegExp(prepend)) {
                    for (let k = supportedList.length; k >= 0; --k) {
                      const algo = supportedList[k];
                      if (prepend.test(algo)) {
                        if (list.indexOf(algo) !== -1)
                          continue;
                        if (list === defaultList)
                          list = list.slice();
                        list.unshift(algo);
                      }
                    }
                  }
                }
              }
              break;
            case "remove":
              if (!Array.isArray(val))
                val = [val];
              if (Array.isArray(val)) {
                for (let j = 0; j < val.length; ++j) {
                  const search = val[j];
                  if (typeof search === "string") {
                    if (!search)
                      continue;
                    const idx = list.indexOf(search);
                    if (idx === -1)
                      continue;
                    if (list === defaultList)
                      list = list.slice();
                    list.splice(idx, 1);
                  } else if (isRegExp(search)) {
                    for (let k = 0; k < list.length; ++k) {
                      if (search.test(list[k])) {
                        if (list === defaultList)
                          list = list.slice();
                        list.splice(k, 1);
                        --k;
                      }
                    }
                  }
                }
              }
              break;
          }
        }
        return list;
      }
      return defaultList;
    }
    module2.exports = {
      ChannelManager,
      generateAlgorithmList,
      onChannelOpenFailure,
      onCHANNEL_CLOSE,
      isWritable: (stream) => {
        return stream && stream.writable && stream._readableState && stream._readableState.ended === false;
      }
    };
  }
});

// node_modules/ssh2/lib/client.js
var require_client = __commonJS({
  "node_modules/ssh2/lib/client.js"(exports, module2) {
    "use strict";
    var {
      createHash,
      getHashes,
      randomFillSync
    } = require("crypto");
    var { Socket } = require("net");
    var { lookup: dnsLookup } = require("dns");
    var EventEmitter = require("events");
    var HASHES = getHashes();
    var {
      COMPAT,
      CHANNEL_EXTENDED_DATATYPE: { STDERR },
      CHANNEL_OPEN_FAILURE,
      DEFAULT_CIPHER,
      DEFAULT_COMPRESSION,
      DEFAULT_KEX,
      DEFAULT_MAC,
      DEFAULT_SERVER_HOST_KEY,
      DISCONNECT_REASON,
      DISCONNECT_REASON_BY_VALUE,
      SUPPORTED_CIPHER,
      SUPPORTED_COMPRESSION,
      SUPPORTED_KEX,
      SUPPORTED_MAC,
      SUPPORTED_SERVER_HOST_KEY
    } = require_constants();
    var { init: cryptoInit } = require_crypto();
    var Protocol = require_Protocol();
    var { parseKey } = require_keyParser();
    var { SFTP } = require_SFTP();
    var {
      bufferCopy,
      makeBufferParser,
      makeError,
      readUInt32BE,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils();
    var { AgentContext, createAgent, isAgent } = require_agent();
    var {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    } = require_Channel();
    var {
      ChannelManager,
      generateAlgorithmList,
      isWritable,
      onChannelOpenFailure,
      onCHANNEL_CLOSE
    } = require_utils2();
    var bufferParser = makeBufferParser();
    var sigParser = makeBufferParser();
    var RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\d)|(?:\d{2,})/;
    var noop = (err) => {
    };
    var Client2 = class extends EventEmitter {
      constructor() {
        super();
        this.config = {
          host: void 0,
          port: void 0,
          localAddress: void 0,
          localPort: void 0,
          forceIPv4: void 0,
          forceIPv6: void 0,
          keepaliveCountMax: void 0,
          keepaliveInterval: void 0,
          readyTimeout: void 0,
          ident: void 0,
          username: void 0,
          password: void 0,
          privateKey: void 0,
          tryKeyboard: void 0,
          agent: void 0,
          allowAgentFwd: void 0,
          authHandler: void 0,
          hostHashAlgo: void 0,
          hostHashCb: void 0,
          strictVendor: void 0,
          debug: void 0
        };
        this._agent = void 0;
        this._readyTimeout = void 0;
        this._chanMgr = void 0;
        this._callbacks = void 0;
        this._forwarding = void 0;
        this._forwardingUnix = void 0;
        this._acceptX11 = void 0;
        this._agentFwdEnabled = void 0;
        this._remoteVer = void 0;
        this._protocol = void 0;
        this._sock = void 0;
        this._resetKA = void 0;
      }
      connect(cfg) {
        if (this._sock && isWritable(this._sock)) {
          this.once("close", () => {
            this.connect(cfg);
          });
          this.end();
          return this;
        }
        this.config.host = cfg.hostname || cfg.host || "localhost";
        this.config.port = cfg.port || 22;
        this.config.localAddress = typeof cfg.localAddress === "string" ? cfg.localAddress : void 0;
        this.config.localPort = typeof cfg.localPort === "string" || typeof cfg.localPort === "number" ? cfg.localPort : void 0;
        this.config.forceIPv4 = cfg.forceIPv4 || false;
        this.config.forceIPv6 = cfg.forceIPv6 || false;
        this.config.keepaliveCountMax = typeof cfg.keepaliveCountMax === "number" && cfg.keepaliveCountMax >= 0 ? cfg.keepaliveCountMax : 3;
        this.config.keepaliveInterval = typeof cfg.keepaliveInterval === "number" && cfg.keepaliveInterval > 0 ? cfg.keepaliveInterval : 0;
        this.config.readyTimeout = typeof cfg.readyTimeout === "number" && cfg.readyTimeout >= 0 ? cfg.readyTimeout : 2e4;
        this.config.ident = typeof cfg.ident === "string" || Buffer.isBuffer(cfg.ident) ? cfg.ident : void 0;
        const algorithms = {
          kex: void 0,
          serverHostKey: void 0,
          cs: {
            cipher: void 0,
            mac: void 0,
            compress: void 0,
            lang: []
          },
          sc: void 0
        };
        let allOfferDefaults = true;
        if (typeof cfg.algorithms === "object" && cfg.algorithms !== null) {
          algorithms.kex = generateAlgorithmList(
            cfg.algorithms.kex,
            DEFAULT_KEX,
            SUPPORTED_KEX
          );
          if (algorithms.kex !== DEFAULT_KEX)
            allOfferDefaults = false;
          algorithms.serverHostKey = generateAlgorithmList(
            cfg.algorithms.serverHostKey,
            DEFAULT_SERVER_HOST_KEY,
            SUPPORTED_SERVER_HOST_KEY
          );
          if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY)
            allOfferDefaults = false;
          algorithms.cs.cipher = generateAlgorithmList(
            cfg.algorithms.cipher,
            DEFAULT_CIPHER,
            SUPPORTED_CIPHER
          );
          if (algorithms.cs.cipher !== DEFAULT_CIPHER)
            allOfferDefaults = false;
          algorithms.cs.mac = generateAlgorithmList(
            cfg.algorithms.hmac,
            DEFAULT_MAC,
            SUPPORTED_MAC
          );
          if (algorithms.cs.mac !== DEFAULT_MAC)
            allOfferDefaults = false;
          algorithms.cs.compress = generateAlgorithmList(
            cfg.algorithms.compress,
            DEFAULT_COMPRESSION,
            SUPPORTED_COMPRESSION
          );
          if (algorithms.cs.compress !== DEFAULT_COMPRESSION)
            allOfferDefaults = false;
          if (!allOfferDefaults)
            algorithms.sc = algorithms.cs;
        }
        if (typeof cfg.username === "string")
          this.config.username = cfg.username;
        else if (typeof cfg.user === "string")
          this.config.username = cfg.user;
        else
          throw new Error("Invalid username");
        this.config.password = typeof cfg.password === "string" ? cfg.password : void 0;
        this.config.privateKey = typeof cfg.privateKey === "string" || Buffer.isBuffer(cfg.privateKey) ? cfg.privateKey : void 0;
        this.config.localHostname = typeof cfg.localHostname === "string" ? cfg.localHostname : void 0;
        this.config.localUsername = typeof cfg.localUsername === "string" ? cfg.localUsername : void 0;
        this.config.tryKeyboard = cfg.tryKeyboard === true;
        if (typeof cfg.agent === "string" && cfg.agent.length)
          this.config.agent = createAgent(cfg.agent);
        else if (isAgent(cfg.agent))
          this.config.agent = cfg.agent;
        else
          this.config.agent = void 0;
        this.config.allowAgentFwd = cfg.agentForward === true && this.config.agent !== void 0;
        let authHandler = this.config.authHandler = typeof cfg.authHandler === "function" || Array.isArray(cfg.authHandler) ? cfg.authHandler : void 0;
        this.config.strictVendor = typeof cfg.strictVendor === "boolean" ? cfg.strictVendor : true;
        const debug = this.config.debug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        if (cfg.agentForward === true && !this.config.allowAgentFwd) {
          throw new Error(
            "You must set a valid agent path to allow agent forwarding"
          );
        }
        let callbacks = this._callbacks = [];
        this._chanMgr = new ChannelManager(this);
        this._forwarding = {};
        this._forwardingUnix = {};
        this._acceptX11 = 0;
        this._agentFwdEnabled = false;
        this._agent = this.config.agent ? this.config.agent : void 0;
        this._remoteVer = void 0;
        let privateKey;
        if (this.config.privateKey) {
          privateKey = parseKey(this.config.privateKey, cfg.passphrase);
          if (privateKey instanceof Error)
            throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
          if (Array.isArray(privateKey)) {
            privateKey = privateKey[0];
          }
          if (privateKey.getPrivatePEM() === null) {
            throw new Error(
              "privateKey value does not contain a (valid) private key"
            );
          }
        }
        let hostVerifier;
        if (typeof cfg.hostVerifier === "function") {
          const hashCb = cfg.hostVerifier;
          let hasher;
          if (HASHES.indexOf(cfg.hostHash) !== -1) {
            hasher = createHash(cfg.hostHash);
          }
          hostVerifier = (key, verify) => {
            if (hasher) {
              hasher.update(key);
              key = hasher.digest("hex");
            }
            const ret = hashCb(key, verify);
            if (ret !== void 0)
              verify(ret);
          };
        }
        const sock = this._sock = cfg.sock || new Socket();
        let ready = false;
        let sawHeader = false;
        if (this._protocol)
          this._protocol.cleanup();
        const DEBUG_HANDLER = !debug ? void 0 : (p, display, msg) => {
          debug(`Debug output from server: ${JSON.stringify(msg)}`);
        };
        let serverSigAlgs;
        const proto = this._protocol = new Protocol({
          ident: this.config.ident,
          offer: allOfferDefaults ? void 0 : algorithms,
          onWrite: (data) => {
            if (isWritable(sock))
              sock.write(data);
          },
          onError: (err) => {
            if (err.level === "handshake")
              clearTimeout(this._readyTimeout);
            if (!proto._destruct)
              sock.removeAllListeners("data");
            this.emit("error", err);
            try {
              sock.end();
            } catch {
            }
          },
          onHeader: (header) => {
            sawHeader = true;
            this._remoteVer = header.versions.software;
            if (header.greeting)
              this.emit("greeting", header.greeting);
          },
          onHandshakeComplete: (negotiated) => {
            this.emit("handshake", negotiated);
            if (!ready) {
              ready = true;
              proto.service("ssh-userauth");
            }
          },
          debug,
          hostVerifier,
          messageHandlers: {
            DEBUG: DEBUG_HANDLER,
            DISCONNECT: (p, reason, desc) => {
              if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
                if (!desc) {
                  desc = DISCONNECT_REASON_BY_VALUE[reason];
                  if (desc === void 0)
                    desc = `Unexpected disconnection reason: ${reason}`;
                }
                const err = new Error(desc);
                err.code = reason;
                this.emit("error", err);
              }
              sock.end();
            },
            SERVICE_ACCEPT: (p, name) => {
              if (name === "ssh-userauth")
                tryNextAuth();
            },
            EXT_INFO: (p, exts) => {
              if (serverSigAlgs === void 0) {
                for (const ext of exts) {
                  if (ext.name === "server-sig-algs") {
                    serverSigAlgs = ext.algs;
                    return;
                  }
                }
                serverSigAlgs = null;
              }
            },
            USERAUTH_BANNER: (p, msg) => {
              this.emit("banner", msg);
            },
            USERAUTH_SUCCESS: (p) => {
              resetKA();
              clearTimeout(this._readyTimeout);
              this.emit("ready");
            },
            USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {
              if (curAuth.keyAlgos) {
                const oldKeyAlgo = curAuth.keyAlgos[0][0];
                if (debug)
                  debug(`Client: ${curAuth.type} (${oldKeyAlgo}) auth failed`);
                curAuth.keyAlgos.shift();
                if (curAuth.keyAlgos.length) {
                  const [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
                  switch (curAuth.type) {
                    case "agent":
                      proto.authPK(
                        curAuth.username,
                        curAuth.agentCtx.currentKey(),
                        keyAlgo
                      );
                      return;
                    case "publickey":
                      proto.authPK(curAuth.username, curAuth.key, keyAlgo);
                      return;
                    case "hostbased":
                      proto.authHostbased(
                        curAuth.username,
                        curAuth.key,
                        curAuth.localHostname,
                        curAuth.localUsername,
                        keyAlgo,
                        (buf, cb) => {
                          const signature = curAuth.key.sign(buf, hashAlgo);
                          if (signature instanceof Error) {
                            signature.message = `Error while signing with key: ${signature.message}`;
                            signature.level = "client-authentication";
                            this.emit("error", signature);
                            return tryNextAuth();
                          }
                          cb(signature);
                        }
                      );
                      return;
                  }
                } else {
                  curAuth.keyAlgos = void 0;
                }
              }
              if (curAuth.type === "agent") {
                const pos = curAuth.agentCtx.pos();
                debug && debug(`Client: Agent key #${pos + 1} failed`);
                return tryNextAgentKey();
              }
              debug && debug(`Client: ${curAuth.type} auth failed`);
              curPartial = partialSuccess;
              curAuthsLeft = authMethods;
              tryNextAuth();
            },
            USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {
              if (curAuth.type === "password") {
                this.emit("change password", prompt, (newPassword) => {
                  proto.authPassword(
                    this.config.username,
                    this.config.password,
                    newPassword
                  );
                });
              }
            },
            USERAUTH_PK_OK: (p) => {
              let keyAlgo;
              let hashAlgo;
              if (curAuth.keyAlgos)
                [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
              if (curAuth.type === "agent") {
                const key = curAuth.agentCtx.currentKey();
                proto.authPK(curAuth.username, key, keyAlgo, (buf, cb) => {
                  const opts = { hash: hashAlgo };
                  curAuth.agentCtx.sign(key, buf, opts, (err, signed) => {
                    if (err) {
                      err.level = "agent";
                      this.emit("error", err);
                    } else {
                      return cb(signed);
                    }
                    tryNextAgentKey();
                  });
                });
              } else if (curAuth.type === "publickey") {
                proto.authPK(curAuth.username, curAuth.key, keyAlgo, (buf, cb) => {
                  const signature = curAuth.key.sign(buf, hashAlgo);
                  if (signature instanceof Error) {
                    signature.message = `Error signing data with key: ${signature.message}`;
                    signature.level = "client-authentication";
                    this.emit("error", signature);
                    return tryNextAuth();
                  }
                  cb(signature);
                });
              }
            },
            USERAUTH_INFO_REQUEST: (p, name, instructions, prompts) => {
              if (curAuth.type === "keyboard-interactive") {
                const nprompts = Array.isArray(prompts) ? prompts.length : 0;
                if (nprompts === 0) {
                  debug && debug(
                    "Client: Sending automatic USERAUTH_INFO_RESPONSE"
                  );
                  proto.authInfoRes();
                  return;
                }
                curAuth.prompt(
                  name,
                  instructions,
                  "",
                  prompts,
                  (answers) => {
                    proto.authInfoRes(answers);
                  }
                );
              }
            },
            REQUEST_SUCCESS: (p, data) => {
              if (callbacks.length)
                callbacks.shift()(false, data);
            },
            REQUEST_FAILURE: (p) => {
              if (callbacks.length)
                callbacks.shift()(true);
            },
            GLOBAL_REQUEST: (p, name, wantReply, data) => {
              switch (name) {
                case "hostkeys-00@openssh.com":
                  hostKeysProve(this, data, (err, keys) => {
                    if (err)
                      return;
                    this.emit("hostkeys", keys);
                  });
                  if (wantReply)
                    proto.requestSuccess();
                  break;
                default:
                  if (wantReply)
                    proto.requestFailure();
              }
            },
            CHANNEL_OPEN: (p, info) => {
              onCHANNEL_OPEN(this, info);
            },
            CHANNEL_OPEN_CONFIRMATION: (p, info) => {
              const channel = this._chanMgr.get(info.recipient);
              if (typeof channel !== "function")
                return;
              const isSFTP = channel.type === "sftp";
              const type = isSFTP ? "session" : channel.type;
              const chanInfo = {
                type,
                incoming: {
                  id: info.recipient,
                  window: MAX_WINDOW,
                  packetSize: PACKET_SIZE,
                  state: "open"
                },
                outgoing: {
                  id: info.sender,
                  window: info.window,
                  packetSize: info.packetSize,
                  state: "open"
                }
              };
              const instance = isSFTP ? new SFTP(this, chanInfo, { debug }) : new Channel(this, chanInfo);
              this._chanMgr.update(info.recipient, instance);
              channel(void 0, instance);
            },
            CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "function")
                return;
              const info = { reason, description };
              onChannelOpenFailure(this, recipient, info, channel);
            },
            CHANNEL_DATA: (p, recipient, data) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.incoming.window === 0)
                return;
              channel.incoming.window -= data.length;
              if (channel.push(data) === false) {
                channel._waitChanDrain = true;
                return;
              }
              if (channel.incoming.window <= WINDOW_THRESHOLD)
                windowAdjust(channel);
            },
            CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {
              if (type !== STDERR)
                return;
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.incoming.window === 0)
                return;
              channel.incoming.window -= data.length;
              if (!channel.stderr.push(data)) {
                channel._waitChanDrain = true;
                return;
              }
              if (channel.incoming.window <= WINDOW_THRESHOLD)
                windowAdjust(channel);
            },
            CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              channel.outgoing.window += amount;
              if (channel._waitWindow) {
                channel._waitWindow = false;
                if (channel._chunk) {
                  channel._write(channel._chunk, null, channel._chunkcb);
                } else if (channel._chunkcb) {
                  channel._chunkcb();
                } else if (channel._chunkErr) {
                  channel.stderr._write(
                    channel._chunkErr,
                    null,
                    channel._chunkcbErr
                  );
                } else if (channel._chunkcbErr) {
                  channel._chunkcbErr();
                }
              }
            },
            CHANNEL_SUCCESS: (p, recipient) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              this._resetKA();
              if (channel._callbacks.length)
                channel._callbacks.shift()(false);
            },
            CHANNEL_FAILURE: (p, recipient) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              this._resetKA();
              if (channel._callbacks.length)
                channel._callbacks.shift()(true);
            },
            CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              const exit = channel._exit;
              if (exit.code !== void 0)
                return;
              switch (type) {
                case "exit-status":
                  channel.emit("exit", exit.code = data);
                  return;
                case "exit-signal":
                  channel.emit(
                    "exit",
                    exit.code = null,
                    exit.signal = `SIG${data.signal}`,
                    exit.dump = data.coreDumped,
                    exit.desc = data.errorMessage
                  );
                  return;
              }
              if (wantReply)
                p.channelFailure(channel.outgoing.id);
            },
            CHANNEL_EOF: (p, recipient) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.incoming.state !== "open")
                return;
              channel.incoming.state = "eof";
              if (channel.readable)
                channel.push(null);
              if (channel.stderr.readable)
                channel.stderr.push(null);
            },
            CHANNEL_CLOSE: (p, recipient) => {
              onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));
            }
          }
        });
        sock.pause();
        const kainterval = this.config.keepaliveInterval;
        const kacountmax = this.config.keepaliveCountMax;
        let kacount = 0;
        let katimer;
        const sendKA = () => {
          if (++kacount > kacountmax) {
            clearInterval(katimer);
            if (sock.readable) {
              const err = new Error("Keepalive timeout");
              err.level = "client-timeout";
              this.emit("error", err);
              sock.destroy();
            }
            return;
          }
          if (isWritable(sock)) {
            callbacks.push(resetKA);
            proto.ping();
          } else {
            clearInterval(katimer);
          }
        };
        function resetKA() {
          if (kainterval > 0) {
            kacount = 0;
            clearInterval(katimer);
            if (isWritable(sock))
              katimer = setInterval(sendKA, kainterval);
          }
        }
        this._resetKA = resetKA;
        const onDone = (() => {
          let called = false;
          return () => {
            if (called)
              return;
            called = true;
            if (wasConnected && !sawHeader) {
              const err = makeError("Connection lost before handshake", "protocol", true);
              this.emit("error", err);
            }
          };
        })();
        const onConnect = (() => {
          let called = false;
          return () => {
            if (called)
              return;
            called = true;
            wasConnected = true;
            debug && debug("Socket connected");
            this.emit("connect");
            cryptoInit.then(() => {
              proto.start();
              sock.on("data", (data) => {
                try {
                  proto.parse(data, 0, data.length);
                } catch (ex) {
                  this.emit("error", ex);
                  try {
                    if (isWritable(sock))
                      sock.end();
                  } catch {
                  }
                }
              });
              if (sock.stderr && typeof sock.stderr.resume === "function")
                sock.stderr.resume();
              sock.resume();
            }).catch((err) => {
              this.emit("error", err);
              try {
                if (isWritable(sock))
                  sock.end();
              } catch {
              }
            });
          };
        })();
        let wasConnected = false;
        sock.on("connect", onConnect).on("timeout", () => {
          this.emit("timeout");
        }).on("error", (err) => {
          debug && debug(`Socket error: ${err.message}`);
          clearTimeout(this._readyTimeout);
          err.level = "client-socket";
          this.emit("error", err);
        }).on("end", () => {
          debug && debug("Socket ended");
          onDone();
          proto.cleanup();
          clearTimeout(this._readyTimeout);
          clearInterval(katimer);
          this.emit("end");
        }).on("close", () => {
          debug && debug("Socket closed");
          onDone();
          proto.cleanup();
          clearTimeout(this._readyTimeout);
          clearInterval(katimer);
          this.emit("close");
          const callbacks_ = callbacks;
          callbacks = this._callbacks = [];
          const err = new Error("No response from server");
          for (let i = 0; i < callbacks_.length; ++i)
            callbacks_[i](err);
          this._chanMgr.cleanup(err);
        });
        let curAuth;
        let curPartial = null;
        let curAuthsLeft = null;
        const authsAllowed = ["none"];
        if (this.config.password !== void 0)
          authsAllowed.push("password");
        if (privateKey !== void 0)
          authsAllowed.push("publickey");
        if (this._agent !== void 0)
          authsAllowed.push("agent");
        if (this.config.tryKeyboard)
          authsAllowed.push("keyboard-interactive");
        if (privateKey !== void 0 && this.config.localHostname !== void 0 && this.config.localUsername !== void 0) {
          authsAllowed.push("hostbased");
        }
        if (Array.isArray(authHandler))
          authHandler = makeSimpleAuthHandler(authHandler);
        else if (typeof authHandler !== "function")
          authHandler = makeSimpleAuthHandler(authsAllowed);
        let hasSentAuth = false;
        const doNextAuth = (nextAuth) => {
          if (hasSentAuth)
            return;
          hasSentAuth = true;
          if (nextAuth === false) {
            const err = new Error("All configured authentication methods failed");
            err.level = "client-authentication";
            this.emit("error", err);
            this.end();
            return;
          }
          if (typeof nextAuth === "string") {
            const type = nextAuth;
            if (authsAllowed.indexOf(type) === -1)
              return skipAuth(`Authentication method not allowed: ${type}`);
            const username = this.config.username;
            switch (type) {
              case "password":
                nextAuth = { type, username, password: this.config.password };
                break;
              case "publickey":
                nextAuth = { type, username, key: privateKey };
                break;
              case "hostbased":
                nextAuth = {
                  type,
                  username,
                  key: privateKey,
                  localHostname: this.config.localHostname,
                  localUsername: this.config.localUsername
                };
                break;
              case "agent":
                nextAuth = {
                  type,
                  username,
                  agentCtx: new AgentContext(this._agent)
                };
                break;
              case "keyboard-interactive":
                nextAuth = {
                  type,
                  username,
                  prompt: (...args) => this.emit("keyboard-interactive", ...args)
                };
                break;
              case "none":
                nextAuth = { type, username };
                break;
              default:
                return skipAuth(
                  `Skipping unsupported authentication method: ${nextAuth}`
                );
            }
          } else if (typeof nextAuth !== "object" || nextAuth === null) {
            return skipAuth(
              `Skipping invalid authentication attempt: ${nextAuth}`
            );
          } else {
            const username = nextAuth.username;
            if (typeof username !== "string") {
              return skipAuth(
                `Skipping invalid authentication attempt: ${nextAuth}`
              );
            }
            const type = nextAuth.type;
            switch (type) {
              case "password": {
                const { password } = nextAuth;
                if (typeof password !== "string" && !Buffer.isBuffer(password))
                  return skipAuth("Skipping invalid password auth attempt");
                nextAuth = { type, username, password };
                break;
              }
              case "publickey": {
                const key = parseKey(nextAuth.key, nextAuth.passphrase);
                if (key instanceof Error)
                  return skipAuth("Skipping invalid key auth attempt");
                if (!key.isPrivateKey())
                  return skipAuth("Skipping non-private key");
                nextAuth = { type, username, key };
                break;
              }
              case "hostbased": {
                const { localHostname, localUsername } = nextAuth;
                const key = parseKey(nextAuth.key, nextAuth.passphrase);
                if (key instanceof Error || typeof localHostname !== "string" || typeof localUsername !== "string") {
                  return skipAuth("Skipping invalid hostbased auth attempt");
                }
                if (!key.isPrivateKey())
                  return skipAuth("Skipping non-private key");
                nextAuth = { type, username, key, localHostname, localUsername };
                break;
              }
              case "agent": {
                let agent = nextAuth.agent;
                if (typeof agent === "string" && agent.length) {
                  agent = createAgent(agent);
                } else if (!isAgent(agent)) {
                  return skipAuth(
                    `Skipping invalid agent: ${nextAuth.agent}`
                  );
                }
                nextAuth = { type, username, agentCtx: new AgentContext(agent) };
                break;
              }
              case "keyboard-interactive": {
                const { prompt } = nextAuth;
                if (typeof prompt !== "function") {
                  return skipAuth(
                    "Skipping invalid keyboard-interactive auth attempt"
                  );
                }
                nextAuth = { type, username, prompt };
                break;
              }
              case "none":
                nextAuth = { type, username };
                break;
              default:
                return skipAuth(
                  `Skipping unsupported authentication method: ${nextAuth}`
                );
            }
          }
          curAuth = nextAuth;
          try {
            const username = curAuth.username;
            switch (curAuth.type) {
              case "password":
                proto.authPassword(username, curAuth.password);
                break;
              case "publickey": {
                let keyAlgo;
                curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);
                if (curAuth.keyAlgos) {
                  if (curAuth.keyAlgos.length) {
                    keyAlgo = curAuth.keyAlgos[0][0];
                  } else {
                    return skipAuth(
                      "Skipping key authentication (no mutual hash algorithm)"
                    );
                  }
                }
                proto.authPK(username, curAuth.key, keyAlgo);
                break;
              }
              case "hostbased": {
                let keyAlgo;
                let hashAlgo;
                curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);
                if (curAuth.keyAlgos) {
                  if (curAuth.keyAlgos.length) {
                    [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
                  } else {
                    return skipAuth(
                      "Skipping hostbased authentication (no mutual hash algorithm)"
                    );
                  }
                }
                proto.authHostbased(
                  username,
                  curAuth.key,
                  curAuth.localHostname,
                  curAuth.localUsername,
                  keyAlgo,
                  (buf, cb) => {
                    const signature = curAuth.key.sign(buf, hashAlgo);
                    if (signature instanceof Error) {
                      signature.message = `Error while signing with key: ${signature.message}`;
                      signature.level = "client-authentication";
                      this.emit("error", signature);
                      return tryNextAuth();
                    }
                    cb(signature);
                  }
                );
                break;
              }
              case "agent":
                curAuth.agentCtx.init((err) => {
                  if (err) {
                    err.level = "agent";
                    this.emit("error", err);
                    return tryNextAuth();
                  }
                  tryNextAgentKey();
                });
                break;
              case "keyboard-interactive":
                proto.authKeyboard(username);
                break;
              case "none":
                proto.authNone(username);
                break;
            }
          } finally {
            hasSentAuth = false;
          }
        };
        function skipAuth(msg) {
          debug && debug(msg);
          process.nextTick(tryNextAuth);
        }
        function tryNextAuth() {
          hasSentAuth = false;
          const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);
          if (hasSentAuth || auth === void 0)
            return;
          doNextAuth(auth);
        }
        const tryNextAgentKey = () => {
          if (curAuth.type === "agent") {
            const key = curAuth.agentCtx.nextKey();
            if (key === false) {
              debug && debug("Agent: No more keys left to try");
              debug && debug("Client: agent auth failed");
              tryNextAuth();
            } else {
              const pos = curAuth.agentCtx.pos();
              let keyAlgo;
              curAuth.keyAlgos = getKeyAlgos(this, key, serverSigAlgs);
              if (curAuth.keyAlgos) {
                if (curAuth.keyAlgos.length) {
                  keyAlgo = curAuth.keyAlgos[0][0];
                } else {
                  debug && debug(
                    `Agent: Skipping key #${pos + 1} (no mutual hash algorithm)`
                  );
                  tryNextAgentKey();
                  return;
                }
              }
              debug && debug(`Agent: Trying key #${pos + 1}`);
              proto.authPK(curAuth.username, key, keyAlgo);
            }
          }
        };
        const startTimeout = () => {
          if (this.config.readyTimeout > 0) {
            this._readyTimeout = setTimeout(() => {
              const err = new Error("Timed out while waiting for handshake");
              err.level = "client-timeout";
              this.emit("error", err);
              sock.destroy();
            }, this.config.readyTimeout);
          }
        };
        if (!cfg.sock) {
          let host = this.config.host;
          const forceIPv4 = this.config.forceIPv4;
          const forceIPv6 = this.config.forceIPv6;
          debug && debug(`Client: Trying ${host} on port ${this.config.port} ...`);
          const doConnect = () => {
            startTimeout();
            sock.connect({
              host,
              port: this.config.port,
              localAddress: this.config.localAddress,
              localPort: this.config.localPort
            });
            sock.setMaxListeners(0);
            sock.setTimeout(typeof cfg.timeout === "number" ? cfg.timeout : 0);
          };
          if (!forceIPv4 && !forceIPv6 || forceIPv4 && forceIPv6) {
            doConnect();
          } else {
            dnsLookup(host, forceIPv4 ? 4 : 6, (err, address, family) => {
              if (err) {
                const type = forceIPv4 ? "IPv4" : "IPv6";
                const error = new Error(
                  `Error while looking up ${type} address for '${host}': ${err}`
                );
                clearTimeout(this._readyTimeout);
                error.level = "client-dns";
                this.emit("error", error);
                this.emit("close");
                return;
              }
              host = address;
              doConnect();
            });
          }
        } else {
          startTimeout();
          if (typeof sock.connecting === "boolean") {
            if (!sock.connecting) {
              onConnect();
            }
          } else {
            onConnect();
          }
        }
        return this;
      }
      end() {
        if (this._sock && isWritable(this._sock)) {
          this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);
          this._sock.end();
        }
        return this;
      }
      destroy() {
        this._sock && isWritable(this._sock) && this._sock.destroy();
        return this;
      }
      exec(cmd, opts, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        const extraOpts = { allowHalfOpen: opts.allowHalfOpen !== false };
        openChannel(this, "session", extraOpts, (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          const todo = [];
          function reqCb(err2) {
            if (err2) {
              chan.close();
              cb(err2);
              return;
            }
            if (todo.length)
              todo.shift()();
          }
          if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== void 0) {
            todo.push(() => reqAgentFwd(chan, reqCb));
          }
          if (typeof opts === "object" && opts !== null) {
            if (typeof opts.env === "object" && opts.env !== null)
              reqEnv(chan, opts.env);
            if (typeof opts.pty === "object" && opts.pty !== null || opts.pty === true) {
              todo.push(() => reqPty(chan, opts.pty, reqCb));
            }
            if (typeof opts.x11 === "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === true) {
              todo.push(() => reqX11(chan, opts.x11, reqCb));
            }
          }
          todo.push(() => reqExec(chan, cmd, opts, cb));
          todo.shift()();
        });
        return this;
      }
      shell(wndopts, opts, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        if (typeof wndopts === "function") {
          cb = wndopts;
          wndopts = opts = void 0;
        } else if (typeof opts === "function") {
          cb = opts;
          opts = void 0;
        }
        if (wndopts && (wndopts.x11 !== void 0 || wndopts.env !== void 0)) {
          opts = wndopts;
          wndopts = void 0;
        }
        openChannel(this, "session", (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          const todo = [];
          function reqCb(err2) {
            if (err2) {
              chan.close();
              cb(err2);
              return;
            }
            if (todo.length)
              todo.shift()();
          }
          if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== void 0) {
            todo.push(() => reqAgentFwd(chan, reqCb));
          }
          if (wndopts !== false)
            todo.push(() => reqPty(chan, wndopts, reqCb));
          if (typeof opts === "object" && opts !== null) {
            if (typeof opts.env === "object" && opts.env !== null)
              reqEnv(chan, opts.env);
            if (typeof opts.x11 === "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === true) {
              todo.push(() => reqX11(chan, opts.x11, reqCb));
            }
          }
          todo.push(() => reqShell(chan, cb));
          todo.shift()();
        });
        return this;
      }
      subsys(name, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        openChannel(this, "session", (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          reqSubsystem(chan, name, (err2, stream) => {
            if (err2) {
              cb(err2);
              return;
            }
            cb(void 0, stream);
          });
        });
        return this;
      }
      forwardIn(bindAddr, bindPort, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (wantReply) {
          this._callbacks.push((had_err, data) => {
            if (had_err) {
              cb(had_err !== true ? had_err : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));
              return;
            }
            let realPort = bindPort;
            if (bindPort === 0 && data && data.length >= 4) {
              realPort = readUInt32BE(data, 0);
              if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG))
                bindPort = realPort;
            }
            this._forwarding[`${bindAddr}:${bindPort}`] = realPort;
            cb(void 0, realPort);
          });
        }
        this._protocol.tcpipForward(bindAddr, bindPort, wantReply);
        return this;
      }
      unforwardIn(bindAddr, bindPort, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (wantReply) {
          this._callbacks.push((had_err) => {
            if (had_err) {
              cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));
              return;
            }
            delete this._forwarding[`${bindAddr}:${bindPort}`];
            cb();
          });
        }
        this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);
        return this;
      }
      forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const cfg = {
          srcIP,
          srcPort,
          dstIP,
          dstPort
        };
        if (typeof cb !== "function")
          cb = noop;
        openChannel(this, "direct-tcpip", cfg, cb);
        return this;
      }
      openssh_noMoreSessions(cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error("Unable to disable future sessions"));
                return;
              }
              cb();
            });
          }
          this._protocol.openssh_noMoreSessions(wantReply);
          return this;
        }
        if (!wantReply)
          return this;
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      openssh_forwardInStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error(`Unable to bind to ${socketPath}`));
                return;
              }
              this._forwardingUnix[socketPath] = true;
              cb();
            });
          }
          this._protocol.openssh_streamLocalForward(socketPath, wantReply);
          return this;
        }
        if (!wantReply)
          return this;
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      openssh_unforwardInStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${socketPath}`));
                return;
              }
              delete this._forwardingUnix[socketPath];
              cb();
            });
          }
          this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);
          return this;
        }
        if (!wantReply)
          return this;
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      openssh_forwardOutStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        if (typeof cb !== "function")
          cb = noop;
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          openChannel(this, "direct-streamlocal@openssh.com", { socketPath }, cb);
          return this;
        }
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      sftp(cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        openChannel(this, "sftp", (err, sftp) => {
          if (err) {
            cb(err);
            return;
          }
          reqSubsystem(sftp, "sftp", (err2, sftp_) => {
            if (err2) {
              cb(err2);
              return;
            }
            function removeListeners() {
              sftp.removeListener("ready", onReady);
              sftp.removeListener("error", onError);
              sftp.removeListener("exit", onExit);
              sftp.removeListener("close", onExit);
            }
            function onReady() {
              removeListeners();
              cb(void 0, sftp);
            }
            function onError(err3) {
              removeListeners();
              cb(err3);
            }
            function onExit(code, signal) {
              removeListeners();
              let msg;
              if (typeof code === "number")
                msg = `Received exit code ${code} while establishing SFTP session`;
              else if (signal !== void 0)
                msg = `Received signal ${signal} while establishing SFTP session`;
              else
                msg = "Received unexpected SFTP session termination";
              const err3 = new Error(msg);
              err3.code = code;
              err3.signal = signal;
              cb(err3);
            }
            sftp.on("ready", onReady).on("error", onError).on("exit", onExit).on("close", onExit);
            sftp._init();
          });
        });
        return this;
      }
      setNoDelay(noDelay) {
        if (this._sock && typeof this._sock.setNoDelay === "function")
          this._sock.setNoDelay(noDelay);
        return this;
      }
    };
    function openChannel(self2, type, opts, cb) {
      const initWindow = MAX_WINDOW;
      const maxPacket = PACKET_SIZE;
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const wrapper = (err, stream) => {
        cb(err, stream);
      };
      wrapper.type = type;
      const localChan = self2._chanMgr.add(wrapper);
      if (localChan === -1) {
        cb(new Error("No free channels available"));
        return;
      }
      switch (type) {
        case "session":
        case "sftp":
          self2._protocol.session(localChan, initWindow, maxPacket);
          break;
        case "direct-tcpip":
          self2._protocol.directTcpip(localChan, initWindow, maxPacket, opts);
          break;
        case "direct-streamlocal@openssh.com":
          self2._protocol.openssh_directStreamLocal(
            localChan,
            initWindow,
            maxPacket,
            opts
          );
          break;
        default:
          throw new Error(`Unsupported channel type: ${type}`);
      }
    }
    function reqX11(chan, screen, cb) {
      const cfg = {
        single: false,
        protocol: "MIT-MAGIC-COOKIE-1",
        cookie: void 0,
        screen: 0
      };
      if (typeof screen === "function") {
        cb = screen;
      } else if (typeof screen === "object" && screen !== null) {
        if (typeof screen.single === "boolean")
          cfg.single = screen.single;
        if (typeof screen.screen === "number")
          cfg.screen = screen.screen;
        if (typeof screen.protocol === "string")
          cfg.protocol = screen.protocol;
        if (typeof screen.cookie === "string")
          cfg.cookie = screen.cookie;
        else if (Buffer.isBuffer(screen.cookie))
          cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);
      }
      if (cfg.cookie === void 0)
        cfg.cookie = randomCookie();
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        if (wantReply)
          cb(new Error("Channel is not open"));
        return;
      }
      if (wantReply) {
        chan._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Unable to request X11"));
            return;
          }
          chan._hasX11 = true;
          ++chan._client._acceptX11;
          chan.once("close", () => {
            if (chan._client._acceptX11)
              --chan._client._acceptX11;
          });
          cb();
        });
      }
      chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);
    }
    function reqPty(chan, opts, cb) {
      let rows = 24;
      let cols = 80;
      let width = 640;
      let height = 480;
      let term = "vt100";
      let modes = null;
      if (typeof opts === "function") {
        cb = opts;
      } else if (typeof opts === "object" && opts !== null) {
        if (typeof opts.rows === "number")
          rows = opts.rows;
        if (typeof opts.cols === "number")
          cols = opts.cols;
        if (typeof opts.width === "number")
          width = opts.width;
        if (typeof opts.height === "number")
          height = opts.height;
        if (typeof opts.term === "string")
          term = opts.term;
        if (typeof opts.modes === "object")
          modes = opts.modes;
      }
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        if (wantReply)
          cb(new Error("Channel is not open"));
        return;
      }
      if (wantReply) {
        chan._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Unable to request a pseudo-terminal"));
            return;
          }
          cb();
        });
      }
      chan._client._protocol.pty(
        chan.outgoing.id,
        rows,
        cols,
        height,
        width,
        term,
        modes,
        wantReply
      );
    }
    function reqAgentFwd(chan, cb) {
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        wantReply && cb(new Error("Channel is not open"));
        return;
      }
      if (chan._client._agentFwdEnabled) {
        wantReply && cb(false);
        return;
      }
      chan._client._agentFwdEnabled = true;
      chan._callbacks.push((had_err) => {
        if (had_err) {
          chan._client._agentFwdEnabled = false;
          if (wantReply) {
            cb(had_err !== true ? had_err : new Error("Unable to request agent forwarding"));
          }
          return;
        }
        if (wantReply)
          cb();
      });
      chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);
    }
    function reqShell(chan, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error("Unable to open shell"));
          return;
        }
        chan.subtype = "shell";
        cb(void 0, chan);
      });
      chan._client._protocol.shell(chan.outgoing.id, true);
    }
    function reqExec(chan, cmd, opts, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error("Unable to exec"));
          return;
        }
        chan.subtype = "exec";
        chan.allowHalfOpen = opts.allowHalfOpen !== false;
        cb(void 0, chan);
      });
      chan._client._protocol.exec(chan.outgoing.id, cmd, true);
    }
    function reqEnv(chan, env) {
      if (chan.outgoing.state !== "open")
        return;
      const keys = Object.keys(env || {});
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const val = env[key];
        chan._client._protocol.env(chan.outgoing.id, key, val, false);
      }
    }
    function reqSubsystem(chan, name, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error(`Unable to start subsystem: ${name}`));
          return;
        }
        chan.subtype = "subsystem";
        cb(void 0, chan);
      });
      chan._client._protocol.subsystem(chan.outgoing.id, name, true);
    }
    function onCHANNEL_OPEN(self2, info) {
      let localChan = -1;
      let reason;
      const accept = () => {
        const chanInfo = {
          type: info.type,
          incoming: {
            id: localChan,
            window: MAX_WINDOW,
            packetSize: PACKET_SIZE,
            state: "open"
          },
          outgoing: {
            id: info.sender,
            window: info.window,
            packetSize: info.packetSize,
            state: "open"
          }
        };
        const stream = new Channel(self2, chanInfo);
        self2._chanMgr.update(localChan, stream);
        self2._protocol.channelOpenConfirm(
          info.sender,
          localChan,
          MAX_WINDOW,
          PACKET_SIZE
        );
        return stream;
      };
      const reject = () => {
        if (reason === void 0) {
          if (localChan === -1)
            reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
          else
            reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;
        }
        if (localChan !== -1)
          self2._chanMgr.remove(localChan);
        self2._protocol.channelOpenFail(info.sender, reason, "");
      };
      const reserveChannel = () => {
        localChan = self2._chanMgr.add();
        if (localChan === -1) {
          reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
          if (self2.config.debug) {
            self2.config.debug(
              "Client: Automatic rejection of incoming channel open: no channels available"
            );
          }
        }
        return localChan !== -1;
      };
      const data = info.data;
      switch (info.type) {
        case "forwarded-tcpip": {
          const val = self2._forwarding[`${data.destIP}:${data.destPort}`];
          if (val !== void 0 && reserveChannel()) {
            if (data.destPort === 0)
              data.destPort = val;
            self2.emit("tcp connection", data, accept, reject);
            return;
          }
          break;
        }
        case "forwarded-streamlocal@openssh.com":
          if (self2._forwardingUnix[data.socketPath] !== void 0 && reserveChannel()) {
            self2.emit("unix connection", data, accept, reject);
            return;
          }
          break;
        case "auth-agent@openssh.com":
          if (self2._agentFwdEnabled && typeof self2._agent.getStream === "function" && reserveChannel()) {
            self2._agent.getStream((err, stream) => {
              if (err)
                return reject();
              const upstream = accept();
              upstream.pipe(stream).pipe(upstream);
            });
            return;
          }
          break;
        case "x11":
          if (self2._acceptX11 !== 0 && reserveChannel()) {
            self2.emit("x11", data, accept, reject);
            return;
          }
          break;
        default:
          reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;
          if (self2.config.debug) {
            self2.config.debug(
              `Client: Automatic rejection of unsupported incoming channel open type: ${info.type}`
            );
          }
      }
      if (reason === void 0) {
        reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
        if (self2.config.debug) {
          self2.config.debug(
            "Client: Automatic rejection of unexpected incoming channel open for: " + info.type
          );
        }
      }
      reject();
    }
    var randomCookie = (() => {
      const buffer = Buffer.allocUnsafe(16);
      return () => {
        randomFillSync(buffer, 0, 16);
        return buffer.hexSlice(0, 16);
      };
    })();
    function makeSimpleAuthHandler(authList) {
      if (!Array.isArray(authList))
        throw new Error("authList must be an array");
      let a = 0;
      return (authsLeft, partialSuccess, cb) => {
        if (a === authList.length)
          return false;
        return authList[a++];
      };
    }
    function hostKeysProve(client, keys_, cb) {
      if (!client._sock || !isWritable(client._sock))
        return;
      if (typeof cb !== "function")
        cb = noop;
      if (!Array.isArray(keys_))
        throw new TypeError("Invalid keys argument type");
      const keys = [];
      for (const key of keys_) {
        const parsed = parseKey(key);
        if (parsed instanceof Error)
          throw parsed;
        keys.push(parsed);
      }
      if (!client.config.strictVendor || client.config.strictVendor && RE_OPENSSH.test(client._remoteVer)) {
        client._callbacks.push((had_err, data) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Server failed to prove supplied keys"));
            return;
          }
          const ret = [];
          let keyIdx = 0;
          bufferParser.init(data, 0);
          while (bufferParser.avail()) {
            if (keyIdx === keys.length)
              break;
            const key = keys[keyIdx++];
            const keyPublic = key.getPublicSSH();
            const sigEntry = bufferParser.readString();
            sigParser.init(sigEntry, 0);
            const type = sigParser.readString(true);
            let value = sigParser.readString();
            let algo;
            if (type !== key.type) {
              if (key.type === "ssh-rsa") {
                switch (type) {
                  case "rsa-sha2-256":
                    algo = "sha256";
                    break;
                  case "rsa-sha2-512":
                    algo = "sha512";
                    break;
                  default:
                    continue;
                }
              } else {
                continue;
              }
            }
            const sessionID = client._protocol._kex.sessionID;
            const verifyData = Buffer.allocUnsafe(
              4 + 29 + 4 + sessionID.length + 4 + keyPublic.length
            );
            let p = 0;
            writeUInt32BE(verifyData, 29, p);
            verifyData.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29);
            writeUInt32BE(verifyData, sessionID.length, p += 29);
            bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);
            writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);
            bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);
            if (!(value = sigSSHToASN1(value, type)))
              continue;
            if (key.verify(verifyData, value, algo) === true)
              ret.push(key);
          }
          sigParser.clear();
          bufferParser.clear();
          cb(null, ret);
        });
        client._protocol.openssh_hostKeysProve(keys);
        return;
      }
      process.nextTick(
        cb,
        new Error(
          "strictVendor enabled and server is not OpenSSH or compatible version"
        )
      );
    }
    function getKeyAlgos(client, key, serverSigAlgs) {
      switch (key.type) {
        case "ssh-rsa":
          if (client._protocol._compatFlags & COMPAT.IMPLY_RSA_SHA2_SIGALGS) {
            if (!Array.isArray(serverSigAlgs))
              serverSigAlgs = ["rsa-sha2-256", "rsa-sha2-512"];
            else
              serverSigAlgs = ["rsa-sha2-256", "rsa-sha2-512", ...serverSigAlgs];
          }
          if (Array.isArray(serverSigAlgs)) {
            if (serverSigAlgs.indexOf("rsa-sha2-256") !== -1)
              return [["rsa-sha2-256", "sha256"]];
            if (serverSigAlgs.indexOf("rsa-sha2-512") !== -1)
              return [["rsa-sha2-512", "sha512"]];
            if (serverSigAlgs.indexOf("ssh-rsa") === -1)
              return [];
          }
          return [["ssh-rsa", "sha1"]];
      }
    }
    module2.exports = Client2;
  }
});

// node_modules/ssh2/lib/http-agents.js
var require_http_agents = __commonJS({
  "node_modules/ssh2/lib/http-agents.js"(exports) {
    "use strict";
    var { Agent: HttpAgent } = require("http");
    var { Agent: HttpsAgent } = require("https");
    var { connect: tlsConnect } = require("tls");
    var Client2;
    for (const ctor of [HttpAgent, HttpsAgent]) {
      class SSHAgent extends ctor {
        constructor(connectCfg, agentOptions) {
          super(agentOptions);
          this._connectCfg = connectCfg;
          this._defaultSrcIP = agentOptions && agentOptions.srcIP || "localhost";
        }
        createConnection(options, cb) {
          const srcIP = options && options.localAddress || this._defaultSrcIP;
          const srcPort = options && options.localPort || 0;
          const dstIP = options.host;
          const dstPort = options.port;
          if (Client2 === void 0)
            Client2 = require_client();
          const client = new Client2();
          let triedForward = false;
          client.on("ready", () => {
            client.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream) => {
              triedForward = true;
              if (err) {
                client.end();
                return cb(err);
              }
              stream.once("close", () => client.end());
              cb(null, decorateStream(stream, ctor, options));
            });
          }).on("error", cb).on("close", () => {
            if (!triedForward)
              cb(new Error("Unexpected connection close"));
          }).connect(this._connectCfg);
        }
      }
      exports[ctor === HttpAgent ? "SSHTTPAgent" : "SSHTTPSAgent"] = SSHAgent;
    }
    function noop() {
    }
    function decorateStream(stream, ctor, options) {
      if (ctor === HttpAgent) {
        stream.setKeepAlive = noop;
        stream.setNoDelay = noop;
        stream.setTimeout = noop;
        stream.ref = noop;
        stream.unref = noop;
        stream.destroySoon = stream.destroy;
        return stream;
      }
      options.socket = stream;
      const wrapped = tlsConnect(options);
      const onClose = (() => {
        let called = false;
        return () => {
          if (called)
            return;
          called = true;
          if (stream.isPaused())
            stream.resume();
        };
      })();
      wrapped.on("end", onClose).on("close", onClose);
      return wrapped;
    }
  }
});

// node_modules/ssh2/lib/server.js
var require_server = __commonJS({
  "node_modules/ssh2/lib/server.js"(exports, module2) {
    "use strict";
    var { Server: netServer } = require("net");
    var EventEmitter = require("events");
    var { listenerCount } = EventEmitter;
    var {
      CHANNEL_OPEN_FAILURE,
      DEFAULT_CIPHER,
      DEFAULT_COMPRESSION,
      DEFAULT_KEX,
      DEFAULT_MAC,
      DEFAULT_SERVER_HOST_KEY,
      DISCONNECT_REASON,
      DISCONNECT_REASON_BY_VALUE,
      SUPPORTED_CIPHER,
      SUPPORTED_COMPRESSION,
      SUPPORTED_KEX,
      SUPPORTED_MAC,
      SUPPORTED_SERVER_HOST_KEY
    } = require_constants();
    var { init: cryptoInit } = require_crypto();
    var { KexInit } = require_kex();
    var { parseKey } = require_keyParser();
    var Protocol = require_Protocol();
    var { SFTP } = require_SFTP();
    var { writeUInt32BE } = require_utils();
    var {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    } = require_Channel();
    var {
      ChannelManager,
      generateAlgorithmList,
      isWritable,
      onChannelOpenFailure,
      onCHANNEL_CLOSE
    } = require_utils2();
    var MAX_PENDING_AUTHS = 10;
    var AuthContext = class extends EventEmitter {
      constructor(protocol, username, service, method, cb) {
        super();
        this.username = this.user = username;
        this.service = service;
        this.method = method;
        this._initialResponse = false;
        this._finalResponse = false;
        this._multistep = false;
        this._cbfinal = (allowed, methodsLeft, isPartial) => {
          if (!this._finalResponse) {
            this._finalResponse = true;
            cb(this, allowed, methodsLeft, isPartial);
          }
        };
        this._protocol = protocol;
      }
      accept() {
        this._cleanup && this._cleanup();
        this._initialResponse = true;
        this._cbfinal(true);
      }
      reject(methodsLeft, isPartial) {
        this._cleanup && this._cleanup();
        this._initialResponse = true;
        this._cbfinal(false, methodsLeft, isPartial);
      }
    };
    var KeyboardAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, submethods, cb) {
        super(protocol, username, service, method, cb);
        this._multistep = true;
        this._cb = void 0;
        this._onInfoResponse = (responses) => {
          const callback = this._cb;
          if (callback) {
            this._cb = void 0;
            callback(responses);
          }
        };
        this.submethods = submethods;
        this.on("abort", () => {
          this._cb && this._cb(new Error("Authentication request aborted"));
        });
      }
      prompt(prompts, title, instructions, cb) {
        if (!Array.isArray(prompts))
          prompts = [prompts];
        if (typeof title === "function") {
          cb = title;
          title = instructions = void 0;
        } else if (typeof instructions === "function") {
          cb = instructions;
          instructions = void 0;
        } else if (typeof cb !== "function") {
          cb = void 0;
        }
        for (let i = 0; i < prompts.length; ++i) {
          if (typeof prompts[i] === "string") {
            prompts[i] = {
              prompt: prompts[i],
              echo: true
            };
          }
        }
        this._cb = cb;
        this._initialResponse = true;
        this._protocol.authInfoReq(title, instructions, prompts);
      }
    };
    var PKAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, pkInfo, cb) {
        super(protocol, username, service, method, cb);
        this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };
        this.hashAlgo = pkInfo.hashAlgo;
        this.signature = pkInfo.signature;
        this.blob = pkInfo.blob;
      }
      accept() {
        if (!this.signature) {
          this._initialResponse = true;
          this._protocol.authPKOK(this.key.algo, this.key.data);
        } else {
          AuthContext.prototype.accept.call(this);
        }
      }
    };
    var HostbasedAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, pkInfo, cb) {
        super(protocol, username, service, method, cb);
        this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };
        this.hashAlgo = pkInfo.hashAlgo;
        this.signature = pkInfo.signature;
        this.blob = pkInfo.blob;
        this.localHostname = pkInfo.localHostname;
        this.localUsername = pkInfo.localUsername;
      }
    };
    var PwdAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, password, cb) {
        super(protocol, username, service, method, cb);
        this.password = password;
        this._changeCb = void 0;
      }
      requestChange(prompt, cb) {
        if (this._changeCb)
          throw new Error("Change request already in progress");
        if (typeof prompt !== "string")
          throw new Error("prompt argument must be a string");
        if (typeof cb !== "function")
          throw new Error("Callback argument must be a function");
        this._changeCb = cb;
        this._protocol.authPasswdChg(prompt);
      }
    };
    var Session = class extends EventEmitter {
      constructor(client, info, localChan) {
        super();
        this.type = "session";
        this.subtype = void 0;
        this.server = true;
        this._ending = false;
        this._channel = void 0;
        this._chanInfo = {
          type: "session",
          incoming: {
            id: localChan,
            window: MAX_WINDOW,
            packetSize: PACKET_SIZE,
            state: "open"
          },
          outgoing: {
            id: info.sender,
            window: info.window,
            packetSize: info.packetSize,
            state: "open"
          }
        };
      }
    };
    var Server = class extends EventEmitter {
      constructor(cfg, listener) {
        super();
        if (typeof cfg !== "object" || cfg === null)
          throw new Error("Missing configuration object");
        const hostKeys = /* @__PURE__ */ Object.create(null);
        const hostKeyAlgoOrder = [];
        const hostKeys_ = cfg.hostKeys;
        if (!Array.isArray(hostKeys_))
          throw new Error("hostKeys must be an array");
        const cfgAlgos = typeof cfg.algorithms === "object" && cfg.algorithms !== null ? cfg.algorithms : {};
        const hostKeyAlgos = generateAlgorithmList(
          cfgAlgos.serverHostKey,
          DEFAULT_SERVER_HOST_KEY,
          SUPPORTED_SERVER_HOST_KEY
        );
        for (let i = 0; i < hostKeys_.length; ++i) {
          let privateKey;
          if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === "string")
            privateKey = parseKey(hostKeys_[i]);
          else
            privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);
          if (privateKey instanceof Error)
            throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
          if (Array.isArray(privateKey)) {
            privateKey = privateKey[0];
          }
          if (privateKey.getPrivatePEM() === null)
            throw new Error("privateKey value contains an invalid private key");
          if (hostKeyAlgoOrder.includes(privateKey.type))
            continue;
          if (privateKey.type === "ssh-rsa") {
            let sha1Pos = hostKeyAlgos.indexOf("ssh-rsa");
            const sha256Pos = hostKeyAlgos.indexOf("rsa-sha2-256");
            const sha512Pos = hostKeyAlgos.indexOf("rsa-sha2-512");
            if (sha1Pos === -1) {
              sha1Pos = Infinity;
            }
            [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach((pos) => {
              if (pos === -1)
                return;
              let type;
              switch (pos) {
                case sha1Pos:
                  type = "ssh-rsa";
                  break;
                case sha256Pos:
                  type = "rsa-sha2-256";
                  break;
                case sha512Pos:
                  type = "rsa-sha2-512";
                  break;
                default:
                  return;
              }
              hostKeys[type] = privateKey;
              hostKeyAlgoOrder.push(type);
            });
          } else {
            hostKeys[privateKey.type] = privateKey;
            hostKeyAlgoOrder.push(privateKey.type);
          }
        }
        const algorithms = {
          kex: generateAlgorithmList(cfgAlgos.kex, DEFAULT_KEX, SUPPORTED_KEX),
          serverHostKey: hostKeyAlgoOrder,
          cs: {
            cipher: generateAlgorithmList(
              cfgAlgos.cipher,
              DEFAULT_CIPHER,
              SUPPORTED_CIPHER
            ),
            mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),
            compress: generateAlgorithmList(
              cfgAlgos.compress,
              DEFAULT_COMPRESSION,
              SUPPORTED_COMPRESSION
            ),
            lang: []
          },
          sc: void 0
        };
        algorithms.sc = algorithms.cs;
        if (typeof listener === "function")
          this.on("connection", listener);
        const origDebug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        const ident = cfg.ident ? Buffer.from(cfg.ident) : void 0;
        const offer = new KexInit(algorithms);
        this._srv = new netServer((socket) => {
          if (this._connections >= this.maxConnections) {
            socket.destroy();
            return;
          }
          ++this._connections;
          socket.once("close", () => {
            --this._connections;
          });
          let debug;
          if (origDebug) {
            const debugPrefix = `[${process.hrtime().join(".")}] `;
            debug = (msg) => {
              origDebug(`${debugPrefix}${msg}`);
            };
          }
          new Client2(socket, hostKeys, ident, offer, debug, this, cfg);
        }).on("error", (err) => {
          this.emit("error", err);
        }).on("listening", () => {
          this.emit("listening");
        }).on("close", () => {
          this.emit("close");
        });
        this._connections = 0;
        this.maxConnections = Infinity;
      }
      injectSocket(socket) {
        this._srv.emit("connection", socket);
      }
      listen(...args) {
        this._srv.listen(...args);
        return this;
      }
      address() {
        return this._srv.address();
      }
      getConnections(cb) {
        this._srv.getConnections(cb);
        return this;
      }
      close(cb) {
        this._srv.close(cb);
        return this;
      }
      ref() {
        this._srv.ref();
        return this;
      }
      unref() {
        this._srv.unref();
        return this;
      }
    };
    Server.KEEPALIVE_CLIENT_INTERVAL = 15e3;
    Server.KEEPALIVE_CLIENT_COUNT_MAX = 3;
    var Client2 = class extends EventEmitter {
      constructor(socket, hostKeys, ident, offer, debug, server, srvCfg) {
        super();
        let exchanges = 0;
        let acceptedAuthSvc = false;
        let pendingAuths = [];
        let authCtx;
        let kaTimer;
        let onPacket;
        const unsentGlobalRequestsReplies = [];
        this._sock = socket;
        this._chanMgr = new ChannelManager(this);
        this._debug = debug;
        this.noMoreSessions = false;
        this.authenticated = false;
        function onClientPreHeaderError(err) {
        }
        this.on("error", onClientPreHeaderError);
        const DEBUG_HANDLER = !debug ? void 0 : (p, display, msg) => {
          debug(`Debug output from client: ${JSON.stringify(msg)}`);
        };
        const kaIntvl = typeof srvCfg.keepaliveInterval === "number" && isFinite(srvCfg.keepaliveInterval) && srvCfg.keepaliveInterval > 0 ? srvCfg.keepaliveInterval : typeof Server.KEEPALIVE_CLIENT_INTERVAL === "number" && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL) && Server.KEEPALIVE_CLIENT_INTERVAL > 0 ? Server.KEEPALIVE_CLIENT_INTERVAL : -1;
        const kaCountMax = typeof srvCfg.keepaliveCountMax === "number" && isFinite(srvCfg.keepaliveCountMax) && srvCfg.keepaliveCountMax >= 0 ? srvCfg.keepaliveCountMax : typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === "number" && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX) && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0 ? Server.KEEPALIVE_CLIENT_COUNT_MAX : -1;
        let kaCurCount = 0;
        if (kaIntvl !== -1 && kaCountMax !== -1) {
          this.once("ready", () => {
            const onClose = () => {
              clearInterval(kaTimer);
            };
            this.on("close", onClose).on("end", onClose);
            kaTimer = setInterval(() => {
              if (++kaCurCount > kaCountMax) {
                clearInterval(kaTimer);
                const err = new Error("Keepalive timeout");
                err.level = "client-timeout";
                this.emit("error", err);
                this.end();
              } else {
                proto.ping();
              }
            }, kaIntvl);
          });
          onPacket = () => {
            kaTimer && kaTimer.refresh();
            kaCurCount = 0;
          };
        }
        const proto = this._protocol = new Protocol({
          server: true,
          hostKeys,
          ident,
          offer,
          onPacket,
          greeting: srvCfg.greeting,
          banner: srvCfg.banner,
          onWrite: (data) => {
            if (isWritable(socket))
              socket.write(data);
          },
          onError: (err) => {
            if (!proto._destruct)
              socket.removeAllListeners("data");
            this.emit("error", err);
            try {
              socket.end();
            } catch {
            }
          },
          onHeader: (header) => {
            this.removeListener("error", onClientPreHeaderError);
            const info = {
              ip: socket.remoteAddress,
              family: socket.remoteFamily,
              port: socket.remotePort,
              header
            };
            if (!server.emit("connection", this, info)) {
              proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);
              socket.end();
              return;
            }
            if (header.greeting)
              this.emit("greeting", header.greeting);
          },
          onHandshakeComplete: (negotiated) => {
            if (++exchanges > 1)
              this.emit("rekey");
            this.emit("handshake", negotiated);
          },
          debug,
          messageHandlers: {
            DEBUG: DEBUG_HANDLER,
            DISCONNECT: (p, reason, desc) => {
              if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
                if (!desc) {
                  desc = DISCONNECT_REASON_BY_VALUE[reason];
                  if (desc === void 0)
                    desc = `Unexpected disconnection reason: ${reason}`;
                }
                const err = new Error(desc);
                err.code = reason;
                this.emit("error", err);
              }
              socket.end();
            },
            CHANNEL_OPEN: (p, info) => {
              if (info.type === "session" && this.noMoreSessions || !this.authenticated) {
                const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
                return proto.channelOpenFail(info.sender, reasonCode);
              }
              let localChan = -1;
              let reason;
              let replied = false;
              let accept;
              const reject = () => {
                if (replied)
                  return;
                replied = true;
                if (reason === void 0) {
                  if (localChan === -1)
                    reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
                  else
                    reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;
                }
                if (localChan !== -1)
                  this._chanMgr.remove(localChan);
                proto.channelOpenFail(info.sender, reason, "");
              };
              const reserveChannel = () => {
                localChan = this._chanMgr.add();
                if (localChan === -1) {
                  reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
                  if (debug) {
                    debug("Automatic rejection of incoming channel open: no channels available");
                  }
                }
                return localChan !== -1;
              };
              const data = info.data;
              switch (info.type) {
                case "session":
                  if (listenerCount(this, "session") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = true;
                      const instance = new Session(this, info, localChan);
                      this._chanMgr.update(localChan, instance);
                      proto.channelOpenConfirm(
                        info.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      );
                      return instance;
                    };
                    this.emit("session", accept, reject);
                    return;
                  }
                  break;
                case "direct-tcpip":
                  if (listenerCount(this, "tcpip") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = true;
                      const chanInfo = {
                        type: void 0,
                        incoming: {
                          id: localChan,
                          window: MAX_WINDOW,
                          packetSize: PACKET_SIZE,
                          state: "open"
                        },
                        outgoing: {
                          id: info.sender,
                          window: info.window,
                          packetSize: info.packetSize,
                          state: "open"
                        }
                      };
                      const stream = new Channel(this, chanInfo, { server: true });
                      this._chanMgr.update(localChan, stream);
                      proto.channelOpenConfirm(
                        info.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      );
                      return stream;
                    };
                    this.emit("tcpip", accept, reject, data);
                    return;
                  }
                  break;
                case "direct-streamlocal@openssh.com":
                  if (listenerCount(this, "openssh.streamlocal") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = true;
                      const chanInfo = {
                        type: void 0,
                        incoming: {
                          id: localChan,
                          window: MAX_WINDOW,
                          packetSize: PACKET_SIZE,
                          state: "open"
                        },
                        outgoing: {
                          id: info.sender,
                          window: info.window,
                          packetSize: info.packetSize,
                          state: "open"
                        }
                      };
                      const stream = new Channel(this, chanInfo, { server: true });
                      this._chanMgr.update(localChan, stream);
                      proto.channelOpenConfirm(
                        info.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      );
                      return stream;
                    };
                    this.emit("openssh.streamlocal", accept, reject, data);
                    return;
                  }
                  break;
                default:
                  reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;
                  if (debug) {
                    debug(`Automatic rejection of unsupported incoming channel open type: ${info.type}`);
                  }
              }
              if (reason === void 0) {
                reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
                if (debug) {
                  debug(`Automatic rejection of unexpected incoming channel open for: ${info.type}`);
                }
              }
              reject();
            },
            CHANNEL_OPEN_CONFIRMATION: (p, info) => {
              const channel = this._chanMgr.get(info.recipient);
              if (typeof channel !== "function")
                return;
              const chanInfo = {
                type: channel.type,
                incoming: {
                  id: info.recipient,
                  window: MAX_WINDOW,
                  packetSize: PACKET_SIZE,
                  state: "open"
                },
                outgoing: {
                  id: info.sender,
                  window: info.window,
                  packetSize: info.packetSize,
                  state: "open"
                }
              };
              const instance = new Channel(this, chanInfo, { server: true });
              this._chanMgr.update(info.recipient, instance);
              channel(void 0, instance);
            },
            CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "function")
                return;
              const info = { reason, description };
              onChannelOpenFailure(this, recipient, info, channel);
            },
            CHANNEL_DATA: (p, recipient, data) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel)
                  return;
              }
              if (channel.incoming.window === 0)
                return;
              channel.incoming.window -= data.length;
              if (channel.push(data) === false) {
                channel._waitChanDrain = true;
                return;
              }
              if (channel.incoming.window <= WINDOW_THRESHOLD)
                windowAdjust(channel);
            },
            CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {
            },
            CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel)
                  return;
              }
              channel.outgoing.window += amount;
              if (channel._waitWindow) {
                channel._waitWindow = false;
                if (channel._chunk) {
                  channel._write(channel._chunk, null, channel._chunkcb);
                } else if (channel._chunkcb) {
                  channel._chunkcb();
                } else if (channel._chunkErr) {
                  channel.stderr._write(
                    channel._chunkErr,
                    null,
                    channel._chunkcbErr
                  );
                } else if (channel._chunkcbErr) {
                  channel._chunkcbErr();
                }
              }
            },
            CHANNEL_SUCCESS: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel)
                  return;
              }
              if (channel._callbacks.length)
                channel._callbacks.shift()(false);
            },
            CHANNEL_FAILURE: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel)
                  return;
              }
              if (channel._callbacks.length)
                channel._callbacks.shift()(true);
            },
            CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {
              const session = this._chanMgr.get(recipient);
              if (typeof session !== "object" || session === null)
                return;
              let replied = false;
              let accept;
              let reject;
              if (session.constructor !== Session) {
                if (wantReply)
                  proto.channelFailure(session.outgoing.id);
                return;
              }
              if (wantReply) {
                if (type !== "shell" && type !== "exec" && type !== "subsystem") {
                  accept = () => {
                    if (replied || session._ending || session._channel)
                      return;
                    replied = true;
                    proto.channelSuccess(session._chanInfo.outgoing.id);
                  };
                }
                reject = () => {
                  if (replied || session._ending || session._channel)
                    return;
                  replied = true;
                  proto.channelFailure(session._chanInfo.outgoing.id);
                };
              }
              if (session._ending) {
                reject && reject();
                return;
              }
              switch (type) {
                case "env":
                  if (listenerCount(session, "env")) {
                    session.emit("env", accept, reject, {
                      key: data.name,
                      val: data.value
                    });
                    return;
                  }
                  break;
                case "pty-req":
                  if (listenerCount(session, "pty")) {
                    session.emit("pty", accept, reject, data);
                    return;
                  }
                  break;
                case "window-change":
                  if (listenerCount(session, "window-change"))
                    session.emit("window-change", accept, reject, data);
                  else
                    reject && reject();
                  break;
                case "x11-req":
                  if (listenerCount(session, "x11")) {
                    session.emit("x11", accept, reject, data);
                    return;
                  }
                  break;
                case "signal":
                  if (listenerCount(session, "signal")) {
                    session.emit("signal", accept, reject, {
                      name: data
                    });
                    return;
                  }
                  break;
                case "auth-agent-req@openssh.com":
                  if (listenerCount(session, "auth-agent")) {
                    session.emit("auth-agent", accept, reject);
                    return;
                  }
                  break;
                case "shell":
                  if (listenerCount(session, "shell")) {
                    accept = () => {
                      if (replied || session._ending || session._channel)
                        return;
                      replied = true;
                      if (wantReply)
                        proto.channelSuccess(session._chanInfo.outgoing.id);
                      const channel = new Channel(
                        this,
                        session._chanInfo,
                        { server: true }
                      );
                      channel.subtype = session.subtype = type;
                      session._channel = channel;
                      return channel;
                    };
                    session.emit("shell", accept, reject);
                    return;
                  }
                  break;
                case "exec":
                  if (listenerCount(session, "exec")) {
                    accept = () => {
                      if (replied || session._ending || session._channel)
                        return;
                      replied = true;
                      if (wantReply)
                        proto.channelSuccess(session._chanInfo.outgoing.id);
                      const channel = new Channel(
                        this,
                        session._chanInfo,
                        { server: true }
                      );
                      channel.subtype = session.subtype = type;
                      session._channel = channel;
                      return channel;
                    };
                    session.emit("exec", accept, reject, {
                      command: data
                    });
                    return;
                  }
                  break;
                case "subsystem": {
                  let useSFTP = data === "sftp";
                  accept = () => {
                    if (replied || session._ending || session._channel)
                      return;
                    replied = true;
                    if (wantReply)
                      proto.channelSuccess(session._chanInfo.outgoing.id);
                    let instance;
                    if (useSFTP) {
                      instance = new SFTP(this, session._chanInfo, {
                        server: true,
                        debug
                      });
                    } else {
                      instance = new Channel(
                        this,
                        session._chanInfo,
                        { server: true }
                      );
                      instance.subtype = session.subtype = `${type}:${data}`;
                    }
                    session._channel = instance;
                    return instance;
                  };
                  if (data === "sftp") {
                    if (listenerCount(session, "sftp")) {
                      session.emit("sftp", accept, reject);
                      return;
                    }
                    useSFTP = false;
                  }
                  if (listenerCount(session, "subsystem")) {
                    session.emit("subsystem", accept, reject, {
                      name: data
                    });
                    return;
                  }
                  break;
                }
              }
              debug && debug(
                `Automatic rejection of incoming channel request: ${type}`
              );
              reject && reject();
            },
            CHANNEL_EOF: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                if (!channel._ending) {
                  channel._ending = true;
                  channel.emit("eof");
                  channel.emit("end");
                }
                channel = channel._channel;
                if (!channel)
                  return;
              }
              if (channel.incoming.state !== "open")
                return;
              channel.incoming.state = "eof";
              if (channel.readable)
                channel.push(null);
            },
            CHANNEL_CLOSE: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                channel._ending = true;
                channel.emit("close");
                channel = channel._channel;
                if (!channel)
                  return;
              }
              onCHANNEL_CLOSE(this, recipient, channel);
            },
            // Begin service/auth-related ==========================================
            SERVICE_REQUEST: (p, service) => {
              if (exchanges === 0 || acceptedAuthSvc || this.authenticated || service !== "ssh-userauth") {
                proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);
                socket.end();
                return;
              }
              acceptedAuthSvc = true;
              proto.serviceAccept(service);
            },
            USERAUTH_REQUEST: (p, username, service, method, methodData) => {
              if (exchanges === 0 || this.authenticated || authCtx && (authCtx.username !== username || authCtx.service !== service) || method !== "password" && method !== "publickey" && method !== "hostbased" && method !== "keyboard-interactive" && method !== "none" || pendingAuths.length === MAX_PENDING_AUTHS) {
                proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);
                socket.end();
                return;
              } else if (service !== "ssh-connection") {
                proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);
                socket.end();
                return;
              }
              let ctx;
              switch (method) {
                case "keyboard-interactive":
                  ctx = new KeyboardAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "publickey":
                  ctx = new PKAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "hostbased":
                  ctx = new HostbasedAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "password":
                  if (authCtx && authCtx instanceof PwdAuthContext && authCtx._changeCb) {
                    const cb = authCtx._changeCb;
                    authCtx._changeCb = void 0;
                    cb(methodData.newPassword);
                    return;
                  }
                  ctx = new PwdAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "none":
                  ctx = new AuthContext(
                    proto,
                    username,
                    service,
                    method,
                    onAuthDecide
                  );
                  break;
              }
              if (authCtx) {
                if (!authCtx._initialResponse) {
                  return pendingAuths.push(ctx);
                } else if (authCtx._multistep && !authCtx._finalResponse) {
                  authCtx._cleanup && authCtx._cleanup();
                  authCtx.emit("abort");
                }
              }
              authCtx = ctx;
              if (listenerCount(this, "authentication"))
                this.emit("authentication", authCtx);
              else
                authCtx.reject();
            },
            USERAUTH_INFO_RESPONSE: (p, responses) => {
              if (authCtx && authCtx instanceof KeyboardAuthContext)
                authCtx._onInfoResponse(responses);
            },
            // End service/auth-related ============================================
            GLOBAL_REQUEST: (p, name, wantReply, data) => {
              const reply = {
                type: null,
                buf: null
              };
              function setReply(type, buf) {
                reply.type = type;
                reply.buf = buf;
                sendReplies();
              }
              if (wantReply)
                unsentGlobalRequestsReplies.push(reply);
              if ((name === "tcpip-forward" || name === "cancel-tcpip-forward" || name === "no-more-sessions@openssh.com" || name === "streamlocal-forward@openssh.com" || name === "cancel-streamlocal-forward@openssh.com") && listenerCount(this, "request") && this.authenticated) {
                let accept;
                let reject;
                if (wantReply) {
                  let replied = false;
                  accept = (chosenPort) => {
                    if (replied)
                      return;
                    replied = true;
                    let bufPort;
                    if (name === "tcpip-forward" && data.bindPort === 0 && typeof chosenPort === "number") {
                      bufPort = Buffer.allocUnsafe(4);
                      writeUInt32BE(bufPort, chosenPort, 0);
                    }
                    setReply("SUCCESS", bufPort);
                  };
                  reject = () => {
                    if (replied)
                      return;
                    replied = true;
                    setReply("FAILURE");
                  };
                }
                if (name === "no-more-sessions@openssh.com") {
                  this.noMoreSessions = true;
                  accept && accept();
                  return;
                }
                this.emit("request", accept, reject, name, data);
              } else if (wantReply) {
                setReply("FAILURE");
              }
            }
          }
        });
        socket.pause();
        cryptoInit.then(() => {
          proto.start();
          socket.on("data", (data) => {
            try {
              proto.parse(data, 0, data.length);
            } catch (ex) {
              this.emit("error", ex);
              try {
                if (isWritable(socket))
                  socket.end();
              } catch {
              }
            }
          });
          socket.resume();
        }).catch((err) => {
          this.emit("error", err);
          try {
            if (isWritable(socket))
              socket.end();
          } catch {
          }
        });
        socket.on("error", (err) => {
          err.level = "socket";
          this.emit("error", err);
        }).once("end", () => {
          debug && debug("Socket ended");
          proto.cleanup();
          this.emit("end");
        }).once("close", () => {
          debug && debug("Socket closed");
          proto.cleanup();
          this.emit("close");
          const err = new Error("No response from server");
          this._chanMgr.cleanup(err);
        });
        const onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {
          if (authCtx === ctx && !this.authenticated) {
            if (allowed) {
              authCtx = void 0;
              this.authenticated = true;
              proto.authSuccess();
              pendingAuths = [];
              this.emit("ready");
            } else {
              proto.authFailure(methodsLeft, isPartial);
              if (pendingAuths.length) {
                authCtx = pendingAuths.pop();
                if (listenerCount(this, "authentication"))
                  this.emit("authentication", authCtx);
                else
                  authCtx.reject();
              }
            }
          }
        };
        function sendReplies() {
          while (unsentGlobalRequestsReplies.length > 0 && unsentGlobalRequestsReplies[0].type) {
            const reply = unsentGlobalRequestsReplies.shift();
            if (reply.type === "SUCCESS")
              proto.requestSuccess(reply.buf);
            if (reply.type === "FAILURE")
              proto.requestFailure();
          }
        }
      }
      end() {
        if (this._sock && isWritable(this._sock)) {
          this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);
          this._sock.end();
        }
        return this;
      }
      x11(originAddr, originPort, cb) {
        const opts = { originAddr, originPort };
        openChannel(this, "x11", opts, cb);
        return this;
      }
      forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {
        const opts = { boundAddr, boundPort, remoteAddr, remotePort };
        openChannel(this, "forwarded-tcpip", opts, cb);
        return this;
      }
      openssh_forwardOutStreamLocal(socketPath, cb) {
        const opts = { socketPath };
        openChannel(this, "forwarded-streamlocal@openssh.com", opts, cb);
        return this;
      }
      rekey(cb) {
        let error;
        try {
          this._protocol.rekey();
        } catch (ex) {
          error = ex;
        }
        if (typeof cb === "function") {
          if (error)
            process.nextTick(cb, error);
          else
            this.once("rekey", cb);
        }
      }
      setNoDelay(noDelay) {
        if (this._sock && typeof this._sock.setNoDelay === "function")
          this._sock.setNoDelay(noDelay);
        return this;
      }
    };
    function openChannel(self2, type, opts, cb) {
      const initWindow = MAX_WINDOW;
      const maxPacket = PACKET_SIZE;
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const wrapper = (err, stream) => {
        cb(err, stream);
      };
      wrapper.type = type;
      const localChan = self2._chanMgr.add(wrapper);
      if (localChan === -1) {
        cb(new Error("No free channels available"));
        return;
      }
      switch (type) {
        case "forwarded-tcpip":
          self2._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);
          break;
        case "x11":
          self2._protocol.x11(localChan, initWindow, maxPacket, opts);
          break;
        case "forwarded-streamlocal@openssh.com":
          self2._protocol.openssh_forwardedStreamLocal(
            localChan,
            initWindow,
            maxPacket,
            opts
          );
          break;
        default:
          throw new Error(`Unsupported channel type: ${type}`);
      }
    }
    function compareNumbers(a, b) {
      return a - b;
    }
    module2.exports = Server;
    module2.exports.IncomingClient = Client2;
  }
});

// node_modules/ssh2/lib/keygen.js
var require_keygen = __commonJS({
  "node_modules/ssh2/lib/keygen.js"(exports, module2) {
    "use strict";
    var {
      createCipheriv,
      generateKeyPair: generateKeyPair_,
      generateKeyPairSync: generateKeyPairSync_,
      getCurves,
      randomBytes
    } = require("crypto");
    var { Ber } = require_lib();
    var bcrypt_pbkdf = require_bcrypt_pbkdf().pbkdf;
    var { CIPHER_INFO } = require_crypto();
    var SALT_LEN = 16;
    var DEFAULT_ROUNDS = 16;
    var curves = getCurves();
    var ciphers = new Map(Object.entries(CIPHER_INFO));
    function makeArgs(type, opts) {
      if (typeof type !== "string")
        throw new TypeError("Key type must be a string");
      const publicKeyEncoding = { type: "spki", format: "der" };
      const privateKeyEncoding = { type: "pkcs8", format: "der" };
      switch (type.toLowerCase()) {
        case "rsa": {
          if (typeof opts !== "object" || opts === null)
            throw new TypeError("Missing options object for RSA key");
          const modulusLength = opts.bits;
          if (!Number.isInteger(modulusLength))
            throw new TypeError("RSA bits must be an integer");
          if (modulusLength <= 0 || modulusLength > 16384)
            throw new RangeError("RSA bits must be non-zero and <= 16384");
          return ["rsa", { modulusLength, publicKeyEncoding, privateKeyEncoding }];
        }
        case "ecdsa": {
          if (typeof opts !== "object" || opts === null)
            throw new TypeError("Missing options object for ECDSA key");
          if (!Number.isInteger(opts.bits))
            throw new TypeError("ECDSA bits must be an integer");
          let namedCurve;
          switch (opts.bits) {
            case 256:
              namedCurve = "prime256v1";
              break;
            case 384:
              namedCurve = "secp384r1";
              break;
            case 521:
              namedCurve = "secp521r1";
              break;
            default:
              throw new Error("ECDSA bits must be 256, 384, or 521");
          }
          if (!curves.includes(namedCurve))
            throw new Error("Unsupported ECDSA bits value");
          return ["ec", { namedCurve, publicKeyEncoding, privateKeyEncoding }];
        }
        case "ed25519":
          return ["ed25519", { publicKeyEncoding, privateKeyEncoding }];
        default:
          throw new Error(`Unsupported key type: ${type}`);
      }
    }
    function parseDERs(keyType, pub, priv) {
      switch (keyType) {
        case "rsa": {
          let reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in RSA private key");
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.113549.1.1.1")
            throw new Error("Bad RSA private OID");
          if (reader.readByte() !== Ber.Null)
            throw new Error("Malformed RSA private key (expected null)");
          if (reader.readByte() !== 0) {
            throw new Error(
              "Malformed RSA private key (expected zero-length null)"
            );
          }
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in RSA private key");
          const n = reader.readString(Ber.Integer, true);
          const e = reader.readString(Ber.Integer, true);
          const d = reader.readString(Ber.Integer, true);
          const p = reader.readString(Ber.Integer, true);
          const q = reader.readString(Ber.Integer, true);
          reader.readString(Ber.Integer, true);
          reader.readString(Ber.Integer, true);
          const iqmp = reader.readString(Ber.Integer, true);
          const keyName = Buffer.from("ssh-rsa");
          const privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + n.length + 4 + e.length + 4 + d.length + 4 + iqmp.length + 4 + p.length + 4 + q.length
          );
          let pos = 0;
          privBuf.writeUInt32BE(keyName.length, pos += 0);
          privBuf.set(keyName, pos += 4);
          privBuf.writeUInt32BE(n.length, pos += keyName.length);
          privBuf.set(n, pos += 4);
          privBuf.writeUInt32BE(e.length, pos += n.length);
          privBuf.set(e, pos += 4);
          privBuf.writeUInt32BE(d.length, pos += e.length);
          privBuf.set(d, pos += 4);
          privBuf.writeUInt32BE(iqmp.length, pos += d.length);
          privBuf.set(iqmp, pos += 4);
          privBuf.writeUInt32BE(p.length, pos += iqmp.length);
          privBuf.set(p, pos += 4);
          privBuf.writeUInt32BE(q.length, pos += p.length);
          privBuf.set(q, pos += 4);
          const pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + e.length + 4 + n.length
          );
          pos = 0;
          pubBuf.writeUInt32BE(keyName.length, pos += 0);
          pubBuf.set(keyName, pos += 4);
          pubBuf.writeUInt32BE(e.length, pos += keyName.length);
          pubBuf.set(e, pos += 4);
          pubBuf.writeUInt32BE(n.length, pos += e.length);
          pubBuf.set(n, pos += 4);
          return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
        case "ec": {
          let reader = new Ber.Reader(pub);
          reader.readSequence();
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.10045.2.1")
            throw new Error("Bad ECDSA public OID");
          reader.readOID();
          let pubBin = reader.readString(Ber.BitString, true);
          {
            let i = 0;
            for (; i < pubBin.length && pubBin[i] === 0; ++i)
              ;
            if (i > 0)
              pubBin = pubBin.slice(i);
          }
          reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in ECDSA private key");
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.10045.2.1")
            throw new Error("Bad ECDSA private OID");
          const curveOID = reader.readOID();
          let sshCurveName;
          switch (curveOID) {
            case "1.2.840.10045.3.1.7":
              sshCurveName = "nistp256";
              break;
            case "1.3.132.0.34":
              sshCurveName = "nistp384";
              break;
            case "1.3.132.0.35":
              sshCurveName = "nistp521";
              break;
            default:
              throw new Error("Unsupported curve in ECDSA private key");
          }
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          reader.readSequence();
          if (reader.readInt() !== 1)
            throw new Error("Unsupported version in ECDSA private key");
          const privBin = Buffer.concat([
            Buffer.from([0]),
            reader.readString(Ber.OctetString, true)
          ]);
          const keyName = Buffer.from(`ecdsa-sha2-${sshCurveName}`);
          sshCurveName = Buffer.from(sshCurveName);
          const privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length + 4 + privBin.length
          );
          let pos = 0;
          privBuf.writeUInt32BE(keyName.length, pos += 0);
          privBuf.set(keyName, pos += 4);
          privBuf.writeUInt32BE(sshCurveName.length, pos += keyName.length);
          privBuf.set(sshCurveName, pos += 4);
          privBuf.writeUInt32BE(pubBin.length, pos += sshCurveName.length);
          privBuf.set(pubBin, pos += 4);
          privBuf.writeUInt32BE(privBin.length, pos += pubBin.length);
          privBuf.set(privBin, pos += 4);
          const pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length
          );
          pos = 0;
          pubBuf.writeUInt32BE(keyName.length, pos += 0);
          pubBuf.set(keyName, pos += 4);
          pubBuf.writeUInt32BE(sshCurveName.length, pos += keyName.length);
          pubBuf.set(sshCurveName, pos += 4);
          pubBuf.writeUInt32BE(pubBin.length, pos += sshCurveName.length);
          pubBuf.set(pubBin, pos += 4);
          return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
        case "ed25519": {
          let reader = new Ber.Reader(pub);
          reader.readSequence();
          reader.readSequence();
          if (reader.readOID() !== "1.3.101.112")
            throw new Error("Bad ED25519 public OID");
          let pubBin = reader.readString(Ber.BitString, true);
          {
            let i = 0;
            for (; i < pubBin.length && pubBin[i] === 0; ++i)
              ;
            if (i > 0)
              pubBin = pubBin.slice(i);
          }
          reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in ED25519 private key");
          reader.readSequence();
          if (reader.readOID() !== "1.3.101.112")
            throw new Error("Bad ED25519 private OID");
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          const privBin = reader.readString(Ber.OctetString, true);
          const keyName = Buffer.from("ssh-ed25519");
          const privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + pubBin.length + 4 + (privBin.length + pubBin.length)
          );
          let pos = 0;
          privBuf.writeUInt32BE(keyName.length, pos += 0);
          privBuf.set(keyName, pos += 4);
          privBuf.writeUInt32BE(pubBin.length, pos += keyName.length);
          privBuf.set(pubBin, pos += 4);
          privBuf.writeUInt32BE(
            privBin.length + pubBin.length,
            pos += pubBin.length
          );
          privBuf.set(privBin, pos += 4);
          privBuf.set(pubBin, pos += privBin.length);
          const pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + pubBin.length
          );
          pos = 0;
          pubBuf.writeUInt32BE(keyName.length, pos += 0);
          pubBuf.set(keyName, pos += 4);
          pubBuf.writeUInt32BE(pubBin.length, pos += keyName.length);
          pubBuf.set(pubBin, pos += 4);
          return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
      }
    }
    function convertKeys(keyType, pub, priv, opts) {
      let format = "new";
      let encrypted;
      let comment = "";
      if (typeof opts === "object" && opts !== null) {
        if (typeof opts.comment === "string" && opts.comment)
          comment = opts.comment;
        if (typeof opts.format === "string" && opts.format)
          format = opts.format;
        if (opts.passphrase) {
          let passphrase;
          if (typeof opts.passphrase === "string")
            passphrase = Buffer.from(opts.passphrase);
          else if (Buffer.isBuffer(opts.passphrase))
            passphrase = opts.passphrase;
          else
            throw new Error("Invalid passphrase");
          if (opts.cipher === void 0)
            throw new Error("Missing cipher name");
          const cipher = ciphers.get(opts.cipher);
          if (cipher === void 0)
            throw new Error("Invalid cipher name");
          if (format === "new") {
            let rounds = DEFAULT_ROUNDS;
            if (opts.rounds !== void 0) {
              if (!Number.isInteger(opts.rounds))
                throw new TypeError("rounds must be an integer");
              if (opts.rounds > 0)
                rounds = opts.rounds;
            }
            const gen = Buffer.allocUnsafe(cipher.keyLen + cipher.ivLen);
            const salt = randomBytes(SALT_LEN);
            const r = bcrypt_pbkdf(
              passphrase,
              passphrase.length,
              salt,
              salt.length,
              gen,
              gen.length,
              rounds
            );
            if (r !== 0)
              return new Error("Failed to generate information to encrypt key");
            const kdfOptions = Buffer.allocUnsafe(4 + salt.length + 4);
            {
              let pos = 0;
              kdfOptions.writeUInt32BE(salt.length, pos += 0);
              kdfOptions.set(salt, pos += 4);
              kdfOptions.writeUInt32BE(rounds, pos += salt.length);
            }
            encrypted = {
              cipher,
              cipherName: opts.cipher,
              kdfName: "bcrypt",
              kdfOptions,
              key: gen.slice(0, cipher.keyLen),
              iv: gen.slice(cipher.keyLen)
            };
          }
        }
      }
      switch (format) {
        case "new": {
          let privateB64 = "-----BEGIN OPENSSH PRIVATE KEY-----\n";
          let publicB64;
          const cipherName = Buffer.from(encrypted ? encrypted.cipherName : "none");
          const kdfName = Buffer.from(encrypted ? encrypted.kdfName : "none");
          const kdfOptions = encrypted ? encrypted.kdfOptions : Buffer.alloc(0);
          const blockLen = encrypted ? encrypted.cipher.blockLen : 8;
          const parsed = parseDERs(keyType, pub, priv);
          const checkInt = randomBytes(4);
          const commentBin = Buffer.from(comment);
          const privBlobLen = 4 + 4 + parsed.priv.length + 4 + commentBin.length;
          let padding = [];
          for (let i = 1; (privBlobLen + padding.length) % blockLen; ++i)
            padding.push(i & 255);
          padding = Buffer.from(padding);
          let privBlob = Buffer.allocUnsafe(privBlobLen + padding.length);
          let extra;
          {
            let pos = 0;
            privBlob.set(checkInt, pos += 0);
            privBlob.set(checkInt, pos += 4);
            privBlob.set(parsed.priv, pos += 4);
            privBlob.writeUInt32BE(commentBin.length, pos += parsed.priv.length);
            privBlob.set(commentBin, pos += 4);
            privBlob.set(padding, pos += commentBin.length);
          }
          if (encrypted) {
            const options = { authTagLength: encrypted.cipher.authLen };
            const cipher = createCipheriv(
              encrypted.cipher.sslName,
              encrypted.key,
              encrypted.iv,
              options
            );
            cipher.setAutoPadding(false);
            privBlob = Buffer.concat([cipher.update(privBlob), cipher.final()]);
            if (encrypted.cipher.authLen > 0)
              extra = cipher.getAuthTag();
            else
              extra = Buffer.alloc(0);
            encrypted.key.fill(0);
            encrypted.iv.fill(0);
          } else {
            extra = Buffer.alloc(0);
          }
          const magicBytes = Buffer.from("openssh-key-v1\0");
          const privBin = Buffer.allocUnsafe(
            magicBytes.length + 4 + cipherName.length + 4 + kdfName.length + 4 + kdfOptions.length + 4 + 4 + parsed.pub.length + 4 + privBlob.length + extra.length
          );
          {
            let pos = 0;
            privBin.set(magicBytes, pos += 0);
            privBin.writeUInt32BE(cipherName.length, pos += magicBytes.length);
            privBin.set(cipherName, pos += 4);
            privBin.writeUInt32BE(kdfName.length, pos += cipherName.length);
            privBin.set(kdfName, pos += 4);
            privBin.writeUInt32BE(kdfOptions.length, pos += kdfName.length);
            privBin.set(kdfOptions, pos += 4);
            privBin.writeUInt32BE(1, pos += kdfOptions.length);
            privBin.writeUInt32BE(parsed.pub.length, pos += 4);
            privBin.set(parsed.pub, pos += 4);
            privBin.writeUInt32BE(privBlob.length, pos += parsed.pub.length);
            privBin.set(privBlob, pos += 4);
            privBin.set(extra, pos += privBlob.length);
          }
          {
            const b64 = privBin.base64Slice(0, privBin.length);
            let formatted = b64.replace(/.{64}/g, "$&\n");
            if (b64.length & 63)
              formatted += "\n";
            privateB64 += formatted;
          }
          {
            const b64 = parsed.pub.base64Slice(0, parsed.pub.length);
            publicB64 = `${parsed.sshName} ${b64}${comment ? ` ${comment}` : ""}`;
          }
          privateB64 += "-----END OPENSSH PRIVATE KEY-----\n";
          return {
            private: privateB64,
            public: publicB64
          };
        }
        default:
          throw new Error("Invalid output key format");
      }
    }
    function noop() {
    }
    module2.exports = {
      generateKeyPair: (keyType, opts, cb) => {
        if (typeof opts === "function") {
          cb = opts;
          opts = void 0;
        }
        if (typeof cb !== "function")
          cb = noop;
        const args = makeArgs(keyType, opts);
        generateKeyPair_(...args, (err, pub, priv) => {
          if (err)
            return cb(err);
          let ret;
          try {
            ret = convertKeys(args[0], pub, priv, opts);
          } catch (ex) {
            return cb(ex);
          }
          cb(null, ret);
        });
      },
      generateKeyPairSync: (keyType, opts) => {
        const args = makeArgs(keyType, opts);
        const { publicKey: pub, privateKey: priv } = generateKeyPairSync_(...args);
        return convertKeys(args[0], pub, priv, opts);
      }
    };
  }
});

// node_modules/ssh2/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/ssh2/lib/index.js"(exports, module2) {
    "use strict";
    var {
      AgentProtocol,
      BaseAgent,
      createAgent,
      CygwinAgent,
      OpenSSHAgent,
      PageantAgent
    } = require_agent();
    var {
      SSHTTPAgent: HTTPAgent,
      SSHTTPSAgent: HTTPSAgent
    } = require_http_agents();
    var { parseKey } = require_keyParser();
    var {
      flagsToString,
      OPEN_MODE,
      STATUS_CODE,
      stringToFlags
    } = require_SFTP();
    module2.exports = {
      AgentProtocol,
      BaseAgent,
      createAgent,
      Client: require_client(),
      CygwinAgent,
      HTTPAgent,
      HTTPSAgent,
      OpenSSHAgent,
      PageantAgent,
      Server: require_server(),
      utils: {
        parseKey,
        ...require_keygen(),
        sftp: {
          flagsToString,
          OPEN_MODE,
          STATUS_CODE,
          stringToFlags
        }
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module2) {
    module2.exports = require("events").EventEmitter;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module2) {
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module2) {
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require("string_decoder/").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports, module2) {
    exports = module2.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length >>>= 0;
        if (length > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      return isModern ? Buffer.from(value) : new Buffer(value);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/typedarray/index.js
var require_typedarray = __commonJS({
  "node_modules/typedarray/index.js"(exports) {
    var undefined2 = void 0;
    var MAX_ARRAY_LENGTH = 1e5;
    var ECMAScript = function() {
      var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) {
          return opts.call(v).replace(/^\[object *|\]$/g, "");
        },
        HasProperty: function(o, p) {
          return p in o;
        },
        HasOwnProperty: function(o, p) {
          return ophop.call(o, p);
        },
        IsCallable: function(o) {
          return typeof o === "function";
        },
        ToInt32: function(v) {
          return v >> 0;
        },
        ToUint32: function(v) {
          return v >>> 0;
        }
      };
    }();
    var LN2 = Math.LN2;
    var abs = Math.abs;
    var floor = Math.floor;
    var log = Math.log;
    var min = Math.min;
    var pow = Math.pow;
    var round = Math.round;
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1) {
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    var defineProp;
    if (Object.defineProperty && function() {
      try {
        Object.defineProperty({}, "x", {});
        return true;
      } catch (e) {
        return false;
      }
    }()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = function(o, p, desc) {
        if (!o === Object(o))
          throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
          Object.prototype.__defineGetter__.call(o, p, desc.get);
        }
        if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
          Object.prototype.__defineSetter__.call(o, p, desc.set);
        }
        if (ECMAScript.HasProperty(desc, "value")) {
          o[p] = desc.value;
        }
        return o;
      };
    }
    var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
      if (o !== Object(o))
        throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    function makeArrayAccessors(obj) {
      if (!defineProp) {
        return;
      }
      if (obj.length > MAX_ARRAY_LENGTH)
        throw new RangeError("Array too large for polyfill");
      function makeArrayAccessor(index) {
        defineProp(obj, index, {
          "get": function() {
            return obj._getter(index);
          },
          "set": function(v) {
            obj._setter(index, v);
          },
          enumerable: true,
          configurable: false
        });
      }
      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }
    function as_signed(value, bits) {
      var s = 32 - bits;
      return value << s >> s;
    }
    function as_unsigned(value, bits) {
      var s = 32 - bits;
      return value << s >>> s;
    }
    function packI8(n) {
      return [n & 255];
    }
    function unpackI8(bytes) {
      return as_signed(bytes[0], 8);
    }
    function packU8(n) {
      return [n & 255];
    }
    function unpackU8(bytes) {
      return as_unsigned(bytes[0], 8);
    }
    function packU8Clamped(n) {
      n = round(Number(n));
      return [n < 0 ? 0 : n > 255 ? 255 : n & 255];
    }
    function packI16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackI16(bytes) {
      return as_signed(bytes[0] << 8 | bytes[1], 16);
    }
    function packU16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackU16(bytes) {
      return as_unsigned(bytes[0] << 8 | bytes[1], 16);
    }
    function packI32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackI32(bytes) {
      return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packU32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackU32(bytes) {
      return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packIEEE754(v, ebits, fbits) {
      var bias = (1 << ebits - 1) - 1, s, e, f, ln, i, bits, str, bytes;
      function roundToEven(n) {
        var w = floor(n), f2 = n - w;
        if (f2 < 0.5)
          return w;
        if (f2 > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }
      if (v !== v) {
        e = (1 << ebits) - 1;
        f = pow(2, fbits - 1);
        s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1;
        f = 0;
        s = v < 0 ? 1 : 0;
      } else if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
      } else {
        s = v < 0;
        v = abs(v);
        if (v >= pow(2, 1 - bias)) {
          e = min(floor(log(v) / LN2), 1023);
          f = roundToEven(v / pow(2, e) * pow(2, fbits));
          if (f / pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            e = e + bias;
            f = f - pow(2, fbits);
          }
        } else {
          e = 0;
          f = roundToEven(v / pow(2, 1 - bias - fbits));
        }
      }
      bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = floor(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = floor(e / 2);
      }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join("");
      bytes = [];
      while (str.length) {
        bytes.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes;
    }
    function unpackIEEE754(bytes, ebits, fbits) {
      var bits = [], i, j, b, str, bias, s, e, f;
      for (i = bytes.length; i; i -= 1) {
        b = bytes[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0);
          b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join("");
      bias = (1 << ebits - 1) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
      } else if (f !== 0) {
        return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }
    function unpackF64(b) {
      return unpackIEEE754(b, 11, 52);
    }
    function packF64(v) {
      return packIEEE754(v, 11, 52);
    }
    function unpackF32(b) {
      return unpackIEEE754(b, 8, 23);
    }
    function packF32(v) {
      return packIEEE754(v, 8, 23);
    }
    (function() {
      var ArrayBuffer = function ArrayBuffer2(length) {
        length = ECMAScript.ToInt32(length);
        if (length < 0)
          throw new RangeError("ArrayBuffer size is not a small enough positive integer");
        this.byteLength = length;
        this._bytes = [];
        this._bytes.length = length;
        var i;
        for (i = 0; i < this.byteLength; i += 1) {
          this._bytes[i] = 0;
        }
        configureProperties(this);
      };
      exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;
      var ArrayBufferView = function ArrayBufferView2() {
      };
      function makeConstructor(bytesPerElement, pack, unpack) {
        var ctor;
        ctor = function(buffer, byteOffset, length) {
          var array, sequence, i, s;
          if (!arguments.length || typeof arguments[0] === "number") {
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length < 0)
              throw new RangeError("ArrayBufferView size is not a small enough positive integer");
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === "object" && arguments[0].constructor === ctor) {
            array = arguments[0];
            this.length = array.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              this._setter(i, array._getter(i));
            }
          } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            sequence = arguments[0];
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              s = sequence[i];
              this._setter(i, Number(s));
            }
          } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            this.buffer = buffer;
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
            if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
          this.constructor = ctor;
          configureProperties(this);
          makeArrayAccessors(this);
        };
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._getter = function(index) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined2;
          }
          var bytes = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            bytes.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes);
        };
        ctor.prototype.get = ctor.prototype._getter;
        ctor.prototype._setter = function(index, value) {
          if (arguments.length < 2)
            throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined2;
          }
          var bytes = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            this.buffer._bytes[o] = bytes[i];
          }
        };
        ctor.prototype.set = function(index, value) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
          if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
            array = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + array.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;
            if (array.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
        ctor.prototype.subarray = function(start, end) {
          function clamp(v, min2, max) {
            return v < min2 ? min2 : v > max ? max : v;
          }
          start = ECMAScript.ToInt32(start);
          end = ECMAScript.ToInt32(end);
          if (arguments.length < 1) {
            start = 0;
          }
          if (arguments.length < 2) {
            end = this.length;
          }
          if (start < 0) {
            start = this.length + start;
          }
          if (end < 0) {
            end = this.length + end;
          }
          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);
          var len = end - start;
          if (len < 0) {
            len = 0;
          }
          return new this.constructor(
            this.buffer,
            this.byteOffset + start * this.BYTES_PER_ELEMENT,
            len
          );
        };
        return ctor;
      }
      var Int8Array2 = makeConstructor(1, packI8, unpackI8);
      var Uint8Array2 = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array2 = makeConstructor(2, packI16, unpackI16);
      var Uint16Array2 = makeConstructor(2, packU16, unpackU16);
      var Int32Array2 = makeConstructor(4, packI32, unpackI32);
      var Uint32Array2 = makeConstructor(4, packU32, unpackU32);
      var Float32Array2 = makeConstructor(4, packF32, unpackF32);
      var Float64Array2 = makeConstructor(8, packF64, unpackF64);
      exports.Int8Array = exports.Int8Array || Int8Array2;
      exports.Uint8Array = exports.Uint8Array || Uint8Array2;
      exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
      exports.Int16Array = exports.Int16Array || Int16Array2;
      exports.Uint16Array = exports.Uint16Array || Uint16Array2;
      exports.Int32Array = exports.Int32Array || Int32Array2;
      exports.Uint32Array = exports.Uint32Array || Uint32Array2;
      exports.Float32Array = exports.Float32Array || Float32Array2;
      exports.Float64Array = exports.Float64Array || Float64Array2;
    })();
    (function() {
      function r(array, index) {
        return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
      }
      var IS_BIG_ENDIAN = function() {
        var u16array = new exports.Uint16Array([4660]), u8array = new exports.Uint8Array(u16array.buffer);
        return r(u8array, 0) === 18;
      }();
      var DataView = function DataView2(buffer, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer = new exports.ArrayBuffer(0);
        } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === "ArrayBuffer")) {
          throw new TypeError("TypeError");
        }
        this.buffer = buffer || new exports.ArrayBuffer(0);
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
        if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
        configureProperties(this);
      };
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
          var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(uint8Array, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
          return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
        };
      }
      DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
      DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
      DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
      DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
      DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
      DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
      DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
      DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          var typeArray = new arrayType([value]), byteArray = new exports.Uint8Array(typeArray.buffer), bytes = [], i, byteView;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(byteArray, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
          byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes);
        };
      }
      DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
      DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
      DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
      DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
      DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
      DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
      DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
      DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);
      exports.DataView = exports.DataView || DataView;
    })();
  }
});

// node_modules/concat-stream/index.js
var require_concat_stream = __commonJS({
  "node_modules/concat-stream/index.js"(exports, module2) {
    var Writable = require_readable_browser().Writable;
    var inherits = require_inherits_browser();
    var bufferFrom = require_buffer_from();
    if (typeof Uint8Array === "undefined") {
      U8 = require_typedarray().Uint8Array;
    } else {
      U8 = Uint8Array;
    }
    var U8;
    function ConcatStream(opts, cb) {
      if (!(this instanceof ConcatStream))
        return new ConcatStream(opts, cb);
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      if (!opts)
        opts = {};
      var encoding = opts.encoding;
      var shouldInferEncoding = false;
      if (!encoding) {
        shouldInferEncoding = true;
      } else {
        encoding = String(encoding).toLowerCase();
        if (encoding === "u8" || encoding === "uint8") {
          encoding = "uint8array";
        }
      }
      Writable.call(this, { objectMode: true });
      this.encoding = encoding;
      this.shouldInferEncoding = shouldInferEncoding;
      if (cb)
        this.on("finish", function() {
          cb(this.getBody());
        });
      this.body = [];
    }
    module2.exports = ConcatStream;
    inherits(ConcatStream, Writable);
    ConcatStream.prototype._write = function(chunk, enc, next) {
      this.body.push(chunk);
      next();
    };
    ConcatStream.prototype.inferEncoding = function(buff) {
      var firstBuffer = buff === void 0 ? this.body[0] : buff;
      if (Buffer.isBuffer(firstBuffer))
        return "buffer";
      if (typeof Uint8Array !== "undefined" && firstBuffer instanceof Uint8Array)
        return "uint8array";
      if (Array.isArray(firstBuffer))
        return "array";
      if (typeof firstBuffer === "string")
        return "string";
      if (Object.prototype.toString.call(firstBuffer) === "[object Object]")
        return "object";
      return "buffer";
    };
    ConcatStream.prototype.getBody = function() {
      if (!this.encoding && this.body.length === 0)
        return [];
      if (this.shouldInferEncoding)
        this.encoding = this.inferEncoding();
      if (this.encoding === "array")
        return arrayConcat(this.body);
      if (this.encoding === "string")
        return stringConcat(this.body);
      if (this.encoding === "buffer")
        return bufferConcat(this.body);
      if (this.encoding === "uint8array")
        return u8Concat(this.body);
      return this.body;
    };
    var isArray = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
    function isArrayish(arr) {
      return /Array\]$/.test(Object.prototype.toString.call(arr));
    }
    function isBufferish(p) {
      return typeof p === "string" || isArrayish(p) || p && typeof p.subarray === "function";
    }
    function stringConcat(parts) {
      var strings = [];
      var needsToString = false;
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (typeof p === "string") {
          strings.push(p);
        } else if (Buffer.isBuffer(p)) {
          strings.push(p);
        } else if (isBufferish(p)) {
          strings.push(bufferFrom(p));
        } else {
          strings.push(bufferFrom(String(p)));
        }
      }
      if (Buffer.isBuffer(parts[0])) {
        strings = Buffer.concat(strings);
        strings = strings.toString("utf8");
      } else {
        strings = strings.join("");
      }
      return strings;
    }
    function bufferConcat(parts) {
      var bufs = [];
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (Buffer.isBuffer(p)) {
          bufs.push(p);
        } else if (isBufferish(p)) {
          bufs.push(bufferFrom(p));
        } else {
          bufs.push(bufferFrom(String(p)));
        }
      }
      return Buffer.concat(bufs);
    }
    function arrayConcat(parts) {
      var res = [];
      for (var i = 0; i < parts.length; i++) {
        res.push.apply(res, parts[i]);
      }
      return res;
    }
    function u8Concat(parts) {
      var len = 0;
      for (var i = 0; i < parts.length; i++) {
        if (typeof parts[i] === "string") {
          parts[i] = bufferFrom(parts[i]);
        }
        len += parts[i].length;
      }
      var u8 = new U8(len);
      for (var i = 0, offset = 0; i < parts.length; i++) {
        var part = parts[i];
        for (var j = 0; j < part.length; j++) {
          u8[offset++] = part[j];
        }
      }
      return u8;
    }
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code === "object") {
        props = code;
        code = void 0;
      }
      if (code != null) {
        props.code = code;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        return assign(new ErrClass(), props);
      }
    }
    module2.exports = createError;
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/promise-retry/index.js
var require_promise_retry = __commonJS({
  "node_modules/promise-retry/index.js"(exports, module2) {
    "use strict";
    var errcode = require_err_code();
    var retry = require_retry2();
    var hasOwn = Object.prototype.hasOwnProperty;
    function isRetryError(err) {
      return err && err.code === "EPROMISERETRY" && hasOwn.call(err, "retried");
    }
    function promiseRetry(fn, options) {
      var temp;
      var operation;
      if (typeof fn === "object" && typeof options === "function") {
        temp = options;
        options = fn;
        fn = temp;
      }
      operation = retry.operation(options);
      return new Promise(function(resolve, reject) {
        operation.attempt(function(number) {
          Promise.resolve().then(function() {
            return fn(function(err) {
              if (isRetryError(err)) {
                err = err.retried;
              }
              throw errcode(new Error("Retrying"), "EPROMISERETRY", { retried: err });
            }, number);
          }).then(resolve, function(err) {
            if (isRetryError(err)) {
              err = err.retried;
              if (operation.retry(err || new Error())) {
                return;
              }
            }
            reject(err);
          });
        });
      });
    }
    module2.exports = promiseRetry;
  }
});

// node_modules/ssh2-sftp-client/src/constants.js
var require_constants2 = __commonJS({
  "node_modules/ssh2-sftp-client/src/constants.js"(exports, module2) {
    var errorCode = {
      generic: "ERR_GENERIC_CLIENT",
      connect: "ERR_NOT_CONNECTED",
      badPath: "ERR_BAD_PATH",
      permission: "EACCES",
      notexist: "ENOENT",
      notdir: "ENOTDIR"
    };
    var targetType = {
      writeFile: 1,
      readFile: 2,
      writeDir: 3,
      readDir: 4,
      readObj: 5,
      writeObj: 6
    };
    module2.exports = {
      errorCode,
      targetType
    };
  }
});

// node_modules/ssh2-sftp-client/src/utils.js
var require_utils3 = __commonJS({
  "node_modules/ssh2-sftp-client/src/utils.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { errorCode } = require_constants2();
    function fmtError(err, name = "sftp", eCode, retryCount) {
      let msg = "";
      let code = "";
      let retry = retryCount ? ` after ${retryCount} ${retryCount > 1 ? "attempts" : "attempt"}` : "";
      if (err === void 0) {
        msg = `${name}: Undefined error - probably a bug!`;
        code = errorCode.generic;
      } else if (typeof err === "string") {
        msg = `${name}: ${err}${retry}`;
        code = eCode ? eCode : errorCode.generic;
      } else if (err.custom) {
        msg = `${name}->${err.message}${retry}`;
        code = err.code;
      } else {
        switch (err.code) {
          case "ENOTFOUND":
            msg = `${name}: ${err.level} error. Address lookup failed for host ${err.hostname}${retry}`;
            break;
          case "ECONNREFUSED":
            msg = `${name}: ${err.level} error. Remote host at ${err.address} refused connection${retry}`;
            break;
          case "ECONNRESET":
            msg = `${name}: Remote host has reset the connection: ${err.message}${retry}`;
            break;
          default:
            msg = `${name}: ${err.message}${retry}`;
        }
        code = err.code ? err.code : errorCode.generic;
      }
      let newError = new Error(msg);
      newError.code = code;
      newError.custom = true;
      return newError;
    }
    function errorListener(client, name, reject) {
      let fn = (err) => {
        if (client.endCalled || client.errorHandled) {
          client.debugMsg(`${name} Error: Ignoring handled error: ${err.message}`);
        } else {
          client.debugMsg(`${name} Error: Handling error: ${err.message}`);
          client.errorHandled = true;
          if (reject) {
            client.debugMsg(`${name} Error: handled error with reject`);
            reject(fmtError(err, name, err.code));
          } else {
            client.debugMsg(`${name} Error: handling error with throw`);
            throw fmtError(err, name, err.code);
          }
        }
      };
      return fn;
    }
    function endListener(client, name, reject) {
      let fn = function() {
        if (client.endCalled || client.endHandled) {
          client.debugMsg(`${name} End: Ignoring expected end event`);
        } else {
          client.debugMsg(`${name} End: Handling end event`);
          client.sftp = void 0;
          client.endHandled = true;
          if (reject) {
            client.debugMsg(`${name} End: handling end event with reject'`);
            reject(fmtError("Unexpected end event raised", name));
          } else {
            client.debugMsg(`${name} End: handling end event with throw`);
            throw fmtError("Unexpected end event raised", name);
          }
        }
      };
      return fn;
    }
    function closeListener(client, name, reject) {
      let fn = function() {
        if (client.endCalled || client.closeHandled) {
          client.debugMsg(`${name} Close: ignoring expected close event`);
        } else {
          client.debugMsg(`${name} Close: handling unexpected close event`);
          client.sftp = void 0;
          client.closeHandled = true;
          if (reject) {
            client.debugMsg(`${name} Close: handling close event with reject`);
            reject(fmtError("Unexpected close event raised", name));
          } else {
            client.debugMsg(`${name} Close: handling close event with throw`);
            throw fmtError("Unexpected close event raised", name);
          }
        }
      };
      return fn;
    }
    function addTempListeners(client, name, reject) {
      let listeners = {
        end: endListener(client, name, reject),
        close: closeListener(client, name, reject),
        error: errorListener(client, name, reject)
      };
      client.debugMsg(`${name}: Adding temp event listeners`);
      client.on("end", listeners.end);
      client.on("close", listeners.close);
      client.on("error", listeners.error);
      return listeners;
    }
    function removeTempListeners(client, listeners, name) {
      client.debugMsg(`${name}: Removing temp event listeners`);
      client.removeListener("end", listeners.end);
      client.removeListener("close", listeners.close);
      client.removeListener("error", listeners.error);
    }
    function localExists(filePath) {
      const stats = fs.statSync(filePath, { throwIfNoEntry: false });
      if (!stats) {
        return false;
      } else if (stats.isDirectory()) {
        return "d";
      } else if (stats.isFile()) {
        return "-";
      } else {
        throw fmtError(
          `Bad path: ${filePath}: target must be a file or directory`,
          "localExists",
          errorCode.badPath
        );
      }
    }
    function haveLocalAccess(filePath, mode = "r") {
      const accessMode = fs.constants.F_OK | mode === "w" ? fs.constants.W_OK : fs.constants.R_OK;
      try {
        fs.accessSync(filePath, accessMode);
        const type = localExists(filePath);
        return {
          status: true,
          type,
          details: "access OK",
          code: 0
        };
      } catch (err) {
        switch (err.errno) {
          case -2:
            return {
              status: false,
              type: null,
              details: "not exist",
              code: -2
            };
          case -13:
            return {
              status: false,
              type: localExists(filePath),
              details: "permission denied",
              code: -13
            };
          case -20:
            return {
              status: false,
              type: null,
              details: "parent not a directory"
            };
          default:
            return {
              status: false,
              type: null,
              details: err.message
            };
        }
      }
    }
    function haveLocalCreate(filePath) {
      const { status, details, type } = haveLocalAccess(filePath, "w");
      if (!status && details === "permission denied") {
        return {
          status,
          details,
          type
        };
      } else if (!status) {
        const dirPath = path.dirname(filePath);
        const localCheck = haveLocalAccess(dirPath, "w");
        if (localCheck.status && localCheck.type !== "d") {
          return {
            status: false,
            details: `${dirPath}: not a directory`,
            type: null
          };
        } else if (!localCheck.status) {
          return {
            status: localCheck.status,
            details: `${dirPath}: ${localCheck.details}`,
            type: null
          };
        } else {
          return {
            status: true,
            details: "access OK",
            type: null,
            code: 0
          };
        }
      }
      return { status, details, type };
    }
    async function normalizeRemotePath(client, aPath) {
      try {
        if (aPath.startsWith("..")) {
          let root = await client.realPath("..");
          return root + client.remotePathSep + aPath.slice(3);
        } else if (aPath.startsWith(".")) {
          let root = await client.realPath(".");
          return root + client.remotePathSep + aPath.slice(2);
        }
        return aPath;
      } catch (err) {
        throw fmtError(err, "normalizeRemotePath");
      }
    }
    function haveConnection(client, name, reject) {
      if (!client.sftp) {
        let newError = fmtError(
          "No SFTP connection available",
          name,
          errorCode.connect
        );
        if (reject) {
          reject(newError);
          return false;
        } else {
          throw newError;
        }
      }
      return true;
    }
    function sleep(ms) {
      return new Promise((resolve, reject) => {
        try {
          setTimeout(() => {
            resolve(true);
          }, ms);
        } catch (err) {
          reject(err);
        }
      });
    }
    module2.exports = {
      fmtError,
      errorListener,
      endListener,
      closeListener,
      addTempListeners,
      removeTempListeners,
      haveLocalAccess,
      haveLocalCreate,
      normalizeRemotePath,
      localExists,
      haveConnection,
      sleep
    };
  }
});

// node_modules/ssh2-sftp-client/src/index.js
var require_src = __commonJS({
  "node_modules/ssh2-sftp-client/src/index.js"(exports, module2) {
    "use strict";
    var { Client: Client2 } = require_lib3();
    var fs = require("fs");
    var concat = require_concat_stream();
    var promiseRetry = require_promise_retry();
    var { join, parse } = require("path");
    var {
      fmtError,
      addTempListeners,
      removeTempListeners,
      haveConnection,
      normalizeRemotePath,
      localExists,
      haveLocalAccess,
      haveLocalCreate,
      sleep
    } = require_utils3();
    var { errorCode } = require_constants2();
    var SftpClient = class {
      constructor(clientName) {
        this.client = new Client2();
        this.sftp = void 0;
        this.clientName = clientName ? clientName : "sftp";
        this.endCalled = false;
        this.errorHandled = false;
        this.closeHandled = false;
        this.endHandled = false;
        this.remotePathSep = "/";
        this.remotePlatform = "unix";
        this.debug = void 0;
        this.client.on("close", () => {
          if (this.endCalled || this.closeHandled) {
            this.debugMsg("Global: Ignoring handled close event");
          } else {
            this.debugMsg("Global: Handling unexpected close event");
            this.sftp = void 0;
          }
        });
        this.client.on("end", () => {
          if (this.endCalled || this.endHandled) {
            this.debugMsg("Global: Ignoring hanlded end event");
          } else {
            this.debugMsg("Global: Handling unexpected end event");
            this.sftp = void 0;
          }
        });
        this.client.on("error", (err) => {
          if (this.endCalled || this.errorHandled) {
            this.debugMsg(`Global: Ignoring handled error: ${err.message}`);
          } else {
            this.debugMsg(`Global; Handling unexpected error; ${err.message}`);
            this.sftp = void 0;
            console.log(
              `ssh2-sftp-client: Unexpected error: ${err.message}. Error code: ${err.code}`
            );
          }
        });
      }
      debugMsg(msg, obj) {
        if (this.debug) {
          if (obj) {
            this.debug(
              `CLIENT[${this.clientName}]: ${msg} ${JSON.stringify(obj, null, " ")}`
            );
          } else {
            this.debug(`CLIENT[${this.clientName}]: ${msg}`);
          }
        }
      }
      /**
       * Add a listner to the client object. This is rarely necessary and can be
       * the source of errors. It is the client's responsibility to remove the
       * listeners when no longer required. Failure to do so can result in memory
       * leaks.
       *
       * @param {string} eventType - one of the supported event types
       * @param {function} callback - function called when event triggers
       */
      on(eventType, callback) {
        this.debugMsg(`Adding listener to ${eventType} event`);
        this.client.prependListener(eventType, callback);
      }
      removeListener(eventType, callback) {
        this.debugMsg(`Removing listener from ${eventType} event`);
        this.client.removeListener(eventType, callback);
      }
      _resetEventFlags() {
        this.closeHandled = false;
        this.endHandled = false;
        this.errorHandled = false;
      }
      /**
       * @async
       *
       * Create a new SFTP connection to a remote SFTP server
       *
       * @param {Object} config - an SFTP configuration object
       *
       * @return {Promise<Object>} which will resolve to an sftp client object
       *
       */
      getConnection(config) {
        let doReady, listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "getConnection", reject);
          this.debugMsg("getConnection: created promise");
          doReady = () => {
            this.debugMsg(
              "getConnection ready listener: got connection - promise resolved"
            );
            resolve(true);
          };
          this.on("ready", doReady);
          this.client.connect(config);
        }).finally(async () => {
          this.debugMsg("getConnection: finally clause fired");
          await sleep(500);
          this.removeListener("ready", doReady);
          removeTempListeners(this, listeners, "getConnection");
          this._resetEventFlags();
        });
      }
      getSftpChannel() {
        let listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "getSftpChannel", reject);
          this.debugMsg("getSftpChannel: created promise");
          this.client.sftp((err, sftp) => {
            if (err) {
              this.debugMsg(`getSftpChannel: SFTP Channel Error: ${err.message}`);
              this.client.end();
              reject(fmtError(err, "getSftpChannel", err.code));
            } else {
              this.debugMsg("getSftpChannel: SFTP channel established");
              this.sftp = sftp;
              resolve(sftp);
            }
          });
        }).finally(() => {
          this.debugMsg("getSftpChannel: finally clause fired");
          removeTempListeners(this, listeners, "getSftpChannel");
          this._resetEventFlags();
        });
      }
      /**
       * @async
       *
       * Create a new SFTP connection to a remote SFTP server.
       * The connection options are the same as those offered
       * by the underlying SSH2 module.
       *
       * @param {Object} config - an SFTP configuration object
       *
       * @return {Promise<Object>} which will resolve to an sftp client object
       *
       */
      async connect(config) {
        try {
          if (config.debug) {
            this.debug = config.debug;
            this.debugMsg("connect: Debugging turned on");
          }
          if (this.sftp) {
            this.debugMsg("connect: Already connected - reject");
            throw fmtError(
              "An existing SFTP connection is already defined",
              "connect",
              errorCode.connect
            );
          }
          await promiseRetry(
            (retry, attempt) => {
              this.debugMsg(`connect: Connect attempt ${attempt}`);
              return this.getConnection(config).catch((err) => {
                this.debugMsg(
                  `getConnection retry catch: ${err.message} Code: ${err.code}`
                );
                switch (err.code) {
                  case "ENOTFOUND":
                  case "ECONNREFUSED":
                  case "ERR_SOCKET_BAD_PORT":
                    throw err;
                  default:
                    retry(err);
                }
              });
            },
            {
              retries: config.retries || 1,
              factor: config.retry_factor || 2,
              minTimeout: config.retry_minTimeout || 1e3
            }
          );
          return this.getSftpChannel();
        } catch (err) {
          this.debugMsg(`connect: Error ${err.message}`);
          this._resetEventFlags();
          throw fmtError(err, "connect");
        }
      }
      /**
       * @async
       *
       * Returns the real absolute path on the remote server. Is able to handle
       * both '.' and '..' in path names, but not '~'. If the path is relative
       * then the current working directory is prepended to create an absolute path.
       * Returns undefined if the path does not exists.
       *
       * @param {String} remotePath - remote path, may be relative
       * @returns {Promise<String>} - remote absolute path or ''
       */
      realPath(remotePath) {
        let listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "realPath", reject);
          this.debugMsg(`realPath -> ${remotePath}`);
          if (haveConnection(this, "realPath", reject)) {
            this.sftp.realpath(remotePath, (err, absPath) => {
              if (err) {
                this.debugMsg(`realPath Error: ${err.message} Code: ${err.code}`);
                if (err.code === 2) {
                  resolve("");
                } else {
                  reject(
                    fmtError(`${err.message} ${remotePath}`, "realPath", err.code)
                  );
                }
              }
              this.debugMsg(`realPath <- ${absPath}`);
              resolve(absPath);
            });
          }
        }).finally(() => {
          removeTempListeners(this, listeners, "realPath");
          this._resetEventFlags();
        });
      }
      /**
       * @async
       *
       * Return the current workding directory path
       *
       * @returns {Promise<String>} - current remote working directory
       */
      cwd() {
        return this.realPath(".");
      }
      /**
       * Retrieves attributes for path
       *
       * @param {String} remotePath - a string containing the path to a file
       * @return {Promise<Object>} stats - attributes info
       */
      async stat(remotePath) {
        const _stat = (aPath) => {
          let listeners;
          return new Promise((resolve, reject) => {
            listeners = addTempListeners(this, "_stat", reject);
            this.debugMsg(`_stat: ${aPath}`);
            this.sftp.stat(aPath, (err, stats) => {
              if (err) {
                this.debugMsg(`_stat: Error ${err.message} code: ${err.code}`);
                if (err.code === 2 || err.code === 4) {
                  reject(
                    fmtError(
                      `No such file: ${remotePath}`,
                      "_stat",
                      errorCode.notexist
                    )
                  );
                } else {
                  reject(
                    fmtError(`${err.message} ${remotePath}`, "_stat", err.code)
                  );
                }
              } else {
                let result = {
                  mode: stats.mode,
                  uid: stats.uid,
                  gid: stats.gid,
                  size: stats.size,
                  accessTime: stats.atime * 1e3,
                  modifyTime: stats.mtime * 1e3,
                  isDirectory: stats.isDirectory(),
                  isFile: stats.isFile(),
                  isBlockDevice: stats.isBlockDevice(),
                  isCharacterDevice: stats.isCharacterDevice(),
                  isSymbolicLink: stats.isSymbolicLink(),
                  isFIFO: stats.isFIFO(),
                  isSocket: stats.isSocket()
                };
                this.debugMsg("_stat: stats <- ", result);
                resolve(result);
              }
            });
          }).finally(() => {
            removeTempListeners(this, listeners, "_stat");
          });
        };
        try {
          haveConnection(this, "stat");
          let absPath = await normalizeRemotePath(this, remotePath);
          return _stat(absPath);
        } catch (err) {
          this._resetEventFlags();
          throw err.custom ? err : fmtError(err, "stat", err.code);
        }
      }
      /**
       * @async
       *
       * Tests to see if an object exists. If it does, return the type of that object
       * (in the format returned by list). If it does not exist, return false.
       *
       * @param {string} remotePath - path to the object on the sftp server.
       *
       * @return {Promise<Boolean|String>} returns false if object does not exist. Returns type of
       *                   object if it does
       */
      async exists(remotePath) {
        try {
          if (haveConnection(this, "exists")) {
            if (remotePath === ".") {
              this.debugMsg("exists: . = d");
              return "d";
            }
            let absPath = await normalizeRemotePath(this, remotePath);
            try {
              this.debugMsg(`exists: ${remotePath} -> ${absPath}`);
              let info = await this.stat(absPath);
              this.debugMsg("exists: <- ", info);
              if (info.isDirectory) {
                this.debugMsg(`exists: ${remotePath} = d`);
                return "d";
              }
              if (info.isSymbolicLink) {
                this.debugMsg(`exists: ${remotePath} = l`);
                return "l";
              }
              if (info.isFile) {
                this.debugMsg(`exists: ${remotePath} = -`);
                return "-";
              }
              this.debugMsg(`exists: ${remotePath} = false`);
              return false;
            } catch (err) {
              if (err.code === errorCode.notexist) {
                this.debugMsg(
                  `exists: ${remotePath} = false errorCode = ${err.code}`
                );
                return false;
              }
              this.debugMsg(`exists: throw error ${err.message} ${err.code}`);
              throw err;
            }
          }
          this.debugMsg(`exists: default ${remotePath} = false`);
          return false;
        } catch (err) {
          this._resetEventFlags();
          throw err.custom ? err : fmtError(err, "exists", err.code);
        }
      }
      /**
       * @async
       *
       * List contents of a remote directory. If a pattern is provided,
       * filter the results to only include files with names that match
       * the supplied pattern. Return value is an array of file entry
       * objects that include properties for type, name, size, modifiyTime,
       * accessTime, rights {user, group other}, owner and group.
       *
       * @param {String} remotePath - path to remote directory
       * @param {RegExp} pattern - regular expression to match filenames
       * @returns {Promise<Array>} array of file description objects
       */
      list(remotePath, pattern = /.*/) {
        let listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "list", reject);
          if (haveConnection(this, "list", reject)) {
            const reg = /-/gi;
            this.debugMsg(`list: ${remotePath} filter: ${pattern}`);
            this.sftp.readdir(remotePath, (err, fileList) => {
              if (err) {
                this.debugMsg(`list: Error ${err.message} code: ${err.code}`);
                reject(fmtError(`${err.message} ${remotePath}`, "list", err.code));
              } else {
                let newList = [];
                if (fileList) {
                  newList = fileList.map((item) => {
                    return {
                      type: item.longname.slice(0, 1),
                      name: item.filename,
                      size: item.attrs.size,
                      modifyTime: item.attrs.mtime * 1e3,
                      accessTime: item.attrs.atime * 1e3,
                      rights: {
                        user: item.longname.slice(1, 4).replace(reg, ""),
                        group: item.longname.slice(4, 7).replace(reg, ""),
                        other: item.longname.slice(7, 10).replace(reg, "")
                      },
                      owner: item.attrs.uid,
                      group: item.attrs.gid,
                      longname: item.longname
                    };
                  });
                }
                let regex;
                if (pattern instanceof RegExp) {
                  regex = pattern;
                } else {
                  let newPattern = pattern.replace(/\*([^*])*?/gi, ".*");
                  regex = new RegExp(newPattern);
                }
                let filteredList = newList.filter((item) => regex.test(item.name));
                this.debugMsg("list: result: ", filteredList);
                resolve(filteredList);
              }
            });
          }
        }).finally(() => {
          removeTempListeners(this, listeners, "list");
          this._resetEventFlags();
        });
      }
      /**
       * get file
       *
       * If a dst argument is provided, it must be either a string, representing the
       * local path to where the data will be put, a stream, in which case data is
       * piped into the stream or undefined, in which case the data is returned as
       * a Buffer object.
       *
       * @param {String} remotePath - remote file path
       * @param {string|stream|undefined} dst - data destination
       * @param {Object} options - options object with supported properties of readStreamOptions,
       *                          writeStreamOptions and pipeOptions.
       *
       * @return {Promise<String|Stream|Buffer>}
       */
      get(remotePath, dst, options = { readStreamOptions: {}, writeStreamOptions: {}, pipeOptions: {} }) {
        let rdr, wtr, listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "get", reject);
          if (haveConnection(this, "get", reject)) {
            this.debugMsg(`get -> ${remotePath} `, options);
            rdr = this.sftp.createReadStream(
              remotePath,
              options.readStreamOptions ? options.readStreamOptions : {}
            );
            rdr.once("error", (err) => {
              reject(fmtError(`${err.message} ${remotePath}`, "get", err.code));
            });
            if (dst === void 0) {
              this.debugMsg("get returning buffer of data");
              wtr = concat((buff) => {
                resolve(buff);
              });
            } else {
              if (typeof dst === "string") {
                this.debugMsg("get returning local file");
                const localCheck = haveLocalCreate(dst);
                if (!localCheck.status) {
                  return reject(
                    fmtError(
                      `Bad path: ${dst}: ${localCheck.details}`,
                      "get",
                      localCheck.code
                    )
                  );
                }
                wtr = fs.createWriteStream(
                  dst,
                  options.writeStreamOptions ? options.writeStreamOptions : {}
                );
              } else {
                this.debugMsg("get returning data into supplied stream");
                wtr = dst;
              }
              wtr.once("error", (err) => {
                reject(
                  fmtError(
                    `${err.message} ${typeof dst === "string" ? dst : ""}`,
                    "get",
                    err.code
                  )
                );
              });
              if (Object.hasOwnProperty.call(options, "pipeOptions") && Object.hasOwnProperty.call(options.pipeOptions, "end") && !options.pipeOptions.end) {
                rdr.once("end", () => {
                  this.debugMsg("get resolved on reader end event");
                  if (typeof dst === "string") {
                    resolve(dst);
                  } else {
                    resolve(wtr);
                  }
                });
              } else {
                wtr.once("finish", () => {
                  this.debugMsg("get resolved on writer finish event");
                  if (typeof dst === "string") {
                    resolve(dst);
                  } else {
                    resolve(wtr);
                  }
                });
              }
            }
            rdr.pipe(wtr, options.pipeOptions ? options.pipeOptions : {});
          }
        }).finally(() => {
          removeTempListeners(this, listeners, "get");
          this._resetEventFlags();
          if (rdr && Object.hasOwnProperty.call(options, "readStreamOptions") && Object.hasOwnProperty.call(options.readStreamOptions, "autoClose") && options.readStreamOptions.autoClose === false) {
            rdr.destroy();
          }
          if (wtr && Object.hasOwnProperty.call(options, "writeStreamOptions") && Object.hasOwnProperty.call(options.writeStreamOptions, "autoClose") && options.writeStreamOptions.autoClose === false && typeof dst === "string") {
            wtr.destroy();
          }
        });
      }
      /**
       * Use SSH2 fastGet for downloading the file.
       * Downloads a file at remotePath to localPath using parallel reads
       * for faster throughput.
       *
       * @param {String} remotePath
       * @param {String} localPath
       * @param {Object} options
       * @return {Promise<String>} the result of downloading the file
       */
      async fastGet(remotePath, localPath, options) {
        try {
          const ftype = await this.exists(remotePath);
          if (ftype !== "-") {
            const msg = ftype === false ? `No such file ${remotePath}` : `Not a regular file ${remotePath}`;
            let err = new Error(msg);
            err.code = errorCode.badPath;
            throw err;
          }
          const localCheck = haveLocalCreate(localPath);
          if (!localCheck.status) {
            let err = new Error(`Bad path: ${localPath}: ${localCheck.details}`);
            err.code = errorCode.badPath;
            throw err;
          }
          let listeners;
          let rslt = await new Promise((resolve, reject) => {
            listeners = addTempListeners(this, "fastGet", reject);
            if (haveConnection(this, "fastGet", reject)) {
              this.debugMsg(
                `fastGet -> remote: ${remotePath} local: ${localPath} `,
                options
              );
              this.sftp.fastGet(remotePath, localPath, options, (err) => {
                if (err) {
                  this.debugMsg(`fastGet error ${err.message} code: ${err.code}`);
                  reject(err);
                }
                resolve(`${remotePath} was successfully download to ${localPath}!`);
              });
            }
          }).finally(() => {
            removeTempListeners(this, listeners, "fastGet");
          });
          return rslt;
        } catch (err) {
          this._resetEventFlags();
          throw fmtError(err, "fastGet");
        }
      }
      /**
       * Use SSH2 fastPut for uploading the file.
       * Uploads a file from localPath to remotePath using parallel reads
       * for faster throughput.
       *
       * See 'fastPut' at
       * https://github.com/mscdex/ssh2-streams/blob/master/SFTPStream.md
       *
       * @param {String} localPath
       * @param {String} remotePath
       * @param {Object} options
       * @return {Promise<String>} the result of downloading the file
       */
      fastPut(localPath, remotePath, options) {
        let listeners;
        this.debugMsg(`fastPut -> local ${localPath} remote ${remotePath}`);
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "fastPut", reject);
          const localCheck = haveLocalAccess(localPath);
          if (!localCheck.status) {
            reject(
              fmtError(
                `Bad path: ${localPath}: ${localCheck.details}`,
                "fastPut",
                localCheck.code
              )
            );
          } else if (localCheck.status && localExists(localPath) === "d") {
            reject(
              fmtError(
                `Bad path: ${localPath} not a regular file`,
                "fastPut",
                errorCode.badPath
              )
            );
          } else if (haveConnection(this, "fastPut", reject)) {
            this.debugMsg(
              `fastPut -> local: ${localPath} remote: ${remotePath} opts: ${JSON.stringify(
                options
              )}`
            );
            this.sftp.fastPut(localPath, remotePath, options, (err) => {
              if (err) {
                this.debugMsg(`fastPut error ${err.message} ${err.code}`);
                reject(
                  fmtError(
                    `${err.message} Local: ${localPath} Remote: ${remotePath}`,
                    "fastPut",
                    err.code
                  )
                );
              }
              this.debugMsg("fastPut file transferred");
              resolve(`${localPath} was successfully uploaded to ${remotePath}!`);
            });
          }
        }).finally(() => {
          removeTempListeners(this, listeners, "fastPut");
          this._resetEventFlags();
        });
      }
      /**
       * Create a file on the remote server. The 'src' argument
       * can be a buffer, string or read stream. If 'src' is a string, it
       * should be the path to a local file.
       *
       * @param  {String|Buffer|stream} localSrc - source data to use
       * @param  {String} remotePath - path to remote file
       * @param  {Object} options - options used for read, write stream and pipe configuration
       *                            value supported by node. Allowed properties are readStreamOptions,
       *                            writeStreamOptions and pipeOptions.
       * @return {Promise<String>}
       */
      put(localSrc, remotePath, options = {
        readStreamOptions: {},
        writeStreamOptions: { autoClose: true },
        pipeOptions: {}
      }) {
        let wtr, rdr, listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "put", reject);
          if (typeof localSrc === "string") {
            const localCheck = haveLocalAccess(localSrc);
            if (!localCheck.status) {
              this.debugMsg(`put: local source check error ${localCheck.details}`);
              return reject(
                fmtError(
                  `Bad path: ${localSrc}: ${localCheck.details}`,
                  "put",
                  localCheck.code
                )
              );
            }
          }
          if (haveConnection(this, "put")) {
            wtr = this.sftp.createWriteStream(
              remotePath,
              options.writeStreamOptions ? { ...options.writeStreamOptions, autoClose: true } : {}
            );
            wtr.once("error", (err) => {
              this.debugMsg(`put: write stream error ${err.message}`);
              reject(fmtError(`${err.message} ${remotePath}`, "put", err.code));
            });
            wtr.once("close", () => {
              this.debugMsg("put: promise resolved");
              resolve(`Uploaded data stream to ${remotePath}`);
            });
            if (localSrc instanceof Buffer) {
              this.debugMsg("put source is a buffer");
              wtr.end(localSrc);
            } else {
              if (typeof localSrc === "string") {
                this.debugMsg(`put source is a file path: ${localSrc}`);
                rdr = fs.createReadStream(
                  localSrc,
                  options.readStreamOptions ? options.readStreamOptions : {}
                );
              } else {
                this.debugMsg("put source is a stream");
                rdr = localSrc;
              }
              rdr.once("error", (err) => {
                this.debugMsg(`put: read stream error ${err.message}`);
                reject(
                  fmtError(
                    `${err.message} ${typeof localSrc === "string" ? localSrc : ""}`,
                    "put",
                    err.code
                  )
                );
              });
              rdr.pipe(wtr, options.pipeOptions ? options.pipeOptions : {});
            }
          }
        }).finally(() => {
          removeTempListeners(this, listeners, "put");
          this._resetEventFlags();
          if (rdr && Object.hasOwnProperty.call(options, "readStreamOptions") && Object.hasOwnProperty.call(options.readStreamOptions, "autoClose") && options.readStreamOptions.autoClose === false && typeof localSrc === "string") {
            rdr.destroy();
          }
        });
      }
      /**
       * Append to an existing remote file
       *
       * @param  {Buffer|stream} input
       * @param  {String} remotePath
       * @param  {Object} options
       * @return {Promise<String>}
       */
      async append(input, remotePath, options = {}) {
        const _append = (input2, remotePath2, options2) => {
          return new Promise((resolve, reject) => {
            this.debugMsg(`append -> remote: ${remotePath2} `, options2);
            options2.flags = "a";
            let stream = this.sftp.createWriteStream(remotePath2, options2);
            stream.on("error", (err) => {
              this.debugMsg(
                `append: Error ${err.message} appending to ${remotePath2}`
              );
              reject(fmtError(`${err.message} ${remotePath2}`, "append", err.code));
            });
            stream.on("close", () => {
              this.debugMsg(`append: data appended to ${remotePath2}`);
              resolve(`Appended data to ${remotePath2}`);
            });
            if (input2 instanceof Buffer) {
              this.debugMsg("append: writing data buffer to remote file");
              stream.write(input2);
              stream.end();
            } else {
              this.debugMsg("append: writing stream to remote file");
              input2.pipe(stream);
            }
          });
        };
        let listeners;
        try {
          listeners = addTempListeners(this, "append");
          if (typeof input === "string") {
            this.debugMsg("append: attempt to append two files - throw");
            throw fmtError(
              "Cannot append one file to another",
              "append",
              errorCode.badPath
            );
          }
          if (haveConnection(this, "append")) {
            const fileType = await this.exists(remotePath);
            if (fileType && fileType === "d") {
              this.debugMsg(`append: Error ${remotePath} not a file`);
              throw fmtError(
                `Bad path: ${remotePath}: cannot append to a directory`,
                "append",
                errorCode.badPath
              );
            }
            await _append(input, remotePath, options);
          }
        } catch (e) {
          throw e.custom ? e : fmtError(e.message, "append", e.code);
        } finally {
          removeTempListeners(this, listeners, "append");
          this._resetEventFlags();
        }
      }
      /**
       * @async
       *
       * Make a directory on remote server
       *
       * @param {string} remotePath - remote directory path.
       * @param {boolean} recursive - if true, recursively create directories
       * @return {Promise<String>}
       */
      async mkdir(remotePath, recursive = false) {
        const _mkdir = (p) => {
          let listeners;
          return new Promise((resolve, reject) => {
            listeners = addTempListeners(this, "_mkdir", reject);
            this.debugMsg(`_mkdir: create ${p}`);
            this.sftp.mkdir(p, (err) => {
              if (err) {
                this.debugMsg(`_mkdir: Error ${err.message} code: ${err.code}`);
                if (err.code === 4) {
                  let error = new Error(`Bad path: ${p} permission denied`);
                  error.code = errorCode.badPath;
                  reject(error);
                } else if (err.code === 2) {
                  let error = new Error(
                    `Bad path: ${p} parent not a directory or not exist`
                  );
                  error.code = errorCode.badPath;
                  reject(error);
                } else {
                  reject(err);
                }
              } else {
                this.debugMsg("_mkdir: directory created");
                resolve(`${p} directory created`);
              }
            });
          }).finally(() => {
            removeTempListeners(this, listeners, "_mkdir");
            this._resetEventFlags();
          });
        };
        try {
          haveConnection(this, "mkdir");
          let rPath = await normalizeRemotePath(this, remotePath);
          let targetExists = await this.exists(rPath);
          if (targetExists && targetExists !== "d") {
            let error = new Error(`Bad path: ${rPath} already exists as a file`);
            error.code = errorCode.badPath;
            throw error;
          } else if (targetExists) {
            return `${rPath} already exists`;
          }
          if (!recursive) {
            return await _mkdir(rPath);
          }
          let dir = parse(rPath).dir;
          if (dir) {
            let dirExists = await this.exists(dir);
            if (!dirExists) {
              await this.mkdir(dir, true);
            } else if (dirExists !== "d") {
              let error = new Error(`Bad path: ${dir} not a directory`);
              error.code = errorCode.badPath;
              throw error;
            }
          }
          return await _mkdir(rPath);
        } catch (err) {
          throw fmtError(`${err.message}`, "mkdir", err.code);
        }
      }
      /**
       * @async
       *
       * Remove directory on remote server
       *
       * @param {string} remotePath - path to directory to be removed
       * @param {boolean} recursive - if true, remove directories/files in target
       *                             directory
       * @return {Promise<String>}
       */
      async rmdir(remotePath, recursive = false) {
        const _delete = (remotePath2) => {
          return new Promise((resolve, reject) => {
            this.sftp.unlink(remotePath2, (err) => {
              if (err && err.code !== 2) {
                reject(fmtError(`${err.message} ${remotePath2}`, "rmdir", err.code));
              }
              resolve(true);
            });
          });
        };
        const _rmdir = (p) => {
          return new Promise((resolve, reject) => {
            this.debugMsg(`rmdir -> ${p}`);
            this.sftp.rmdir(p, (err) => {
              if (err) {
                this.debugMsg(`rmdir error ${err.message} code: ${err.code}`);
                reject(fmtError(`${err.message} ${p}`, "rmdir", err.code));
              }
              resolve("Successfully removed directory");
            });
          }).finally(() => {
            removeTempListeners(this, listeners, "_rmdir");
          });
        };
        const _dormdir = async (p, recur) => {
          try {
            if (recur) {
              let list = await this.list(p);
              if (list.length) {
                let files = list.filter((item) => item.type !== "d");
                let dirs = list.filter((item) => item.type === "d");
                this.debugMsg("rmdir contents (files): ", files);
                this.debugMsg("rmdir contents (dirs): ", dirs);
                for (let d of dirs) {
                  await _dormdir(`${p}${this.remotePathSep}${d.name}`, true);
                }
                let promiseList = [];
                for (let f of files) {
                  promiseList.push(_delete(`${p}${this.remotePathSep}${f.name}`));
                }
                await Promise.all(promiseList);
              }
            }
            return await _rmdir(p);
          } catch (err) {
            throw err.custom ? err : fmtError(err, "_dormdir", err.code);
          }
        };
        let listeners;
        try {
          listeners = addTempListeners(this, "rmdir");
          haveConnection(this, "rmdir");
          let absPath = await normalizeRemotePath(this, remotePath);
          let dirStatus = await this.exists(absPath);
          if (dirStatus && dirStatus !== "d") {
            throw fmtError(
              `Bad path: ${absPath} not a directory`,
              "rmdir",
              errorCode.badPath
            );
          } else if (!dirStatus) {
            throw fmtError(
              `Bad path: ${absPath} No such file`,
              "rmdir",
              errorCode.badPath
            );
          } else {
            return await _dormdir(absPath, recursive);
          }
        } catch (err) {
          this._resetEventFlags();
          throw err.custom ? err : fmtError(err, "rmdir", err.code);
        } finally {
          removeTempListeners(this, listeners, "rmdir");
        }
      }
      /**
       * @async
       *
       * Delete a file on the remote SFTP server
       *
       * @param {string} remotePath - path to the file to delete
       * @param {boolean} notFoundOK - if true, ignore errors for missing target.
       *                               Default is false.
       * @return {Promise<String>} with string 'Successfully deleted file' once resolved
       *
       */
      delete(remotePath, notFoundOK = false) {
        let listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "delete", reject);
          if (haveConnection(this, "delete", reject)) {
            this.debugMsg(`delete -> ${remotePath}`);
            this.sftp.unlink(remotePath, (err) => {
              if (err) {
                this.debugMsg(`delete error ${err.message} code: ${err.code}`);
                if (notFoundOK && err.code === 2) {
                  this.debugMsg("delete ignore missing target error");
                  resolve(`Successfully deleted ${remotePath}`);
                } else {
                  reject(
                    fmtError(`${err.message} ${remotePath}`, "delete", err.code)
                  );
                }
              }
              resolve(`Successfully deleted ${remotePath}`);
            });
          }
        }).finally(() => {
          removeTempListeners(this, listeners, "delete");
          this._resetEventFlags();
        });
      }
      /**
       * @async
       *
       * Rename a file on the remote SFTP repository
       *
       * @param {string} fromPath - path to the file to be renamed.
       * @param {string} toPath - path to the new name.
       *
       * @return {Promise<String>}
       *
       */
      rename(fromPath, toPath) {
        let listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "rename", reject);
          if (haveConnection(this, "rename", reject)) {
            this.debugMsg(`rename -> ${fromPath} ${toPath}`);
            this.sftp.rename(fromPath, toPath, (err) => {
              if (err) {
                this.debugMsg(`rename error ${err.message} code: ${err.code}`);
                reject(
                  fmtError(
                    `${err.message} From: ${fromPath} To: ${toPath}`,
                    "rename",
                    err.code
                  )
                );
              }
              resolve(`Successfully renamed ${fromPath} to ${toPath}`);
            });
          }
        }).finally(() => {
          removeTempListeners(this, listeners, "rename");
          this._resetEventFlags();
        });
      }
      /**
       * @async
       *
       * Rename a file on the remote SFTP repository using the SSH extension
       * posix-rename@openssh.com using POSIX atomic rename. (Introduced in SSH 4.8)
       *
       * @param {string} fromPath - path to the file to be renamed.
       * @param {string} toPath - path  the new name.
       *
       * @return {Promise<String>}
       *
       */
      posixRename(fromPath, toPath) {
        let listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "posixRename", reject);
          if (haveConnection(this, "posixRename", reject)) {
            this.debugMsg(`posixRename -> ${fromPath} ${toPath}`);
            this.sftp.ext_openssh_rename(fromPath, toPath, (err) => {
              if (err) {
                this.debugMsg(`posixRename error ${err.message} code: ${err.code}`);
                reject(
                  fmtError(
                    `${err.message} From: ${fromPath} To: ${toPath}`,
                    "posixRename",
                    err.code
                  )
                );
              }
              resolve(`Successful POSIX rename ${fromPath} to ${toPath}`);
            });
          }
        }).finally(() => {
          removeTempListeners(this, listeners, "posixRename");
          this._resetEventFlags();
        });
      }
      /**
       * @async
       *
       * Change the mode of a remote file on the SFTP repository
       *
       * @param {string} remotePath - path to the remote target object.
       * @param {number | string} mode - the new octal mode to set
       *
       * @return {Promise<String>}
       */
      chmod(remotePath, mode) {
        let listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "chmod", reject);
          this.debugMsg(`chmod -> ${remotePath} ${mode}`);
          this.sftp.chmod(remotePath, mode, (err) => {
            if (err) {
              reject(fmtError(`${err.message} ${remotePath}`, "chmod", err.code));
            }
            resolve("Successfully change file mode");
          });
        }).finally(() => {
          removeTempListeners(this, listeners, "chmod");
          this._resetEventFlags();
        });
      }
      /**
       * @async
       *
       * Upload the specified source directory to the specified destination
       * directory. All regular files and sub-directories are uploaded to the remote
       * server.
       * @param {String} srcDir - local source directory
       * @param {String} dstDir - remote destination directory
       * @param {function(String,Boolean):Boolean} filter - (Optional) The first argument is the full path of the item to be uploaded and the second argument is a boolean, which will be true if the target path is for a directory.  If the function returns true, the item will be uploaded
       * @returns {Promise<String>}
       */
      async uploadDir(srcDir, dstDir, filter) {
        try {
          this.debugMsg(`uploadDir -> SRC = ${srcDir} DST = ${dstDir}`);
          haveConnection(this, "uploadDir");
          let absDstDir = await normalizeRemotePath(this, dstDir);
          this.debugMsg(`uploadDir <- SRC = ${srcDir} DST = ${absDstDir}`);
          const srcType = localExists(srcDir);
          if (!srcType) {
            throw fmtError(
              `Bad path: ${srcDir} not exist`,
              "uploadDir",
              errorCode.badPath
            );
          }
          if (srcType !== "d") {
            throw fmtError(
              `Bad path: ${srcDir}: not a directory`,
              "uploadDir",
              errorCode.badPath
            );
          }
          let dstStatus = await this.exists(absDstDir);
          if (dstStatus && dstStatus !== "d") {
            this.debugMsg(`UploadDir: DST ${absDstDir} exists but not a directory`);
            throw fmtError(
              `Bad path ${absDstDir} Not a directory`,
              "uploadDir",
              errorCode.badPath
            );
          }
          if (!dstStatus) {
            this.debugMsg(`UploadDir: Creating directory ${absDstDir}`);
            await this.mkdir(absDstDir, true);
          }
          let dirEntries = fs.readdirSync(srcDir, {
            encoding: "utf8",
            withFileTypes: true
          });
          if (filter) {
            dirEntries = dirEntries.filter(
              (item) => filter(join(srcDir, item.name), item.isDirectory())
            );
          }
          for (let e of dirEntries) {
            let newSrc = join(srcDir, e.name);
            let newDst = `${absDstDir}${this.remotePathSep}${e.name}`;
            if (e.isDirectory()) {
              await this.uploadDir(newSrc, newDst, filter);
            } else if (e.isFile()) {
              await this.put(newSrc, newDst);
              this.client.emit("upload", { source: newSrc, destination: newDst });
            } else {
              this.debugMsg(
                `uploadDir: File ignored: ${e.name} not a regular file`
              );
            }
          }
          return `${srcDir} uploaded to ${absDstDir}`;
        } catch (err) {
          this._resetEventFlags();
          throw err.custom ? err : fmtError(err, "uploadDir");
        }
      }
      /**
       * @async
       *
       * Download the specified source directory to the specified destination
       * directory. All regular files and sub-directories are downloaded to the local
       * file system.
       * @param {String} srcDir - remote source directory
       * @param {String} dstDir - local destination directory
       * @param {function(String,Boolean):Boolean} filter - (Optional) The first argument is the full path of the item to be downloaded and the second argument is a boolean, which will be true if the target path is for a directory.  If the function returns true, the item will be downloaded
       * @returns {Promise<String>}
       */
      async downloadDir(srcDir, dstDir, filter) {
        try {
          this.debugMsg(`downloadDir -> ${srcDir} ${dstDir}`);
          haveConnection(this, "downloadDir");
          let fileList = await this.list(srcDir);
          if (filter) {
            fileList = fileList.filter(
              (item) => filter(
                `${srcDir}${this.remotePathSep}${item.name}`,
                item.type === "d" ? true : false
              )
            );
          }
          const localCheck = haveLocalCreate(dstDir);
          if (!localCheck.status && localCheck.details === "permission denied") {
            throw fmtError(
              `Bad path: ${dstDir}: ${localCheck.details}`,
              "downloadDir",
              localCheck.code
            );
          } else if (localCheck.status && !localCheck.type) {
            fs.mkdirSync(dstDir, { recursive: true });
          } else if (localCheck.status && localCheck.type !== "d") {
            throw fmtError(
              `Bad path: ${dstDir}: not a directory`,
              "downloadDir",
              errorCode.badPath
            );
          }
          for (let f of fileList) {
            let newSrc = `${srcDir}${this.remotePathSep}${f.name}`;
            let newDst = join(dstDir, f.name);
            if (f.type === "d") {
              await this.downloadDir(newSrc, newDst, filter);
            } else if (f.type === "-") {
              await this.get(newSrc, newDst);
              this.client.emit("download", { source: newSrc, destination: newDst });
            } else {
              this.debugMsg(
                `downloadDir: File ignored: ${f.name} not regular file`
              );
            }
          }
          return `${srcDir} downloaded to ${dstDir}`;
        } catch (err) {
          this._resetEventFlags();
          throw err.custom ? err : fmtError(err, "downloadDir", err.code);
        }
      }
      /**
       * @async
       *
       * End the SFTP connection
       *
       * @returns {Promise<Boolean>}
       */
      end() {
        let endCloseHandler, listeners;
        return new Promise((resolve, reject) => {
          listeners = addTempListeners(this, "end", reject);
          this.endCalled = true;
          endCloseHandler = () => {
            this.sftp = void 0;
            this.debugMsg("end: Connection closed");
            resolve(true);
          };
          this.on("close", endCloseHandler);
          if (haveConnection(this, "end", reject)) {
            this.debugMsg("end: Have connection - calling end()");
            this.client.end();
          }
        }).finally(() => {
          this.debugMsg("end: finally clause fired");
          removeTempListeners(this, listeners, "end");
          this.removeListener("close", endCloseHandler);
          this.endCalled = false;
          this._resetEventFlags();
        });
      }
    };
    module2.exports = SftpClient;
  }
});

// node_modules/ip/lib/ip.js
var require_ip = __commonJS({
  "node_modules/ip/lib/ip.js"(exports) {
    var ip = exports;
    var { Buffer: Buffer2 } = require("buffer");
    var os = require("os");
    ip.toBuffer = function(ip2, buff, offset) {
      offset = ~~offset;
      let result;
      if (this.isV4Format(ip2)) {
        result = buff || Buffer2.alloc(offset + 4);
        ip2.split(/\./g).map((byte) => {
          result[offset++] = parseInt(byte, 10) & 255;
        });
      } else if (this.isV6Format(ip2)) {
        const sections = ip2.split(":", 8);
        let i;
        for (i = 0; i < sections.length; i++) {
          const isv4 = this.isV4Format(sections[i]);
          let v4Buffer;
          if (isv4) {
            v4Buffer = this.toBuffer(sections[i]);
            sections[i] = v4Buffer.slice(0, 2).toString("hex");
          }
          if (v4Buffer && ++i < 8) {
            sections.splice(i, 0, v4Buffer.slice(2, 4).toString("hex"));
          }
        }
        if (sections[0] === "") {
          while (sections.length < 8)
            sections.unshift("0");
        } else if (sections[sections.length - 1] === "") {
          while (sections.length < 8)
            sections.push("0");
        } else if (sections.length < 8) {
          for (i = 0; i < sections.length && sections[i] !== ""; i++)
            ;
          const argv = [i, 1];
          for (i = 9 - sections.length; i > 0; i--) {
            argv.push("0");
          }
          sections.splice(...argv);
        }
        result = buff || Buffer2.alloc(offset + 16);
        for (i = 0; i < sections.length; i++) {
          const word = parseInt(sections[i], 16);
          result[offset++] = word >> 8 & 255;
          result[offset++] = word & 255;
        }
      }
      if (!result) {
        throw Error(`Invalid ip address: ${ip2}`);
      }
      return result;
    };
    ip.toString = function(buff, offset, length) {
      offset = ~~offset;
      length = length || buff.length - offset;
      let result = [];
      if (length === 4) {
        for (let i = 0; i < length; i++) {
          result.push(buff[offset + i]);
        }
        result = result.join(".");
      } else if (length === 16) {
        for (let i = 0; i < length; i += 2) {
          result.push(buff.readUInt16BE(offset + i).toString(16));
        }
        result = result.join(":");
        result = result.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
        result = result.replace(/:{3,4}/, "::");
      }
      return result;
    };
    var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
    var ipv6Regex = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;
    ip.isV4Format = function(ip2) {
      return ipv4Regex.test(ip2);
    };
    ip.isV6Format = function(ip2) {
      return ipv6Regex.test(ip2);
    };
    function _normalizeFamily(family) {
      if (family === 4) {
        return "ipv4";
      }
      if (family === 6) {
        return "ipv6";
      }
      return family ? family.toLowerCase() : "ipv4";
    }
    ip.fromPrefixLen = function(prefixlen, family) {
      if (prefixlen > 32) {
        family = "ipv6";
      } else {
        family = _normalizeFamily(family);
      }
      let len = 4;
      if (family === "ipv6") {
        len = 16;
      }
      const buff = Buffer2.alloc(len);
      for (let i = 0, n = buff.length; i < n; ++i) {
        let bits = 8;
        if (prefixlen < 8) {
          bits = prefixlen;
        }
        prefixlen -= bits;
        buff[i] = ~(255 >> bits) & 255;
      }
      return ip.toString(buff);
    };
    ip.mask = function(addr, mask) {
      addr = ip.toBuffer(addr);
      mask = ip.toBuffer(mask);
      const result = Buffer2.alloc(Math.max(addr.length, mask.length));
      let i;
      if (addr.length === mask.length) {
        for (i = 0; i < addr.length; i++) {
          result[i] = addr[i] & mask[i];
        }
      } else if (mask.length === 4) {
        for (i = 0; i < mask.length; i++) {
          result[i] = addr[addr.length - 4 + i] & mask[i];
        }
      } else {
        for (i = 0; i < result.length - 6; i++) {
          result[i] = 0;
        }
        result[10] = 255;
        result[11] = 255;
        for (i = 0; i < addr.length; i++) {
          result[i + 12] = addr[i] & mask[i + 12];
        }
        i += 12;
      }
      for (; i < result.length; i++) {
        result[i] = 0;
      }
      return ip.toString(result);
    };
    ip.cidr = function(cidrString) {
      const cidrParts = cidrString.split("/");
      const addr = cidrParts[0];
      if (cidrParts.length !== 2) {
        throw new Error(`invalid CIDR subnet: ${addr}`);
      }
      const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
      return ip.mask(addr, mask);
    };
    ip.subnet = function(addr, mask) {
      const networkAddress = ip.toLong(ip.mask(addr, mask));
      const maskBuffer = ip.toBuffer(mask);
      let maskLength = 0;
      for (let i = 0; i < maskBuffer.length; i++) {
        if (maskBuffer[i] === 255) {
          maskLength += 8;
        } else {
          let octet = maskBuffer[i] & 255;
          while (octet) {
            octet = octet << 1 & 255;
            maskLength++;
          }
        }
      }
      const numberOfAddresses = 2 ** (32 - maskLength);
      return {
        networkAddress: ip.fromLong(networkAddress),
        firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),
        lastAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress + numberOfAddresses - 1) : ip.fromLong(networkAddress + numberOfAddresses - 2),
        broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
        subnetMask: mask,
        subnetMaskLength: maskLength,
        numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,
        length: numberOfAddresses,
        contains(other) {
          return networkAddress === ip.toLong(ip.mask(other, mask));
        }
      };
    };
    ip.cidrSubnet = function(cidrString) {
      const cidrParts = cidrString.split("/");
      const addr = cidrParts[0];
      if (cidrParts.length !== 2) {
        throw new Error(`invalid CIDR subnet: ${addr}`);
      }
      const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
      return ip.subnet(addr, mask);
    };
    ip.not = function(addr) {
      const buff = ip.toBuffer(addr);
      for (let i = 0; i < buff.length; i++) {
        buff[i] = 255 ^ buff[i];
      }
      return ip.toString(buff);
    };
    ip.or = function(a, b) {
      a = ip.toBuffer(a);
      b = ip.toBuffer(b);
      if (a.length === b.length) {
        for (let i = 0; i < a.length; ++i) {
          a[i] |= b[i];
        }
        return ip.toString(a);
      }
      let buff = a;
      let other = b;
      if (b.length > a.length) {
        buff = b;
        other = a;
      }
      const offset = buff.length - other.length;
      for (let i = offset; i < buff.length; ++i) {
        buff[i] |= other[i - offset];
      }
      return ip.toString(buff);
    };
    ip.isEqual = function(a, b) {
      a = ip.toBuffer(a);
      b = ip.toBuffer(b);
      if (a.length === b.length) {
        for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i])
            return false;
        }
        return true;
      }
      if (b.length === 4) {
        const t = b;
        b = a;
        a = t;
      }
      for (let i = 0; i < 10; i++) {
        if (b[i] !== 0)
          return false;
      }
      const word = b.readUInt16BE(10);
      if (word !== 0 && word !== 65535)
        return false;
      for (let i = 0; i < 4; i++) {
        if (a[i] !== b[i + 12])
          return false;
      }
      return true;
    };
    ip.isPrivate = function(addr) {
      return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    };
    ip.isPublic = function(addr) {
      return !ip.isPrivate(addr);
    };
    ip.isLoopback = function(addr) {
      return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    };
    ip.loopback = function(family) {
      family = _normalizeFamily(family);
      if (family !== "ipv4" && family !== "ipv6") {
        throw new Error("family must be ipv4 or ipv6");
      }
      return family === "ipv4" ? "127.0.0.1" : "fe80::1";
    };
    ip.address = function(name, family) {
      const interfaces = os.networkInterfaces();
      family = _normalizeFamily(family);
      if (name && name !== "private" && name !== "public") {
        const res = interfaces[name].filter((details) => {
          const itemFamily = _normalizeFamily(details.family);
          return itemFamily === family;
        });
        if (res.length === 0) {
          return void 0;
        }
        return res[0].address;
      }
      const all = Object.keys(interfaces).map((nic) => {
        const addresses = interfaces[nic].filter((details) => {
          details.family = _normalizeFamily(details.family);
          if (details.family !== family || ip.isLoopback(details.address)) {
            return false;
          }
          if (!name) {
            return true;
          }
          return name === "public" ? ip.isPrivate(details.address) : ip.isPublic(details.address);
        });
        return addresses.length ? addresses[0].address : void 0;
      }).filter(Boolean);
      return !all.length ? ip.loopback(family) : all[0];
    };
    ip.toLong = function(ip2) {
      let ipl = 0;
      ip2.split(".").forEach((octet) => {
        ipl <<= 8;
        ipl += parseInt(octet);
      });
      return ipl >>> 0;
    };
    ip.fromLong = function(ipl) {
      return `${ipl >>> 24}.${ipl >> 16 & 255}.${ipl >> 8 & 255}.${ipl & 255}`;
    };
  }
});

// node_modules/smart-buffer/build/utils.js
var require_utils4 = __commonJS({
  "node_modules/smart-buffer/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var ERRORS = {
      INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
      INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
      INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
      INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
      INVALID_OFFSET: "An invalid offset value was provided.",
      INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
      INVALID_LENGTH: "An invalid length value was provided.",
      INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
      INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
      INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
      INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
      INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
    };
    exports.ERRORS = ERRORS;
    function checkEncoding(encoding) {
      if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
      }
    }
    exports.checkEncoding = checkEncoding;
    function isFiniteInteger(value) {
      return typeof value === "number" && isFinite(value) && isInteger(value);
    }
    exports.isFiniteInteger = isFiniteInteger;
    function checkOffsetOrLengthValue(value, offset) {
      if (typeof value === "number") {
        if (!isFiniteInteger(value) || value < 0) {
          throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
      } else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
      }
    }
    function checkLengthValue(length) {
      checkOffsetOrLengthValue(length, false);
    }
    exports.checkLengthValue = checkLengthValue;
    function checkOffsetValue(offset) {
      checkOffsetOrLengthValue(offset, true);
    }
    exports.checkOffsetValue = checkOffsetValue;
    function checkTargetOffset(offset, buff) {
      if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
      }
    }
    exports.checkTargetOffset = checkTargetOffset;
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }
    function bigIntAndBufferInt64Check(bufferMethod) {
      if (typeof BigInt === "undefined") {
        throw new Error("Platform does not support JS BigInt type.");
      }
      if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
      }
    }
    exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
  }
});

// node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS({
  "node_modules/smart-buffer/build/smartbuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils4();
    var DEFAULT_SMARTBUFFER_SIZE = 4096;
    var DEFAULT_SMARTBUFFER_ENCODING = "utf8";
    var SmartBuffer = class {
      /**
       * Creates a new SmartBuffer instance.
       *
       * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.
       */
      constructor(options) {
        this.length = 0;
        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
        this._writeOffset = 0;
        this._readOffset = 0;
        if (SmartBuffer.isSmartBufferOptions(options)) {
          if (options.encoding) {
            utils_1.checkEncoding(options.encoding);
            this._encoding = options.encoding;
          }
          if (options.size) {
            if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
              this._buff = Buffer.allocUnsafe(options.size);
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
            }
          } else if (options.buff) {
            if (Buffer.isBuffer(options.buff)) {
              this._buff = options.buff;
              this.length = options.buff.length;
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
            }
          } else {
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        } else {
          if (typeof options !== "undefined") {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
          }
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      }
      /**
       * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.
       *
       * @param size { Number } The size of the internal Buffer.
       * @param encoding { String } The BufferEncoding to use for strings.
       *
       * @return { SmartBuffer }
       */
      static fromSize(size, encoding) {
        return new this({
          size,
          encoding
        });
      }
      /**
       * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.
       *
       * @param buffer { Buffer } The Buffer to use as the internal Buffer value.
       * @param encoding { String } The BufferEncoding to use for strings.
       *
       * @return { SmartBuffer }
       */
      static fromBuffer(buff, encoding) {
        return new this({
          buff,
          encoding
        });
      }
      /**
       * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.
       *
       * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.
       */
      static fromOptions(options) {
        return new this(options);
      }
      /**
       * Type checking function that determines if an object is a SmartBufferOptions object.
       */
      static isSmartBufferOptions(options) {
        const castOptions = options;
        return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
      }
      // Signed integers
      /**
       * Reads an Int8 value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
      }
      /**
       * Reads an Int16BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
      }
      /**
       * Reads an Int16LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
      }
      /**
       * Reads an Int32BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
      }
      /**
       * Reads an Int32LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
      }
      /**
       * Reads a BigInt64BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
      }
      /**
       * Reads a BigInt64LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
      }
      /**
       * Writes an Int8 value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt8(value, offset) {
        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
        return this;
      }
      /**
       * Inserts an Int8 value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      }
      /**
       * Writes an Int16BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      /**
       * Inserts an Int16BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      /**
       * Writes an Int16LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      /**
       * Inserts an Int16LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      /**
       * Writes an Int32BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      /**
       * Inserts an Int32BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      /**
       * Writes an Int32LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      /**
       * Inserts an Int32LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      /**
       * Writes a BigInt64BE value to the current write position (or at optional offset).
       *
       * @param value { BigInt } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      /**
       * Inserts a BigInt64BE value at the given offset value.
       *
       * @param value { BigInt } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      /**
       * Writes a BigInt64LE value to the current write position (or at optional offset).
       *
       * @param value { BigInt } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      /**
       * Inserts a Int64LE value at the given offset value.
       *
       * @param value { BigInt } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      // Unsigned Integers
      /**
       * Reads an UInt8 value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
      }
      /**
       * Reads an UInt16BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
      }
      /**
       * Reads an UInt16LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
      }
      /**
       * Reads an UInt32BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
      }
      /**
       * Reads an UInt32LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
      }
      /**
       * Reads a BigUInt64BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigUInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
      }
      /**
       * Reads a BigUInt64LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigUInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
      }
      /**
       * Writes an UInt8 value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt8(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      /**
       * Inserts an UInt8 value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      /**
       * Writes an UInt16BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      /**
       * Inserts an UInt16BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      /**
       * Writes an UInt16LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      /**
       * Inserts an UInt16LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      /**
       * Writes an UInt32BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      /**
       * Inserts an UInt32BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      /**
       * Writes an UInt32LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      /**
       * Inserts an UInt32LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      /**
       * Writes a BigUInt64BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      /**
       * Inserts a BigUInt64BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      /**
       * Writes a BigUInt64LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      /**
       * Inserts a BigUInt64LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      // Floating Point
      /**
       * Reads an FloatBE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readFloatBE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
      }
      /**
       * Reads an FloatLE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readFloatLE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
      }
      /**
       * Writes a FloatBE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeFloatBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      /**
       * Inserts a FloatBE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertFloatBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      /**
       * Writes a FloatLE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeFloatLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      /**
       * Inserts a FloatLE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertFloatLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      // Double Floating Point
      /**
       * Reads an DoublEBE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readDoubleBE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
      }
      /**
       * Reads an DoubleLE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readDoubleLE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
      }
      /**
       * Writes a DoubleBE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeDoubleBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      /**
       * Inserts a DoubleBE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertDoubleBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      /**
       * Writes a DoubleLE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeDoubleLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      /**
       * Inserts a DoubleLE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertDoubleLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      // Strings
      /**
       * Reads a String from the current read position.
       *
       * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for
       *             the string (Defaults to instance level encoding).
       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
       *
       * @return { String }
       */
      readString(arg1, encoding) {
        let lengthVal;
        if (typeof arg1 === "number") {
          utils_1.checkLengthValue(arg1);
          lengthVal = Math.min(arg1, this.length - this._readOffset);
        } else {
          encoding = arg1;
          lengthVal = this.length - this._readOffset;
        }
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
        this._readOffset += lengthVal;
        return value;
      }
      /**
       * Inserts a String
       *
       * @param value { String } The String value to insert.
       * @param offset { Number } The offset to insert the string at.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      insertString(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        return this._handleString(value, true, offset, encoding);
      }
      /**
       * Writes a String
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      writeString(value, arg2, encoding) {
        return this._handleString(value, false, arg2, encoding);
      }
      /**
       * Reads a null-terminated String from the current read position.
       *
       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
       *
       * @return { String }
       */
      readStringNT(encoding) {
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value.toString(encoding || this._encoding);
      }
      /**
       * Inserts a null-terminated String.
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      insertStringNT(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        this.insertString(value, offset, encoding);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      /**
       * Writes a null-terminated String.
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      writeStringNT(value, arg2, encoding) {
        this.writeString(value, arg2, encoding);
        this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
        return this;
      }
      // Buffers
      /**
       * Reads a Buffer from the internal read position.
       *
       * @param length { Number } The length of data to read as a Buffer.
       *
       * @return { Buffer }
       */
      readBuffer(length) {
        if (typeof length !== "undefined") {
          utils_1.checkLengthValue(length);
        }
        const lengthVal = typeof length === "number" ? length : this.length;
        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
        const value = this._buff.slice(this._readOffset, endPoint);
        this._readOffset = endPoint;
        return value;
      }
      /**
       * Writes a Buffer to the current write position.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      insertBuffer(value, offset) {
        utils_1.checkOffsetValue(offset);
        return this._handleBuffer(value, true, offset);
      }
      /**
       * Writes a Buffer to the current write position.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      writeBuffer(value, offset) {
        return this._handleBuffer(value, false, offset);
      }
      /**
       * Reads a null-terminated Buffer from the current read poisiton.
       *
       * @return { Buffer }
       */
      readBufferNT() {
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value;
      }
      /**
       * Inserts a null-terminated Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      insertBufferNT(value, offset) {
        utils_1.checkOffsetValue(offset);
        this.insertBuffer(value, offset);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      /**
       * Writes a null-terminated Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      writeBufferNT(value, offset) {
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
        }
        this.writeBuffer(value, offset);
        this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
        return this;
      }
      /**
       * Clears the SmartBuffer instance to its original empty state.
       */
      clear() {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
        return this;
      }
      /**
       * Gets the remaining data left to be read from the SmartBuffer instance.
       *
       * @return { Number }
       */
      remaining() {
        return this.length - this._readOffset;
      }
      /**
       * Gets the current read offset value of the SmartBuffer instance.
       *
       * @return { Number }
       */
      get readOffset() {
        return this._readOffset;
      }
      /**
       * Sets the read offset value of the SmartBuffer instance.
       *
       * @param offset { Number } - The offset value to set.
       */
      set readOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._readOffset = offset;
      }
      /**
       * Gets the current write offset value of the SmartBuffer instance.
       *
       * @return { Number }
       */
      get writeOffset() {
        return this._writeOffset;
      }
      /**
       * Sets the write offset value of the SmartBuffer instance.
       *
       * @param offset { Number } - The offset value to set.
       */
      set writeOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._writeOffset = offset;
      }
      /**
       * Gets the currently set string encoding of the SmartBuffer instance.
       *
       * @return { BufferEncoding } The string Buffer encoding currently set.
       */
      get encoding() {
        return this._encoding;
      }
      /**
       * Sets the string encoding of the SmartBuffer instance.
       *
       * @param encoding { BufferEncoding } The string Buffer encoding to set.
       */
      set encoding(encoding) {
        utils_1.checkEncoding(encoding);
        this._encoding = encoding;
      }
      /**
       * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)
       *
       * @return { Buffer } The Buffer value.
       */
      get internalBuffer() {
        return this._buff;
      }
      /**
       * Gets the value of the internal managed Buffer (Includes managed data only)
       *
       * @param { Buffer }
       */
      toBuffer() {
        return this._buff.slice(0, this.length);
      }
      /**
       * Gets the String value of the internal managed Buffer
       *
       * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).
       */
      toString(encoding) {
        const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
        utils_1.checkEncoding(encodingVal);
        return this._buff.toString(encodingVal, 0, this.length);
      }
      /**
       * Destroys the SmartBuffer instance.
       */
      destroy() {
        this.clear();
        return this;
      }
      /**
       * Handles inserting and writing strings.
       *
       * @param value { String } The String value to insert.
       * @param isInsert { Boolean } True if inserting a string, false if writing.
       * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       */
      _handleString(value, isInsert, arg3, encoding) {
        let offsetVal = this._writeOffset;
        let encodingVal = this._encoding;
        if (typeof arg3 === "number") {
          offsetVal = arg3;
        } else if (typeof arg3 === "string") {
          utils_1.checkEncoding(arg3);
          encodingVal = arg3;
        }
        if (typeof encoding === "string") {
          utils_1.checkEncoding(encoding);
          encodingVal = encoding;
        }
        const byteLength = Buffer.byteLength(value, encodingVal);
        if (isInsert) {
          this.ensureInsertable(byteLength, offsetVal);
        } else {
          this._ensureWriteable(byteLength, offsetVal);
        }
        this._buff.write(value, offsetVal, byteLength, encodingVal);
        if (isInsert) {
          this._writeOffset += byteLength;
        } else {
          if (typeof arg3 === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
          } else {
            this._writeOffset += byteLength;
          }
        }
        return this;
      }
      /**
       * Handles writing or insert of a Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       */
      _handleBuffer(value, isInsert, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        if (isInsert) {
          this.ensureInsertable(value.length, offsetVal);
        } else {
          this._ensureWriteable(value.length, offsetVal);
        }
        value.copy(this._buff, offsetVal);
        if (isInsert) {
          this._writeOffset += value.length;
        } else {
          if (typeof offset === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
          } else {
            this._writeOffset += value.length;
          }
        }
        return this;
      }
      /**
       * Ensures that the internal Buffer is large enough to read data.
       *
       * @param length { Number } The length of the data that needs to be read.
       * @param offset { Number } The offset of the data that needs to be read.
       */
      ensureReadable(length, offset) {
        let offsetVal = this._readOffset;
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
          offsetVal = offset;
        }
        if (offsetVal < 0 || offsetVal + length > this.length) {
          throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to insert data.
       *
       * @param dataLength { Number } The length of the data that needs to be written.
       * @param offset { Number } The offset of the data to be written.
       */
      ensureInsertable(dataLength, offset) {
        utils_1.checkOffsetValue(offset);
        this._ensureCapacity(this.length + dataLength);
        if (offset < this.length) {
          this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
        }
        if (offset + dataLength > this.length) {
          this.length = offset + dataLength;
        } else {
          this.length += dataLength;
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to write data.
       *
       * @param dataLength { Number } The length of the data that needs to be written.
       * @param offset { Number } The offset of the data to be written (defaults to writeOffset).
       */
      _ensureWriteable(dataLength, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureCapacity(offsetVal + dataLength);
        if (offsetVal + dataLength > this.length) {
          this.length = offsetVal + dataLength;
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to write at least the given amount of data.
       *
       * @param minLength { Number } The minimum length of the data needs to be written.
       */
      _ensureCapacity(minLength) {
        const oldLength = this._buff.length;
        if (minLength > oldLength) {
          let data = this._buff;
          let newLength = oldLength * 3 / 2 + 1;
          if (newLength < minLength) {
            newLength = minLength;
          }
          this._buff = Buffer.allocUnsafe(newLength);
          data.copy(this._buff, 0, 0, oldLength);
        }
      }
      /**
       * Reads a numeric number value using the provided function.
       *
       * @typeparam T { number | bigint } The type of the value to be read
       *
       * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes read.
       * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.
       *
       * @returns { T } the number value
       */
      _readNumberValue(func, byteSize, offset) {
        this.ensureReadable(byteSize, offset);
        const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
        if (typeof offset === "undefined") {
          this._readOffset += byteSize;
        }
        return value;
      }
      /**
       * Inserts a numeric number value based on the given offset and value.
       *
       * @typeparam T { number | bigint } The type of the value to be written
       *
       * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes written.
       * @param value { T } The number value to write.
       * @param offset { Number } the offset to write the number at (REQUIRED).
       *
       * @returns SmartBuffer this buffer
       */
      _insertNumberValue(func, byteSize, value, offset) {
        utils_1.checkOffsetValue(offset);
        this.ensureInsertable(byteSize, offset);
        func.call(this._buff, value, offset);
        this._writeOffset += byteSize;
        return this;
      }
      /**
       * Writes a numeric number value based on the given offset and value.
       *
       * @typeparam T { number | bigint } The type of the value to be written
       *
       * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes written.
       * @param value { T } The number value to write.
       * @param offset { Number } the offset to write the number at (REQUIRED).
       *
       * @returns SmartBuffer this buffer
       */
      _writeNumberValue(func, byteSize, value, offset) {
        if (typeof offset === "number") {
          if (offset < 0) {
            throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
          }
          utils_1.checkOffsetValue(offset);
        }
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureWriteable(byteSize, offsetVal);
        func.call(this._buff, value, offsetVal);
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
        } else {
          this._writeOffset += byteSize;
        }
        return this;
      }
    };
    exports.SmartBuffer = SmartBuffer;
  }
});

// node_modules/socks/build/common/constants.js
var require_constants3 = __commonJS({
  "node_modules/socks/build/common/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SOCKS5_NO_ACCEPTABLE_AUTH = exports.SOCKS5_CUSTOM_AUTH_END = exports.SOCKS5_CUSTOM_AUTH_START = exports.SOCKS_INCOMING_PACKET_SIZES = exports.SocksClientState = exports.Socks5Response = exports.Socks5HostType = exports.Socks5Auth = exports.Socks4Response = exports.SocksCommand = exports.ERRORS = exports.DEFAULT_TIMEOUT = void 0;
    var DEFAULT_TIMEOUT = 3e4;
    exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var ERRORS = {
      InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
      InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
      InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
      InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
      InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
      InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
      InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
      InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
      InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
      InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
      NegotiationError: "Negotiation error",
      SocketClosed: "Socket closed",
      ProxyConnectionTimedOut: "Proxy connection timed out",
      InternalError: "SocksClient internal error (this should not happen)",
      InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
      Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
      InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
      Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
      InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
      InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
      InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
      InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
      Socks5AuthenticationFailed: "Socks5 Authentication failed",
      InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
      InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
      InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
      Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
    };
    exports.ERRORS = ERRORS;
    var SOCKS_INCOMING_PACKET_SIZES = {
      Socks5InitialHandshakeResponse: 2,
      Socks5UserPassAuthenticationResponse: 2,
      // Command response + incoming connection (bind)
      Socks5ResponseHeader: 5,
      Socks5ResponseIPv4: 10,
      Socks5ResponseIPv6: 22,
      Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
      // Command response + incoming connection (bind)
      Socks4Response: 8
      // 2 header + 2 port + 4 ip
    };
    exports.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
      SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
      SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
    })(SocksCommand || (SocksCommand = {}));
    exports.SocksCommand = SocksCommand;
    var Socks4Response;
    (function(Socks4Response2) {
      Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
      Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
      Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
      Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
    })(Socks4Response || (Socks4Response = {}));
    exports.Socks4Response = Socks4Response;
    var Socks5Auth;
    (function(Socks5Auth2) {
      Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
      Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
      Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
    })(Socks5Auth || (Socks5Auth = {}));
    exports.Socks5Auth = Socks5Auth;
    var SOCKS5_CUSTOM_AUTH_START = 128;
    exports.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
    var SOCKS5_CUSTOM_AUTH_END = 254;
    exports.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
    var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
    exports.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
    var Socks5Response;
    (function(Socks5Response2) {
      Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
      Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
      Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
      Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
      Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
      Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
      Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
      Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
    })(Socks5Response || (Socks5Response = {}));
    exports.Socks5Response = Socks5Response;
    var Socks5HostType;
    (function(Socks5HostType2) {
      Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
      Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
      Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
    })(Socks5HostType || (Socks5HostType = {}));
    exports.Socks5HostType = Socks5HostType;
    var SocksClientState;
    (function(SocksClientState2) {
      SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
      SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
      SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
      SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
      SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
      SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
      SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
      SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
      SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
      SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
      SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
      SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
      SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
    })(SocksClientState || (SocksClientState = {}));
    exports.SocksClientState = SocksClientState;
  }
});

// node_modules/socks/build/common/util.js
var require_util = __commonJS({
  "node_modules/socks/build/common/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shuffleArray = exports.SocksClientError = void 0;
    var SocksClientError = class extends Error {
      constructor(message, options) {
        super(message);
        this.options = options;
      }
    };
    exports.SocksClientError = SocksClientError;
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    exports.shuffleArray = shuffleArray;
  }
});

// node_modules/socks/build/common/helpers.js
var require_helpers = __commonJS({
  "node_modules/socks/build/common/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSocksClientChainOptions = exports.validateSocksClientOptions = void 0;
    var util_1 = require_util();
    var constants_1 = require_constants3();
    var stream = require("stream");
    function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
      if (!constants_1.SocksCommand[options.command]) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
      }
      if (acceptedCommands.indexOf(options.command) === -1) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!isValidSocksProxy(options.proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
      }
      validateCustomProxyAuth(options.proxy, options);
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
      if (options.existing_socket && !(options.existing_socket instanceof stream.Duplex)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
      }
    }
    exports.validateSocksClientOptions = validateSocksClientOptions;
    function validateSocksClientChainOptions(options) {
      if (options.command !== "connect") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
      }
      options.proxies.forEach((proxy) => {
        if (!isValidSocksProxy(proxy)) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
        }
        validateCustomProxyAuth(proxy, options);
      });
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
    }
    exports.validateSocksClientChainOptions = validateSocksClientChainOptions;
    function validateCustomProxyAuth(proxy, options) {
      if (proxy.custom_auth_method !== void 0) {
        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
        }
        if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_size === void 0) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
      }
    }
    function isValidSocksRemoteHost(remoteHost) {
      return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
    }
    function isValidSocksProxy(proxy) {
      return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
    }
    function isValidTimeoutValue(value) {
      return typeof value === "number" && value > 0;
    }
  }
});

// node_modules/socks/build/common/receivebuffer.js
var require_receivebuffer = __commonJS({
  "node_modules/socks/build/common/receivebuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReceiveBuffer = void 0;
    var ReceiveBuffer = class {
      constructor(size = 4096) {
        this.buffer = Buffer.allocUnsafe(size);
        this.offset = 0;
        this.originalSize = size;
      }
      get length() {
        return this.offset;
      }
      append(data) {
        if (!Buffer.isBuffer(data)) {
          throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
        }
        if (this.offset + data.length >= this.buffer.length) {
          const tmp = this.buffer;
          this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
          tmp.copy(this.buffer);
        }
        data.copy(this.buffer, this.offset);
        return this.offset += data.length;
      }
      peek(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        return this.buffer.slice(0, length);
      }
      get(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        const value = Buffer.allocUnsafe(length);
        this.buffer.slice(0, length).copy(value);
        this.buffer.copyWithin(0, length, length + this.offset - length);
        this.offset -= length;
        return value;
      }
    };
    exports.ReceiveBuffer = ReceiveBuffer;
  }
});

// node_modules/socks/build/client/socksclient.js
var require_socksclient = __commonJS({
  "node_modules/socks/build/client/socksclient.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocksClientError = exports.SocksClient = void 0;
    var events_1 = require("events");
    var net = require("net");
    var ip = require_ip();
    var smart_buffer_1 = require_smartbuffer();
    var constants_1 = require_constants3();
    var helpers_1 = require_helpers();
    var receivebuffer_1 = require_receivebuffer();
    var util_1 = require_util();
    Object.defineProperty(exports, "SocksClientError", { enumerable: true, get: function() {
      return util_1.SocksClientError;
    } });
    var SocksClient2 = class extends events_1.EventEmitter {
      constructor(options) {
        super();
        this.options = Object.assign({}, options);
        (0, helpers_1.validateSocksClientOptions)(options);
        this.setState(constants_1.SocksClientState.Created);
      }
      /**
       * Creates a new SOCKS connection.
       *
       * Note: Supports callbacks and promises. Only supports the connect command.
       * @param options { SocksClientOptions } Options.
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnection(options, callback) {
        return new Promise((resolve, reject) => {
          try {
            (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          const client = new SocksClient2(options);
          client.connect(options.existing_socket);
          client.once("established", (info) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(null, info);
              resolve(info);
            } else {
              resolve(info);
            }
          });
          client.once("error", (err) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          });
        });
      }
      /**
       * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.
       *
       * Note: Supports callbacks and promises. Only supports the connect method.
       * Note: Implemented via createConnection() factory function.
       * @param options { SocksClientChainOptions } Options
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnectionChain(options, callback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          try {
            (0, helpers_1.validateSocksClientChainOptions)(options);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          if (options.randomizeChain) {
            (0, util_1.shuffleArray)(options.proxies);
          }
          try {
            let sock;
            for (let i = 0; i < options.proxies.length; i++) {
              const nextProxy = options.proxies[i];
              const nextDestination = i === options.proxies.length - 1 ? options.destination : {
                host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,
                port: options.proxies[i + 1].port
              };
              const result = yield SocksClient2.createConnection({
                command: "connect",
                proxy: nextProxy,
                destination: nextDestination,
                existing_socket: sock
              });
              sock = sock || result.socket;
            }
            if (typeof callback === "function") {
              callback(null, { socket: sock });
              resolve({ socket: sock });
            } else {
              resolve({ socket: sock });
            }
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          }
        }));
      }
      /**
       * Creates a SOCKS UDP Frame.
       * @param options
       */
      static createUDPFrame(options) {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt16BE(0);
        buff.writeUInt8(options.frameNumber || 0);
        if (net.isIPv4(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeUInt32BE(ip.toLong(options.remoteHost.host));
        } else if (net.isIPv6(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer(ip.toBuffer(options.remoteHost.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
          buff.writeString(options.remoteHost.host);
        }
        buff.writeUInt16BE(options.remoteHost.port);
        buff.writeBuffer(options.data);
        return buff.toBuffer();
      }
      /**
       * Parses a SOCKS UDP frame.
       * @param data
       */
      static parseUDPFrame(data) {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const frameNumber = buff.readUInt8();
        const hostType = buff.readUInt8();
        let remoteHost;
        if (hostType === constants_1.Socks5HostType.IPv4) {
          remoteHost = ip.fromLong(buff.readUInt32BE());
        } else if (hostType === constants_1.Socks5HostType.IPv6) {
          remoteHost = ip.toString(buff.readBuffer(16));
        } else {
          remoteHost = buff.readString(buff.readUInt8());
        }
        const remotePort = buff.readUInt16BE();
        return {
          frameNumber,
          remoteHost: {
            host: remoteHost,
            port: remotePort
          },
          data: buff.readBuffer()
        };
      }
      /**
       * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.
       */
      setState(newState) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.state = newState;
        }
      }
      /**
       * Starts the connection establishment to the proxy and destination.
       * @param existingSocket Connected socket to use instead of creating a new one (internal use).
       */
      connect(existingSocket) {
        this.onDataReceived = (data) => this.onDataReceivedHandler(data);
        this.onClose = () => this.onCloseHandler();
        this.onError = (err) => this.onErrorHandler(err);
        this.onConnect = () => this.onConnectHandler();
        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
        if (timer.unref && typeof timer.unref === "function") {
          timer.unref();
        }
        if (existingSocket) {
          this.socket = existingSocket;
        } else {
          this.socket = new net.Socket();
        }
        this.socket.once("close", this.onClose);
        this.socket.once("error", this.onError);
        this.socket.once("connect", this.onConnect);
        this.socket.on("data", this.onDataReceived);
        this.setState(constants_1.SocksClientState.Connecting);
        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
        if (existingSocket) {
          this.socket.emit("connect");
        } else {
          this.socket.connect(this.getSocketOptions());
          if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
            this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
          }
        }
        this.prependOnceListener("established", (info) => {
          setImmediate(() => {
            if (this.receiveBuffer.length > 0) {
              const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
              info.socket.emit("data", excessData);
            }
            info.socket.resume();
          });
        });
      }
      // Socket options (defaults host/port to options.proxy.host/options.proxy.port)
      getSocketOptions() {
        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
      }
      /**
       * Handles internal Socks timeout callback.
       * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.
       */
      onEstablishedTimeout() {
        if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
          this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
        }
      }
      /**
       * Handles Socket connect event.
       */
      onConnectHandler() {
        this.setState(constants_1.SocksClientState.Connected);
        if (this.options.proxy.type === 4) {
          this.sendSocks4InitialHandshake();
        } else {
          this.sendSocks5InitialHandshake();
        }
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles Socket data event.
       * @param data
       */
      onDataReceivedHandler(data) {
        this.receiveBuffer.append(data);
        this.processData();
      }
      /**
       * Handles processing of the data we have received.
       */
      processData() {
        while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
          if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4FinalHandshakeResponse();
            } else {
              this.handleInitialSocks5HandshakeResponse();
            }
          } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
            this.handleInitialSocks5AuthenticationHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
            this.handleSocks5FinalHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4IncomingConnectionResponse();
            } else {
              this.handleSocks5IncomingConnectionResponse();
            }
          } else {
            this.closeSocket(constants_1.ERRORS.InternalError);
            break;
          }
        }
      }
      /**
       * Handles Socket close event.
       * @param had_error
       */
      onCloseHandler() {
        this.closeSocket(constants_1.ERRORS.SocketClosed);
      }
      /**
       * Handles Socket error event.
       * @param err
       */
      onErrorHandler(err) {
        this.closeSocket(err.message);
      }
      /**
       * Removes internal event listeners on the underlying Socket.
       */
      removeInternalSocketHandlers() {
        this.socket.pause();
        this.socket.removeListener("data", this.onDataReceived);
        this.socket.removeListener("close", this.onClose);
        this.socket.removeListener("error", this.onError);
        this.socket.removeListener("connect", this.onConnect);
      }
      /**
       * Closes and destroys the underlying Socket. Emits an error event.
       * @param err { String } An error string to include in error event.
       */
      closeSocket(err) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.setState(constants_1.SocksClientState.Error);
          this.socket.destroy();
          this.removeInternalSocketHandlers();
          this.emit("error", new util_1.SocksClientError(err, this.options));
        }
      }
      /**
       * Sends initial Socks v4 handshake request.
       */
      sendSocks4InitialHandshake() {
        const userId = this.options.proxy.userId || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(4);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt16BE(this.options.destination.port);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeBuffer(ip.toBuffer(this.options.destination.host));
          buff.writeStringNT(userId);
        } else {
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(1);
          buff.writeStringNT(userId);
          buff.writeStringNT(this.options.destination.host);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
        this.socket.write(buff.toBuffer());
      }
      /**
       * Handles Socks v4 handshake response.
       * @param data
       */
      handleSocks4FinalHandshakeResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: ip.fromLong(buff.readUInt32BE())
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.emit("bound", { remoteHost, socket: this.socket });
          } else {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { socket: this.socket });
          }
        }
      }
      /**
       * Handles Socks v4 incoming connection request (BIND)
       * @param data
       */
      handleSocks4IncomingConnectionResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: ip.fromLong(buff.readUInt32BE())
          };
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      /**
       * Sends initial Socks v5 handshake request.
       */
      sendSocks5InitialHandshake() {
        const buff = new smart_buffer_1.SmartBuffer();
        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
        if (this.options.proxy.userId || this.options.proxy.password) {
          supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
        }
        if (this.options.proxy.custom_auth_method !== void 0) {
          supportedAuthMethods.push(this.options.proxy.custom_auth_method);
        }
        buff.writeUInt8(5);
        buff.writeUInt8(supportedAuthMethods.length);
        for (const authMethod of supportedAuthMethods) {
          buff.writeUInt8(authMethod);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles initial Socks v5 handshake response.
       * @param data
       */
      handleInitialSocks5HandshakeResponse() {
        const data = this.receiveBuffer.get(2);
        if (data[0] !== 5) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
        } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
        } else {
          if (data[1] === constants_1.Socks5Auth.NoAuth) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
            this.sendSocks5CommandRequest();
          } else if (data[1] === constants_1.Socks5Auth.UserPass) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
            this.sendSocks5UserPassAuthentication();
          } else if (data[1] === this.options.proxy.custom_auth_method) {
            this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
            this.sendSocks5CustomAuthentication();
          } else {
            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
          }
        }
      }
      /**
       * Sends Socks v5 user & password auth handshake.
       *
       * Note: No auth and user/pass are currently supported.
       */
      sendSocks5UserPassAuthentication() {
        const userId = this.options.proxy.userId || "";
        const password = this.options.proxy.password || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(1);
        buff.writeUInt8(Buffer.byteLength(userId));
        buff.writeString(userId);
        buff.writeUInt8(Buffer.byteLength(password));
        buff.writeString(password);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      }
      sendSocks5CustomAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
          this.socket.write(yield this.options.proxy.custom_auth_request_handler());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        });
      }
      handleSocks5CustomAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.options.proxy.custom_auth_response_handler(data);
        });
      }
      handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleSocks5AuthenticationUserPassHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      /**
       * Handles Socks v5 auth handshake response.
       * @param data
       */
      handleInitialSocks5AuthenticationHandshakeResponse() {
        return __awaiter(this, void 0, void 0, function* () {
          this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
          let authResult = false;
          if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
            authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
            authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
            authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
          }
          if (!authResult) {
            this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
          } else {
            this.sendSocks5CommandRequest();
          }
        });
      }
      /**
       * Sends Socks v5 final handshake request.
       */
      sendSocks5CommandRequest() {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(5);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt8(0);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeBuffer(ip.toBuffer(this.options.destination.host));
        } else if (net.isIPv6(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer(ip.toBuffer(this.options.destination.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(this.options.destination.host.length);
          buff.writeString(this.options.destination.host);
        }
        buff.writeUInt16BE(this.options.destination.port);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentFinalHandshake);
      }
      /**
       * Handles Socks v5 final handshake response.
       * @param data
       */
      handleSocks5FinalHandshakeResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.fromLong(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.toString(buff.readBuffer(16)),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
            this.emit("bound", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", {
              remoteHost,
              socket: this.socket
            });
          }
        }
      }
      /**
       * Handles Socks v5 incoming connection request (BIND).
       */
      handleSocks5IncomingConnectionResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.fromLong(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.toString(buff.readBuffer(16)),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      get socksClientOptions() {
        return Object.assign({}, this.options);
      }
    };
    exports.SocksClient = SocksClient2;
  }
});

// node_modules/socks/build/index.js
var require_build = __commonJS({
  "node_modules/socks/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_socksclient(), exports);
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SyncFTP
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/credential.ts
var import_obsidian = require("obsidian");
var CredentialTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "SFTP Settings" });
    new import_obsidian.Setting(containerEl).setName("URL").setDesc("FTP URL").addText((text) => text.setValue(this.plugin.settings.url).onChange(async (value) => {
      this.plugin.settings.url = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Port").setDesc("FTP Port").addText((text) => text.setValue(this.plugin.settings.port).onChange(async (value) => {
      this.plugin.settings.port = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "If you are not using a proxy please leave these fields empty." });
    new import_obsidian.Setting(containerEl).setName("Proxy URL").setDesc("Proxy URL").addText((text) => text.setValue(this.plugin.settings.proxy_host).onChange(async (value) => {
      this.plugin.settings.proxy_host = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Proxy Port").setDesc("Proxy Port").addText((text) => text.setValue(this.plugin.settings.proxy_port).onChange(async (value) => {
      this.plugin.settings.proxy_port = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Credentials" });
    new import_obsidian.Setting(containerEl).setName("Username").setDesc("FTP Username").addText((text) => text.setValue(this.plugin.settings.username).onChange(async (value) => {
      this.plugin.settings.username = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Password").setDesc("FTP Password").addText((text) => text.setValue(this.plugin.settings.password).onChange(async (value) => {
      this.plugin.settings.password = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Vaults Path").setDesc("FTP Vaults Directory Path").addText((text) => text.setValue(this.plugin.settings.vault_path).onChange(async (value) => {
      this.plugin.settings.vault_path = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Notifications").setDesc("Would you like to be notified of all SyncFTP actions? Necessary Notices will still populate.").addToggle((toggle) => toggle.setValue(this.plugin.settings.notify).onChange(async (value) => {
      this.plugin.settings.notify = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Sync on Load").setDesc("Would you like to pull new changes from the SFTP every time you open Obsidian?").addToggle((toggle) => toggle.setValue(this.plugin.settings.load_sync).onChange(async (value) => {
      this.plugin.settings.load_sync = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/client.ts
var import_ssh2_sftp_client = __toESM(require_src());
var import_socks = __toESM(require_build());
var SFTPClient = class {
  constructor() {
    this.client = new import_ssh2_sftp_client.default();
  }
  async connect(options) {
    console.log(`Connecting to ${options.host}:${options.port}`);
    try {
      if (options.proxy_host !== "") {
        let opt = {
          proxy: {
            host: options.proxy_host,
            port: options.proxy_port,
            type: 5
          },
          command: "connect",
          destination: {
            host: options.host,
            port: options.port
          }
        };
        var socks = await import_socks.SocksClient.createConnection(opt);
        await this.client.connect({
          host: options.host,
          port: options.port,
          sock: socks.socket,
          username: options.username,
          password: options.password
        });
      } else {
        await this.client.connect({
          host: options.host,
          port: options.port,
          username: options.username,
          password: options.password
        });
      }
    } catch (err) {
      console.log("Failed to connect:", err);
      return `Failed to connect:
${err}`;
    }
    return "Connected to SFTP";
  }
  async disconnect() {
    console.log(`Disconnecting from SFTP.`);
    await this.client.end();
    return "Disconnected from SFTP";
  }
  async listFiles(remoteDir, fileGlob) {
    let fileObjects;
    try {
      fileObjects = await this.client.list(remoteDir, fileGlob);
    } catch (err) {
      console.log("Listing failed:", err);
    }
    var fileNames = [];
    for (const file of fileObjects) {
      if (file.type === "d") {
        console.log(`${new Date(file.modifyTime).toISOString()} PRE ${file.name}`);
        fileNames.push({
          "name": file.name,
          "mtime": file.modifyTime,
          "type": file.type,
          "size": file.size,
          "path": remoteDir
        });
        let subFiles = await this.listFiles(`${remoteDir}/${file.name}`);
        fileNames = fileNames.concat(subFiles);
      } else {
        console.log(`${new Date(file.modifyTime).toISOString()} ${file.size} ${file.name}`);
        fileNames.push({
          "name": file.name,
          "mtime": file.modifyTime,
          "type": file.type,
          "size": file.size,
          "path": remoteDir
        });
      }
    }
    return fileNames;
  }
  async uploadFile(localFile, remoteFile) {
    console.log(`Uploading ${localFile} to ${remoteFile}`);
    try {
      await this.client.put(localFile, remoteFile);
    } catch (err) {
      console.error("Uploading failed:", err);
      return `Uploading failed:
${err}`;
    }
    return `Uploading success for
${localFile}`;
  }
  async downloadFile(remoteFile, localFile) {
    console.log(`Downloading ${remoteFile} to ${localFile}`);
    try {
      await this.client.get(remoteFile, localFile);
    } catch (err) {
      console.error("Downloading failed:", err);
      return `Downloading failed:
${err}`;
    }
    return `Downloading success for
${localFile}`;
  }
  async makeDir(remoteDir) {
    console.log(`Creating directory ${remoteDir}`);
    try {
      await this.client.mkdir(remoteDir, true);
    } catch (err) {
      console.error("Failed to create directory:", err);
      return `Failed to make directory:
${err}`;
    }
    return `Successfully made directory:
${remoteDir}`;
  }
  async removeDir(remoteDir) {
    console.log(`Deleting directory ${remoteDir}`);
    try {
      await this.client.rmdir(remoteDir, true);
    } catch (err) {
      console.error("Failed to remove directory:", err);
      return `Failed to remove directory:
${err}`;
    }
    return `Successfully removed directory:
${remoteDir}`;
  }
  async deleteFile(remoteFile) {
    console.log(`Deleting ${remoteFile}`);
    try {
      await this.client.delete(remoteFile);
    } catch (err) {
      console.error("Deleting failed:", err);
      return `Deleting failed:
${err}`;
    }
    return `Delete success for
${remoteFile}`;
  }
  async fileExists(remoteFile) {
    console.log(`Checking if ${remoteFile} exists`);
    let exists = false;
    try {
      exists = await this.client.exists(remoteFile);
    } catch (err) {
      console.error("Exists check failed:", err);
    }
    return exists;
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  url: "",
  port: 22,
  proxy_host: "",
  proxy_port: 22,
  username: "",
  password: "",
  vault_path: "/obsidian/",
  notify: false,
  load_sync: false
};
var SyncFTP = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.client = new SFTPClient();
    if (this.settings.load_sync) {
      this.downloadFile();
    }
    this.addCommand({
      id: "push-to-sftp",
      name: "Upload files to the SFTP",
      callback: () => {
        this.uploadFile();
      }
    });
    this.addCommand({
      id: "pull-from-sftp",
      name: "Download files from the SFTP",
      callback: () => {
        this.downloadFile();
      }
    });
    const syncUpload = this.addRibbonIcon(
      "arrow-up",
      "Upload to FTP",
      () => {
        this.uploadFile();
      }
    );
    const syncDownload = this.addRibbonIcon(
      "arrow-down",
      "Download from FTP",
      () => {
        this.downloadFile();
      }
    );
    this.addSettingTab(new CredentialTab(this.app, this));
    this.registerDomEvent(document, "click", (evt) => {
      console.log("click", evt);
    });
  }
  async onunload() {
    await this.saveSettings();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async uploadFile() {
    if (this.settings.url !== "") {
      new Notice(`Connecting to SFTP for file sync:
${this.settings.url}:${this.settings.port}
${this.settings.username}`);
      try {
        let conn = await this.client.connect({
          proxy_host: this.settings.proxy_host,
          proxy_port: Number(this.settings.proxy_port),
          host: this.settings.url,
          port: Number(this.settings.port),
          username: this.settings.username,
          password: this.settings.password
        });
        if (this.settings.notify)
          new Notice(conn);
        if (await this.client.fileExists(this.settings.vault_path) === false) {
          await this.client.makeDir(this.settings.vault_path);
        }
        if (await this.client.fileExists(`${this.settings.vault_path}${this.app.vault.getName()}/`) === false) {
          await this.client.makeDir(`${this.settings.vault_path}${this.app.vault.getName()}/`);
        }
        let rem_path = this.settings.vault_path + this.app.vault.getName();
        let rem_list = await this.client.listFiles(rem_path);
        let loc_path = this.app.vault.adapter.basePath;
        let loc_list = this.app.vault.getAllLoadedFiles();
        loc_list.splice(0, 1);
        for (const rem_file of rem_list) {
          let match_index = loc_list.findIndex((file) => `/${file.path}` === `${rem_file.path.replace(rem_path, "")}/${rem_file.name}`);
          let match = loc_list[match_index];
          try {
            if (match) {
              if (rem_file.type === "d" || rem_file.size === match.stat.size) {
                loc_list.splice(match_index, 1);
              }
            } else if (!match) {
              let sync = "";
              if (rem_file.type === "d") {
                if (await this.client.fileExists(`${rem_file.path}/${rem_file.name}`)) {
                  sync = await this.client.removeDir(`${rem_file.path}/${rem_file.name}`);
                }
              } else {
                if (await this.client.fileExists(`${rem_file.path}/${rem_file.name}`)) {
                  sync = await this.client.deleteFile(`${rem_file.path}/${rem_file.name}`);
                }
              }
              if (this.settings.notify && sync.trim() != "")
                new Notice(sync);
            }
          } catch (err) {
            console.error(`Error deleting ${rem_file.name}: ${err}`);
          }
        }
        for (const loc_file of loc_list) {
          let sync = "";
          if (loc_file instanceof import_obsidian2.TFolder) {
            sync = await this.client.makeDir(`${rem_path}/${loc_file.path}`);
          } else if (loc_file instanceof import_obsidian2.TFile) {
            sync = await this.client.uploadFile(`${loc_path}/${loc_file.path}`, `${rem_path}/${loc_file.path}`);
          }
          if (this.settings.notify && sync.trim() != "")
            new Notice(sync);
        }
        let disconn = await this.client.disconnect();
        if (this.settings.notify)
          new Notice(disconn);
        else
          new Notice("Done!");
      } catch (err) {
        new Notice(`Failed to connect to SFTP: ${err}`);
      }
    }
  }
  async downloadFile() {
    if (this.settings.url !== "") {
      new Notice(`Connecting to SFTP for file sync:
${this.settings.url}:${this.settings.port}
${this.settings.username}`);
      try {
        let conn = await this.client.connect({
          proxy_host: this.settings.proxy_host,
          proxy_port: Number(this.settings.proxy_port),
          host: this.settings.url,
          port: Number(this.settings.port),
          username: this.settings.username,
          password: this.settings.password
        });
        if (this.settings.notify)
          new Notice(conn);
        console.log(this.client.fileExists(this.settings.vault_path + this.app.vault.getName()));
        if (!await this.client.fileExists(this.settings.vault_path + this.app.vault.getName())) {
          new Notice("Vault does not exist on SFTP, nothing to download. Please upload.");
        } else {
          let rem_path = this.settings.vault_path + this.app.vault.getName();
          let rem_list = await this.client.listFiles(rem_path);
          let loc_path = this.app.vault.adapter.basePath;
          let loc_list = this.app.vault.getAllLoadedFiles();
          loc_list.splice(0, 1);
          for (const loc_file of loc_list) {
            let match_index = rem_list.findIndex((file) => `${file.path.replace(rem_path, "")}/${file.name}` === `/${loc_file.path}`);
            let match = rem_list[match_index];
            try {
              let sync = "";
              if (match) {
                if (match.type === "d" || match.size === loc_file.stat.size) {
                  rem_list.splice(match_index, 1);
                }
              } else if (!match && loc_file.path !== "/") {
                await this.app.vault.trash(loc_file, false);
                sync = `Local file ${loc_file.name} moved to Obsidian trash.`;
              }
              if (this.settings.notify && sync.trim() != "")
                new Notice(sync);
            } catch (err) {
              console.error(`Error moving ${loc_file.name} to trash: ${err}`);
            }
          }
          for (const rem_file of rem_list) {
            let sync = "";
            let dst_path = rem_file.path !== rem_path ? `${rem_file.path.replace(rem_path, "")}/` : "";
            if (rem_file.type !== "d") {
              sync = await this.client.downloadFile(`${rem_file.path}/${rem_file.name}`, `${loc_path}${dst_path}${rem_file.name}`);
            } else {
              if (!loc_list.find((folder) => folder.name === rem_file.name)) {
                if (await this.client.fileExists(`${dst_path}${rem_file.name}/`) === false) {
                  await this.app.vault.createFolder(`${dst_path}${rem_file.name}/`);
                  sync = `Successfully made directory: ${rem_file.name}`;
                }
              }
            }
            if (this.settings.notify && sync.trim() != "")
              new Notice(sync);
          }
          ;
        }
        let disconn = await this.client.disconnect();
        if (this.settings.notify)
          new Notice(disconn);
        else
          new Notice("Done!");
      } catch (err) {
        new Notice(`Failed to connect to SFTP: ${err}`);
      }
    }
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci9lcnJvcnMuanMiLCAibm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci90eXBlcy5qcyIsICJub2RlX21vZHVsZXMvc2FmZXItYnVmZmVyL3NhZmVyLmpzIiwgIm5vZGVfbW9kdWxlcy9hc24xL2xpYi9iZXIvcmVhZGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9hc24xL2xpYi9iZXIvd3JpdGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9hc24xL2xpYi9iZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2FzbjEvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy90d2VldG5hY2wvbmFjbC1mYXN0LmpzIiwgIm5vZGVfbW9kdWxlcy9iY3J5cHQtcGJrZGYvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2NwdS1mZWF0dXJlcy9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3NzaDIvbGliL3Byb3RvY29sL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvc3NoMi9saWIvcHJvdG9jb2wvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL3NzaDIvbGliL3Byb3RvY29sL2NyeXB0by9wb2x5MTMwNS5qcyIsICJub2RlX21vZHVsZXMvc3NoMi9saWIvcHJvdG9jb2wvY3J5cHRvLmpzIiwgIm5vZGVfbW9kdWxlcy9zc2gyL2xpYi9wcm90b2NvbC9rZXlQYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL3NzaDIvbGliL2FnZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9zc2gyL2xpYi9wcm90b2NvbC96bGliLmpzIiwgIm5vZGVfbW9kdWxlcy9zc2gyL2xpYi9wcm90b2NvbC9oYW5kbGVycy5taXNjLmpzIiwgIm5vZGVfbW9kdWxlcy9zc2gyL2xpYi9wcm90b2NvbC9oYW5kbGVycy5qcyIsICJub2RlX21vZHVsZXMvc3NoMi9saWIvcHJvdG9jb2wva2V4LmpzIiwgIm5vZGVfbW9kdWxlcy9zc2gyL3BhY2thZ2UuanNvbiIsICJub2RlX21vZHVsZXMvc3NoMi9saWIvcHJvdG9jb2wvUHJvdG9jb2wuanMiLCAibm9kZV9tb2R1bGVzL3NzaDIvbGliL3Byb3RvY29sL25vZGUtZnMtY29tcGF0LmpzIiwgIm5vZGVfbW9kdWxlcy9zc2gyL2xpYi9wcm90b2NvbC9TRlRQLmpzIiwgIm5vZGVfbW9kdWxlcy9zc2gyL2xpYi9DaGFubmVsLmpzIiwgIm5vZGVfbW9kdWxlcy9zc2gyL2xpYi91dGlscy5qcyIsICJub2RlX21vZHVsZXMvc3NoMi9saWIvY2xpZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9zc2gyL2xpYi9odHRwLWFnZW50cy5qcyIsICJub2RlX21vZHVsZXMvc3NoMi9saWIvc2VydmVyLmpzIiwgIm5vZGVfbW9kdWxlcy9zc2gyL2xpYi9rZXlnZW4uanMiLCAibm9kZV9tb2R1bGVzL3NzaDIvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdC5qcyIsICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9lcnJvcnMtYnJvd3Nlci5qcyIsICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwgIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3IuanMiLCAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9idWZmZXItZnJvbS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvdHlwZWRhcnJheS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvY29uY2F0LXN0cmVhbS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZXJyLWNvZGUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3JldHJ5L2xpYi9yZXRyeV9vcGVyYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL3JldHJ5L2xpYi9yZXRyeS5qcyIsICJub2RlX21vZHVsZXMvcmV0cnkvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3Byb21pc2UtcmV0cnkvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3NzaDItc2Z0cC1jbGllbnQvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvc3NoMi1zZnRwLWNsaWVudC9zcmMvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL3NzaDItc2Z0cC1jbGllbnQvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9pcC9saWIvaXAuanMiLCAibm9kZV9tb2R1bGVzL3NtYXJ0LWJ1ZmZlci9zcmMvdXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL3NtYXJ0LWJ1ZmZlci9zcmMvc21hcnRidWZmZXIudHMiLCAibm9kZV9tb2R1bGVzL3NvY2tzL3NyYy9jb21tb24vY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9zb2Nrcy9zcmMvY29tbW9uL3V0aWwudHMiLCAibm9kZV9tb2R1bGVzL3NvY2tzL3NyYy9jb21tb24vaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvc29ja3Mvc3JjL2NvbW1vbi9yZWNlaXZlYnVmZmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9zb2Nrcy9zcmMvY2xpZW50L3NvY2tzY2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9zb2Nrcy9zcmMvaW5kZXgudHMiLCAibWFpbi50cyIsICJzcmMvY3JlZGVudGlhbC50cyIsICJzcmMvY2xpZW50LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgbmV3SW52YWxpZEFzbjFFcnJvcjogZnVuY3Rpb24gKG1zZykge1xuICAgIHZhciBlID0gbmV3IEVycm9yKCk7XG4gICAgZS5uYW1lID0gJ0ludmFsaWRBc24xRXJyb3InO1xuICAgIGUubWVzc2FnZSA9IG1zZyB8fCAnJztcbiAgICByZXR1cm4gZTtcbiAgfVxuXG59O1xuIiwgIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRU9DOiAwLFxuICBCb29sZWFuOiAxLFxuICBJbnRlZ2VyOiAyLFxuICBCaXRTdHJpbmc6IDMsXG4gIE9jdGV0U3RyaW5nOiA0LFxuICBOdWxsOiA1LFxuICBPSUQ6IDYsXG4gIE9iamVjdERlc2NyaXB0b3I6IDcsXG4gIEV4dGVybmFsOiA4LFxuICBSZWFsOiA5LCAvLyBmbG9hdFxuICBFbnVtZXJhdGlvbjogMTAsXG4gIFBEVjogMTEsXG4gIFV0ZjhTdHJpbmc6IDEyLFxuICBSZWxhdGl2ZU9JRDogMTMsXG4gIFNlcXVlbmNlOiAxNixcbiAgU2V0OiAxNyxcbiAgTnVtZXJpY1N0cmluZzogMTgsXG4gIFByaW50YWJsZVN0cmluZzogMTksXG4gIFQ2MVN0cmluZzogMjAsXG4gIFZpZGVvdGV4U3RyaW5nOiAyMSxcbiAgSUE1U3RyaW5nOiAyMixcbiAgVVRDVGltZTogMjMsXG4gIEdlbmVyYWxpemVkVGltZTogMjQsXG4gIEdyYXBoaWNTdHJpbmc6IDI1LFxuICBWaXNpYmxlU3RyaW5nOiAyNixcbiAgR2VuZXJhbFN0cmluZzogMjgsXG4gIFVuaXZlcnNhbFN0cmluZzogMjksXG4gIENoYXJhY3RlclN0cmluZzogMzAsXG4gIEJNUFN0cmluZzogMzEsXG4gIENvbnN0cnVjdG9yOiAzMixcbiAgQ29udGV4dDogMTI4XG59O1xuIiwgIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxudmFyIHNhZmVyID0ge31cblxudmFyIGtleVxuXG5mb3IgKGtleSBpbiBidWZmZXIpIHtcbiAgaWYgKCFidWZmZXIuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWVcbiAgaWYgKGtleSA9PT0gJ1Nsb3dCdWZmZXInIHx8IGtleSA9PT0gJ0J1ZmZlcicpIGNvbnRpbnVlXG4gIHNhZmVyW2tleV0gPSBidWZmZXJba2V5XVxufVxuXG52YXIgU2FmZXIgPSBzYWZlci5CdWZmZXIgPSB7fVxuZm9yIChrZXkgaW4gQnVmZmVyKSB7XG4gIGlmICghQnVmZmVyLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlXG4gIGlmIChrZXkgPT09ICdhbGxvY1Vuc2FmZScgfHwga2V5ID09PSAnYWxsb2NVbnNhZmVTbG93JykgY29udGludWVcbiAgU2FmZXJba2V5XSA9IEJ1ZmZlcltrZXldXG59XG5cbnNhZmVyLkJ1ZmZlci5wcm90b3R5cGUgPSBCdWZmZXIucHJvdG90eXBlXG5cbmlmICghU2FmZXIuZnJvbSB8fCBTYWZlci5mcm9tID09PSBVaW50OEFycmF5LmZyb20pIHtcbiAgU2FmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiB2YWx1ZSlcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cbn1cblxuaWYgKCFTYWZlci5hbGxvYykge1xuICBTYWZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc2l6ZSlcbiAgICB9XG4gICAgaWYgKHNpemUgPCAwIHx8IHNpemUgPj0gMiAqICgxIDw8IDMwKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gICAgfVxuICAgIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgICBpZiAoIWZpbGwgfHwgZmlsbC5sZW5ndGggPT09IDApIHtcbiAgICAgIGJ1Zi5maWxsKDApXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG59XG5cbmlmICghc2FmZXIua1N0cmluZ01heExlbmd0aCkge1xuICB0cnkge1xuICAgIHNhZmVyLmtTdHJpbmdNYXhMZW5ndGggPSBwcm9jZXNzLmJpbmRpbmcoJ2J1ZmZlcicpLmtTdHJpbmdNYXhMZW5ndGhcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHdlIGNhbid0IGRldGVybWluZSBrU3RyaW5nTWF4TGVuZ3RoIGluIGVudmlyb25tZW50cyB3aGVyZSBwcm9jZXNzLmJpbmRpbmdcbiAgICAvLyBpcyB1bnN1cHBvcnRlZCwgc28gbGV0J3Mgbm90IHNldCBpdFxuICB9XG59XG5cbmlmICghc2FmZXIuY29uc3RhbnRzKSB7XG4gIHNhZmVyLmNvbnN0YW50cyA9IHtcbiAgICBNQVhfTEVOR1RIOiBzYWZlci5rTWF4TGVuZ3RoXG4gIH1cbiAgaWYgKHNhZmVyLmtTdHJpbmdNYXhMZW5ndGgpIHtcbiAgICBzYWZlci5jb25zdGFudHMuTUFYX1NUUklOR19MRU5HVEggPSBzYWZlci5rU3RyaW5nTWF4TGVuZ3RoXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlclxuIiwgIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIEFTTjEgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuXG4vLyAtLS0gR2xvYmFsc1xuXG52YXIgbmV3SW52YWxpZEFzbjFFcnJvciA9IGVycm9ycy5uZXdJbnZhbGlkQXNuMUVycm9yO1xuXG5cblxuLy8gLS0tIEFQSVxuXG5mdW5jdGlvbiBSZWFkZXIoZGF0YSkge1xuICBpZiAoIWRhdGEgfHwgIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIG11c3QgYmUgYSBub2RlIEJ1ZmZlcicpO1xuXG4gIHRoaXMuX2J1ZiA9IGRhdGE7XG4gIHRoaXMuX3NpemUgPSBkYXRhLmxlbmd0aDtcblxuICAvLyBUaGVzZSBob2xkIHRoZSBcImN1cnJlbnRcIiBzdGF0ZVxuICB0aGlzLl9sZW4gPSAwO1xuICB0aGlzLl9vZmZzZXQgPSAwO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGVyLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5fbGVuKTsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLl9vZmZzZXQpOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRlci5wcm90b3R5cGUsICdyZW1haW4nLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuX3NpemUgLSB0aGlzLl9vZmZzZXQpOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRlci5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuX2J1Zi5zbGljZSh0aGlzLl9vZmZzZXQpKTsgfVxufSk7XG5cblxuLyoqXG4gKiBSZWFkcyBhIHNpbmdsZSBieXRlIGFuZCBhZHZhbmNlcyBvZmZzZXQ7IHlvdSBjYW4gcGFzcyBpbiBgdHJ1ZWAgdG8gbWFrZSB0aGlzXG4gKiBhIFwicGVla1wiIG9wZXJhdGlvbiAoaS5lLiwgZ2V0IHRoZSBieXRlLCBidXQgZG9uJ3QgYWR2YW5jZSB0aGUgb2Zmc2V0KS5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBlZWsgdHJ1ZSBtZWFucyBkb24ndCBtb3ZlIG9mZnNldC5cbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIG5leHQgYnl0ZSwgbnVsbCBpZiBub3QgZW5vdWdoIGRhdGEuXG4gKi9cblJlYWRlci5wcm90b3R5cGUucmVhZEJ5dGUgPSBmdW5jdGlvbiAocGVlaykge1xuICBpZiAodGhpcy5fc2l6ZSAtIHRoaXMuX29mZnNldCA8IDEpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGIgPSB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0XSAmIDB4ZmY7XG5cbiAgaWYgKCFwZWVrKVxuICAgIHRoaXMuX29mZnNldCArPSAxO1xuXG4gIHJldHVybiBiO1xufTtcblxuXG5SZWFkZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlYWRCeXRlKHRydWUpO1xufTtcblxuXG4vKipcbiAqIFJlYWRzIGEgKHBvdGVudGlhbGx5KSB2YXJpYWJsZSBsZW5ndGggb2ZmIHRoZSBCRVIgYnVmZmVyLiAgVGhpcyBjYWxsIGlzXG4gKiBub3QgcmVhbGx5IG1lYW50IHRvIGJlIGNhbGxlZCBkaXJlY3RseSwgYXMgY2FsbGVycyBoYXZlIHRvIG1hbmlwdWxhdGVcbiAqIHRoZSBpbnRlcm5hbCBidWZmZXIgYWZ0ZXJ3YXJkcy5cbiAqXG4gKiBBcyBhIHJlc3VsdCBvZiB0aGlzIGNhbGwsIHlvdSBjYW4gY2FsbCBgUmVhZGVyLmxlbmd0aGAsIHVudGlsIHRoZVxuICogbmV4dCB0aGluZyBjYWxsZWQgdGhhdCBkb2VzIGEgcmVhZExlbmd0aC5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBhbW91bnQgb2Ygb2Zmc2V0IHRvIGFkdmFuY2UgdGhlIGJ1ZmZlci5cbiAqIEB0aHJvd3Mge0ludmFsaWRBc24xRXJyb3J9IG9uIGJhZCBBU04uMVxuICovXG5SZWFkZXIucHJvdG90eXBlLnJlYWRMZW5ndGggPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcbiAgICBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLl9zaXplKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBsZW5CID0gdGhpcy5fYnVmW29mZnNldCsrXSAmIDB4ZmY7XG4gIGlmIChsZW5CID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICgobGVuQiAmIDB4ODApID09PSAweDgwKSB7XG4gICAgbGVuQiAmPSAweDdmO1xuXG4gICAgaWYgKGxlbkIgPT09IDApXG4gICAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdJbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBpZiAobGVuQiA+IDQpXG4gICAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdlbmNvZGluZyB0b28gbG9uZycpO1xuXG4gICAgaWYgKHRoaXMuX3NpemUgLSBvZmZzZXQgPCBsZW5CKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB0aGlzLl9sZW4gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuQjsgaSsrKVxuICAgICAgdGhpcy5fbGVuID0gKHRoaXMuX2xlbiA8PCA4KSArICh0aGlzLl9idWZbb2Zmc2V0KytdICYgMHhmZik7XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBXYXNuJ3QgYSB2YXJpYWJsZSBsZW5ndGhcbiAgICB0aGlzLl9sZW4gPSBsZW5CO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cblxuLyoqXG4gKiBQYXJzZXMgdGhlIG5leHQgc2VxdWVuY2UgaW4gdGhpcyBCRVIgYnVmZmVyLlxuICpcbiAqIFRvIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBzZXF1ZW5jZSwgY2FsbCBgUmVhZGVyLmxlbmd0aGAuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgc2VxdWVuY2UncyB0YWcuXG4gKi9cblJlYWRlci5wcm90b3R5cGUucmVhZFNlcXVlbmNlID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc2VxID0gdGhpcy5wZWVrKCk7XG4gIGlmIChzZXEgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0YWcgIT09IHVuZGVmaW5lZCAmJiB0YWcgIT09IHNlcSlcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdFeHBlY3RlZCAweCcgKyB0YWcudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6IGdvdCAweCcgKyBzZXEudG9TdHJpbmcoMTYpKTtcblxuICB2YXIgbyA9IHRoaXMucmVhZExlbmd0aCh0aGlzLl9vZmZzZXQgKyAxKTsgLy8gc3RvcmVkIGluIGBsZW5ndGhgXG4gIGlmIChvID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHRoaXMuX29mZnNldCA9IG87XG4gIHJldHVybiBzZXE7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUucmVhZEludCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRUYWcoQVNOMS5JbnRlZ2VyKTtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkQm9vbGVhbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLl9yZWFkVGFnKEFTTjEuQm9vbGVhbikgPT09IDAgPyBmYWxzZSA6IHRydWUpO1xufTtcblxuXG5SZWFkZXIucHJvdG90eXBlLnJlYWRFbnVtZXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRUYWcoQVNOMS5FbnVtZXJhdGlvbik7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUucmVhZFN0cmluZyA9IGZ1bmN0aW9uICh0YWcsIHJldGJ1Zikge1xuICBpZiAoIXRhZylcbiAgICB0YWcgPSBBU04xLk9jdGV0U3RyaW5nO1xuXG4gIHZhciBiID0gdGhpcy5wZWVrKCk7XG4gIGlmIChiID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChiICE9PSB0YWcpXG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignRXhwZWN0ZWQgMHgnICsgdGFnLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiBnb3QgMHgnICsgYi50b1N0cmluZygxNikpO1xuXG4gIHZhciBvID0gdGhpcy5yZWFkTGVuZ3RoKHRoaXMuX29mZnNldCArIDEpOyAvLyBzdG9yZWQgaW4gYGxlbmd0aGBcblxuICBpZiAobyA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLl9zaXplIC0gbylcbiAgICByZXR1cm4gbnVsbDtcblxuICB0aGlzLl9vZmZzZXQgPSBvO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gcmV0YnVmID8gQnVmZmVyLmFsbG9jKDApIDogJyc7XG5cbiAgdmFyIHN0ciA9IHRoaXMuX2J1Zi5zbGljZSh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIHRoaXMubGVuZ3RoKTtcbiAgdGhpcy5fb2Zmc2V0ICs9IHRoaXMubGVuZ3RoO1xuXG4gIHJldHVybiByZXRidWYgPyBzdHIgOiBzdHIudG9TdHJpbmcoJ3V0ZjgnKTtcbn07XG5cblJlYWRlci5wcm90b3R5cGUucmVhZE9JRCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgaWYgKCF0YWcpXG4gICAgdGFnID0gQVNOMS5PSUQ7XG5cbiAgdmFyIGIgPSB0aGlzLnJlYWRTdHJpbmcodGFnLCB0cnVlKTtcbiAgaWYgKGIgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgdmFsdWUgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gYltpXSAmIDB4ZmY7XG5cbiAgICB2YWx1ZSA8PD0gNztcbiAgICB2YWx1ZSArPSBieXRlICYgMHg3ZjtcbiAgICBpZiAoKGJ5dGUgJiAweDgwKSA9PT0gMCkge1xuICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHZhbHVlID0gdmFsdWVzLnNoaWZ0KCk7XG4gIHZhbHVlcy51bnNoaWZ0KHZhbHVlICUgNDApO1xuICB2YWx1ZXMudW5zaGlmdCgodmFsdWUgLyA0MCkgPj4gMCk7XG5cbiAgcmV0dXJuIHZhbHVlcy5qb2luKCcuJyk7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUuX3JlYWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIGFzc2VydC5vayh0YWcgIT09IHVuZGVmaW5lZCk7XG5cbiAgdmFyIGIgPSB0aGlzLnBlZWsoKTtcblxuICBpZiAoYiA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAoYiAhPT0gdGFnKVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0V4cGVjdGVkIDB4JyArIHRhZy50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogZ290IDB4JyArIGIudG9TdHJpbmcoMTYpKTtcblxuICB2YXIgbyA9IHRoaXMucmVhZExlbmd0aCh0aGlzLl9vZmZzZXQgKyAxKTsgLy8gc3RvcmVkIGluIGBsZW5ndGhgXG4gIGlmIChvID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA+IDQpXG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignSW50ZWdlciB0b28gbG9uZzogJyArIHRoaXMubGVuZ3RoKTtcblxuICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLl9zaXplIC0gbylcbiAgICByZXR1cm4gbnVsbDtcbiAgdGhpcy5fb2Zmc2V0ID0gbztcblxuICB2YXIgZmIgPSB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0XTtcbiAgdmFyIHZhbHVlID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA8PD0gODtcbiAgICB2YWx1ZSB8PSAodGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSAmIDB4ZmYpO1xuICB9XG5cbiAgaWYgKChmYiAmIDB4ODApID09PSAweDgwICYmIGkgIT09IDQpXG4gICAgdmFsdWUgLT0gKDEgPDwgKGkgKiA4KSk7XG5cbiAgcmV0dXJuIHZhbHVlID4+IDA7XG59O1xuXG5cblxuLy8gLS0tIEV4cG9ydGVkIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRlcjtcbiIsICIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgQVNOMSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbi8vIC0tLSBHbG9iYWxzXG5cbnZhciBuZXdJbnZhbGlkQXNuMUVycm9yID0gZXJyb3JzLm5ld0ludmFsaWRBc24xRXJyb3I7XG5cbnZhciBERUZBVUxUX09QVFMgPSB7XG4gIHNpemU6IDEwMjQsXG4gIGdyb3d0aEZhY3RvcjogOFxufTtcblxuXG4vLyAtLS0gSGVscGVyc1xuXG5mdW5jdGlvbiBtZXJnZShmcm9tLCB0bykge1xuICBhc3NlcnQub2soZnJvbSk7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgKGZyb20pLCAnb2JqZWN0Jyk7XG4gIGFzc2VydC5vayh0byk7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgKHRvKSwgJ29iamVjdCcpO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZnJvbSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHRvW2tleV0pXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIGtleSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIHZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRvO1xufVxuXG5cblxuLy8gLS0tIEFQSVxuXG5mdW5jdGlvbiBXcml0ZXIob3B0aW9ucykge1xuICBvcHRpb25zID0gbWVyZ2UoREVGQVVMVF9PUFRTLCBvcHRpb25zIHx8IHt9KTtcblxuICB0aGlzLl9idWYgPSBCdWZmZXIuYWxsb2Mob3B0aW9ucy5zaXplIHx8IDEwMjQpO1xuICB0aGlzLl9zaXplID0gdGhpcy5fYnVmLmxlbmd0aDtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgLy8gQSBsaXN0IG9mIG9mZnNldHMgaW4gdGhlIGJ1ZmZlciB3aGVyZSB3ZSBuZWVkIHRvIGluc2VydFxuICAvLyBzZXF1ZW5jZSB0YWcvbGVuIHBhaXJzLlxuICB0aGlzLl9zZXEgPSBbXTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRlci5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9zZXEubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcih0aGlzLl9zZXEubGVuZ3RoICsgJyB1bmVuZGVkIHNlcXVlbmNlKHMpJyk7XG5cbiAgICByZXR1cm4gKHRoaXMuX2J1Zi5zbGljZSgwLCB0aGlzLl9vZmZzZXQpKTtcbiAgfVxufSk7XG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYgKHR5cGVvZiAoYikgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBOdW1iZXInKTtcblxuICB0aGlzLl9lbnN1cmUoMSk7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBiO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlSW50ID0gZnVuY3Rpb24gKGksIHRhZykge1xuICBpZiAodHlwZW9mIChpKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICBpZiAodHlwZW9mICh0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLkludGVnZXI7XG5cbiAgdmFyIHN6ID0gNDtcblxuICB3aGlsZSAoKCgoaSAmIDB4ZmY4MDAwMDApID09PSAwKSB8fCAoKGkgJiAweGZmODAwMDAwKSA9PT0gMHhmZjgwMDAwMCA+PiAwKSkgJiZcbiAgICAgICAgKHN6ID4gMSkpIHtcbiAgICBzei0tO1xuICAgIGkgPDw9IDg7XG4gIH1cblxuICBpZiAoc3ogPiA0KVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0JFUiBpbnRzIGNhbm5vdCBiZSA+IDB4ZmZmZmZmZmYnKTtcblxuICB0aGlzLl9lbnN1cmUoMiArIHN6KTtcbiAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IHRhZztcbiAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IHN6O1xuXG4gIHdoaWxlIChzei0tID4gMCkge1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSAoKGkgJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICAgIGkgPDw9IDg7XG4gIH1cblxufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlTnVsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy53cml0ZUJ5dGUoQVNOMS5OdWxsKTtcbiAgdGhpcy53cml0ZUJ5dGUoMHgwMCk7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVFbnVtZXJhdGlvbiA9IGZ1bmN0aW9uIChpLCB0YWcpIHtcbiAgaWYgKHR5cGVvZiAoaSkgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgaWYgKHR5cGVvZiAodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5FbnVtZXJhdGlvbjtcblxuICByZXR1cm4gdGhpcy53cml0ZUludChpLCB0YWcpO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlQm9vbGVhbiA9IGZ1bmN0aW9uIChiLCB0YWcpIHtcbiAgaWYgKHR5cGVvZiAoYikgIT09ICdib29sZWFuJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgQm9vbGVhbicpO1xuICBpZiAodHlwZW9mICh0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLkJvb2xlYW47XG5cbiAgdGhpcy5fZW5zdXJlKDMpO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gdGFnO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHgwMTtcbiAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGIgPyAweGZmIDogMHgwMDtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZVN0cmluZyA9IGZ1bmN0aW9uIChzLCB0YWcpIHtcbiAgaWYgKHR5cGVvZiAocykgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgKHdhczogJyArIHR5cGVvZiAocykgKyAnKScpO1xuICBpZiAodHlwZW9mICh0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLk9jdGV0U3RyaW5nO1xuXG4gIHZhciBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChzKTtcbiAgdGhpcy53cml0ZUJ5dGUodGFnKTtcbiAgdGhpcy53cml0ZUxlbmd0aChsZW4pO1xuICBpZiAobGVuKSB7XG4gICAgdGhpcy5fZW5zdXJlKGxlbik7XG4gICAgdGhpcy5fYnVmLndyaXRlKHMsIHRoaXMuX29mZnNldCk7XG4gICAgdGhpcy5fb2Zmc2V0ICs9IGxlbjtcbiAgfVxufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlQnVmZmVyID0gZnVuY3Rpb24gKGJ1ZiwgdGFnKSB7XG4gIGlmICh0eXBlb2YgKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhZyBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIGJ1ZmZlcicpO1xuXG4gIHRoaXMud3JpdGVCeXRlKHRhZyk7XG4gIHRoaXMud3JpdGVMZW5ndGgoYnVmLmxlbmd0aCk7XG4gIHRoaXMuX2Vuc3VyZShidWYubGVuZ3RoKTtcbiAgYnVmLmNvcHkodGhpcy5fYnVmLCB0aGlzLl9vZmZzZXQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLl9vZmZzZXQgKz0gYnVmLmxlbmd0aDtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZVN0cmluZ0FycmF5ID0gZnVuY3Rpb24gKHN0cmluZ3MpIHtcbiAgaWYgKCghc3RyaW5ncyBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5W1N0cmluZ10nKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgIHNlbGYud3JpdGVTdHJpbmcocyk7XG4gIH0pO1xufTtcblxuLy8gVGhpcyBpcyByZWFsbHkgdG8gc29sdmUgREVSIGNhc2VzLCBidXQgd2hhdGV2ZXIgZm9yIG5vd1xuV3JpdGVyLnByb3RvdHlwZS53cml0ZU9JRCA9IGZ1bmN0aW9uIChzLCB0YWcpIHtcbiAgaWYgKHR5cGVvZiAocykgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgaWYgKHR5cGVvZiAodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5PSUQ7XG5cbiAgaWYgKCEvXihbMC05XStcXC4pezMsfVswLTldKyQvLnRlc3QocykpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCBpcyBub3QgYSB2YWxpZCBPSUQgc3RyaW5nJyk7XG5cbiAgZnVuY3Rpb24gZW5jb2RlT2N0ZXQoYnl0ZXMsIG9jdGV0KSB7XG4gICAgaWYgKG9jdGV0IDwgMTI4KSB7XG4gICAgICAgIGJ5dGVzLnB1c2gob2N0ZXQpO1xuICAgIH0gZWxzZSBpZiAob2N0ZXQgPCAxNjM4NCkge1xuICAgICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gNykgfCAweDgwKTtcbiAgICAgICAgYnl0ZXMucHVzaChvY3RldCAmIDB4N0YpO1xuICAgIH0gZWxzZSBpZiAob2N0ZXQgPCAyMDk3MTUyKSB7XG4gICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gMTQpIHwgMHg4MCk7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDcpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2gob2N0ZXQgJiAweDdGKTtcbiAgICB9IGVsc2UgaWYgKG9jdGV0IDwgMjY4NDM1NDU2KSB7XG4gICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gMjEpIHwgMHg4MCk7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDE0KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDcpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2gob2N0ZXQgJiAweDdGKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAyOCkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAyMSkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAxNCkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiA3KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKG9jdGV0ICYgMHg3Rik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRtcCA9IHMuc3BsaXQoJy4nKTtcbiAgdmFyIGJ5dGVzID0gW107XG4gIGJ5dGVzLnB1c2gocGFyc2VJbnQodG1wWzBdLCAxMCkgKiA0MCArIHBhcnNlSW50KHRtcFsxXSwgMTApKTtcbiAgdG1wLnNsaWNlKDIpLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICBlbmNvZGVPY3RldChieXRlcywgcGFyc2VJbnQoYiwgMTApKTtcbiAgfSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9lbnN1cmUoMiArIGJ5dGVzLmxlbmd0aCk7XG4gIHRoaXMud3JpdGVCeXRlKHRhZyk7XG4gIHRoaXMud3JpdGVMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcbiAgYnl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgIHNlbGYud3JpdGVCeXRlKGIpO1xuICB9KTtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZUxlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgaWYgKHR5cGVvZiAobGVuKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpO1xuXG4gIHRoaXMuX2Vuc3VyZSg0KTtcblxuICBpZiAobGVuIDw9IDB4N2YpIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IDB4ODE7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPD0gMHhmZmZmKSB7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IDB4ODI7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbiA+PiA4O1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZmZmKSB7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IDB4ODM7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbiA+PiAxNjtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuID4+IDg7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdMZW5ndGggdG9vIGxvbmcgKD4gNCBieXRlcyknKTtcbiAgfVxufTtcblxuV3JpdGVyLnByb3RvdHlwZS5zdGFydFNlcXVlbmNlID0gZnVuY3Rpb24gKHRhZykge1xuICBpZiAodHlwZW9mICh0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLlNlcXVlbmNlIHwgQVNOMS5Db25zdHJ1Y3RvcjtcblxuICB0aGlzLndyaXRlQnl0ZSh0YWcpO1xuICB0aGlzLl9zZXEucHVzaCh0aGlzLl9vZmZzZXQpO1xuICB0aGlzLl9lbnN1cmUoMyk7XG4gIHRoaXMuX29mZnNldCArPSAzO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLmVuZFNlcXVlbmNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VxID0gdGhpcy5fc2VxLnBvcCgpO1xuICB2YXIgc3RhcnQgPSBzZXEgKyAzO1xuICB2YXIgbGVuID0gdGhpcy5fb2Zmc2V0IC0gc3RhcnQ7XG5cbiAgaWYgKGxlbiA8PSAweDdmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgLTIpO1xuICAgIHRoaXMuX2J1ZltzZXFdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgLTEpO1xuICAgIHRoaXMuX2J1ZltzZXFdID0gMHg4MTtcbiAgICB0aGlzLl9idWZbc2VxICsgMV0gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZikge1xuICAgIHRoaXMuX2J1ZltzZXFdID0gMHg4MjtcbiAgICB0aGlzLl9idWZbc2VxICsgMV0gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbc2VxICsgMl0gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZmZmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgMSk7XG4gICAgdGhpcy5fYnVmW3NlcV0gPSAweDgzO1xuICAgIHRoaXMuX2J1ZltzZXEgKyAxXSA9IGxlbiA+PiAxNjtcbiAgICB0aGlzLl9idWZbc2VxICsgMl0gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbc2VxICsgM10gPSBsZW47XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignU2VxdWVuY2UgdG9vIGxvbmcnKTtcbiAgfVxufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLl9zaGlmdCA9IGZ1bmN0aW9uIChzdGFydCwgbGVuLCBzaGlmdCkge1xuICBhc3NlcnQub2soc3RhcnQgIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydC5vayhsZW4gIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydC5vayhzaGlmdCk7XG5cbiAgdGhpcy5fYnVmLmNvcHkodGhpcy5fYnVmLCBzdGFydCArIHNoaWZ0LCBzdGFydCwgc3RhcnQgKyBsZW4pO1xuICB0aGlzLl9vZmZzZXQgKz0gc2hpZnQ7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLl9lbnN1cmUgPSBmdW5jdGlvbiAobGVuKSB7XG4gIGFzc2VydC5vayhsZW4pO1xuXG4gIGlmICh0aGlzLl9zaXplIC0gdGhpcy5fb2Zmc2V0IDwgbGVuKSB7XG4gICAgdmFyIHN6ID0gdGhpcy5fc2l6ZSAqIHRoaXMuX29wdGlvbnMuZ3Jvd3RoRmFjdG9yO1xuICAgIGlmIChzeiAtIHRoaXMuX29mZnNldCA8IGxlbilcbiAgICAgIHN6ICs9IGxlbjtcblxuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2Moc3opO1xuXG4gICAgdGhpcy5fYnVmLmNvcHkoYnVmLCAwLCAwLCB0aGlzLl9vZmZzZXQpO1xuICAgIHRoaXMuX2J1ZiA9IGJ1ZjtcbiAgICB0aGlzLl9zaXplID0gc3o7XG4gIH1cbn07XG5cblxuXG4vLyAtLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuIiwgIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbnZhciBSZWFkZXIgPSByZXF1aXJlKCcuL3JlYWRlcicpO1xudmFyIFdyaXRlciA9IHJlcXVpcmUoJy4vd3JpdGVyJyk7XG5cblxuLy8gLS0tIEV4cG9ydHNcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgUmVhZGVyOiBSZWFkZXIsXG5cbiAgV3JpdGVyOiBXcml0ZXJcblxufTtcblxuZm9yICh2YXIgdCBpbiB0eXBlcykge1xuICBpZiAodHlwZXMuaGFzT3duUHJvcGVydHkodCkpXG4gICAgbW9kdWxlLmV4cG9ydHNbdF0gPSB0eXBlc1t0XTtcbn1cbmZvciAodmFyIGUgaW4gZXJyb3JzKSB7XG4gIGlmIChlcnJvcnMuaGFzT3duUHJvcGVydHkoZSkpXG4gICAgbW9kdWxlLmV4cG9ydHNbZV0gPSBlcnJvcnNbZV07XG59XG4iLCAiLy8gQ29weXJpZ2h0IDIwMTEgTWFyayBDYXZhZ2UgPG1jYXZhZ2VAZ21haWwuY29tPiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4vLyBJZiB5b3UgaGF2ZSBubyBpZGVhIHdoYXQgQVNOLjEgb3IgQkVSIGlzLCBzZWUgdGhpczpcbi8vIGZ0cDovL2Z0cC5yc2EuY29tL3B1Yi9wa2NzL2FzY2lpL2xheW1hbi5hc2NcblxudmFyIEJlciA9IHJlcXVpcmUoJy4vYmVyL2luZGV4Jyk7XG5cblxuXG4vLyAtLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIEJlcjogQmVyLFxuXG4gIEJlclJlYWRlcjogQmVyLlJlYWRlcixcblxuICBCZXJXcml0ZXI6IEJlci5Xcml0ZXJcblxufTtcbiIsICIoZnVuY3Rpb24obmFjbCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQb3J0ZWQgaW4gMjAxNCBieSBEbWl0cnkgQ2hlc3RueWtoIGFuZCBEZXZpIE1hbmRpcmkuXG4vLyBQdWJsaWMgZG9tYWluLlxuLy9cbi8vIEltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBUd2VldE5hQ2wgdmVyc2lvbiAyMDE0MDQyNy5cbi8vIFNlZSBmb3IgZGV0YWlsczogaHR0cDovL3R3ZWV0bmFjbC5jci55cC50by9cblxudmFyIGdmID0gZnVuY3Rpb24oaW5pdCkge1xuICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICBpZiAoaW5pdCkgZm9yIChpID0gMDsgaSA8IGluaXQubGVuZ3RoOyBpKyspIHJbaV0gPSBpbml0W2ldO1xuICByZXR1cm4gcjtcbn07XG5cbi8vICBQbHVnZ2FibGUsIGluaXRpYWxpemVkIGluIGhpZ2gtbGV2ZWwgQVBJIGJlbG93LlxudmFyIHJhbmRvbWJ5dGVzID0gZnVuY3Rpb24oLyogeCwgbiAqLykgeyB0aHJvdyBuZXcgRXJyb3IoJ25vIFBSTkcnKTsgfTtcblxudmFyIF8wID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xudmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpOyBfOVswXSA9IDk7XG5cbnZhciBnZjAgPSBnZigpLFxuICAgIGdmMSA9IGdmKFsxXSksXG4gICAgXzEyMTY2NSA9IGdmKFsweGRiNDEsIDFdKSxcbiAgICBEID0gZ2YoWzB4NzhhMywgMHgxMzU5LCAweDRkY2EsIDB4NzVlYiwgMHhkOGFiLCAweDQxNDEsIDB4MGE0ZCwgMHgwMDcwLCAweGU4OTgsIDB4Nzc3OSwgMHg0MDc5LCAweDhjYzcsIDB4ZmU3MywgMHgyYjZmLCAweDZjZWUsIDB4NTIwM10pLFxuICAgIEQyID0gZ2YoWzB4ZjE1OSwgMHgyNmIyLCAweDliOTQsIDB4ZWJkNiwgMHhiMTU2LCAweDgyODMsIDB4MTQ5YSwgMHgwMGUwLCAweGQxMzAsIDB4ZWVmMywgMHg4MGYyLCAweDE5OGUsIDB4ZmNlNywgMHg1NmRmLCAweGQ5ZGMsIDB4MjQwNl0pLFxuICAgIFggPSBnZihbMHhkNTFhLCAweDhmMjUsIDB4MmQ2MCwgMHhjOTU2LCAweGE3YjIsIDB4OTUyNSwgMHhjNzYwLCAweDY5MmMsIDB4ZGM1YywgMHhmZGQ2LCAweGUyMzEsIDB4YzBhNCwgMHg1M2ZlLCAweGNkNmUsIDB4MzZkMywgMHgyMTY5XSksXG4gICAgWSA9IGdmKFsweDY2NTgsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjZdKSxcbiAgICBJID0gZ2YoWzB4YTBiMCwgMHg0YTBlLCAweDFiMjcsIDB4YzRlZSwgMHhlNDc4LCAweGFkMmYsIDB4MTgwNiwgMHgyZjQzLCAweGQ3YTcsIDB4M2RmYiwgMHgwMDk5LCAweDJiNGQsIDB4ZGYwYiwgMHg0ZmMxLCAweDI0ODAsIDB4MmI4M10pO1xuXG5mdW5jdGlvbiB0czY0KHgsIGksIGgsIGwpIHtcbiAgeFtpXSAgID0gKGggPj4gMjQpICYgMHhmZjtcbiAgeFtpKzFdID0gKGggPj4gMTYpICYgMHhmZjtcbiAgeFtpKzJdID0gKGggPj4gIDgpICYgMHhmZjtcbiAgeFtpKzNdID0gaCAmIDB4ZmY7XG4gIHhbaSs0XSA9IChsID4+IDI0KSAgJiAweGZmO1xuICB4W2krNV0gPSAobCA+PiAxNikgICYgMHhmZjtcbiAgeFtpKzZdID0gKGwgPj4gIDgpICAmIDB4ZmY7XG4gIHhbaSs3XSA9IGwgJiAweGZmO1xufVxuXG5mdW5jdGlvbiB2bih4LCB4aSwgeSwgeWksIG4pIHtcbiAgdmFyIGksZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGQgfD0geFt4aStpXV55W3lpK2ldO1xuICByZXR1cm4gKDEgJiAoKGQgLSAxKSA+Pj4gOCkpIC0gMTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8xNih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwxNik7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMzIpO1xufVxuXG5mdW5jdGlvbiBjb3JlX3NhbHNhMjAobywgcCwgaywgYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZik8PDggfCAoY1sgMl0gJiAweGZmKTw8MTYgfCAoY1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKTw8OCB8IChrWyAyXSAmIDB4ZmYpPDwxNiB8IChrWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpPDw4IHwgKGtbIDZdICYgMHhmZik8PDE2IHwgKGtbIDddICYgMHhmZik8PDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZik8PDggfCAoa1sxMF0gJiAweGZmKTw8MTYgfCAoa1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKTw8OCB8IChrWzE0XSAmIDB4ZmYpPDwxNiB8IChrWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpPDw4IHwgKGNbIDZdICYgMHhmZik8PDE2IHwgKGNbIDddICYgMHhmZik8PDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZik8PDggfCAocFsgMl0gJiAweGZmKTw8MTYgfCAocFsgM10gJiAweGZmKTw8MjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKTw8OCB8IChwWyA2XSAmIDB4ZmYpPDwxNiB8IChwWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpPDw4IHwgKHBbMTBdICYgMHhmZik8PDE2IHwgKHBbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZik8PDggfCAocFsxNF0gJiAweGZmKTw8MTYgfCAocFsxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKTw8OCB8IChjWzEwXSAmIDB4ZmYpPDwxNiB8IChjWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpPDw4IHwgKGtbMThdICYgMHhmZik8PDE2IHwgKGtbMTldICYgMHhmZik8PDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZik8PDggfCAoa1syMl0gJiAweGZmKTw8MTYgfCAoa1syM10gJiAweGZmKTw8MjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKTw8OCB8IChrWzI2XSAmIDB4ZmYpPDwxNiB8IChrWzI3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpPDw4IHwgKGtbMzBdICYgMHhmZik8PDE2IHwgKGtbMzFdICYgMHhmZik8PDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZik8PDggfCAoY1sxNF0gJiAweGZmKTw8MTYgfCAoY1sxNV0gJiAweGZmKTw8MjQ7XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwO1xuICAgIHg0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NCArIHgwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4NCB8IDA7XG4gICAgeDEyIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMiArIHg4IHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDEgfCAwO1xuICAgIHg5IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4OSArIHg1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHg5IHwgMDtcbiAgICB4MSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MSArIHgxMyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4NiB8IDA7XG4gICAgeDE0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTQgKyB4MTAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxNCB8IDA7XG4gICAgeDYgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDYgKyB4MiB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMDtcbiAgICB4MyBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDMgKyB4MTUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHgzIHwgMDtcbiAgICB4MTEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDExICsgeDcgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgwICsgeDMgfCAwO1xuICAgIHgxIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MSArIHgwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MSB8IDA7XG4gICAgeDMgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDMgKyB4MiB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHg0IHwgMDtcbiAgICB4NiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDYgKyB4NSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDYgfCAwO1xuICAgIHg0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg0ICsgeDcgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDkgfCAwO1xuICAgIHgxMSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDExICsgeDEwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4MTEgfCAwO1xuICAgIHg5IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg5ICsgeDggfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxNCB8IDA7XG4gICAgeDEyIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTIgKyB4MTUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDEyIHwgMDtcbiAgICB4MTQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDE0ICsgeDEzIHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcbiAgfVxuICAgeDAgPSAgeDAgKyAgajAgfCAwO1xuICAgeDEgPSAgeDEgKyAgajEgfCAwO1xuICAgeDIgPSAgeDIgKyAgajIgfCAwO1xuICAgeDMgPSAgeDMgKyAgajMgfCAwO1xuICAgeDQgPSAgeDQgKyAgajQgfCAwO1xuICAgeDUgPSAgeDUgKyAgajUgfCAwO1xuICAgeDYgPSAgeDYgKyAgajYgfCAwO1xuICAgeDcgPSAgeDcgKyAgajcgfCAwO1xuICAgeDggPSAgeDggKyAgajggfCAwO1xuICAgeDkgPSAgeDkgKyAgajkgfCAwO1xuICB4MTAgPSB4MTAgKyBqMTAgfCAwO1xuICB4MTEgPSB4MTEgKyBqMTEgfCAwO1xuICB4MTIgPSB4MTIgKyBqMTIgfCAwO1xuICB4MTMgPSB4MTMgKyBqMTMgfCAwO1xuICB4MTQgPSB4MTQgKyBqMTQgfCAwO1xuICB4MTUgPSB4MTUgKyBqMTUgfCAwO1xuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZjtcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmO1xuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA0XSA9IHgxID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDVdID0geDEgPj4+ICA4ICYgMHhmZjtcbiAgb1sgNl0gPSB4MSA+Pj4gMTYgJiAweGZmO1xuICBvWyA3XSA9IHgxID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgOF0gPSB4MiA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgyID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDIgPj4+IDE2ICYgMHhmZjtcbiAgb1sxMV0gPSB4MiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDMgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MyA+Pj4gIDggJiAweGZmO1xuICBvWzE0XSA9IHgzID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDMgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDQgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NCA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDYgPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4NiA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg2ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDYgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg3ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDcgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4NyA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg3ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szMl0gPSB4OCA+Pj4gIDAgJiAweGZmO1xuICBvWzMzXSA9IHg4ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzRdID0geDggPj4+IDE2ICYgMHhmZjtcbiAgb1szNV0gPSB4OCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMzZdID0geDkgPj4+ICAwICYgMHhmZjtcbiAgb1szN10gPSB4OSA+Pj4gIDggJiAweGZmO1xuICBvWzM4XSA9IHg5ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzldID0geDkgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQwXSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWzQxXSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzQyXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzQzXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDRdID0geDExID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDVdID0geDExID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDZdID0geDExID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDddID0geDExID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0OF0gPSB4MTIgPj4+ICAwICYgMHhmZjtcbiAgb1s0OV0gPSB4MTIgPj4+ICA4ICYgMHhmZjtcbiAgb1s1MF0gPSB4MTIgPj4+IDE2ICYgMHhmZjtcbiAgb1s1MV0gPSB4MTIgPj4+IDI0ICYgMHhmZjtcblxuICBvWzUyXSA9IHgxMyA+Pj4gIDAgJiAweGZmO1xuICBvWzUzXSA9IHgxMyA+Pj4gIDggJiAweGZmO1xuICBvWzU0XSA9IHgxMyA+Pj4gMTYgJiAweGZmO1xuICBvWzU1XSA9IHgxMyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTZdID0geDE0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTddID0geDE0ID4+PiAgOCAmIDB4ZmY7XG4gIG9bNThdID0geDE0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTldID0geDE0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s2MF0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1s2MV0gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1s2Ml0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1s2M10gPSB4MTUgPj4+IDI0ICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gY29yZV9oc2Fsc2EyMChvLHAsayxjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDUgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4NSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHg1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDUgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzEwXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDE1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTNdID0geDE1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDE1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDE1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxNl0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzE3XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMThdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1sxOV0gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjBdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syMV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzIyXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjNdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI0XSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjVdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1syNl0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzI3XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syOF0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzI5XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzBdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szMV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX2hzYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpO1xufVxuXG52YXIgc2lnbWEgPSBuZXcgVWludDhBcnJheShbMTAxLCAxMjAsIDExMiwgOTcsIDExMCwgMTAwLCAzMiwgNTEsIDUwLCA0NSwgOTgsIDEyMSwgMTE2LCAxMDEsIDMyLCAxMDddKTtcbiAgICAgICAgICAgIC8vIFwiZXhwYW5kIDMyLWJ5dGUga1wiXG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYyxjcG9zLG0sbXBvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IG1bbXBvcytpXSBeIHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICAgIG1wb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICB9XG4gIGlmIChiID4gMCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiOyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW0oYyxjcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxkLHNuLHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3hvcihjLGNwb3MsbSxtcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGQsc24scyk7XG59XG5cbi8qXG4qIFBvcnQgb2YgQW5kcmV3IE1vb24ncyBQb2x5MTMwNS1kb25uYS0xNi4gUHVibGljIGRvbWFpbi5cbiogaHR0cHM6Ly9naXRodWIuY29tL2Zsb29keWJlcnJ5L3BvbHkxMzA1LWRvbm5hXG4qL1xuXG52YXIgcG9seTEzMDUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMuaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMucGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgdGhpcy5maW4gPSAwO1xuXG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDc7XG5cbiAgdDAgPSBrZXlbIDBdICYgMHhmZiB8IChrZXlbIDFdICYgMHhmZikgPDwgODsgdGhpcy5yWzBdID0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gIHQxID0ga2V5WyAyXSAmIDB4ZmYgfCAoa2V5WyAzXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICB0MiA9IGtleVsgNF0gJiAweGZmIHwgKGtleVsgNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWYwMztcbiAgdDMgPSBrZXlbIDZdICYgMHhmZiB8IChrZXlbIDddICYgMHhmZikgPDwgODsgdGhpcy5yWzNdID0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gIHQ0ID0ga2V5WyA4XSAmIDB4ZmYgfCAoa2V5WyA5XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls0XSA9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgwMGZmO1xuICB0aGlzLnJbNV0gPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZlO1xuICB0NSA9IGtleVsxMF0gJiAweGZmIHwgKGtleVsxMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgdDYgPSBrZXlbMTJdICYgMHhmZiB8IChrZXlbMTNdICYgMHhmZikgPDwgODsgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmODE7XG4gIHQ3ID0ga2V5WzE0XSAmIDB4ZmYgfCAoa2V5WzE1XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls4XSA9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICB0aGlzLnJbOV0gPSAoKHQ3ID4+PiAgNSkpICYgMHgwMDdmO1xuXG4gIHRoaXMucGFkWzBdID0ga2V5WzE2XSAmIDB4ZmYgfCAoa2V5WzE3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzFdID0ga2V5WzE4XSAmIDB4ZmYgfCAoa2V5WzE5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzJdID0ga2V5WzIwXSAmIDB4ZmYgfCAoa2V5WzIxXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzNdID0ga2V5WzIyXSAmIDB4ZmYgfCAoa2V5WzIzXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzRdID0ga2V5WzI0XSAmIDB4ZmYgfCAoa2V5WzI1XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzVdID0ga2V5WzI2XSAmIDB4ZmYgfCAoa2V5WzI3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzZdID0ga2V5WzI4XSAmIDB4ZmYgfCAoa2V5WzI5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzddID0ga2V5WzMwXSAmIDB4ZmYgfCAoa2V5WzMxXSAmIDB4ZmYpIDw8IDg7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuYmxvY2tzID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGhpYml0ID0gdGhpcy5maW4gPyAwIDogKDEgPDwgMTEpO1xuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3LCBjO1xuICB2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDk7XG5cbiAgdmFyIGgwID0gdGhpcy5oWzBdLFxuICAgICAgaDEgPSB0aGlzLmhbMV0sXG4gICAgICBoMiA9IHRoaXMuaFsyXSxcbiAgICAgIGgzID0gdGhpcy5oWzNdLFxuICAgICAgaDQgPSB0aGlzLmhbNF0sXG4gICAgICBoNSA9IHRoaXMuaFs1XSxcbiAgICAgIGg2ID0gdGhpcy5oWzZdLFxuICAgICAgaDcgPSB0aGlzLmhbN10sXG4gICAgICBoOCA9IHRoaXMuaFs4XSxcbiAgICAgIGg5ID0gdGhpcy5oWzldO1xuXG4gIHZhciByMCA9IHRoaXMuclswXSxcbiAgICAgIHIxID0gdGhpcy5yWzFdLFxuICAgICAgcjIgPSB0aGlzLnJbMl0sXG4gICAgICByMyA9IHRoaXMuclszXSxcbiAgICAgIHI0ID0gdGhpcy5yWzRdLFxuICAgICAgcjUgPSB0aGlzLnJbNV0sXG4gICAgICByNiA9IHRoaXMucls2XSxcbiAgICAgIHI3ID0gdGhpcy5yWzddLFxuICAgICAgcjggPSB0aGlzLnJbOF0sXG4gICAgICByOSA9IHRoaXMucls5XTtcblxuICB3aGlsZSAoYnl0ZXMgPj0gMTYpIHtcbiAgICB0MCA9IG1bbXBvcysgMF0gJiAweGZmIHwgKG1bbXBvcysgMV0gJiAweGZmKSA8PCA4OyBoMCArPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgICB0MSA9IG1bbXBvcysgMl0gJiAweGZmIHwgKG1bbXBvcysgM10gJiAweGZmKSA8PCA4OyBoMSArPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgICB0MiA9IG1bbXBvcysgNF0gJiAweGZmIHwgKG1bbXBvcysgNV0gJiAweGZmKSA8PCA4OyBoMiArPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWZmZjtcbiAgICB0MyA9IG1bbXBvcysgNl0gJiAweGZmIHwgKG1bbXBvcysgN10gJiAweGZmKSA8PCA4OyBoMyArPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgICB0NCA9IG1bbXBvcysgOF0gJiAweGZmIHwgKG1bbXBvcysgOV0gJiAweGZmKSA8PCA4OyBoNCArPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZjtcbiAgICBoNSArPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZmO1xuICAgIHQ1ID0gbVttcG9zKzEwXSAmIDB4ZmYgfCAobVttcG9zKzExXSAmIDB4ZmYpIDw8IDg7IGg2ICs9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICAgIHQ2ID0gbVttcG9zKzEyXSAmIDB4ZmYgfCAobVttcG9zKzEzXSAmIDB4ZmYpIDw8IDg7IGg3ICs9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZmZmO1xuICAgIHQ3ID0gbVttcG9zKzE0XSAmIDB4ZmYgfCAobVttcG9zKzE1XSAmIDB4ZmYpIDw8IDg7IGg4ICs9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICAgIGg5ICs9ICgodDcgPj4+IDUpKSB8IGhpYml0O1xuXG4gICAgYyA9IDA7XG5cbiAgICBkMCA9IGM7XG4gICAgZDAgKz0gaDAgKiByMDtcbiAgICBkMCArPSBoMSAqICg1ICogcjkpO1xuICAgIGQwICs9IGgyICogKDUgKiByOCk7XG4gICAgZDAgKz0gaDMgKiAoNSAqIHI3KTtcbiAgICBkMCArPSBoNCAqICg1ICogcjYpO1xuICAgIGMgPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuICAgIGQwICs9IGg1ICogKDUgKiByNSk7XG4gICAgZDAgKz0gaDYgKiAoNSAqIHI0KTtcbiAgICBkMCArPSBoNyAqICg1ICogcjMpO1xuICAgIGQwICs9IGg4ICogKDUgKiByMik7XG4gICAgZDAgKz0gaDkgKiAoNSAqIHIxKTtcbiAgICBjICs9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG5cbiAgICBkMSA9IGM7XG4gICAgZDEgKz0gaDAgKiByMTtcbiAgICBkMSArPSBoMSAqIHIwO1xuICAgIGQxICs9IGgyICogKDUgKiByOSk7XG4gICAgZDEgKz0gaDMgKiAoNSAqIHI4KTtcbiAgICBkMSArPSBoNCAqICg1ICogcjcpO1xuICAgIGMgPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuICAgIGQxICs9IGg1ICogKDUgKiByNik7XG4gICAgZDEgKz0gaDYgKiAoNSAqIHI1KTtcbiAgICBkMSArPSBoNyAqICg1ICogcjQpO1xuICAgIGQxICs9IGg4ICogKDUgKiByMyk7XG4gICAgZDEgKz0gaDkgKiAoNSAqIHIyKTtcbiAgICBjICs9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG5cbiAgICBkMiA9IGM7XG4gICAgZDIgKz0gaDAgKiByMjtcbiAgICBkMiArPSBoMSAqIHIxO1xuICAgIGQyICs9IGgyICogcjA7XG4gICAgZDIgKz0gaDMgKiAoNSAqIHI5KTtcbiAgICBkMiArPSBoNCAqICg1ICogcjgpO1xuICAgIGMgPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuICAgIGQyICs9IGg1ICogKDUgKiByNyk7XG4gICAgZDIgKz0gaDYgKiAoNSAqIHI2KTtcbiAgICBkMiArPSBoNyAqICg1ICogcjUpO1xuICAgIGQyICs9IGg4ICogKDUgKiByNCk7XG4gICAgZDIgKz0gaDkgKiAoNSAqIHIzKTtcbiAgICBjICs9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG5cbiAgICBkMyA9IGM7XG4gICAgZDMgKz0gaDAgKiByMztcbiAgICBkMyArPSBoMSAqIHIyO1xuICAgIGQzICs9IGgyICogcjE7XG4gICAgZDMgKz0gaDMgKiByMDtcbiAgICBkMyArPSBoNCAqICg1ICogcjkpO1xuICAgIGMgPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuICAgIGQzICs9IGg1ICogKDUgKiByOCk7XG4gICAgZDMgKz0gaDYgKiAoNSAqIHI3KTtcbiAgICBkMyArPSBoNyAqICg1ICogcjYpO1xuICAgIGQzICs9IGg4ICogKDUgKiByNSk7XG4gICAgZDMgKz0gaDkgKiAoNSAqIHI0KTtcbiAgICBjICs9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG5cbiAgICBkNCA9IGM7XG4gICAgZDQgKz0gaDAgKiByNDtcbiAgICBkNCArPSBoMSAqIHIzO1xuICAgIGQ0ICs9IGgyICogcjI7XG4gICAgZDQgKz0gaDMgKiByMTtcbiAgICBkNCArPSBoNCAqIHIwO1xuICAgIGMgPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuICAgIGQ0ICs9IGg1ICogKDUgKiByOSk7XG4gICAgZDQgKz0gaDYgKiAoNSAqIHI4KTtcbiAgICBkNCArPSBoNyAqICg1ICogcjcpO1xuICAgIGQ0ICs9IGg4ICogKDUgKiByNik7XG4gICAgZDQgKz0gaDkgKiAoNSAqIHI1KTtcbiAgICBjICs9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG5cbiAgICBkNSA9IGM7XG4gICAgZDUgKz0gaDAgKiByNTtcbiAgICBkNSArPSBoMSAqIHI0O1xuICAgIGQ1ICs9IGgyICogcjM7XG4gICAgZDUgKz0gaDMgKiByMjtcbiAgICBkNSArPSBoNCAqIHIxO1xuICAgIGMgPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuICAgIGQ1ICs9IGg1ICogcjA7XG4gICAgZDUgKz0gaDYgKiAoNSAqIHI5KTtcbiAgICBkNSArPSBoNyAqICg1ICogcjgpO1xuICAgIGQ1ICs9IGg4ICogKDUgKiByNyk7XG4gICAgZDUgKz0gaDkgKiAoNSAqIHI2KTtcbiAgICBjICs9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG5cbiAgICBkNiA9IGM7XG4gICAgZDYgKz0gaDAgKiByNjtcbiAgICBkNiArPSBoMSAqIHI1O1xuICAgIGQ2ICs9IGgyICogcjQ7XG4gICAgZDYgKz0gaDMgKiByMztcbiAgICBkNiArPSBoNCAqIHIyO1xuICAgIGMgPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuICAgIGQ2ICs9IGg1ICogcjE7XG4gICAgZDYgKz0gaDYgKiByMDtcbiAgICBkNiArPSBoNyAqICg1ICogcjkpO1xuICAgIGQ2ICs9IGg4ICogKDUgKiByOCk7XG4gICAgZDYgKz0gaDkgKiAoNSAqIHI3KTtcbiAgICBjICs9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG5cbiAgICBkNyA9IGM7XG4gICAgZDcgKz0gaDAgKiByNztcbiAgICBkNyArPSBoMSAqIHI2O1xuICAgIGQ3ICs9IGgyICogcjU7XG4gICAgZDcgKz0gaDMgKiByNDtcbiAgICBkNyArPSBoNCAqIHIzO1xuICAgIGMgPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuICAgIGQ3ICs9IGg1ICogcjI7XG4gICAgZDcgKz0gaDYgKiByMTtcbiAgICBkNyArPSBoNyAqIHIwO1xuICAgIGQ3ICs9IGg4ICogKDUgKiByOSk7XG4gICAgZDcgKz0gaDkgKiAoNSAqIHI4KTtcbiAgICBjICs9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG5cbiAgICBkOCA9IGM7XG4gICAgZDggKz0gaDAgKiByODtcbiAgICBkOCArPSBoMSAqIHI3O1xuICAgIGQ4ICs9IGgyICogcjY7XG4gICAgZDggKz0gaDMgKiByNTtcbiAgICBkOCArPSBoNCAqIHI0O1xuICAgIGMgPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuICAgIGQ4ICs9IGg1ICogcjM7XG4gICAgZDggKz0gaDYgKiByMjtcbiAgICBkOCArPSBoNyAqIHIxO1xuICAgIGQ4ICs9IGg4ICogcjA7XG4gICAgZDggKz0gaDkgKiAoNSAqIHI5KTtcbiAgICBjICs9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG5cbiAgICBkOSA9IGM7XG4gICAgZDkgKz0gaDAgKiByOTtcbiAgICBkOSArPSBoMSAqIHI4O1xuICAgIGQ5ICs9IGgyICogcjc7XG4gICAgZDkgKz0gaDMgKiByNjtcbiAgICBkOSArPSBoNCAqIHI1O1xuICAgIGMgPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuICAgIGQ5ICs9IGg1ICogcjQ7XG4gICAgZDkgKz0gaDYgKiByMztcbiAgICBkOSArPSBoNyAqIHIyO1xuICAgIGQ5ICs9IGg4ICogcjE7XG4gICAgZDkgKz0gaDkgKiByMDtcbiAgICBjICs9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG5cbiAgICBjID0gKCgoYyA8PCAyKSArIGMpKSB8IDA7XG4gICAgYyA9IChjICsgZDApIHwgMDtcbiAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgYyA9IChjID4+PiAxMyk7XG4gICAgZDEgKz0gYztcblxuICAgIGgwID0gZDA7XG4gICAgaDEgPSBkMTtcbiAgICBoMiA9IGQyO1xuICAgIGgzID0gZDM7XG4gICAgaDQgPSBkNDtcbiAgICBoNSA9IGQ1O1xuICAgIGg2ID0gZDY7XG4gICAgaDcgPSBkNztcbiAgICBoOCA9IGQ4O1xuICAgIGg5ID0gZDk7XG5cbiAgICBtcG9zICs9IDE2O1xuICAgIGJ5dGVzIC09IDE2O1xuICB9XG4gIHRoaXMuaFswXSA9IGgwO1xuICB0aGlzLmhbMV0gPSBoMTtcbiAgdGhpcy5oWzJdID0gaDI7XG4gIHRoaXMuaFszXSA9IGgzO1xuICB0aGlzLmhbNF0gPSBoNDtcbiAgdGhpcy5oWzVdID0gaDU7XG4gIHRoaXMuaFs2XSA9IGg2O1xuICB0aGlzLmhbN10gPSBoNztcbiAgdGhpcy5oWzhdID0gaDg7XG4gIHRoaXMuaFs5XSA9IGg5O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKG1hYywgbWFjcG9zKSB7XG4gIHZhciBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdmFyIGMsIG1hc2ssIGYsIGk7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICBpID0gdGhpcy5sZWZ0b3ZlcjtcbiAgICB0aGlzLmJ1ZmZlcltpKytdID0gMTtcbiAgICBmb3IgKDsgaSA8IDE2OyBpKyspIHRoaXMuYnVmZmVyW2ldID0gMDtcbiAgICB0aGlzLmZpbiA9IDE7XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgfVxuXG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgIHRoaXMuaFtpXSArPSBjO1xuICAgIGMgPSB0aGlzLmhbaV0gPj4+IDEzO1xuICAgIHRoaXMuaFtpXSAmPSAweDFmZmY7XG4gIH1cbiAgdGhpcy5oWzBdICs9IChjICogNSk7XG4gIGMgPSB0aGlzLmhbMF0gPj4+IDEzO1xuICB0aGlzLmhbMF0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMV0gKz0gYztcbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsyXSArPSBjO1xuXG4gIGdbMF0gPSB0aGlzLmhbMF0gKyA1O1xuICBjID0gZ1swXSA+Pj4gMTM7XG4gIGdbMF0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgIGdbaV0gPSB0aGlzLmhbaV0gKyBjO1xuICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICBnW2ldICY9IDB4MWZmZjtcbiAgfVxuICBnWzldIC09ICgxIDw8IDEzKTtcblxuICBtYXNrID0gKGMgXiAxKSAtIDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSBnW2ldICY9IG1hc2s7XG4gIG1hc2sgPSB+bWFzaztcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHRoaXMuaFtpXSA9ICh0aGlzLmhbaV0gJiBtYXNrKSB8IGdbaV07XG5cbiAgdGhpcy5oWzBdID0gKCh0aGlzLmhbMF0gICAgICAgKSB8ICh0aGlzLmhbMV0gPDwgMTMpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMV0gPSAoKHRoaXMuaFsxXSA+Pj4gIDMpIHwgKHRoaXMuaFsyXSA8PCAxMCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsyXSA9ICgodGhpcy5oWzJdID4+PiAgNikgfCAodGhpcy5oWzNdIDw8ICA3KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzNdID0gKCh0aGlzLmhbM10gPj4+ICA5KSB8ICh0aGlzLmhbNF0gPDwgIDQpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNF0gPSAoKHRoaXMuaFs0XSA+Pj4gMTIpIHwgKHRoaXMuaFs1XSA8PCAgMSkgfCAodGhpcy5oWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gIHRoaXMuaFs1XSA9ICgodGhpcy5oWzZdID4+PiAgMikgfCAodGhpcy5oWzddIDw8IDExKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzZdID0gKCh0aGlzLmhbN10gPj4+ICA1KSB8ICh0aGlzLmhbOF0gPDwgIDgpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbN10gPSAoKHRoaXMuaFs4XSA+Pj4gIDgpIHwgKHRoaXMuaFs5XSA8PCAgNSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG5cbiAgZiA9IHRoaXMuaFswXSArIHRoaXMucGFkWzBdO1xuICB0aGlzLmhbMF0gPSBmICYgMHhmZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgZiA9ICgoKHRoaXMuaFtpXSArIHRoaXMucGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgIHRoaXMuaFtpXSA9IGYgJiAweGZmZmY7XG4gIH1cblxuICBtYWNbbWFjcG9zKyAwXSA9ICh0aGlzLmhbMF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMV0gPSAodGhpcy5oWzBdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDJdID0gKHRoaXMuaFsxXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAzXSA9ICh0aGlzLmhbMV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNF0gPSAodGhpcy5oWzJdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDVdID0gKHRoaXMuaFsyXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA2XSA9ICh0aGlzLmhbM10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgN10gPSAodGhpcy5oWzNdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDhdID0gKHRoaXMuaFs0XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA5XSA9ICh0aGlzLmhbNF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMF0gPSAodGhpcy5oWzVdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTFdID0gKHRoaXMuaFs1XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEyXSA9ICh0aGlzLmhbNl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxM10gPSAodGhpcy5oWzZdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTRdID0gKHRoaXMuaFs3XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE1XSA9ICh0aGlzLmhbN10gPj4+IDgpICYgMHhmZjtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaSwgd2FudDtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIHdhbnQgPSAoMTYgLSB0aGlzLmxlZnRvdmVyKTtcbiAgICBpZiAod2FudCA+IGJ5dGVzKVxuICAgICAgd2FudCA9IGJ5dGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YW50OyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgdGhpcy5sZWZ0b3ZlciArPSB3YW50O1xuICAgIGlmICh0aGlzLmxlZnRvdmVyIDwgMTYpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgfVxuXG4gIGlmIChieXRlcyA+PSAxNikge1xuICAgIHdhbnQgPSBieXRlcyAtIChieXRlcyAlIDE2KTtcbiAgICB0aGlzLmJsb2NrcyhtLCBtcG9zLCB3YW50KTtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgfVxuXG4gIGlmIChieXRlcykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIHRoaXMubGVmdG92ZXIgKz0gYnl0ZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aChvdXQsIG91dHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgcyA9IG5ldyBwb2x5MTMwNShrKTtcbiAgcy51cGRhdGUobSwgbXBvcywgbik7XG4gIHMuZmluaXNoKG91dCwgb3V0cG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoaCwgaHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKHgsMCxtLG1wb3MsbixrKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMTYoaCxocG9zLHgsMCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3goYyxtLGQsbixrKSB7XG4gIHZhciBpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKGMsMCxtLDAsZCxuLGspO1xuICBjcnlwdG9fb25ldGltZWF1dGgoYywgMTYsIGMsIDMyLCBkIC0gMzIsIGMpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgY1tpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X29wZW4obSxjLGQsbixrKSB7XG4gIHZhciBpO1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtKHgsMCwzMixuLGspO1xuICBpZiAoY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShjLCAxNixjLCAzMixkIC0gMzIseCkgIT09IDApIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IobSwwLGMsMCxkLG4sayk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHNldDI1NTE5KHIsIGEpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSByW2ldID0gYVtpXXwwO1xufVxuXG5mdW5jdGlvbiBjYXIyNTUxOShvKSB7XG4gIHZhciBpLCB2LCBjID0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2ID0gb1tpXSArIGMgKyA2NTUzNTtcbiAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgIG9baV0gPSB2IC0gYyAqIDY1NTM2O1xuICB9XG4gIG9bMF0gKz0gYy0xICsgMzcgKiAoYy0xKTtcbn1cblxuZnVuY3Rpb24gc2VsMjU1MTkocCwgcSwgYikge1xuICB2YXIgdCwgYyA9IH4oYi0xKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdCA9IGMgJiAocFtpXSBeIHFbaV0pO1xuICAgIHBbaV0gXj0gdDtcbiAgICBxW2ldIF49IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGksIGosIGI7XG4gIHZhciBtID0gZ2YoKSwgdCA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB0W2ldID0gbltpXTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgZm9yIChqID0gMDsgaiA8IDI7IGorKykge1xuICAgIG1bMF0gPSB0WzBdIC0gMHhmZmVkO1xuICAgIGZvciAoaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICBtW2ldID0gdFtpXSAtIDB4ZmZmZiAtICgobVtpLTFdPj4xNikgJiAxKTtcbiAgICAgIG1baS0xXSAmPSAweGZmZmY7XG4gICAgfVxuICAgIG1bMTVdID0gdFsxNV0gLSAweDdmZmYgLSAoKG1bMTRdPj4xNikgJiAxKTtcbiAgICBiID0gKG1bMTVdPj4xNikgJiAxO1xuICAgIG1bMTRdICY9IDB4ZmZmZjtcbiAgICBzZWwyNTUxOSh0LCBtLCAxLWIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgb1syKmldID0gdFtpXSAmIDB4ZmY7XG4gICAgb1syKmkrMV0gPSB0W2ldPj44O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lcTI1NTE5KGEsIGIpIHtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheSgzMiksIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShjLCBhKTtcbiAgcGFjazI1NTE5KGQsIGIpO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8zMihjLCAwLCBkLCAwKTtcbn1cblxuZnVuY3Rpb24gcGFyMjU1MTkoYSkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGQsIGEpO1xuICByZXR1cm4gZFswXSAmIDE7XG59XG5cbmZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gblsyKmldICsgKG5bMippKzFdIDw8IDgpO1xuICBvWzE1XSAmPSAweDdmZmY7XG59XG5cbmZ1bmN0aW9uIEEobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldICsgYltpXTtcbn1cblxuZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gLSBiW2ldO1xufVxuXG5mdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgdmFyIHYsIGMsXG4gICAgIHQwID0gMCwgIHQxID0gMCwgIHQyID0gMCwgIHQzID0gMCwgIHQ0ID0gMCwgIHQ1ID0gMCwgIHQ2ID0gMCwgIHQ3ID0gMCxcbiAgICAgdDggPSAwLCAgdDkgPSAwLCB0MTAgPSAwLCB0MTEgPSAwLCB0MTIgPSAwLCB0MTMgPSAwLCB0MTQgPSAwLCB0MTUgPSAwLFxuICAgIHQxNiA9IDAsIHQxNyA9IDAsIHQxOCA9IDAsIHQxOSA9IDAsIHQyMCA9IDAsIHQyMSA9IDAsIHQyMiA9IDAsIHQyMyA9IDAsXG4gICAgdDI0ID0gMCwgdDI1ID0gMCwgdDI2ID0gMCwgdDI3ID0gMCwgdDI4ID0gMCwgdDI5ID0gMCwgdDMwID0gMCxcbiAgICBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM10sXG4gICAgYjQgPSBiWzRdLFxuICAgIGI1ID0gYls1XSxcbiAgICBiNiA9IGJbNl0sXG4gICAgYjcgPSBiWzddLFxuICAgIGI4ID0gYls4XSxcbiAgICBiOSA9IGJbOV0sXG4gICAgYjEwID0gYlsxMF0sXG4gICAgYjExID0gYlsxMV0sXG4gICAgYjEyID0gYlsxMl0sXG4gICAgYjEzID0gYlsxM10sXG4gICAgYjE0ID0gYlsxNF0sXG4gICAgYjE1ID0gYlsxNV07XG5cbiAgdiA9IGFbMF07XG4gIHQwICs9IHYgKiBiMDtcbiAgdDEgKz0gdiAqIGIxO1xuICB0MiArPSB2ICogYjI7XG4gIHQzICs9IHYgKiBiMztcbiAgdDQgKz0gdiAqIGI0O1xuICB0NSArPSB2ICogYjU7XG4gIHQ2ICs9IHYgKiBiNjtcbiAgdDcgKz0gdiAqIGI3O1xuICB0OCArPSB2ICogYjg7XG4gIHQ5ICs9IHYgKiBiOTtcbiAgdDEwICs9IHYgKiBiMTA7XG4gIHQxMSArPSB2ICogYjExO1xuICB0MTIgKz0gdiAqIGIxMjtcbiAgdDEzICs9IHYgKiBiMTM7XG4gIHQxNCArPSB2ICogYjE0O1xuICB0MTUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMV07XG4gIHQxICs9IHYgKiBiMDtcbiAgdDIgKz0gdiAqIGIxO1xuICB0MyArPSB2ICogYjI7XG4gIHQ0ICs9IHYgKiBiMztcbiAgdDUgKz0gdiAqIGI0O1xuICB0NiArPSB2ICogYjU7XG4gIHQ3ICs9IHYgKiBiNjtcbiAgdDggKz0gdiAqIGI3O1xuICB0OSArPSB2ICogYjg7XG4gIHQxMCArPSB2ICogYjk7XG4gIHQxMSArPSB2ICogYjEwO1xuICB0MTIgKz0gdiAqIGIxMTtcbiAgdDEzICs9IHYgKiBiMTI7XG4gIHQxNCArPSB2ICogYjEzO1xuICB0MTUgKz0gdiAqIGIxNDtcbiAgdDE2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzJdO1xuICB0MiArPSB2ICogYjA7XG4gIHQzICs9IHYgKiBiMTtcbiAgdDQgKz0gdiAqIGIyO1xuICB0NSArPSB2ICogYjM7XG4gIHQ2ICs9IHYgKiBiNDtcbiAgdDcgKz0gdiAqIGI1O1xuICB0OCArPSB2ICogYjY7XG4gIHQ5ICs9IHYgKiBiNztcbiAgdDEwICs9IHYgKiBiODtcbiAgdDExICs9IHYgKiBiOTtcbiAgdDEyICs9IHYgKiBiMTA7XG4gIHQxMyArPSB2ICogYjExO1xuICB0MTQgKz0gdiAqIGIxMjtcbiAgdDE1ICs9IHYgKiBiMTM7XG4gIHQxNiArPSB2ICogYjE0O1xuICB0MTcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbM107XG4gIHQzICs9IHYgKiBiMDtcbiAgdDQgKz0gdiAqIGIxO1xuICB0NSArPSB2ICogYjI7XG4gIHQ2ICs9IHYgKiBiMztcbiAgdDcgKz0gdiAqIGI0O1xuICB0OCArPSB2ICogYjU7XG4gIHQ5ICs9IHYgKiBiNjtcbiAgdDEwICs9IHYgKiBiNztcbiAgdDExICs9IHYgKiBiODtcbiAgdDEyICs9IHYgKiBiOTtcbiAgdDEzICs9IHYgKiBiMTA7XG4gIHQxNCArPSB2ICogYjExO1xuICB0MTUgKz0gdiAqIGIxMjtcbiAgdDE2ICs9IHYgKiBiMTM7XG4gIHQxNyArPSB2ICogYjE0O1xuICB0MTggKz0gdiAqIGIxNTtcbiAgdiA9IGFbNF07XG4gIHQ0ICs9IHYgKiBiMDtcbiAgdDUgKz0gdiAqIGIxO1xuICB0NiArPSB2ICogYjI7XG4gIHQ3ICs9IHYgKiBiMztcbiAgdDggKz0gdiAqIGI0O1xuICB0OSArPSB2ICogYjU7XG4gIHQxMCArPSB2ICogYjY7XG4gIHQxMSArPSB2ICogYjc7XG4gIHQxMiArPSB2ICogYjg7XG4gIHQxMyArPSB2ICogYjk7XG4gIHQxNCArPSB2ICogYjEwO1xuICB0MTUgKz0gdiAqIGIxMTtcbiAgdDE2ICs9IHYgKiBiMTI7XG4gIHQxNyArPSB2ICogYjEzO1xuICB0MTggKz0gdiAqIGIxNDtcbiAgdDE5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzVdO1xuICB0NSArPSB2ICogYjA7XG4gIHQ2ICs9IHYgKiBiMTtcbiAgdDcgKz0gdiAqIGIyO1xuICB0OCArPSB2ICogYjM7XG4gIHQ5ICs9IHYgKiBiNDtcbiAgdDEwICs9IHYgKiBiNTtcbiAgdDExICs9IHYgKiBiNjtcbiAgdDEyICs9IHYgKiBiNztcbiAgdDEzICs9IHYgKiBiODtcbiAgdDE0ICs9IHYgKiBiOTtcbiAgdDE1ICs9IHYgKiBiMTA7XG4gIHQxNiArPSB2ICogYjExO1xuICB0MTcgKz0gdiAqIGIxMjtcbiAgdDE4ICs9IHYgKiBiMTM7XG4gIHQxOSArPSB2ICogYjE0O1xuICB0MjAgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNl07XG4gIHQ2ICs9IHYgKiBiMDtcbiAgdDcgKz0gdiAqIGIxO1xuICB0OCArPSB2ICogYjI7XG4gIHQ5ICs9IHYgKiBiMztcbiAgdDEwICs9IHYgKiBiNDtcbiAgdDExICs9IHYgKiBiNTtcbiAgdDEyICs9IHYgKiBiNjtcbiAgdDEzICs9IHYgKiBiNztcbiAgdDE0ICs9IHYgKiBiODtcbiAgdDE1ICs9IHYgKiBiOTtcbiAgdDE2ICs9IHYgKiBiMTA7XG4gIHQxNyArPSB2ICogYjExO1xuICB0MTggKz0gdiAqIGIxMjtcbiAgdDE5ICs9IHYgKiBiMTM7XG4gIHQyMCArPSB2ICogYjE0O1xuICB0MjEgKz0gdiAqIGIxNTtcbiAgdiA9IGFbN107XG4gIHQ3ICs9IHYgKiBiMDtcbiAgdDggKz0gdiAqIGIxO1xuICB0OSArPSB2ICogYjI7XG4gIHQxMCArPSB2ICogYjM7XG4gIHQxMSArPSB2ICogYjQ7XG4gIHQxMiArPSB2ICogYjU7XG4gIHQxMyArPSB2ICogYjY7XG4gIHQxNCArPSB2ICogYjc7XG4gIHQxNSArPSB2ICogYjg7XG4gIHQxNiArPSB2ICogYjk7XG4gIHQxNyArPSB2ICogYjEwO1xuICB0MTggKz0gdiAqIGIxMTtcbiAgdDE5ICs9IHYgKiBiMTI7XG4gIHQyMCArPSB2ICogYjEzO1xuICB0MjEgKz0gdiAqIGIxNDtcbiAgdDIyICs9IHYgKiBiMTU7XG4gIHYgPSBhWzhdO1xuICB0OCArPSB2ICogYjA7XG4gIHQ5ICs9IHYgKiBiMTtcbiAgdDEwICs9IHYgKiBiMjtcbiAgdDExICs9IHYgKiBiMztcbiAgdDEyICs9IHYgKiBiNDtcbiAgdDEzICs9IHYgKiBiNTtcbiAgdDE0ICs9IHYgKiBiNjtcbiAgdDE1ICs9IHYgKiBiNztcbiAgdDE2ICs9IHYgKiBiODtcbiAgdDE3ICs9IHYgKiBiOTtcbiAgdDE4ICs9IHYgKiBiMTA7XG4gIHQxOSArPSB2ICogYjExO1xuICB0MjAgKz0gdiAqIGIxMjtcbiAgdDIxICs9IHYgKiBiMTM7XG4gIHQyMiArPSB2ICogYjE0O1xuICB0MjMgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOV07XG4gIHQ5ICs9IHYgKiBiMDtcbiAgdDEwICs9IHYgKiBiMTtcbiAgdDExICs9IHYgKiBiMjtcbiAgdDEyICs9IHYgKiBiMztcbiAgdDEzICs9IHYgKiBiNDtcbiAgdDE0ICs9IHYgKiBiNTtcbiAgdDE1ICs9IHYgKiBiNjtcbiAgdDE2ICs9IHYgKiBiNztcbiAgdDE3ICs9IHYgKiBiODtcbiAgdDE4ICs9IHYgKiBiOTtcbiAgdDE5ICs9IHYgKiBiMTA7XG4gIHQyMCArPSB2ICogYjExO1xuICB0MjEgKz0gdiAqIGIxMjtcbiAgdDIyICs9IHYgKiBiMTM7XG4gIHQyMyArPSB2ICogYjE0O1xuICB0MjQgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTBdO1xuICB0MTAgKz0gdiAqIGIwO1xuICB0MTEgKz0gdiAqIGIxO1xuICB0MTIgKz0gdiAqIGIyO1xuICB0MTMgKz0gdiAqIGIzO1xuICB0MTQgKz0gdiAqIGI0O1xuICB0MTUgKz0gdiAqIGI1O1xuICB0MTYgKz0gdiAqIGI2O1xuICB0MTcgKz0gdiAqIGI3O1xuICB0MTggKz0gdiAqIGI4O1xuICB0MTkgKz0gdiAqIGI5O1xuICB0MjAgKz0gdiAqIGIxMDtcbiAgdDIxICs9IHYgKiBiMTE7XG4gIHQyMiArPSB2ICogYjEyO1xuICB0MjMgKz0gdiAqIGIxMztcbiAgdDI0ICs9IHYgKiBiMTQ7XG4gIHQyNSArPSB2ICogYjE1O1xuICB2ID0gYVsxMV07XG4gIHQxMSArPSB2ICogYjA7XG4gIHQxMiArPSB2ICogYjE7XG4gIHQxMyArPSB2ICogYjI7XG4gIHQxNCArPSB2ICogYjM7XG4gIHQxNSArPSB2ICogYjQ7XG4gIHQxNiArPSB2ICogYjU7XG4gIHQxNyArPSB2ICogYjY7XG4gIHQxOCArPSB2ICogYjc7XG4gIHQxOSArPSB2ICogYjg7XG4gIHQyMCArPSB2ICogYjk7XG4gIHQyMSArPSB2ICogYjEwO1xuICB0MjIgKz0gdiAqIGIxMTtcbiAgdDIzICs9IHYgKiBiMTI7XG4gIHQyNCArPSB2ICogYjEzO1xuICB0MjUgKz0gdiAqIGIxNDtcbiAgdDI2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEyXTtcbiAgdDEyICs9IHYgKiBiMDtcbiAgdDEzICs9IHYgKiBiMTtcbiAgdDE0ICs9IHYgKiBiMjtcbiAgdDE1ICs9IHYgKiBiMztcbiAgdDE2ICs9IHYgKiBiNDtcbiAgdDE3ICs9IHYgKiBiNTtcbiAgdDE4ICs9IHYgKiBiNjtcbiAgdDE5ICs9IHYgKiBiNztcbiAgdDIwICs9IHYgKiBiODtcbiAgdDIxICs9IHYgKiBiOTtcbiAgdDIyICs9IHYgKiBiMTA7XG4gIHQyMyArPSB2ICogYjExO1xuICB0MjQgKz0gdiAqIGIxMjtcbiAgdDI1ICs9IHYgKiBiMTM7XG4gIHQyNiArPSB2ICogYjE0O1xuICB0MjcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTNdO1xuICB0MTMgKz0gdiAqIGIwO1xuICB0MTQgKz0gdiAqIGIxO1xuICB0MTUgKz0gdiAqIGIyO1xuICB0MTYgKz0gdiAqIGIzO1xuICB0MTcgKz0gdiAqIGI0O1xuICB0MTggKz0gdiAqIGI1O1xuICB0MTkgKz0gdiAqIGI2O1xuICB0MjAgKz0gdiAqIGI3O1xuICB0MjEgKz0gdiAqIGI4O1xuICB0MjIgKz0gdiAqIGI5O1xuICB0MjMgKz0gdiAqIGIxMDtcbiAgdDI0ICs9IHYgKiBiMTE7XG4gIHQyNSArPSB2ICogYjEyO1xuICB0MjYgKz0gdiAqIGIxMztcbiAgdDI3ICs9IHYgKiBiMTQ7XG4gIHQyOCArPSB2ICogYjE1O1xuICB2ID0gYVsxNF07XG4gIHQxNCArPSB2ICogYjA7XG4gIHQxNSArPSB2ICogYjE7XG4gIHQxNiArPSB2ICogYjI7XG4gIHQxNyArPSB2ICogYjM7XG4gIHQxOCArPSB2ICogYjQ7XG4gIHQxOSArPSB2ICogYjU7XG4gIHQyMCArPSB2ICogYjY7XG4gIHQyMSArPSB2ICogYjc7XG4gIHQyMiArPSB2ICogYjg7XG4gIHQyMyArPSB2ICogYjk7XG4gIHQyNCArPSB2ICogYjEwO1xuICB0MjUgKz0gdiAqIGIxMTtcbiAgdDI2ICs9IHYgKiBiMTI7XG4gIHQyNyArPSB2ICogYjEzO1xuICB0MjggKz0gdiAqIGIxNDtcbiAgdDI5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE1XTtcbiAgdDE1ICs9IHYgKiBiMDtcbiAgdDE2ICs9IHYgKiBiMTtcbiAgdDE3ICs9IHYgKiBiMjtcbiAgdDE4ICs9IHYgKiBiMztcbiAgdDE5ICs9IHYgKiBiNDtcbiAgdDIwICs9IHYgKiBiNTtcbiAgdDIxICs9IHYgKiBiNjtcbiAgdDIyICs9IHYgKiBiNztcbiAgdDIzICs9IHYgKiBiODtcbiAgdDI0ICs9IHYgKiBiOTtcbiAgdDI1ICs9IHYgKiBiMTA7XG4gIHQyNiArPSB2ICogYjExO1xuICB0MjcgKz0gdiAqIGIxMjtcbiAgdDI4ICs9IHYgKiBiMTM7XG4gIHQyOSArPSB2ICogYjE0O1xuICB0MzAgKz0gdiAqIGIxNTtcblxuICB0MCAgKz0gMzggKiB0MTY7XG4gIHQxICArPSAzOCAqIHQxNztcbiAgdDIgICs9IDM4ICogdDE4O1xuICB0MyAgKz0gMzggKiB0MTk7XG4gIHQ0ICArPSAzOCAqIHQyMDtcbiAgdDUgICs9IDM4ICogdDIxO1xuICB0NiAgKz0gMzggKiB0MjI7XG4gIHQ3ICArPSAzOCAqIHQyMztcbiAgdDggICs9IDM4ICogdDI0O1xuICB0OSAgKz0gMzggKiB0MjU7XG4gIHQxMCArPSAzOCAqIHQyNjtcbiAgdDExICs9IDM4ICogdDI3O1xuICB0MTIgKz0gMzggKiB0Mjg7XG4gIHQxMyArPSAzOCAqIHQyOTtcbiAgdDE0ICs9IDM4ICogdDMwO1xuICAvLyB0MTUgbGVmdCBhcyBpc1xuXG4gIC8vIGZpcnN0IGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICAvLyBzZWNvbmQgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIG9bIDBdID0gdDA7XG4gIG9bIDFdID0gdDE7XG4gIG9bIDJdID0gdDI7XG4gIG9bIDNdID0gdDM7XG4gIG9bIDRdID0gdDQ7XG4gIG9bIDVdID0gdDU7XG4gIG9bIDZdID0gdDY7XG4gIG9bIDddID0gdDc7XG4gIG9bIDhdID0gdDg7XG4gIG9bIDldID0gdDk7XG4gIG9bMTBdID0gdDEwO1xuICBvWzExXSA9IHQxMTtcbiAgb1sxMl0gPSB0MTI7XG4gIG9bMTNdID0gdDEzO1xuICBvWzE0XSA9IHQxNDtcbiAgb1sxNV0gPSB0MTU7XG59XG5cbmZ1bmN0aW9uIFMobywgYSkge1xuICBNKG8sIGEsIGEpO1xufVxuXG5mdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUzOyBhID49IDA7IGEtLSkge1xuICAgIFMoYywgYyk7XG4gICAgaWYoYSAhPT0gMiAmJiBhICE9PSA0KSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUwOyBhID49IDA7IGEtLSkge1xuICAgICAgUyhjLCBjKTtcbiAgICAgIGlmKGEgIT09IDEpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoODApLCByLCBpO1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMTsgaSsrKSB6W2ldID0gbltpXTtcbiAgelszMV09KG5bMzFdJjEyNyl8NjQ7XG4gIHpbMF0mPTI0ODtcbiAgdW5wYWNrMjU1MTkoeCxwKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBiW2ldPXhbaV07XG4gICAgZFtpXT1hW2ldPWNbaV09MDtcbiAgfVxuICBhWzBdPWRbMF09MTtcbiAgZm9yIChpPTI1NDsgaT49MDsgLS1pKSB7XG4gICAgcj0oeltpPj4+M10+Pj4oaSY3KSkmMTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIEEoYyxiLGQpO1xuICAgIFooYixiLGQpO1xuICAgIFMoZCxlKTtcbiAgICBTKGYsYSk7XG4gICAgTShhLGMsYSk7XG4gICAgTShjLGIsZSk7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgUyhiLGEpO1xuICAgIFooYyxkLGYpO1xuICAgIE0oYSxjLF8xMjE2NjUpO1xuICAgIEEoYSxhLGQpO1xuICAgIE0oYyxjLGEpO1xuICAgIE0oYSxkLGYpO1xuICAgIE0oZCxiLHgpO1xuICAgIFMoYixlKTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgeFtpKzE2XT1hW2ldO1xuICAgIHhbaSszMl09Y1tpXTtcbiAgICB4W2krNDhdPWJbaV07XG4gICAgeFtpKzY0XT1kW2ldO1xuICB9XG4gIHZhciB4MzIgPSB4LnN1YmFycmF5KDMyKTtcbiAgdmFyIHgxNiA9IHguc3ViYXJyYXkoMTYpO1xuICBpbnYyNTUxOSh4MzIseDMyKTtcbiAgTSh4MTYseDE2LHgzMik7XG4gIHBhY2syNTUxOShxLHgxNik7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pIHtcbiAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIF85KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9rZXlwYWlyKHksIHgpIHtcbiAgcmFuZG9tYnl0ZXMoeCwgMzIpO1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHRfYmFzZSh5LCB4KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fc2NhbGFybXVsdChzLCB4LCB5KTtcbiAgcmV0dXJuIGNyeXB0b19jb3JlX2hzYWxzYTIwKGssIF8wLCBzLCBzaWdtYSk7XG59XG5cbnZhciBjcnlwdG9fYm94X2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94O1xudmFyIGNyeXB0b19ib3hfb3Blbl9hZnRlcm5tID0gY3J5cHRvX3NlY3JldGJveF9vcGVuO1xuXG5mdW5jdGlvbiBjcnlwdG9fYm94KGMsIG0sIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X2FmdGVybm0oYywgbSwgZCwgbiwgayk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfb3BlbihtLCBjLCBkLCBuLCB5LCB4KSB7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICByZXR1cm4gY3J5cHRvX2JveF9vcGVuX2FmdGVybm0obSwgYywgZCwgbiwgayk7XG59XG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG5mdW5jdGlvbiBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pIHtcbiAgdmFyIHdoID0gbmV3IEludDMyQXJyYXkoMTYpLCB3bCA9IG5ldyBJbnQzMkFycmF5KDE2KSxcbiAgICAgIGJoMCwgYmgxLCBiaDIsIGJoMywgYmg0LCBiaDUsIGJoNiwgYmg3LFxuICAgICAgYmwwLCBibDEsIGJsMiwgYmwzLCBibDQsIGJsNSwgYmw2LCBibDcsXG4gICAgICB0aCwgdGwsIGksIGosIGgsIGwsIGEsIGIsIGMsIGQ7XG5cbiAgdmFyIGFoMCA9IGhoWzBdLFxuICAgICAgYWgxID0gaGhbMV0sXG4gICAgICBhaDIgPSBoaFsyXSxcbiAgICAgIGFoMyA9IGhoWzNdLFxuICAgICAgYWg0ID0gaGhbNF0sXG4gICAgICBhaDUgPSBoaFs1XSxcbiAgICAgIGFoNiA9IGhoWzZdLFxuICAgICAgYWg3ID0gaGhbN10sXG5cbiAgICAgIGFsMCA9IGhsWzBdLFxuICAgICAgYWwxID0gaGxbMV0sXG4gICAgICBhbDIgPSBobFsyXSxcbiAgICAgIGFsMyA9IGhsWzNdLFxuICAgICAgYWw0ID0gaGxbNF0sXG4gICAgICBhbDUgPSBobFs1XSxcbiAgICAgIGFsNiA9IGhsWzZdLFxuICAgICAgYWw3ID0gaGxbN107XG5cbiAgdmFyIHBvcyA9IDA7XG4gIHdoaWxlIChuID49IDEyOCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBqID0gOCAqIGkgKyBwb3M7XG4gICAgICB3aFtpXSA9IChtW2orMF0gPDwgMjQpIHwgKG1baisxXSA8PCAxNikgfCAobVtqKzJdIDw8IDgpIHwgbVtqKzNdO1xuICAgICAgd2xbaV0gPSAobVtqKzRdIDw8IDI0KSB8IChtW2orNV0gPDwgMTYpIHwgKG1bais2XSA8PCA4KSB8IG1bais3XTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGJoMCA9IGFoMDtcbiAgICAgIGJoMSA9IGFoMTtcbiAgICAgIGJoMiA9IGFoMjtcbiAgICAgIGJoMyA9IGFoMztcbiAgICAgIGJoNCA9IGFoNDtcbiAgICAgIGJoNSA9IGFoNTtcbiAgICAgIGJoNiA9IGFoNjtcbiAgICAgIGJoNyA9IGFoNztcblxuICAgICAgYmwwID0gYWwwO1xuICAgICAgYmwxID0gYWwxO1xuICAgICAgYmwyID0gYWwyO1xuICAgICAgYmwzID0gYWwzO1xuICAgICAgYmw0ID0gYWw0O1xuICAgICAgYmw1ID0gYWw1O1xuICAgICAgYmw2ID0gYWw2O1xuICAgICAgYmw3ID0gYWw3O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBhaDc7XG4gICAgICBsID0gYWw3O1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWExXG4gICAgICBoID0gKChhaDQgPj4+IDE0KSB8IChhbDQgPDwgKDMyLTE0KSkpIF4gKChhaDQgPj4+IDE4KSB8IChhbDQgPDwgKDMyLTE4KSkpIF4gKChhbDQgPj4+ICg0MS0zMikpIHwgKGFoNCA8PCAoMzItKDQxLTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsNCA+Pj4gMTQpIHwgKGFoNCA8PCAoMzItMTQpKSkgXiAoKGFsNCA+Pj4gMTgpIHwgKGFoNCA8PCAoMzItMTgpKSkgXiAoKGFoNCA+Pj4gKDQxLTMyKSkgfCAoYWw0IDw8ICgzMi0oNDEtMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIENoXG4gICAgICBoID0gKGFoNCAmIGFoNSkgXiAofmFoNCAmIGFoNik7XG4gICAgICBsID0gKGFsNCAmIGFsNSkgXiAofmFsNCAmIGFsNik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gS1xuICAgICAgaCA9IEtbaSoyXTtcbiAgICAgIGwgPSBLW2kqMisxXTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyB3XG4gICAgICBoID0gd2hbaSUxNl07XG4gICAgICBsID0gd2xbaSUxNl07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICB0aCA9IGMgJiAweGZmZmYgfCBkIDw8IDE2O1xuICAgICAgdGwgPSBhICYgMHhmZmZmIHwgYiA8PCAxNjtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTBcbiAgICAgIGggPSAoKGFoMCA+Pj4gMjgpIHwgKGFsMCA8PCAoMzItMjgpKSkgXiAoKGFsMCA+Pj4gKDM0LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhbDAgPj4+ICgzOS0zMikpIHwgKGFoMCA8PCAoMzItKDM5LTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsMCA+Pj4gMjgpIHwgKGFoMCA8PCAoMzItMjgpKSkgXiAoKGFoMCA+Pj4gKDM0LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhaDAgPj4+ICgzOS0zMikpIHwgKGFsMCA8PCAoMzItKDM5LTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBNYWpcbiAgICAgIGggPSAoYWgwICYgYWgxKSBeIChhaDAgJiBhaDIpIF4gKGFoMSAmIGFoMik7XG4gICAgICBsID0gKGFsMCAmIGFsMSkgXiAoYWwwICYgYWwyKSBeIChhbDEgJiBhbDIpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBiaDM7XG4gICAgICBsID0gYmwzO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICBhaDEgPSBiaDA7XG4gICAgICBhaDIgPSBiaDE7XG4gICAgICBhaDMgPSBiaDI7XG4gICAgICBhaDQgPSBiaDM7XG4gICAgICBhaDUgPSBiaDQ7XG4gICAgICBhaDYgPSBiaDU7XG4gICAgICBhaDcgPSBiaDY7XG4gICAgICBhaDAgPSBiaDc7XG5cbiAgICAgIGFsMSA9IGJsMDtcbiAgICAgIGFsMiA9IGJsMTtcbiAgICAgIGFsMyA9IGJsMjtcbiAgICAgIGFsNCA9IGJsMztcbiAgICAgIGFsNSA9IGJsNDtcbiAgICAgIGFsNiA9IGJsNTtcbiAgICAgIGFsNyA9IGJsNjtcbiAgICAgIGFsMCA9IGJsNztcblxuICAgICAgaWYgKGklMTYgPT09IDE1KSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgaCA9IHdoW2pdO1xuICAgICAgICAgIGwgPSB3bFtqXTtcblxuICAgICAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgICAgIGggPSB3aFsoais5KSUxNl07XG4gICAgICAgICAgbCA9IHdsWyhqKzkpJTE2XTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTBcbiAgICAgICAgICB0aCA9IHdoWyhqKzEpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzEpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMSkgfCAodGwgPDwgKDMyLTEpKSkgXiAoKHRoID4+PiA4KSB8ICh0bCA8PCAoMzItOCkpKSBeICh0aCA+Pj4gNyk7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDEpIHwgKHRoIDw8ICgzMi0xKSkpIF4gKCh0bCA+Pj4gOCkgfCAodGggPDwgKDMyLTgpKSkgXiAoKHRsID4+PiA3KSB8ICh0aCA8PCAoMzItNykpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTFcbiAgICAgICAgICB0aCA9IHdoWyhqKzE0KSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxNCklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxOSkgfCAodGwgPDwgKDMyLTE5KSkpIF4gKCh0bCA+Pj4gKDYxLTMyKSkgfCAodGggPDwgKDMyLSg2MS0zMikpKSkgXiAodGggPj4+IDYpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxOSkgfCAodGggPDwgKDMyLTE5KSkpIF4gKCh0aCA+Pj4gKDYxLTMyKSkgfCAodGwgPDwgKDMyLSg2MS0zMikpKSkgXiAoKHRsID4+PiA2KSB8ICh0aCA8PCAoMzItNikpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgICAgIHdoW2pdID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgICAgIHdsW2pdID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkXG4gICAgaCA9IGFoMDtcbiAgICBsID0gYWwwO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzBdO1xuICAgIGwgPSBobFswXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzBdID0gYWgwID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzBdID0gYWwwID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMTtcbiAgICBsID0gYWwxO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzFdO1xuICAgIGwgPSBobFsxXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzFdID0gYWgxID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzFdID0gYWwxID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMjtcbiAgICBsID0gYWwyO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzJdO1xuICAgIGwgPSBobFsyXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzJdID0gYWgyID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzJdID0gYWwyID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMztcbiAgICBsID0gYWwzO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzNdO1xuICAgIGwgPSBobFszXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzNdID0gYWgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzNdID0gYWwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNDtcbiAgICBsID0gYWw0O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzRdO1xuICAgIGwgPSBobFs0XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzRdID0gYWg0ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzRdID0gYWw0ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNTtcbiAgICBsID0gYWw1O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzVdO1xuICAgIGwgPSBobFs1XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzVdID0gYWg1ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzVdID0gYWw1ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNjtcbiAgICBsID0gYWw2O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzZdO1xuICAgIGwgPSBobFs2XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzZdID0gYWg2ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzZdID0gYWw2ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNztcbiAgICBsID0gYWw3O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzddO1xuICAgIGwgPSBobFs3XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzddID0gYWg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzddID0gYWw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgcG9zICs9IDEyODtcbiAgICBuIC09IDEyODtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9faGFzaChvdXQsIG0sIG4pIHtcbiAgdmFyIGhoID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICBobCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgeCA9IG5ldyBVaW50OEFycmF5KDI1NiksXG4gICAgICBpLCBiID0gbjtcblxuICBoaFswXSA9IDB4NmEwOWU2Njc7XG4gIGhoWzFdID0gMHhiYjY3YWU4NTtcbiAgaGhbMl0gPSAweDNjNmVmMzcyO1xuICBoaFszXSA9IDB4YTU0ZmY1M2E7XG4gIGhoWzRdID0gMHg1MTBlNTI3ZjtcbiAgaGhbNV0gPSAweDliMDU2ODhjO1xuICBoaFs2XSA9IDB4MWY4M2Q5YWI7XG4gIGhoWzddID0gMHg1YmUwY2QxOTtcblxuICBobFswXSA9IDB4ZjNiY2M5MDg7XG4gIGhsWzFdID0gMHg4NGNhYTczYjtcbiAgaGxbMl0gPSAweGZlOTRmODJiO1xuICBobFszXSA9IDB4NWYxZDM2ZjE7XG4gIGhsWzRdID0gMHhhZGU2ODJkMTtcbiAgaGxbNV0gPSAweDJiM2U2YzFmO1xuICBobFs2XSA9IDB4ZmI0MWJkNmI7XG4gIGhsWzddID0gMHgxMzdlMjE3OTtcblxuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pO1xuICBuICU9IDEyODtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gbVtiLW4raV07XG4gIHhbbl0gPSAxMjg7XG5cbiAgbiA9IDI1Ni0xMjgqKG48MTEyPzE6MCk7XG4gIHhbbi05XSA9IDA7XG4gIHRzNjQoeCwgbi04LCAgKGIgLyAweDIwMDAwMDAwKSB8IDAsIGIgPDwgMyk7XG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgeCwgbik7XG5cbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgdHM2NChvdXQsIDgqaSwgaGhbaV0sIGhsW2ldKTtcblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWRkKHAsIHEpIHtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpLFxuICAgICAgZyA9IGdmKCksIGggPSBnZigpLCB0ID0gZ2YoKTtcblxuICBaKGEsIHBbMV0sIHBbMF0pO1xuICBaKHQsIHFbMV0sIHFbMF0pO1xuICBNKGEsIGEsIHQpO1xuICBBKGIsIHBbMF0sIHBbMV0pO1xuICBBKHQsIHFbMF0sIHFbMV0pO1xuICBNKGIsIGIsIHQpO1xuICBNKGMsIHBbM10sIHFbM10pO1xuICBNKGMsIGMsIEQyKTtcbiAgTShkLCBwWzJdLCBxWzJdKTtcbiAgQShkLCBkLCBkKTtcbiAgWihlLCBiLCBhKTtcbiAgWihmLCBkLCBjKTtcbiAgQShnLCBkLCBjKTtcbiAgQShoLCBiLCBhKTtcblxuICBNKHBbMF0sIGUsIGYpO1xuICBNKHBbMV0sIGgsIGcpO1xuICBNKHBbMl0sIGcsIGYpO1xuICBNKHBbM10sIGUsIGgpO1xufVxuXG5mdW5jdGlvbiBjc3dhcChwLCBxLCBiKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2VsMjU1MTkocFtpXSwgcVtpXSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gIHZhciB0eCA9IGdmKCksIHR5ID0gZ2YoKSwgemkgPSBnZigpO1xuICBpbnYyNTUxOSh6aSwgcFsyXSk7XG4gIE0odHgsIHBbMF0sIHppKTtcbiAgTSh0eSwgcFsxXSwgemkpO1xuICBwYWNrMjU1MTkociwgdHkpO1xuICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbn1cblxuZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gIHZhciBiLCBpO1xuICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICBzZXQyNTUxOShwWzFdLCBnZjEpO1xuICBzZXQyNTUxOShwWzJdLCBnZjEpO1xuICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICBmb3IgKGkgPSAyNTU7IGkgPj0gMDsgLS1pKSB7XG4gICAgYiA9IChzWyhpLzgpfDBdID4+IChpJjcpKSAmIDE7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gICAgYWRkKHEsIHApO1xuICAgIGFkZChwLCBwKTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgdmFyIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHNldDI1NTE5KHFbMF0sIFgpO1xuICBzZXQyNTUxOShxWzFdLCBZKTtcbiAgc2V0MjU1MTkocVsyXSwgZ2YxKTtcbiAgTShxWzNdLCBYLCBZKTtcbiAgc2NhbGFybXVsdChwLCBxLCBzKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHNlZWRlZCkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHZhciBpO1xuXG4gIGlmICghc2VlZGVkKSByYW5kb21ieXRlcyhzaywgMzIpO1xuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICBzY2FsYXJiYXNlKHAsIGQpO1xuICBwYWNrKHBrLCBwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaSszMl0gPSBwa1tpXTtcbiAgcmV0dXJuIDA7XG59XG5cbnZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbMHhlZCwgMHhkMywgMHhmNSwgMHg1YywgMHgxYSwgMHg2MywgMHgxMiwgMHg1OCwgMHhkNiwgMHg5YywgMHhmNywgMHhhMiwgMHhkZSwgMHhmOSwgMHhkZSwgMHgxNCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgxMF0pO1xuXG5mdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgdmFyIGNhcnJ5LCBpLCBqLCBrO1xuICBmb3IgKGkgPSA2MzsgaSA+PSAzMjsgLS1pKSB7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaiA9IGkgLSAzMiwgayA9IGkgLSAxMjsgaiA8IGs7ICsraikge1xuICAgICAgeFtqXSArPSBjYXJyeSAtIDE2ICogeFtpXSAqIExbaiAtIChpIC0gMzIpXTtcbiAgICAgIGNhcnJ5ID0gKHhbal0gKyAxMjgpID4+IDg7XG4gICAgICB4W2pdIC09IGNhcnJ5ICogMjU2O1xuICAgIH1cbiAgICB4W2pdICs9IGNhcnJ5O1xuICAgIHhbaV0gPSAwO1xuICB9XG4gIGNhcnJ5ID0gMDtcbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHtcbiAgICB4W2pdICs9IGNhcnJ5IC0gKHhbMzFdID4+IDQpICogTFtqXTtcbiAgICBjYXJyeSA9IHhbal0gPj4gODtcbiAgICB4W2pdICY9IDI1NTtcbiAgfVxuICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykgeFtqXSAtPSBjYXJyeSAqIExbal07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgeFtpKzFdICs9IHhbaV0gPj4gODtcbiAgICByW2ldID0geFtpXSAmIDI1NTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2Uocikge1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpLCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeFtpXSA9IHJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSByW2ldID0gMDtcbiAgbW9kTChyLCB4KTtcbn1cblxuLy8gTm90ZTogZGlmZmVyZW5jZSBmcm9tIEMgLSBzbWxlbiByZXR1cm5lZCwgbm90IHBhc3NlZCBhcyBhcmd1bWVudC5cbmZ1bmN0aW9uIGNyeXB0b19zaWduKHNtLCBtLCBuLCBzaykge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KSwgciA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIGksIGosIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgY3J5cHRvX2hhc2goZCwgc2ssIDMyKTtcbiAgZFswXSAmPSAyNDg7XG4gIGRbMzFdICY9IDEyNztcbiAgZFszMV0gfD0gNjQ7XG5cbiAgdmFyIHNtbGVuID0gbiArIDY0O1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBzbVs2NCArIGldID0gbVtpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHNtWzMyICsgaV0gPSBkWzMyICsgaV07XG5cbiAgY3J5cHRvX2hhc2gociwgc20uc3ViYXJyYXkoMzIpLCBuKzMyKTtcbiAgcmVkdWNlKHIpO1xuICBzY2FsYXJiYXNlKHAsIHIpO1xuICBwYWNrKHNtLCBwKTtcblxuICBmb3IgKGkgPSAzMjsgaSA8IDY0OyBpKyspIHNtW2ldID0gc2tbaV07XG4gIGNyeXB0b19oYXNoKGgsIHNtLCBuICsgNjQpO1xuICByZWR1Y2UoaCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgeFtpXSA9IHJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHtcbiAgICAgIHhbaStqXSArPSBoW2ldICogZFtqXTtcbiAgICB9XG4gIH1cblxuICBtb2RMKHNtLnN1YmFycmF5KDMyKSwgeCk7XG4gIHJldHVybiBzbWxlbjtcbn1cblxuZnVuY3Rpb24gdW5wYWNrbmVnKHIsIHApIHtcbiAgdmFyIHQgPSBnZigpLCBjaGsgPSBnZigpLCBudW0gPSBnZigpLFxuICAgICAgZGVuID0gZ2YoKSwgZGVuMiA9IGdmKCksIGRlbjQgPSBnZigpLFxuICAgICAgZGVuNiA9IGdmKCk7XG5cbiAgc2V0MjU1MTkoclsyXSwgZ2YxKTtcbiAgdW5wYWNrMjU1MTkoclsxXSwgcCk7XG4gIFMobnVtLCByWzFdKTtcbiAgTShkZW4sIG51bSwgRCk7XG4gIFoobnVtLCBudW0sIHJbMl0pO1xuICBBKGRlbiwgclsyXSwgZGVuKTtcblxuICBTKGRlbjIsIGRlbik7XG4gIFMoZGVuNCwgZGVuMik7XG4gIE0oZGVuNiwgZGVuNCwgZGVuMik7XG4gIE0odCwgZGVuNiwgbnVtKTtcbiAgTSh0LCB0LCBkZW4pO1xuXG4gIHBvdzI1MjModCwgdCk7XG4gIE0odCwgdCwgbnVtKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHQsIHQsIGRlbik7XG4gIE0oclswXSwgdCwgZGVuKTtcblxuICBTKGNoaywgclswXSk7XG4gIE0oY2hrLCBjaGssIGRlbik7XG4gIGlmIChuZXEyNTUxOShjaGssIG51bSkpIE0oclswXSwgclswXSwgSSk7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSByZXR1cm4gLTE7XG5cbiAgaWYgKHBhcjI1NTE5KHJbMF0pID09PSAocFszMV0+PjcpKSBaKHJbMF0sIGdmMCwgclswXSk7XG5cbiAgTShyWzNdLCByWzBdLCByWzFdKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX29wZW4obSwgc20sIG4sIHBrKSB7XG4gIHZhciBpLCBtbGVuO1xuICB2YXIgdCA9IG5ldyBVaW50OEFycmF5KDMyKSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV0sXG4gICAgICBxID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIG1sZW4gPSAtMTtcbiAgaWYgKG4gPCA2NCkgcmV0dXJuIC0xO1xuXG4gIGlmICh1bnBhY2tuZWcocSwgcGspKSByZXR1cm4gLTE7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgbVtpKzMyXSA9IHBrW2ldO1xuICBjcnlwdG9faGFzaChoLCBtLCBuKTtcbiAgcmVkdWNlKGgpO1xuICBzY2FsYXJtdWx0KHAsIHEsIGgpO1xuXG4gIHNjYWxhcmJhc2UocSwgc20uc3ViYXJyYXkoMzIpKTtcbiAgYWRkKHAsIHEpO1xuICBwYWNrKHQsIHApO1xuXG4gIG4gLT0gNjQ7XG4gIGlmIChjcnlwdG9fdmVyaWZ5XzMyKHNtLCAwLCB0LCAwKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1baV0gPSAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1baV0gPSBzbVtpICsgNjRdO1xuICBtbGVuID0gbjtcbiAgcmV0dXJuIG1sZW47XG59XG5cbnZhciBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTID0gMjQsXG4gICAgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyA9IDE2LFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfTk9OQ0VCWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbiAgICBjcnlwdG9fYm94X1pFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTLFxuICAgIGNyeXB0b19ib3hfQk9YWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsXG4gICAgY3J5cHRvX3NpZ25fQllURVMgPSA2NCxcbiAgICBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fU0VFREJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2hhc2hfQllURVMgPSA2NDtcblxubmFjbC5sb3dsZXZlbCA9IHtcbiAgY3J5cHRvX2NvcmVfaHNhbHNhMjA6IGNyeXB0b19jb3JlX2hzYWxzYTIwLFxuICBjcnlwdG9fc3RyZWFtX3hvcjogY3J5cHRvX3N0cmVhbV94b3IsXG4gIGNyeXB0b19zdHJlYW06IGNyeXB0b19zdHJlYW0sXG4gIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3I6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IsXG4gIGNyeXB0b19zdHJlYW1fc2Fsc2EyMDogY3J5cHRvX3N0cmVhbV9zYWxzYTIwLFxuICBjcnlwdG9fb25ldGltZWF1dGg6IGNyeXB0b19vbmV0aW1lYXV0aCxcbiAgY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeTogY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeSxcbiAgY3J5cHRvX3ZlcmlmeV8xNjogY3J5cHRvX3ZlcmlmeV8xNixcbiAgY3J5cHRvX3ZlcmlmeV8zMjogY3J5cHRvX3ZlcmlmeV8zMixcbiAgY3J5cHRvX3NlY3JldGJveDogY3J5cHRvX3NlY3JldGJveCxcbiAgY3J5cHRvX3NlY3JldGJveF9vcGVuOiBjcnlwdG9fc2VjcmV0Ym94X29wZW4sXG4gIGNyeXB0b19zY2FsYXJtdWx0OiBjcnlwdG9fc2NhbGFybXVsdCxcbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZTogY3J5cHRvX3NjYWxhcm11bHRfYmFzZSxcbiAgY3J5cHRvX2JveF9iZWZvcmVubTogY3J5cHRvX2JveF9iZWZvcmVubSxcbiAgY3J5cHRvX2JveF9hZnRlcm5tOiBjcnlwdG9fYm94X2FmdGVybm0sXG4gIGNyeXB0b19ib3g6IGNyeXB0b19ib3gsXG4gIGNyeXB0b19ib3hfb3BlbjogY3J5cHRvX2JveF9vcGVuLFxuICBjcnlwdG9fYm94X2tleXBhaXI6IGNyeXB0b19ib3hfa2V5cGFpcixcbiAgY3J5cHRvX2hhc2g6IGNyeXB0b19oYXNoLFxuICBjcnlwdG9fc2lnbjogY3J5cHRvX3NpZ24sXG4gIGNyeXB0b19zaWduX2tleXBhaXI6IGNyeXB0b19zaWduX2tleXBhaXIsXG4gIGNyeXB0b19zaWduX29wZW46IGNyeXB0b19zaWduX29wZW4sXG5cbiAgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUzogY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyxcbiAgY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyxcbiAgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVM6IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTLFxuICBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUzogY3J5cHRvX3NjYWxhcm11bHRfQllURVMsXG4gIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTOiBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUyxcbiAgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUzogY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyxcbiAgY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUzogY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyxcbiAgY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTOiBjcnlwdG9fYm94X0JFRk9SRU5NQllURVMsXG4gIGNyeXB0b19ib3hfTk9OQ0VCWVRFUzogY3J5cHRvX2JveF9OT05DRUJZVEVTLFxuICBjcnlwdG9fYm94X1pFUk9CWVRFUzogY3J5cHRvX2JveF9aRVJPQllURVMsXG4gIGNyeXB0b19ib3hfQk9YWkVST0JZVEVTOiBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUyxcbiAgY3J5cHRvX3NpZ25fQllURVM6IGNyeXB0b19zaWduX0JZVEVTLFxuICBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUzogY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMsXG4gIGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTOiBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyxcbiAgY3J5cHRvX3NpZ25fU0VFREJZVEVTOiBjcnlwdG9fc2lnbl9TRUVEQllURVMsXG4gIGNyeXB0b19oYXNoX0JZVEVTOiBjcnlwdG9faGFzaF9CWVRFU1xufTtcblxuLyogSGlnaC1sZXZlbCBBUEkgKi9cblxuZnVuY3Rpb24gY2hlY2tMZW5ndGhzKGssIG4pIHtcbiAgaWYgKGsubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBrZXkgc2l6ZScpO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbm9uY2Ugc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveExlbmd0aHMocGssIHNrKSB7XG4gIGlmIChway5sZW5ndGggIT09IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICBpZiAoc2subGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVzKCkge1xuICB2YXIgdCwgaTtcbiAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICBpZiAoKHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzW2ldKSkgIT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJylcbiAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmV4cGVjdGVkIHR5cGUgJyArIHQgKyAnLCB1c2UgVWludDhBcnJheScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFudXAoYXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnJbaV0gPSAwO1xufVxuXG4vLyBUT0RPOiBDb21wbGV0ZWx5IHJlbW92ZSB0aGlzIGluIHYwLjE1LlxuaWYgKCFuYWNsLnV0aWwpIHtcbiAgbmFjbC51dGlsID0ge307XG4gIG5hY2wudXRpbC5kZWNvZGVVVEY4ID0gbmFjbC51dGlsLmVuY29kZVVURjggPSBuYWNsLnV0aWwuZW5jb2RlQmFzZTY0ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NCA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbmFjbC51dGlsIG1vdmVkIGludG8gc2VwYXJhdGUgcGFja2FnZTogaHR0cHM6Ly9naXRodWIuY29tL2RjaGVzdC90d2VldG5hY2wtdXRpbC1qcycpO1xuICB9O1xufVxuXG5uYWNsLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obikge1xuICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG4pO1xuICByYW5kb21ieXRlcyhiLCBuKTtcbiAgcmV0dXJuIGI7XG59O1xuXG5uYWNsLnNlY3JldGJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgbVtpK2NyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTXSA9IG1zZ1tpXTtcbiAgY3J5cHRvX3NlY3JldGJveChjLCBtLCBtLmxlbmd0aCwgbm9uY2UsIGtleSk7XG4gIHJldHVybiBjLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94Lm9wZW4gPSBmdW5jdGlvbihib3gsIG5vbmNlLCBrZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKGJveCwgbm9uY2UsIGtleSk7XG4gIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyArIGJveC5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKyspIGNbaStjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFU10gPSBib3hbaV07XG4gIGlmIChjLmxlbmd0aCA8IDMyKSByZXR1cm4gZmFsc2U7XG4gIGlmIChjcnlwdG9fc2VjcmV0Ym94X29wZW4obSwgYywgYy5sZW5ndGgsIG5vbmNlLCBrZXkpICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBtLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94LmtleUxlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM7XG5uYWNsLnNlY3JldGJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUztcbm5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVM7XG5cbm5hY2wuc2NhbGFyTXVsdCA9IGZ1bmN0aW9uKG4sIHApIHtcbiAgY2hlY2tBcnJheVR5cGVzKG4sIHApO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgaWYgKHAubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcCBzaXplJyk7XG4gIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKTtcbiAgcmV0dXJuIHE7XG59O1xuXG5uYWNsLnNjYWxhck11bHQuYmFzZSA9IGZ1bmN0aW9uKG4pIHtcbiAgY2hlY2tBcnJheVR5cGVzKG4pO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgdmFyIHEgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbik7XG4gIHJldHVybiBxO1xufTtcblxubmFjbC5zY2FsYXJNdWx0LnNjYWxhckxlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTO1xubmFjbC5zY2FsYXJNdWx0Lmdyb3VwRWxlbWVudExlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTO1xuXG5uYWNsLmJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94KG1zZywgbm9uY2UsIGspO1xufTtcblxubmFjbC5ib3guYmVmb3JlID0gZnVuY3Rpb24ocHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgY2hlY2tCb3hMZW5ndGhzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X0JFRk9SRU5NQllURVMpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIGs7XG59O1xuXG5uYWNsLmJveC5hZnRlciA9IG5hY2wuc2VjcmV0Ym94O1xuXG5uYWNsLmJveC5vcGVuID0gZnVuY3Rpb24obXNnLCBub25jZSwgcHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgdmFyIGsgPSBuYWNsLmJveC5iZWZvcmUocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICByZXR1cm4gbmFjbC5zZWNyZXRib3gub3Blbihtc2csIG5vbmNlLCBrKTtcbn07XG5cbm5hY2wuYm94Lm9wZW4uYWZ0ZXIgPSBuYWNsLnNlY3JldGJveC5vcGVuO1xuXG5uYWNsLmJveC5rZXlQYWlyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX2JveF9rZXlwYWlyKHBrLCBzayk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkgPSBmdW5jdGlvbihzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlY3JldEtleSk7XG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShwaywgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IG5ldyBVaW50OEFycmF5KHNlY3JldEtleSl9O1xufTtcblxubmFjbC5ib3gucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUztcbm5hY2wuYm94LnNlY3JldEtleUxlbmd0aCA9IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM7XG5uYWNsLmJveC5zaGFyZWRLZXlMZW5ndGggPSBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM7XG5uYWNsLmJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19ib3hfTk9OQ0VCWVRFUztcbm5hY2wuYm94Lm92ZXJoZWFkTGVuZ3RoID0gbmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGg7XG5cbm5hY2wuc2lnbiA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNlY3JldEtleSk7XG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHNpZ25lZE1zZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTK21zZy5sZW5ndGgpO1xuICBjcnlwdG9fc2lnbihzaWduZWRNc2csIG1zZywgbXNnLmxlbmd0aCwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIHNpZ25lZE1zZztcbn07XG5cbm5hY2wuc2lnbi5vcGVuID0gZnVuY3Rpb24oc2lnbmVkTXNnLCBwdWJsaWNLZXkpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKCduYWNsLnNpZ24ub3BlbiBhY2NlcHRzIDIgYXJndW1lbnRzOyBkaWQgeW91IG1lYW4gdG8gdXNlIG5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnk/Jyk7XG4gIGNoZWNrQXJyYXlUeXBlcyhzaWduZWRNc2csIHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KHNpZ25lZE1zZy5sZW5ndGgpO1xuICB2YXIgbWxlbiA9IGNyeXB0b19zaWduX29wZW4odG1wLCBzaWduZWRNc2csIHNpZ25lZE1zZy5sZW5ndGgsIHB1YmxpY0tleSk7XG4gIGlmIChtbGVuIDwgMCkgcmV0dXJuIG51bGw7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkobWxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgbVtpXSA9IHRtcFtpXTtcbiAgcmV0dXJuIG07XG59O1xuXG5uYWNsLnNpZ24uZGV0YWNoZWQgPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICB2YXIgc2lnbmVkTXNnID0gbmFjbC5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAgdmFyIHNpZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspIHNpZ1tpXSA9IHNpZ25lZE1zZ1tpXTtcbiAgcmV0dXJuIHNpZztcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkgPSBmdW5jdGlvbihtc2csIHNpZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNpZywgcHVibGljS2V5KTtcbiAgaWYgKHNpZy5sZW5ndGggIT09IGNyeXB0b19zaWduX0JZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNpZ25hdHVyZSBzaXplJyk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHNtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGNyeXB0b19zaWduX0JZVEVTOyBpKyspIHNtW2ldID0gc2lnW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBzbVtpK2NyeXB0b19zaWduX0JZVEVTXSA9IG1zZ1tpXTtcbiAgcmV0dXJuIChjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBzbS5sZW5ndGgsIHB1YmxpY0tleSkgPj0gMCk7XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5zaWduLmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGsubGVuZ3RoOyBpKyspIHBrW2ldID0gc2VjcmV0S2V5WzMyK2ldO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KX07XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlZWQpO1xuICBpZiAoc2VlZC5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFRURCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWVkIHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaV0gPSBzZWVkW2ldO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgdHJ1ZSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM7XG5uYWNsLnNpZ24uc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM7XG5uYWNsLnNpZ24uc2VlZExlbmd0aCA9IGNyeXB0b19zaWduX1NFRURCWVRFUztcbm5hY2wuc2lnbi5zaWduYXR1cmVMZW5ndGggPSBjcnlwdG9fc2lnbl9CWVRFUztcblxubmFjbC5oYXNoID0gZnVuY3Rpb24obXNnKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2cpO1xuICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19oYXNoX0JZVEVTKTtcbiAgY3J5cHRvX2hhc2goaCwgbXNnLCBtc2cubGVuZ3RoKTtcbiAgcmV0dXJuIGg7XG59O1xuXG5uYWNsLmhhc2guaGFzaExlbmd0aCA9IGNyeXB0b19oYXNoX0JZVEVTO1xuXG5uYWNsLnZlcmlmeSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHgsIHkpO1xuICAvLyBaZXJvIGxlbmd0aCBhcmd1bWVudHMgYXJlIGNvbnNpZGVyZWQgbm90IGVxdWFsLlxuICBpZiAoeC5sZW5ndGggPT09IDAgfHwgeS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKHZuKHgsIDAsIHksIDAsIHgubGVuZ3RoKSA9PT0gMCkgPyB0cnVlIDogZmFsc2U7XG59O1xuXG5uYWNsLnNldFBSTkcgPSBmdW5jdGlvbihmbikge1xuICByYW5kb21ieXRlcyA9IGZuO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAvLyBJbml0aWFsaXplIFBSTkcgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgQ1NQUk5HLlxuICAvLyBJZiBub3QsIG1ldGhvZHMgY2FsbGluZyByYW5kb21ieXRlcyB3aWxsIHRocm93LlxuICB2YXIgY3J5cHRvID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gKHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG8pIDogbnVsbDtcbiAgaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gQnJvd3NlcnMuXG4gICAgdmFyIFFVT1RBID0gNjU1MzY7XG4gICAgbmFjbC5zZXRQUk5HKGZ1bmN0aW9uKHgsIG4pIHtcbiAgICAgIHZhciBpLCB2ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSBRVU9UQSkge1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHYuc3ViYXJyYXkoaSwgaSArIE1hdGgubWluKG4gLSBpLCBRVU9UQSkpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSB2W2ldO1xuICAgICAgY2xlYW51cCh2KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOb2RlLmpzLlxuICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgIGlmIChjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICB2YXIgaSwgdiA9IGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICAgIGNsZWFudXAodik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbn0pKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgOiAoc2VsZi5uYWNsID0gc2VsZi5uYWNsIHx8IHt9KSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3J5cHRvX2hhc2hfc2hhNTEyID0gcmVxdWlyZSgndHdlZXRuYWNsJykubG93bGV2ZWwuY3J5cHRvX2hhc2g7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaXMgYSAxOjEgcG9ydCBmcm9tIHRoZSBPcGVuQlNEIGJsb3dmaXNoLmMgYW5kIGJjcnlwdF9wYmtkZi5jLiBBcyBhXG4gKiByZXN1bHQsIGl0IHJldGFpbnMgdGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhbmQgbGljZW5zZS4gVGhlIHR3byBmaWxlcyBhcmVcbiAqIHVuZGVyIHNsaWdodGx5IGRpZmZlcmVudCAoYnV0IGNvbXBhdGlibGUpIGxpY2Vuc2VzLCBhbmQgYXJlIGhlcmUgY29tYmluZWQgaW5cbiAqIG9uZSBmaWxlLlxuICpcbiAqIENyZWRpdCBmb3IgdGhlIGFjdHVhbCBwb3J0aW5nIHdvcmsgZ29lcyB0bzpcbiAqICBEZXZpIE1hbmRpcmkgPG1lQGRldmkud2ViLmlkPlxuICovXG5cbi8qXG4gKiBUaGUgQmxvd2Zpc2ggcG9ydGlvbnMgYXJlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqXG4gKiBCbG93ZmlzaCBibG9jayBjaXBoZXIgZm9yIE9wZW5CU0RcbiAqIENvcHlyaWdodCAxOTk3IE5pZWxzIFByb3ZvcyA8cHJvdm9zQHBoeXNuZXQudW5pLWhhbWJ1cmcuZGU+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIEltcGxlbWVudGF0aW9uIGFkdmljZSBieSBEYXZpZCBNYXppZXJlcyA8ZG1AbGNzLm1pdC5lZHU+LlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogMy4gVGhlIG5hbWUgb2YgdGhlIGF1dGhvciBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gKiAgICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBBVVRIT1IgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTUyBPUlxuICogSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCxcbiAqIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAqIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLypcbiAqIFRoZSBiY3J5cHRfcGJrZGYgcG9ydGlvbnMgYXJlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGVkIFVuYW5nc3QgPHRlZHVAb3BlbmJzZC5vcmc+XG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqL1xuXG4vKlxuICogUGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzIChKYXZhc2NyaXB0LXNwZWNpZmljKTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNiwgSm95ZW50IEluY1xuICogQXV0aG9yOiBBbGV4IFdpbHNvbiA8YWxleC53aWxzb25Aam95ZW50LmNvbT5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICovXG5cbi8vIFBvcnRlZCBmcm9tIE9wZW5CU0QgYmNyeXB0X3Bia2RmLmMgdjEuOVxuXG52YXIgQkxGX0ogPSAwO1xuXG52YXIgQmxvd2Zpc2ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5TID0gW1xuICAgIG5ldyBVaW50MzJBcnJheShbXG4gICAgICAweGQxMzEwYmE2LCAweDk4ZGZiNWFjLCAweDJmZmQ3MmRiLCAweGQwMWFkZmI3LFxuICAgICAgMHhiOGUxYWZlZCwgMHg2YTI2N2U5NiwgMHhiYTdjOTA0NSwgMHhmMTJjN2Y5OSxcbiAgICAgIDB4MjRhMTk5NDcsIDB4YjM5MTZjZjcsIDB4MDgwMWYyZTIsIDB4ODU4ZWZjMTYsXG4gICAgICAweDYzNjkyMGQ4LCAweDcxNTc0ZTY5LCAweGE0NThmZWEzLCAweGY0OTMzZDdlLFxuICAgICAgMHgwZDk1NzQ4ZiwgMHg3MjhlYjY1OCwgMHg3MThiY2Q1OCwgMHg4MjE1NGFlZSxcbiAgICAgIDB4N2I1NGE0MWQsIDB4YzI1YTU5YjUsIDB4OWMzMGQ1MzksIDB4MmFmMjYwMTMsXG4gICAgICAweGM1ZDFiMDIzLCAweDI4NjA4NWYwLCAweGNhNDE3OTE4LCAweGI4ZGIzOGVmLFxuICAgICAgMHg4ZTc5ZGNiMCwgMHg2MDNhMTgwZSwgMHg2YzllMGU4YiwgMHhiMDFlOGEzZSxcbiAgICAgIDB4ZDcxNTc3YzEsIDB4YmQzMTRiMjcsIDB4NzhhZjJmZGEsIDB4NTU2MDVjNjAsXG4gICAgICAweGU2NTUyNWYzLCAweGFhNTVhYjk0LCAweDU3NDg5ODYyLCAweDYzZTgxNDQwLFxuICAgICAgMHg1NWNhMzk2YSwgMHgyYWFiMTBiNiwgMHhiNGNjNWMzNCwgMHgxMTQxZThjZSxcbiAgICAgIDB4YTE1NDg2YWYsIDB4N2M3MmU5OTMsIDB4YjNlZTE0MTEsIDB4NjM2ZmJjMmEsXG4gICAgICAweDJiYTljNTVkLCAweDc0MTgzMWY2LCAweGNlNWMzZTE2LCAweDliODc5MzFlLFxuICAgICAgMHhhZmQ2YmEzMywgMHg2YzI0Y2Y1YywgMHg3YTMyNTM4MSwgMHgyODk1ODY3NyxcbiAgICAgIDB4M2I4ZjQ4OTgsIDB4NmI0YmI5YWYsIDB4YzRiZmU4MWIsIDB4NjYyODIxOTMsXG4gICAgICAweDYxZDgwOWNjLCAweGZiMjFhOTkxLCAweDQ4N2NhYzYwLCAweDVkZWM4MDMyLFxuICAgICAgMHhlZjg0NWQ1ZCwgMHhlOTg1NzViMSwgMHhkYzI2MjMwMiwgMHhlYjY1MWI4OCxcbiAgICAgIDB4MjM4OTNlODEsIDB4ZDM5NmFjYzUsIDB4MGY2ZDZmZjMsIDB4ODNmNDQyMzksXG4gICAgICAweDJlMGI0NDgyLCAweGE0ODQyMDA0LCAweDY5YzhmMDRhLCAweDllMWY5YjVlLFxuICAgICAgMHgyMWM2Njg0MiwgMHhmNmU5NmM5YSwgMHg2NzBjOWM2MSwgMHhhYmQzODhmMCxcbiAgICAgIDB4NmE1MWEwZDIsIDB4ZDg1NDJmNjgsIDB4OTYwZmE3MjgsIDB4YWI1MTMzYTMsXG4gICAgICAweDZlZWYwYjZjLCAweDEzN2EzYmU0LCAweGJhM2JmMDUwLCAweDdlZmIyYTk4LFxuICAgICAgMHhhMWYxNjUxZCwgMHgzOWFmMDE3NiwgMHg2NmNhNTkzZSwgMHg4MjQzMGU4OCxcbiAgICAgIDB4OGNlZTg2MTksIDB4NDU2ZjlmYjQsIDB4N2Q4NGE1YzMsIDB4M2I4YjVlYmUsXG4gICAgICAweGUwNmY3NWQ4LCAweDg1YzEyMDczLCAweDQwMWE0NDlmLCAweDU2YzE2YWE2LFxuICAgICAgMHg0ZWQzYWE2MiwgMHgzNjNmNzcwNiwgMHgxYmZlZGY3MiwgMHg0MjliMDIzZCxcbiAgICAgIDB4MzdkMGQ3MjQsIDB4ZDAwYTEyNDgsIDB4ZGIwZmVhZDMsIDB4NDlmMWMwOWIsXG4gICAgICAweDA3NTM3MmM5LCAweDgwOTkxYjdiLCAweDI1ZDQ3OWQ4LCAweGY2ZThkZWY3LFxuICAgICAgMHhlM2ZlNTAxYSwgMHhiNjc5NGMzYiwgMHg5NzZjZTBiZCwgMHgwNGMwMDZiYSxcbiAgICAgIDB4YzFhOTRmYjYsIDB4NDA5ZjYwYzQsIDB4NWU1YzllYzIsIDB4MTk2YTI0NjMsXG4gICAgICAweDY4ZmI2ZmFmLCAweDNlNmM1M2I1LCAweDEzMzliMmViLCAweDNiNTJlYzZmLFxuICAgICAgMHg2ZGZjNTExZiwgMHg5YjMwOTUyYywgMHhjYzgxNDU0NCwgMHhhZjVlYmQwOSxcbiAgICAgIDB4YmVlM2QwMDQsIDB4ZGUzMzRhZmQsIDB4NjYwZjI4MDcsIDB4MTkyZTRiYjMsXG4gICAgICAweGMwY2JhODU3LCAweDQ1Yzg3NDBmLCAweGQyMGI1ZjM5LCAweGI5ZDNmYmRiLFxuICAgICAgMHg1NTc5YzBiZCwgMHgxYTYwMzIwYSwgMHhkNmExMDBjNiwgMHg0MDJjNzI3OSxcbiAgICAgIDB4Njc5ZjI1ZmUsIDB4ZmIxZmEzY2MsIDB4OGVhNWU5ZjgsIDB4ZGIzMjIyZjgsXG4gICAgICAweDNjNzUxNmRmLCAweGZkNjE2YjE1LCAweDJmNTAxZWM4LCAweGFkMDU1MmFiLFxuICAgICAgMHgzMjNkYjVmYSwgMHhmZDIzODc2MCwgMHg1MzMxN2I0OCwgMHgzZTAwZGY4MixcbiAgICAgIDB4OWU1YzU3YmIsIDB4Y2E2ZjhjYTAsIDB4MWE4NzU2MmUsIDB4ZGYxNzY5ZGIsXG4gICAgICAweGQ1NDJhOGY2LCAweDI4N2VmZmMzLCAweGFjNjczMmM2LCAweDhjNGY1NTczLFxuICAgICAgMHg2OTViMjdiMCwgMHhiYmNhNThjOCwgMHhlMWZmYTM1ZCwgMHhiOGYwMTFhMCxcbiAgICAgIDB4MTBmYTNkOTgsIDB4ZmQyMTgzYjgsIDB4NGFmY2I1NmMsIDB4MmRkMWQzNWIsXG4gICAgICAweDlhNTNlNDc5LCAweGI2Zjg0NTY1LCAweGQyOGU0OWJjLCAweDRiZmI5NzkwLFxuICAgICAgMHhlMWRkZjJkYSwgMHhhNGNiN2UzMywgMHg2MmZiMTM0MSwgMHhjZWU0YzZlOCxcbiAgICAgIDB4ZWYyMGNhZGEsIDB4MzY3NzRjMDEsIDB4ZDA3ZTllZmUsIDB4MmJmMTFmYjQsXG4gICAgICAweDk1ZGJkYTRkLCAweGFlOTA5MTk4LCAweGVhYWQ4ZTcxLCAweDZiOTNkNWEwLFxuICAgICAgMHhkMDhlZDFkMCwgMHhhZmM3MjVlMCwgMHg4ZTNjNWIyZiwgMHg4ZTc1OTRiNyxcbiAgICAgIDB4OGZmNmUyZmIsIDB4ZjIxMjJiNjQsIDB4ODg4OGI4MTIsIDB4OTAwZGYwMWMsXG4gICAgICAweDRmYWQ1ZWEwLCAweDY4OGZjMzFjLCAweGQxY2ZmMTkxLCAweGIzYThjMWFkLFxuICAgICAgMHgyZjJmMjIxOCwgMHhiZTBlMTc3NywgMHhlYTc1MmRmZSwgMHg4YjAyMWZhMSxcbiAgICAgIDB4ZTVhMGNjMGYsIDB4YjU2Zjc0ZTgsIDB4MThhY2YzZDYsIDB4Y2U4OWUyOTksXG4gICAgICAweGI0YTg0ZmUwLCAweGZkMTNlMGI3LCAweDdjYzQzYjgxLCAweGQyYWRhOGQ5LFxuICAgICAgMHgxNjVmYTI2NiwgMHg4MDk1NzcwNSwgMHg5M2NjNzMxNCwgMHgyMTFhMTQ3NyxcbiAgICAgIDB4ZTZhZDIwNjUsIDB4NzdiNWZhODYsIDB4Yzc1NDQyZjUsIDB4ZmI5ZDM1Y2YsXG4gICAgICAweGViY2RhZjBjLCAweDdiM2U4OWEwLCAweGQ2NDExYmQzLCAweGFlMWU3ZTQ5LFxuICAgICAgMHgwMDI1MGUyZCwgMHgyMDcxYjM1ZSwgMHgyMjY4MDBiYiwgMHg1N2I4ZTBhZixcbiAgICAgIDB4MjQ2NDM2OWIsIDB4ZjAwOWI5MWUsIDB4NTU2MzkxMWQsIDB4NTlkZmE2YWEsXG4gICAgICAweDc4YzE0Mzg5LCAweGQ5NWE1MzdmLCAweDIwN2Q1YmEyLCAweDAyZTViOWM1LFxuICAgICAgMHg4MzI2MDM3NiwgMHg2Mjk1Y2ZhOSwgMHgxMWM4MTk2OCwgMHg0ZTczNGE0MSxcbiAgICAgIDB4YjM0NzJkY2EsIDB4N2IxNGE5NGEsIDB4MWI1MTAwNTIsIDB4OWE1MzI5MTUsXG4gICAgICAweGQ2MGY1NzNmLCAweGJjOWJjNmU0LCAweDJiNjBhNDc2LCAweDgxZTY3NDAwLFxuICAgICAgMHgwOGJhNmZiNSwgMHg1NzFiZTkxZiwgMHhmMjk2ZWM2YiwgMHgyYTBkZDkxNSxcbiAgICAgIDB4YjY2MzY1MjEsIDB4ZTdiOWY5YjYsIDB4ZmYzNDA1MmUsIDB4YzU4NTU2NjQsXG4gICAgICAweDUzYjAyZDVkLCAweGE5OWY4ZmExLCAweDA4YmE0Nzk5LCAweDZlODUwNzZhXSksXG4gICAgbmV3IFVpbnQzMkFycmF5KFtcbiAgICAgIDB4NGI3YTcwZTksIDB4YjViMzI5NDQsIDB4ZGI3NTA5MmUsIDB4YzQxOTI2MjMsXG4gICAgICAweGFkNmVhNmIwLCAweDQ5YTdkZjdkLCAweDljZWU2MGI4LCAweDhmZWRiMjY2LFxuICAgICAgMHhlY2FhOGM3MSwgMHg2OTlhMTdmZiwgMHg1NjY0NTI2YywgMHhjMmIxOWVlMSxcbiAgICAgIDB4MTkzNjAyYTUsIDB4NzUwOTRjMjksIDB4YTA1OTEzNDAsIDB4ZTQxODNhM2UsXG4gICAgICAweDNmNTQ5ODlhLCAweDViNDI5ZDY1LCAweDZiOGZlNGQ2LCAweDk5ZjczZmQ2LFxuICAgICAgMHhhMWQyOWMwNywgMHhlZmU4MzBmNSwgMHg0ZDJkMzhlNiwgMHhmMDI1NWRjMSxcbiAgICAgIDB4NGNkZDIwODYsIDB4ODQ3MGViMjYsIDB4NjM4MmU5YzYsIDB4MDIxZWNjNWUsXG4gICAgICAweDA5Njg2YjNmLCAweDNlYmFlZmM5LCAweDNjOTcxODE0LCAweDZiNmE3MGExLFxuICAgICAgMHg2ODdmMzU4NCwgMHg1MmEwZTI4NiwgMHhiNzljNTMwNSwgMHhhYTUwMDczNyxcbiAgICAgIDB4M2UwNzg0MWMsIDB4N2ZkZWFlNWMsIDB4OGU3ZDQ0ZWMsIDB4NTcxNmYyYjgsXG4gICAgICAweGIwM2FkYTM3LCAweGYwNTAwYzBkLCAweGYwMWMxZjA0LCAweDAyMDBiM2ZmLFxuICAgICAgMHhhZTBjZjUxYSwgMHgzY2I1NzRiMiwgMHgyNTgzN2E1OCwgMHhkYzA5MjFiZCxcbiAgICAgIDB4ZDE5MTEzZjksIDB4N2NhOTJmZjYsIDB4OTQzMjQ3NzMsIDB4MjJmNTQ3MDEsXG4gICAgICAweDNhZTVlNTgxLCAweDM3YzJkYWRjLCAweGM4YjU3NjM0LCAweDlhZjNkZGE3LFxuICAgICAgMHhhOTQ0NjE0NiwgMHgwZmQwMDMwZSwgMHhlY2M4YzczZSwgMHhhNDc1MWU0MSxcbiAgICAgIDB4ZTIzOGNkOTksIDB4M2JlYTBlMmYsIDB4MzI4MGJiYTEsIDB4MTgzZWIzMzEsXG4gICAgICAweDRlNTQ4YjM4LCAweDRmNmRiOTA4LCAweDZmNDIwZDAzLCAweGY2MGEwNGJmLFxuICAgICAgMHgyY2I4MTI5MCwgMHgyNDk3N2M3OSwgMHg1Njc5YjA3MiwgMHhiY2FmODlhZixcbiAgICAgIDB4ZGU5YTc3MWYsIDB4ZDk5MzA4MTAsIDB4YjM4YmFlMTIsIDB4ZGNjZjNmMmUsXG4gICAgICAweDU1MTI3MjFmLCAweDJlNmI3MTI0LCAweDUwMWFkZGU2LCAweDlmODRjZDg3LFxuICAgICAgMHg3YTU4NDcxOCwgMHg3NDA4ZGExNywgMHhiYzlmOWFiYywgMHhlOTRiN2Q4YyxcbiAgICAgIDB4ZWM3YWVjM2EsIDB4ZGI4NTFkZmEsIDB4NjMwOTQzNjYsIDB4YzQ2NGMzZDIsXG4gICAgICAweGVmMWMxODQ3LCAweDMyMTVkOTA4LCAweGRkNDMzYjM3LCAweDI0YzJiYTE2LFxuICAgICAgMHgxMmExNGQ0MywgMHgyYTY1YzQ1MSwgMHg1MDk0MDAwMiwgMHgxMzNhZTRkZCxcbiAgICAgIDB4NzFkZmY4OWUsIDB4MTAzMTRlNTUsIDB4ODFhYzc3ZDYsIDB4NWYxMTE5OWIsXG4gICAgICAweDA0MzU1NmYxLCAweGQ3YTNjNzZiLCAweDNjMTExODNiLCAweDU5MjRhNTA5LFxuICAgICAgMHhmMjhmZTZlZCwgMHg5N2YxZmJmYSwgMHg5ZWJhYmYyYywgMHgxZTE1M2M2ZSxcbiAgICAgIDB4ODZlMzQ1NzAsIDB4ZWFlOTZmYjEsIDB4ODYwZTVlMGEsIDB4NWEzZTJhYjMsXG4gICAgICAweDc3MWZlNzFjLCAweDRlM2QwNmZhLCAweDI5NjVkY2I5LCAweDk5ZTcxZDBmLFxuICAgICAgMHg4MDNlODlkNiwgMHg1MjY2YzgyNSwgMHgyZTRjYzk3OCwgMHg5YzEwYjM2YSxcbiAgICAgIDB4YzYxNTBlYmEsIDB4OTRlMmVhNzgsIDB4YTVmYzNjNTMsIDB4MWUwYTJkZjQsXG4gICAgICAweGYyZjc0ZWE3LCAweDM2MWQyYjNkLCAweDE5MzkyNjBmLCAweDE5YzI3OTYwLFxuICAgICAgMHg1MjIzYTcwOCwgMHhmNzEzMTJiNiwgMHhlYmFkZmU2ZSwgMHhlYWMzMWY2NixcbiAgICAgIDB4ZTNiYzQ1OTUsIDB4YTY3YmM4ODMsIDB4YjE3ZjM3ZDEsIDB4MDE4Y2ZmMjgsXG4gICAgICAweGMzMzJkZGVmLCAweGJlNmM1YWE1LCAweDY1NTgyMTg1LCAweDY4YWI5ODAyLFxuICAgICAgMHhlZWNlYTUwZiwgMHhkYjJmOTUzYiwgMHgyYWVmN2RhZCwgMHg1YjZlMmY4NCxcbiAgICAgIDB4MTUyMWI2MjgsIDB4MjkwNzYxNzAsIDB4ZWNkZDQ3NzUsIDB4NjE5ZjE1MTAsXG4gICAgICAweDEzY2NhODMwLCAweGViNjFiZDk2LCAweDAzMzRmZTFlLCAweGFhMDM2M2NmLFxuICAgICAgMHhiNTczNWM5MCwgMHg0YzcwYTIzOSwgMHhkNTllOWUwYiwgMHhjYmFhZGUxNCxcbiAgICAgIDB4ZWVjYzg2YmMsIDB4NjA2MjJjYTcsIDB4OWNhYjVjYWIsIDB4YjJmMzg0NmUsXG4gICAgICAweDY0OGIxZWFmLCAweDE5YmRmMGNhLCAweGEwMjM2OWI5LCAweDY1NWFiYjUwLFxuICAgICAgMHg0MDY4NWEzMiwgMHgzYzJhYjRiMywgMHgzMTllZTlkNSwgMHhjMDIxYjhmNyxcbiAgICAgIDB4OWI1NDBiMTksIDB4ODc1ZmEwOTksIDB4OTVmNzk5N2UsIDB4NjIzZDdkYTgsXG4gICAgICAweGY4Mzc4ODlhLCAweDk3ZTMyZDc3LCAweDExZWQ5MzVmLCAweDE2NjgxMjgxLFxuICAgICAgMHgwZTM1ODgyOSwgMHhjN2U2MWZkNiwgMHg5NmRlZGZhMSwgMHg3ODU4YmE5OSxcbiAgICAgIDB4NTdmNTg0YTUsIDB4MWIyMjcyNjMsIDB4OWI4M2MzZmYsIDB4MWFjMjQ2OTYsXG4gICAgICAweGNkYjMwYWViLCAweDUzMmUzMDU0LCAweDhmZDk0OGU0LCAweDZkYmMzMTI4LFxuICAgICAgMHg1OGViZjJlZiwgMHgzNGM2ZmZlYSwgMHhmZTI4ZWQ2MSwgMHhlZTdjM2M3MyxcbiAgICAgIDB4NWQ0YTE0ZDksIDB4ZTg2NGI3ZTMsIDB4NDIxMDVkMTQsIDB4MjAzZTEzZTAsXG4gICAgICAweDQ1ZWVlMmI2LCAweGEzYWFhYmVhLCAweGRiNmM0ZjE1LCAweGZhY2I0ZmQwLFxuICAgICAgMHhjNzQyZjQ0MiwgMHhlZjZhYmJiNSwgMHg2NTRmM2IxZCwgMHg0MWNkMjEwNSxcbiAgICAgIDB4ZDgxZTc5OWUsIDB4ODY4NTRkYzcsIDB4ZTQ0YjQ3NmEsIDB4M2Q4MTYyNTAsXG4gICAgICAweGNmNjJhMWYyLCAweDViOGQyNjQ2LCAweGZjODg4M2EwLCAweGMxYzdiNmEzLFxuICAgICAgMHg3ZjE1MjRjMywgMHg2OWNiNzQ5MiwgMHg0Nzg0OGEwYiwgMHg1NjkyYjI4NSxcbiAgICAgIDB4MDk1YmJmMDAsIDB4YWQxOTQ4OWQsIDB4MTQ2MmIxNzQsIDB4MjM4MjBlMDAsXG4gICAgICAweDU4NDI4ZDJhLCAweDBjNTVmNWVhLCAweDFkYWRmNDNlLCAweDIzM2Y3MDYxLFxuICAgICAgMHgzMzcyZjA5MiwgMHg4ZDkzN2U0MSwgMHhkNjVmZWNmMSwgMHg2YzIyM2JkYixcbiAgICAgIDB4N2NkZTM3NTksIDB4Y2JlZTc0NjAsIDB4NDA4NWYyYTcsIDB4Y2U3NzMyNmUsXG4gICAgICAweGE2MDc4MDg0LCAweDE5Zjg1MDllLCAweGU4ZWZkODU1LCAweDYxZDk5NzM1LFxuICAgICAgMHhhOTY5YTdhYSwgMHhjNTBjMDZjMiwgMHg1YTA0YWJmYywgMHg4MDBiY2FkYyxcbiAgICAgIDB4OWU0NDdhMmUsIDB4YzM0NTM0ODQsIDB4ZmRkNTY3MDUsIDB4MGUxZTllYzksXG4gICAgICAweGRiNzNkYmQzLCAweDEwNTU4OGNkLCAweDY3NWZkYTc5LCAweGUzNjc0MzQwLFxuICAgICAgMHhjNWM0MzQ2NSwgMHg3MTNlMzhkOCwgMHgzZDI4Zjg5ZSwgMHhmMTZkZmYyMCxcbiAgICAgIDB4MTUzZTIxZTcsIDB4OGZiMDNkNGEsIDB4ZTZlMzlmMmIsIDB4ZGI4M2FkZjddKSxcbiAgICBuZXcgVWludDMyQXJyYXkoW1xuICAgICAgMHhlOTNkNWE2OCwgMHg5NDgxNDBmNywgMHhmNjRjMjYxYywgMHg5NDY5MjkzNCxcbiAgICAgIDB4NDExNTIwZjcsIDB4NzYwMmQ0ZjcsIDB4YmNmNDZiMmUsIDB4ZDRhMjAwNjgsXG4gICAgICAweGQ0MDgyNDcxLCAweDMzMjBmNDZhLCAweDQzYjdkNGI3LCAweDUwMDA2MWFmLFxuICAgICAgMHgxZTM5ZjYyZSwgMHg5NzI0NDU0NiwgMHgxNDIxNGY3NCwgMHhiZjhiODg0MCxcbiAgICAgIDB4NGQ5NWZjMWQsIDB4OTZiNTkxYWYsIDB4NzBmNGRkZDMsIDB4NjZhMDJmNDUsXG4gICAgICAweGJmYmMwOWVjLCAweDAzYmQ5Nzg1LCAweDdmYWM2ZGQwLCAweDMxY2I4NTA0LFxuICAgICAgMHg5NmViMjdiMywgMHg1NWZkMzk0MSwgMHhkYTI1NDdlNiwgMHhhYmNhMGE5YSxcbiAgICAgIDB4Mjg1MDc4MjUsIDB4NTMwNDI5ZjQsIDB4MGEyYzg2ZGEsIDB4ZTliNjZkZmIsXG4gICAgICAweDY4ZGMxNDYyLCAweGQ3NDg2OTAwLCAweDY4MGVjMGE0LCAweDI3YTE4ZGVlLFxuICAgICAgMHg0ZjNmZmVhMiwgMHhlODg3YWQ4YywgMHhiNThjZTAwNiwgMHg3YWY0ZDZiNixcbiAgICAgIDB4YWFjZTFlN2MsIDB4ZDMzNzVmZWMsIDB4Y2U3OGEzOTksIDB4NDA2YjJhNDIsXG4gICAgICAweDIwZmU5ZTM1LCAweGQ5ZjM4NWI5LCAweGVlMzlkN2FiLCAweDNiMTI0ZThiLFxuICAgICAgMHgxZGM5ZmFmNywgMHg0YjZkMTg1NiwgMHgyNmEzNjYzMSwgMHhlYWUzOTdiMixcbiAgICAgIDB4M2E2ZWZhNzQsIDB4ZGQ1YjQzMzIsIDB4Njg0MWU3ZjcsIDB4Y2E3ODIwZmIsXG4gICAgICAweGZiMGFmNTRlLCAweGQ4ZmViMzk3LCAweDQ1NDA1NmFjLCAweGJhNDg5NTI3LFxuICAgICAgMHg1NTUzM2EzYSwgMHgyMDgzOGQ4NywgMHhmZTZiYTliNywgMHhkMDk2OTU0YixcbiAgICAgIDB4NTVhODY3YmMsIDB4YTExNTlhNTgsIDB4Y2NhOTI5NjMsIDB4OTllMWRiMzMsXG4gICAgICAweGE2MmE0YTU2LCAweDNmMzEyNWY5LCAweDVlZjQ3ZTFjLCAweDkwMjkzMTdjLFxuICAgICAgMHhmZGY4ZTgwMiwgMHgwNDI3MmY3MCwgMHg4MGJiMTU1YywgMHgwNTI4MmNlMyxcbiAgICAgIDB4OTVjMTE1NDgsIDB4ZTRjNjZkMjIsIDB4NDhjMTEzM2YsIDB4YzcwZjg2ZGMsXG4gICAgICAweDA3ZjljOWVlLCAweDQxMDQxZjBmLCAweDQwNDc3OWE0LCAweDVkODg2ZTE3LFxuICAgICAgMHgzMjVmNTFlYiwgMHhkNTliYzBkMSwgMHhmMmJjYzE4ZiwgMHg0MTExMzU2NCxcbiAgICAgIDB4MjU3Yjc4MzQsIDB4NjAyYTljNjAsIDB4ZGZmOGU4YTMsIDB4MWY2MzZjMWIsXG4gICAgICAweDBlMTJiNGMyLCAweDAyZTEzMjllLCAweGFmNjY0ZmQxLCAweGNhZDE4MTE1LFxuICAgICAgMHg2YjIzOTVlMCwgMHgzMzNlOTJlMSwgMHgzYjI0MGI2MiwgMHhlZWJlYjkyMixcbiAgICAgIDB4ODViMmEyMGUsIDB4ZTZiYTBkOTksIDB4ZGU3MjBjOGMsIDB4MmRhMmY3MjgsXG4gICAgICAweGQwMTI3ODQ1LCAweDk1Yjc5NGZkLCAweDY0N2QwODYyLCAweGU3Y2NmNWYwLFxuICAgICAgMHg1NDQ5YTM2ZiwgMHg4NzdkNDhmYSwgMHhjMzlkZmQyNywgMHhmMzNlOGQxZSxcbiAgICAgIDB4MGE0NzYzNDEsIDB4OTkyZWZmNzQsIDB4M2E2ZjZlYWIsIDB4ZjRmOGZkMzcsXG4gICAgICAweGE4MTJkYzYwLCAweGExZWJkZGY4LCAweDk5MWJlMTRjLCAweGRiNmU2YjBkLFxuICAgICAgMHhjNjdiNTUxMCwgMHg2ZDY3MmMzNywgMHgyNzY1ZDQzYiwgMHhkY2QwZTgwNCxcbiAgICAgIDB4ZjEyOTBkYzcsIDB4Y2MwMGZmYTMsIDB4YjUzOTBmOTIsIDB4NjkwZmVkMGIsXG4gICAgICAweDY2N2I5ZmZiLCAweGNlZGI3ZDljLCAweGEwOTFjZjBiLCAweGQ5MTU1ZWEzLFxuICAgICAgMHhiYjEzMmY4OCwgMHg1MTViYWQyNCwgMHg3Yjk0NzliZiwgMHg3NjNiZDZlYixcbiAgICAgIDB4MzczOTJlYjMsIDB4Y2MxMTU5NzksIDB4ODAyNmUyOTcsIDB4ZjQyZTMxMmQsXG4gICAgICAweDY4NDJhZGE3LCAweGM2NmEyYjNiLCAweDEyNzU0Y2NjLCAweDc4MmVmMTFjLFxuICAgICAgMHg2YTEyNDIzNywgMHhiNzkyNTFlNywgMHgwNmExYmJlNiwgMHg0YmZiNjM1MCxcbiAgICAgIDB4MWE2YjEwMTgsIDB4MTFjYWVkZmEsIDB4M2QyNWJkZDgsIDB4ZTJlMWMzYzksXG4gICAgICAweDQ0NDIxNjU5LCAweDBhMTIxMzg2LCAweGQ5MGNlYzZlLCAweGQ1YWJlYTJhLFxuICAgICAgMHg2NGFmNjc0ZSwgMHhkYTg2YTg1ZiwgMHhiZWJmZTk4OCwgMHg2NGU0YzNmZSxcbiAgICAgIDB4OWRiYzgwNTcsIDB4ZjBmN2MwODYsIDB4NjA3ODdiZjgsIDB4NjAwMzYwNGQsXG4gICAgICAweGQxZmQ4MzQ2LCAweGY2MzgxZmIwLCAweDc3NDVhZTA0LCAweGQ3MzZmY2NjLFxuICAgICAgMHg4MzQyNmIzMywgMHhmMDFlYWI3MSwgMHhiMDgwNDE4NywgMHgzYzAwNWU1ZixcbiAgICAgIDB4NzdhMDU3YmUsIDB4YmRlOGFlMjQsIDB4NTU0NjQyOTksIDB4YmY1ODJlNjEsXG4gICAgICAweDRlNThmNDhmLCAweGYyZGRmZGEyLCAweGY0NzRlZjM4LCAweDg3ODliZGMyLFxuICAgICAgMHg1MzY2ZjljMywgMHhjOGIzOGU3NCwgMHhiNDc1ZjI1NSwgMHg0NmZjZDliOSxcbiAgICAgIDB4N2FlYjI2NjEsIDB4OGIxZGRmODQsIDB4ODQ2YTBlNzksIDB4OTE1Zjk1ZTIsXG4gICAgICAweDQ2NmU1OThlLCAweDIwYjQ1NzcwLCAweDhjZDU1NTkxLCAweGM5MDJkZTRjLFxuICAgICAgMHhiOTBiYWNlMSwgMHhiYjgyMDVkMCwgMHgxMWE4NjI0OCwgMHg3NTc0YTk5ZSxcbiAgICAgIDB4Yjc3ZjE5YjYsIDB4ZTBhOWRjMDksIDB4NjYyZDA5YTEsIDB4YzQzMjQ2MzMsXG4gICAgICAweGU4NWExZjAyLCAweDA5ZjBiZThjLCAweDRhOTlhMDI1LCAweDFkNmVmZTEwLFxuICAgICAgMHgxYWI5M2QxZCwgMHgwYmE1YTRkZiwgMHhhMTg2ZjIwZiwgMHgyODY4ZjE2OSxcbiAgICAgIDB4ZGNiN2RhODMsIDB4NTczOTA2ZmUsIDB4YTFlMmNlOWIsIDB4NGZjZDdmNTIsXG4gICAgICAweDUwMTE1ZTAxLCAweGE3MDY4M2ZhLCAweGEwMDJiNWM0LCAweDBkZTZkMDI3LFxuICAgICAgMHg5YWY4OGMyNywgMHg3NzNmODY0MSwgMHhjMzYwNGMwNiwgMHg2MWE4MDZiNSxcbiAgICAgIDB4ZjAxNzdhMjgsIDB4YzBmNTg2ZTAsIDB4MDA2MDU4YWEsIDB4MzBkYzdkNjIsXG4gICAgICAweDExZTY5ZWQ3LCAweDIzMzhlYTYzLCAweDUzYzJkZDk0LCAweGMyYzIxNjM0LFxuICAgICAgMHhiYmNiZWU1NiwgMHg5MGJjYjZkZSwgMHhlYmZjN2RhMSwgMHhjZTU5MWQ3NixcbiAgICAgIDB4NmYwNWU0MDksIDB4NGI3YzAxODgsIDB4Mzk3MjBhM2QsIDB4N2M5MjdjMjQsXG4gICAgICAweDg2ZTM3MjVmLCAweDcyNGQ5ZGI5LCAweDFhYzE1YmI0LCAweGQzOWViOGZjLFxuICAgICAgMHhlZDU0NTU3OCwgMHgwOGZjYTViNSwgMHhkODNkN2NkMywgMHg0ZGFkMGZjNCxcbiAgICAgIDB4MWU1MGVmNWUsIDB4YjE2MWU2ZjgsIDB4YTI4NTE0ZDksIDB4NmM1MTEzM2MsXG4gICAgICAweDZmZDVjN2U3LCAweDU2ZTE0ZWM0LCAweDM2MmFiZmNlLCAweGRkYzZjODM3LFxuICAgICAgMHhkNzlhMzIzNCwgMHg5MjYzODIxMiwgMHg2NzBlZmE4ZSwgMHg0MDYwMDBlMF0pLFxuICAgIG5ldyBVaW50MzJBcnJheShbXG4gICAgICAweDNhMzljZTM3LCAweGQzZmFmNWNmLCAweGFiYzI3NzM3LCAweDVhYzUyZDFiLFxuICAgICAgMHg1Y2IwNjc5ZSwgMHg0ZmEzMzc0MiwgMHhkMzgyMjc0MCwgMHg5OWJjOWJiZSxcbiAgICAgIDB4ZDUxMThlOWQsIDB4YmYwZjczMTUsIDB4ZDYyZDFjN2UsIDB4YzcwMGM0N2IsXG4gICAgICAweGI3OGMxYjZiLCAweDIxYTE5MDQ1LCAweGIyNmViMWJlLCAweDZhMzY2ZWI0LFxuICAgICAgMHg1NzQ4YWIyZiwgMHhiYzk0NmU3OSwgMHhjNmEzNzZkMiwgMHg2NTQ5YzJjOCxcbiAgICAgIDB4NTMwZmY4ZWUsIDB4NDY4ZGRlN2QsIDB4ZDU3MzBhMWQsIDB4NGNkMDRkYzYsXG4gICAgICAweDI5MzliYmRiLCAweGE5YmE0NjUwLCAweGFjOTUyNmU4LCAweGJlNWVlMzA0LFxuICAgICAgMHhhMWZhZDVmMCwgMHg2YTJkNTE5YSwgMHg2M2VmOGNlMiwgMHg5YTg2ZWUyMixcbiAgICAgIDB4YzA4OWMyYjgsIDB4NDMyNDJlZjYsIDB4YTUxZTAzYWEsIDB4OWNmMmQwYTQsXG4gICAgICAweDgzYzA2MWJhLCAweDliZTk2YTRkLCAweDhmZTUxNTUwLCAweGJhNjQ1YmQ2LFxuICAgICAgMHgyODI2YTJmOSwgMHhhNzNhM2FlMSwgMHg0YmE5OTU4NiwgMHhlZjU1NjJlOSxcbiAgICAgIDB4YzcyZmVmZDMsIDB4Zjc1MmY3ZGEsIDB4M2YwNDZmNjksIDB4NzdmYTBhNTksXG4gICAgICAweDgwZTRhOTE1LCAweDg3YjA4NjAxLCAweDliMDllNmFkLCAweDNiM2VlNTkzLFxuICAgICAgMHhlOTkwZmQ1YSwgMHg5ZTM0ZDc5NywgMHgyY2YwYjdkOSwgMHgwMjJiOGI1MSxcbiAgICAgIDB4OTZkNWFjM2EsIDB4MDE3ZGE2N2QsIDB4ZDFjZjNlZDYsIDB4N2M3ZDJkMjgsXG4gICAgICAweDFmOWYyNWNmLCAweGFkZjJiODliLCAweDVhZDZiNDcyLCAweDVhODhmNTRjLFxuICAgICAgMHhlMDI5YWM3MSwgMHhlMDE5YTVlNiwgMHg0N2IwYWNmZCwgMHhlZDkzZmE5YixcbiAgICAgIDB4ZThkM2M0OGQsIDB4MjgzYjU3Y2MsIDB4ZjhkNTY2MjksIDB4NzkxMzJlMjgsXG4gICAgICAweDc4NWYwMTkxLCAweGVkNzU2MDU1LCAweGY3OTYwZTQ0LCAweGUzZDM1ZThjLFxuICAgICAgMHgxNTA1NmRkNCwgMHg4OGY0NmRiYSwgMHgwM2ExNjEyNSwgMHgwNTY0ZjBiZCxcbiAgICAgIDB4YzNlYjllMTUsIDB4M2M5MDU3YTIsIDB4OTcyNzFhZWMsIDB4YTkzYTA3MmEsXG4gICAgICAweDFiM2Y2ZDliLCAweDFlNjMyMWY1LCAweGY1OWM2NmZiLCAweDI2ZGNmMzE5LFxuICAgICAgMHg3NTMzZDkyOCwgMHhiMTU1ZmRmNSwgMHgwMzU2MzQ4MiwgMHg4YWJhM2NiYixcbiAgICAgIDB4Mjg1MTc3MTEsIDB4YzIwYWQ5ZjgsIDB4YWJjYzUxNjcsIDB4Y2NhZDkyNWYsXG4gICAgICAweDRkZTgxNzUxLCAweDM4MzBkYzhlLCAweDM3OWQ1ODYyLCAweDkzMjBmOTkxLFxuICAgICAgMHhlYTdhOTBjMiwgMHhmYjNlN2JjZSwgMHg1MTIxY2U2NCwgMHg3NzRmYmUzMixcbiAgICAgIDB4YThiNmUzN2UsIDB4YzMyOTNkNDYsIDB4NDhkZTUzNjksIDB4NjQxM2U2ODAsXG4gICAgICAweGEyYWUwODEwLCAweGRkNmRiMjI0LCAweDY5ODUyZGZkLCAweDA5MDcyMTY2LFxuICAgICAgMHhiMzlhNDYwYSwgMHg2NDQ1YzBkZCwgMHg1ODZjZGVjZiwgMHgxYzIwYzhhZSxcbiAgICAgIDB4NWJiZWY3ZGQsIDB4MWI1ODhkNDAsIDB4Y2NkMjAxN2YsIDB4NmJiNGUzYmIsXG4gICAgICAweGRkYTI2YTdlLCAweDNhNTlmZjQ1LCAweDNlMzUwYTQ0LCAweGJjYjRjZGQ1LFxuICAgICAgMHg3MmVhY2VhOCwgMHhmYTY0ODRiYiwgMHg4ZDY2MTJhZSwgMHhiZjNjNmY0NyxcbiAgICAgIDB4ZDI5YmU0NjMsIDB4NTQyZjVkOWUsIDB4YWVjMjc3MWIsIDB4ZjY0ZTYzNzAsXG4gICAgICAweDc0MGUwZDhkLCAweGU3NWIxMzU3LCAweGY4NzIxNjcxLCAweGFmNTM3ZDVkLFxuICAgICAgMHg0MDQwY2IwOCwgMHg0ZWI0ZTJjYywgMHgzNGQyNDY2YSwgMHgwMTE1YWY4NCxcbiAgICAgIDB4ZTFiMDA0MjgsIDB4OTU5ODNhMWQsIDB4MDZiODlmYjQsIDB4Y2U2ZWEwNDgsXG4gICAgICAweDZmM2YzYjgyLCAweDM1MjBhYjgyLCAweDAxMWExZDRiLCAweDI3NzIyN2Y4LFxuICAgICAgMHg2MTE1NjBiMSwgMHhlNzkzM2ZkYywgMHhiYjNhNzkyYiwgMHgzNDQ1MjViZCxcbiAgICAgIDB4YTA4ODM5ZTEsIDB4NTFjZTc5NGIsIDB4MmYzMmM5YjcsIDB4YTAxZmJhYzksXG4gICAgICAweGUwMWNjODdlLCAweGJjYzdkMWY2LCAweGNmMDExMWMzLCAweGExZThhYWM3LFxuICAgICAgMHgxYTkwODc0OSwgMHhkNDRmYmQ5YSwgMHhkMGRhZGVjYiwgMHhkNTBhZGEzOCxcbiAgICAgIDB4MDMzOWMzMmEsIDB4YzY5MTM2NjcsIDB4OGRmOTMxN2MsIDB4ZTBiMTJiNGYsXG4gICAgICAweGY3OWU1OWI3LCAweDQzZjViYjNhLCAweGYyZDUxOWZmLCAweDI3ZDk0NTljLFxuICAgICAgMHhiZjk3MjIyYywgMHgxNWU2ZmMyYSwgMHgwZjkxZmM3MSwgMHg5Yjk0MTUyNSxcbiAgICAgIDB4ZmFlNTkzNjEsIDB4Y2ViNjljZWIsIDB4YzJhODY0NTksIDB4MTJiYWE4ZDEsXG4gICAgICAweGI2YzEwNzVlLCAweGUzMDU2YTBjLCAweDEwZDI1MDY1LCAweGNiMDNhNDQyLFxuICAgICAgMHhlMGVjNmUwZSwgMHgxNjk4ZGIzYiwgMHg0Yzk4YTBiZSwgMHgzMjc4ZTk2NCxcbiAgICAgIDB4OWYxZjk1MzIsIDB4ZTBkMzkyZGYsIDB4ZDNhMDM0MmIsIDB4ODk3MWYyMWUsXG4gICAgICAweDFiMGE3NDQxLCAweDRiYTMzNDhjLCAweGM1YmU3MTIwLCAweGMzNzYzMmQ4LFxuICAgICAgMHhkZjM1OWY4ZCwgMHg5Yjk5MmYyZSwgMHhlNjBiNmY0NywgMHgwZmUzZjExZCxcbiAgICAgIDB4ZTU0Y2RhNTQsIDB4MWVkYWQ4OTEsIDB4Y2U2Mjc5Y2YsIDB4Y2QzZTdlNmYsXG4gICAgICAweDE2MThiMTY2LCAweGZkMmMxZDA1LCAweDg0OGZkMmM1LCAweGY2ZmIyMjk5LFxuICAgICAgMHhmNTIzZjM1NywgMHhhNjMyNzYyMywgMHg5M2E4MzUzMSwgMHg1NmNjY2QwMixcbiAgICAgIDB4YWNmMDgxNjIsIDB4NWE3NWViYjUsIDB4NmUxNjM2OTcsIDB4ODhkMjczY2MsXG4gICAgICAweGRlOTY2MjkyLCAweDgxYjk0OWQwLCAweDRjNTA5MDFiLCAweDcxYzY1NjE0LFxuICAgICAgMHhlNmM2YzdiZCwgMHgzMjdhMTQwYSwgMHg0NWUxZDAwNiwgMHhjM2YyN2I5YSxcbiAgICAgIDB4YzlhYTUzZmQsIDB4NjJhODBmMDAsIDB4YmIyNWJmZTIsIDB4MzViZGQyZjYsXG4gICAgICAweDcxMTI2OTA1LCAweGIyMDQwMjIyLCAweGI2Y2JjZjdjLCAweGNkNzY5YzJiLFxuICAgICAgMHg1MzExM2VjMCwgMHgxNjQwZTNkMywgMHgzOGFiYmQ2MCwgMHgyNTQ3YWRmMCxcbiAgICAgIDB4YmEzODIwOWMsIDB4Zjc0NmNlNzYsIDB4NzdhZmExYzUsIDB4MjA3NTYwNjAsXG4gICAgICAweDg1Y2JmZTRlLCAweDhhZTg4ZGQ4LCAweDdhYWFmOWIwLCAweDRjZjlhYTdlLFxuICAgICAgMHgxOTQ4YzI1YywgMHgwMmZiOGE4YywgMHgwMWMzNmFlNCwgMHhkNmViZTFmOSxcbiAgICAgIDB4OTBkNGY4NjksIDB4YTY1Y2RlYTAsIDB4M2YwOTI1MmQsIDB4YzIwOGU2OWYsXG4gICAgICAweGI3NGU2MTMyLCAweGNlNzdlMjViLCAweDU3OGZkZmUzLCAweDNhYzM3MmU2XSlcbiAgICBdO1xuICB0aGlzLlAgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4MjQzZjZhODgsIDB4ODVhMzA4ZDMsIDB4MTMxOThhMmUsIDB4MDM3MDczNDQsXG4gICAgMHhhNDA5MzgyMiwgMHgyOTlmMzFkMCwgMHgwODJlZmE5OCwgMHhlYzRlNmM4OSxcbiAgICAweDQ1MjgyMWU2LCAweDM4ZDAxMzc3LCAweGJlNTQ2NmNmLCAweDM0ZTkwYzZjLFxuICAgIDB4YzBhYzI5YjcsIDB4Yzk3YzUwZGQsIDB4M2Y4NGQ1YjUsIDB4YjU0NzA5MTcsXG4gICAgMHg5MjE2ZDVkOSwgMHg4OTc5ZmIxYl0pO1xufTtcblxuZnVuY3Rpb24gRihTLCB4OCwgaSkge1xuICByZXR1cm4gKCgoU1swXVt4OFtpKzNdXSArXG4gICAgICAgICAgICBTWzFdW3g4W2krMl1dKSBeXG4gICAgICAgICAgICBTWzJdW3g4W2krMV1dKSArXG4gICAgICAgICAgICBTWzNdW3g4W2ldXSk7XG59O1xuXG5CbG93ZmlzaC5wcm90b3R5cGUuZW5jaXBoZXIgPSBmdW5jdGlvbih4LCB4OCkge1xuICBpZiAoeDggPT09IHVuZGVmaW5lZCkge1xuICAgIHg4ID0gbmV3IFVpbnQ4QXJyYXkoeC5idWZmZXIpO1xuICAgIGlmICh4LmJ5dGVPZmZzZXQgIT09IDApXG4gICAgICB4OCA9IHg4LnN1YmFycmF5KHguYnl0ZU9mZnNldCk7XG4gIH1cbiAgeFswXSBePSB0aGlzLlBbMF07XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgMTY7IGkgKz0gMikge1xuICAgIHhbMV0gXj0gRih0aGlzLlMsIHg4LCAwKSBeIHRoaXMuUFtpXTtcbiAgICB4WzBdIF49IEYodGhpcy5TLCB4OCwgNCkgXiB0aGlzLlBbaSsxXTtcbiAgfVxuICB2YXIgdCA9IHhbMF07XG4gIHhbMF0gPSB4WzFdIF4gdGhpcy5QWzE3XTtcbiAgeFsxXSA9IHQ7XG59O1xuXG5CbG93ZmlzaC5wcm90b3R5cGUuZGVjaXBoZXIgPSBmdW5jdGlvbih4KSB7XG4gIHZhciB4OCA9IG5ldyBVaW50OEFycmF5KHguYnVmZmVyKTtcbiAgaWYgKHguYnl0ZU9mZnNldCAhPT0gMClcbiAgICB4OCA9IHg4LnN1YmFycmF5KHguYnl0ZU9mZnNldCk7XG4gIHhbMF0gXj0gdGhpcy5QWzE3XTtcbiAgZm9yICh2YXIgaSA9IDE2OyBpID4gMDsgaSAtPSAyKSB7XG4gICAgeFsxXSBePSBGKHRoaXMuUywgeDgsIDApIF4gdGhpcy5QW2ldO1xuICAgIHhbMF0gXj0gRih0aGlzLlMsIHg4LCA0KSBeIHRoaXMuUFtpLTFdO1xuICB9XG4gIHZhciB0ID0geFswXTtcbiAgeFswXSA9IHhbMV0gXiB0aGlzLlBbMF07XG4gIHhbMV0gPSB0O1xufTtcblxuZnVuY3Rpb24gc3RyZWFtMndvcmQoZGF0YSwgZGF0YWJ5dGVzKXtcbiAgdmFyIGksIHRlbXAgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrLCBCTEZfSisrKSB7XG4gICAgaWYgKEJMRl9KID49IGRhdGFieXRlcykgQkxGX0ogPSAwO1xuICAgIHRlbXAgPSAodGVtcCA8PCA4KSB8IGRhdGFbQkxGX0pdO1xuICB9XG4gIHJldHVybiB0ZW1wO1xufTtcblxuQmxvd2Zpc2gucHJvdG90eXBlLmV4cGFuZDBzdGF0ZSA9IGZ1bmN0aW9uKGtleSwga2V5Ynl0ZXMpIHtcbiAgdmFyIGQgPSBuZXcgVWludDMyQXJyYXkoMiksIGksIGs7XG4gIHZhciBkOCA9IG5ldyBVaW50OEFycmF5KGQuYnVmZmVyKTtcblxuICBmb3IgKGkgPSAwLCBCTEZfSiA9IDA7IGkgPCAxODsgaSsrKSB7XG4gICAgdGhpcy5QW2ldIF49IHN0cmVhbTJ3b3JkKGtleSwga2V5Ynl0ZXMpO1xuICB9XG4gIEJMRl9KID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTg7IGkgKz0gMikge1xuICAgIHRoaXMuZW5jaXBoZXIoZCwgZDgpO1xuICAgIHRoaXMuUFtpXSAgID0gZFswXTtcbiAgICB0aGlzLlBbaSsxXSA9IGRbMV07XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgZm9yIChrID0gMDsgayA8IDI1NjsgayArPSAyKSB7XG4gICAgICB0aGlzLmVuY2lwaGVyKGQsIGQ4KTtcbiAgICAgIHRoaXMuU1tpXVtrXSAgID0gZFswXTtcbiAgICAgIHRoaXMuU1tpXVtrKzFdID0gZFsxXTtcbiAgICB9XG4gIH1cbn07XG5cbkJsb3dmaXNoLnByb3RvdHlwZS5leHBhbmRzdGF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGRhdGFieXRlcywga2V5LCBrZXlieXRlcykge1xuICB2YXIgZCA9IG5ldyBVaW50MzJBcnJheSgyKSwgaSwgaztcblxuICBmb3IgKGkgPSAwLCBCTEZfSiA9IDA7IGkgPCAxODsgaSsrKSB7XG4gICAgdGhpcy5QW2ldIF49IHN0cmVhbTJ3b3JkKGtleSwga2V5Ynl0ZXMpO1xuICB9XG5cbiAgZm9yIChpID0gMCwgQkxGX0ogPSAwOyBpIDwgMTg7IGkgKz0gMikge1xuICAgIGRbMF0gXj0gc3RyZWFtMndvcmQoZGF0YSwgZGF0YWJ5dGVzKTtcbiAgICBkWzFdIF49IHN0cmVhbTJ3b3JkKGRhdGEsIGRhdGFieXRlcyk7XG4gICAgdGhpcy5lbmNpcGhlcihkKTtcbiAgICB0aGlzLlBbaV0gICA9IGRbMF07XG4gICAgdGhpcy5QW2krMV0gPSBkWzFdO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGZvciAoayA9IDA7IGsgPCAyNTY7IGsgKz0gMikge1xuICAgICAgZFswXSBePSBzdHJlYW0yd29yZChkYXRhLCBkYXRhYnl0ZXMpO1xuICAgICAgZFsxXSBePSBzdHJlYW0yd29yZChkYXRhLCBkYXRhYnl0ZXMpO1xuICAgICAgdGhpcy5lbmNpcGhlcihkKTtcbiAgICAgIHRoaXMuU1tpXVtrXSAgID0gZFswXTtcbiAgICAgIHRoaXMuU1tpXVtrKzFdID0gZFsxXTtcbiAgICB9XG4gIH1cbiAgQkxGX0ogPSAwO1xufTtcblxuQmxvd2Zpc2gucHJvdG90eXBlLmVuYyA9IGZ1bmN0aW9uKGRhdGEsIGJsb2Nrcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrczsgaSsrKSB7XG4gICAgdGhpcy5lbmNpcGhlcihkYXRhLnN1YmFycmF5KGkqMikpO1xuICB9XG59O1xuXG5CbG93ZmlzaC5wcm90b3R5cGUuZGVjID0gZnVuY3Rpb24oZGF0YSwgYmxvY2tzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzOyBpKyspIHtcbiAgICB0aGlzLmRlY2lwaGVyKGRhdGEuc3ViYXJyYXkoaSoyKSk7XG4gIH1cbn07XG5cbnZhciBCQ1JZUFRfQkxPQ0tTID0gOCxcbiAgICBCQ1JZUFRfSEFTSFNJWkUgPSAzMjtcblxuZnVuY3Rpb24gYmNyeXB0X2hhc2goc2hhMnBhc3MsIHNoYTJzYWx0LCBvdXQpIHtcbiAgdmFyIHN0YXRlID0gbmV3IEJsb3dmaXNoKCksXG4gICAgICBjZGF0YSA9IG5ldyBVaW50MzJBcnJheShCQ1JZUFRfQkxPQ0tTKSwgaSxcbiAgICAgIGNpcGhlcnRleHQgPSBuZXcgVWludDhBcnJheShbNzksMTIwLDEyMSw5OSwxMDQsMTE0LDExMSwxMDksOTcsMTE2LDEwNSxcbiAgICAgICAgICAgIDk5LDY2LDEwOCwxMTEsMTE5LDEwMiwxMDUsMTE1LDEwNCw4MywxMTksOTcsMTE2LDY4LDEyMSwxMTAsOTcsMTA5LFxuICAgICAgICAgICAgMTA1LDExNiwxMDFdKTsgLy9cIk94eWNocm9tYXRpY0Jsb3dmaXNoU3dhdER5bmFtaXRlXCJcblxuICBzdGF0ZS5leHBhbmRzdGF0ZShzaGEyc2FsdCwgNjQsIHNoYTJwYXNzLCA2NCk7XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgc3RhdGUuZXhwYW5kMHN0YXRlKHNoYTJzYWx0LCA2NCk7XG4gICAgc3RhdGUuZXhwYW5kMHN0YXRlKHNoYTJwYXNzLCA2NCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgQkNSWVBUX0JMT0NLUzsgaSsrKVxuICAgIGNkYXRhW2ldID0gc3RyZWFtMndvcmQoY2lwaGVydGV4dCwgY2lwaGVydGV4dC5ieXRlTGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspXG4gICAgc3RhdGUuZW5jKGNkYXRhLCBjZGF0YS5ieXRlTGVuZ3RoIC8gOCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IEJDUllQVF9CTE9DS1M7IGkrKykge1xuICAgIG91dFs0KmkrM10gPSBjZGF0YVtpXSA+Pj4gMjQ7XG4gICAgb3V0WzQqaSsyXSA9IGNkYXRhW2ldID4+PiAxNjtcbiAgICBvdXRbNCppKzFdID0gY2RhdGFbaV0gPj4+IDg7XG4gICAgb3V0WzQqaSswXSA9IGNkYXRhW2ldO1xuICB9XG59O1xuXG5mdW5jdGlvbiBiY3J5cHRfcGJrZGYocGFzcywgcGFzc2xlbiwgc2FsdCwgc2FsdGxlbiwga2V5LCBrZXlsZW4sIHJvdW5kcykge1xuICB2YXIgc2hhMnBhc3MgPSBuZXcgVWludDhBcnJheSg2NCksXG4gICAgICBzaGEyc2FsdCA9IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KEJDUllQVF9IQVNIU0laRSksXG4gICAgICB0bXBvdXQgPSBuZXcgVWludDhBcnJheShCQ1JZUFRfSEFTSFNJWkUpLFxuICAgICAgY291bnRzYWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2FsdGxlbis0KSxcbiAgICAgIGksIGosIGFtdCwgc3RyaWRlLCBkZXN0LCBjb3VudCxcbiAgICAgIG9yaWdrZXlsZW4gPSBrZXlsZW47XG5cbiAgaWYgKHJvdW5kcyA8IDEpXG4gICAgcmV0dXJuIC0xO1xuICBpZiAocGFzc2xlbiA9PT0gMCB8fCBzYWx0bGVuID09PSAwIHx8IGtleWxlbiA9PT0gMCB8fFxuICAgICAga2V5bGVuID4gKG91dC5ieXRlTGVuZ3RoICogb3V0LmJ5dGVMZW5ndGgpIHx8IHNhbHRsZW4gPiAoMTw8MjApKVxuICAgIHJldHVybiAtMTtcblxuICBzdHJpZGUgPSBNYXRoLmZsb29yKChrZXlsZW4gKyBvdXQuYnl0ZUxlbmd0aCAtIDEpIC8gb3V0LmJ5dGVMZW5ndGgpO1xuICBhbXQgPSBNYXRoLmZsb29yKChrZXlsZW4gKyBzdHJpZGUgLSAxKSAvIHN0cmlkZSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNhbHRsZW47IGkrKylcbiAgICBjb3VudHNhbHRbaV0gPSBzYWx0W2ldO1xuXG4gIGNyeXB0b19oYXNoX3NoYTUxMihzaGEycGFzcywgcGFzcywgcGFzc2xlbik7XG5cbiAgZm9yIChjb3VudCA9IDE7IGtleWxlbiA+IDA7IGNvdW50KyspIHtcbiAgICBjb3VudHNhbHRbc2FsdGxlbiswXSA9IGNvdW50ID4+PiAyNDtcbiAgICBjb3VudHNhbHRbc2FsdGxlbisxXSA9IGNvdW50ID4+PiAxNjtcbiAgICBjb3VudHNhbHRbc2FsdGxlbisyXSA9IGNvdW50ID4+PiAgODtcbiAgICBjb3VudHNhbHRbc2FsdGxlbiszXSA9IGNvdW50O1xuXG4gICAgY3J5cHRvX2hhc2hfc2hhNTEyKHNoYTJzYWx0LCBjb3VudHNhbHQsIHNhbHRsZW4gKyA0KTtcbiAgICBiY3J5cHRfaGFzaChzaGEycGFzcywgc2hhMnNhbHQsIHRtcG91dCk7XG4gICAgZm9yIChpID0gb3V0LmJ5dGVMZW5ndGg7IGktLTspXG4gICAgICBvdXRbaV0gPSB0bXBvdXRbaV07XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgcm91bmRzOyBpKyspIHtcbiAgICAgIGNyeXB0b19oYXNoX3NoYTUxMihzaGEyc2FsdCwgdG1wb3V0LCB0bXBvdXQuYnl0ZUxlbmd0aCk7XG4gICAgICBiY3J5cHRfaGFzaChzaGEycGFzcywgc2hhMnNhbHQsIHRtcG91dCk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgb3V0LmJ5dGVMZW5ndGg7IGorKylcbiAgICAgICAgb3V0W2pdIF49IHRtcG91dFtqXTtcbiAgICB9XG5cbiAgICBhbXQgPSBNYXRoLm1pbihhbXQsIGtleWxlbik7XG4gICAgZm9yIChpID0gMDsgaSA8IGFtdDsgaSsrKSB7XG4gICAgICBkZXN0ID0gaSAqIHN0cmlkZSArIChjb3VudCAtIDEpO1xuICAgICAgaWYgKGRlc3QgPj0gb3JpZ2tleWxlbilcbiAgICAgICAgYnJlYWs7XG4gICAgICBrZXlbZGVzdF0gPSBvdXRbaV07XG4gICAgfVxuICAgIGtleWxlbiAtPSBpO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIEJMT0NLUzogQkNSWVBUX0JMT0NLUyxcbiAgICAgIEhBU0hTSVpFOiBCQ1JZUFRfSEFTSFNJWkUsXG4gICAgICBoYXNoOiBiY3J5cHRfaGFzaCxcbiAgICAgIHBia2RmOiBiY3J5cHRfcGJrZGZcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBiaW5kaW5nID0gcmVxdWlyZSgnLi4vYnVpbGQvUmVsZWFzZS9jcHVmZWF0dXJlcy5ub2RlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZGluZy5nZXRDUFVJbmZvO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmxldCBjcHVJbmZvO1xudHJ5IHtcbiAgY3B1SW5mbyA9IHJlcXVpcmUoJ2NwdS1mZWF0dXJlcycpKCk7XG59IGNhdGNoIHt9XG5cbmNvbnN0IHsgYmluZGluZ0F2YWlsYWJsZSwgQ0lQSEVSX0lORk8sIE1BQ19JTkZPIH0gPSByZXF1aXJlKCcuL2NyeXB0by5qcycpO1xuXG5jb25zdCBlZGRzYVN1cHBvcnRlZCA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgY3J5cHRvLnNpZ24gPT09ICdmdW5jdGlvbidcbiAgICAgICYmIHR5cGVvZiBjcnlwdG8udmVyaWZ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3Qga2V5ID1cbiAgICAgICctLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXHJcXG5NQzRDQVFBd0JRWURLMlZ3QkNJRUlIS2orc1ZhOVdjRCdcbiAgICAgICsgJy9xMkRKVUphZjQzS3B0Yzh4WXVVUUE0Yk9Gajl2QzhUXFxyXFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLSc7XG4gICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKCdhJyk7XG4gICAgbGV0IHNpZztcbiAgICBsZXQgdmVyaWZpZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHNpZyA9IGNyeXB0by5zaWduKG51bGwsIGRhdGEsIGtleSk7XG4gICAgICB2ZXJpZmllZCA9IGNyeXB0by52ZXJpZnkobnVsbCwgZGF0YSwga2V5LCBzaWcpO1xuICAgIH0gY2F0Y2gge31cbiAgICByZXR1cm4gKEJ1ZmZlci5pc0J1ZmZlcihzaWcpICYmIHNpZy5sZW5ndGggPT09IDY0ICYmIHZlcmlmaWVkID09PSB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0pKCk7XG5cbmNvbnN0IGN1cnZlMjU1MTlTdXBwb3J0ZWQgPSAodHlwZW9mIGNyeXB0by5kaWZmaWVIZWxsbWFuID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHR5cGVvZiBjcnlwdG8uZ2VuZXJhdGVLZXlQYWlyU3luYyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0eXBlb2YgY3J5cHRvLmNyZWF0ZVB1YmxpY0tleSA9PT0gJ2Z1bmN0aW9uJyk7XG5cbmNvbnN0IERFRkFVTFRfS0VYID0gW1xuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTY1NiNzZWN0aW9uLTEwLjFcbiAgJ2VjZGgtc2hhMi1uaXN0cDI1NicsXG4gICdlY2RoLXNoYTItbmlzdHAzODQnLFxuICAnZWNkaC1zaGEyLW5pc3RwNTIxJyxcblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDQxOSNzZWN0aW9uLTRcbiAgJ2RpZmZpZS1oZWxsbWFuLWdyb3VwLWV4Y2hhbmdlLXNoYTI1NicsXG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgyNjhcbiAgJ2RpZmZpZS1oZWxsbWFuLWdyb3VwMTQtc2hhMjU2JyxcbiAgJ2RpZmZpZS1oZWxsbWFuLWdyb3VwMTUtc2hhNTEyJyxcbiAgJ2RpZmZpZS1oZWxsbWFuLWdyb3VwMTYtc2hhNTEyJyxcbiAgJ2RpZmZpZS1oZWxsbWFuLWdyb3VwMTctc2hhNTEyJyxcbiAgJ2RpZmZpZS1oZWxsbWFuLWdyb3VwMTgtc2hhNTEyJyxcbl07XG5pZiAoY3VydmUyNTUxOVN1cHBvcnRlZCkge1xuICBERUZBVUxUX0tFWC51bnNoaWZ0KCdjdXJ2ZTI1NTE5LXNoYTI1NicpO1xuICBERUZBVUxUX0tFWC51bnNoaWZ0KCdjdXJ2ZTI1NTE5LXNoYTI1NkBsaWJzc2gub3JnJyk7XG59XG5jb25zdCBTVVBQT1JURURfS0VYID0gREVGQVVMVF9LRVguY29uY2F0KFtcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ0MTkjc2VjdGlvbi00XG4gICdkaWZmaWUtaGVsbG1hbi1ncm91cC1leGNoYW5nZS1zaGExJyxcblxuICAnZGlmZmllLWhlbGxtYW4tZ3JvdXAxNC1zaGExJywgLy8gUkVRVUlSRURcbiAgJ2RpZmZpZS1oZWxsbWFuLWdyb3VwMS1zaGExJywgIC8vIFJFUVVJUkVEXG5dKTtcblxuXG5jb25zdCBERUZBVUxUX1NFUlZFUl9IT1NUX0tFWSA9IFtcbiAgJ2VjZHNhLXNoYTItbmlzdHAyNTYnLFxuICAnZWNkc2Etc2hhMi1uaXN0cDM4NCcsXG4gICdlY2RzYS1zaGEyLW5pc3RwNTIxJyxcbiAgJ3JzYS1zaGEyLTUxMicsIC8vIFJGQyA4MzMyXG4gICdyc2Etc2hhMi0yNTYnLCAvLyBSRkMgODMzMlxuICAnc3NoLXJzYScsXG5dO1xuaWYgKGVkZHNhU3VwcG9ydGVkKVxuICBERUZBVUxUX1NFUlZFUl9IT1NUX0tFWS51bnNoaWZ0KCdzc2gtZWQyNTUxOScpO1xuY29uc3QgU1VQUE9SVEVEX1NFUlZFUl9IT1NUX0tFWSA9IERFRkFVTFRfU0VSVkVSX0hPU1RfS0VZLmNvbmNhdChbXG4gICdzc2gtZHNzJyxcbl0pO1xuXG5cbmNvbnN0IGNhblVzZUNpcGhlciA9ICgoKSA9PiB7XG4gIGNvbnN0IGNpcGhlcnMgPSBjcnlwdG8uZ2V0Q2lwaGVycygpO1xuICByZXR1cm4gKG5hbWUpID0+IGNpcGhlcnMuaW5jbHVkZXMoQ0lQSEVSX0lORk9bbmFtZV0uc3NsTmFtZSk7XG59KSgpO1xubGV0IERFRkFVTFRfQ0lQSEVSID0gW1xuICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1NjQ3XG4gICdhZXMxMjgtZ2NtQG9wZW5zc2guY29tJyxcbiAgJ2FlczI1Ni1nY21Ab3BlbnNzaC5jb20nLFxuXG4gIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQzNDQjc2VjdGlvbi00XG4gICdhZXMxMjgtY3RyJyxcbiAgJ2FlczE5Mi1jdHInLFxuICAnYWVzMjU2LWN0cicsXG5dO1xuaWYgKGNwdUluZm8gJiYgY3B1SW5mby5mbGFncyAmJiAhY3B1SW5mby5mbGFncy5hZXMpIHtcbiAgLy8gV2Uga25vdyBmb3Igc3VyZSB0aGUgQ1BVIGRvZXMgbm90IHN1cHBvcnQgQUVTIGFjY2VsZXJhdGlvblxuICBpZiAoYmluZGluZ0F2YWlsYWJsZSlcbiAgICBERUZBVUxUX0NJUEhFUi51bnNoaWZ0KCdjaGFjaGEyMC1wb2x5MTMwNUBvcGVuc3NoLmNvbScpO1xuICBlbHNlXG4gICAgREVGQVVMVF9DSVBIRVIucHVzaCgnY2hhY2hhMjAtcG9seTEzMDVAb3BlbnNzaC5jb20nKTtcbn0gZWxzZSBpZiAoYmluZGluZ0F2YWlsYWJsZSAmJiBjcHVJbmZvICYmIGNwdUluZm8uYXJjaCA9PT0gJ3g4NicpIHtcbiAgLy8gUGxhY2VzIGNoYWNoYTIwLXBvbHkxMzA1IGltbWVkaWF0ZWx5IGFmdGVyIEdDTSBjaXBoZXJzIHNpbmNlIEdDTSBjaXBoZXJzXG4gIC8vIHNlZW0gdG8gb3V0cGVyZm9ybSBpdCBvbiB4ODYsIGJ1dCBpdCBzZWVtcyB0byBiZSBmYXN0ZXIgdGhhbiBDVFIgY2lwaGVyc1xuICBERUZBVUxUX0NJUEhFUi5zcGxpY2UoNCwgMCwgJ2NoYWNoYTIwLXBvbHkxMzA1QG9wZW5zc2guY29tJyk7XG59IGVsc2Uge1xuICBERUZBVUxUX0NJUEhFUi5wdXNoKCdjaGFjaGEyMC1wb2x5MTMwNUBvcGVuc3NoLmNvbScpO1xufVxuREVGQVVMVF9DSVBIRVIgPSBERUZBVUxUX0NJUEhFUi5maWx0ZXIoY2FuVXNlQ2lwaGVyKTtcbmNvbnN0IFNVUFBPUlRFRF9DSVBIRVIgPSBERUZBVUxUX0NJUEhFUi5jb25jYXQoW1xuICAnYWVzMjU2LWNiYycsXG4gICdhZXMxOTItY2JjJyxcbiAgJ2FlczEyOC1jYmMnLFxuICAnYmxvd2Zpc2gtY2JjJyxcbiAgJzNkZXMtY2JjJyxcbiAgJ2FlczEyOC1nY20nLFxuICAnYWVzMjU2LWdjbScsXG5cbiAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDM0NSNzZWN0aW9uLTQ6XG4gICdhcmNmb3VyMjU2JyxcbiAgJ2FyY2ZvdXIxMjgnLFxuXG4gICdjYXN0MTI4LWNiYycsXG4gICdhcmNmb3VyJyxcbl0uZmlsdGVyKGNhblVzZUNpcGhlcikpO1xuXG5cbmNvbnN0IGNhblVzZU1BQyA9ICgoKSA9PiB7XG4gIGNvbnN0IGhhc2hlcyA9IGNyeXB0by5nZXRIYXNoZXMoKTtcbiAgcmV0dXJuIChuYW1lKSA9PiBoYXNoZXMuaW5jbHVkZXMoTUFDX0lORk9bbmFtZV0uc3NsTmFtZSk7XG59KSgpO1xuY29uc3QgREVGQVVMVF9NQUMgPSBbXG4gICdobWFjLXNoYTItMjU2LWV0bUBvcGVuc3NoLmNvbScsXG4gICdobWFjLXNoYTItNTEyLWV0bUBvcGVuc3NoLmNvbScsXG4gICdobWFjLXNoYTEtZXRtQG9wZW5zc2guY29tJyxcbiAgJ2htYWMtc2hhMi0yNTYnLFxuICAnaG1hYy1zaGEyLTUxMicsXG4gICdobWFjLXNoYTEnLFxuXS5maWx0ZXIoY2FuVXNlTUFDKTtcbmNvbnN0IFNVUFBPUlRFRF9NQUMgPSBERUZBVUxUX01BQy5jb25jYXQoW1xuICAnaG1hYy1tZDUnLFxuICAnaG1hYy1zaGEyLTI1Ni05NicsIC8vIGZpcnN0IDk2IGJpdHMgb2YgSE1BQy1TSEEyNTZcbiAgJ2htYWMtc2hhMi01MTItOTYnLCAvLyBmaXJzdCA5NiBiaXRzIG9mIEhNQUMtU0hBNTEyXG4gICdobWFjLXJpcGVtZDE2MCcsXG4gICdobWFjLXNoYTEtOTYnLCAgICAgLy8gZmlyc3QgOTYgYml0cyBvZiBITUFDLVNIQTFcbiAgJ2htYWMtbWQ1LTk2JywgICAgICAvLyBmaXJzdCA5NiBiaXRzIG9mIEhNQUMtTUQ1XG5dLmZpbHRlcihjYW5Vc2VNQUMpKTtcblxuY29uc3QgREVGQVVMVF9DT01QUkVTU0lPTiA9IFtcbiAgJ25vbmUnLFxuICAnemxpYkBvcGVuc3NoLmNvbScsIC8vIFpMSUIgKExaNzcpIGNvbXByZXNzaW9uLCBleGNlcHRcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGRvZXMgbm90IHN0YXJ0IHVudGlsIGFmdGVyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCB1c2VyIGF1dGhlbnRpY2F0aW9uXG4gICd6bGliJywgICAgICAgICAgICAgLy8gWkxJQiAoTFo3NykgY29tcHJlc3Npb25cbl07XG5jb25zdCBTVVBQT1JURURfQ09NUFJFU1NJT04gPSBERUZBVUxUX0NPTVBSRVNTSU9OLmNvbmNhdChbXG5dKTtcblxuXG5jb25zdCBDT01QQVQgPSB7XG4gIEJBRF9ESEdFWDogMSA8PCAwLFxuICBPTERfRVhJVDogMSA8PCAxLFxuICBEWU5fUlBPUlRfQlVHOiAxIDw8IDIsXG4gIEJVR19ESEdFWF9MQVJHRTogMSA8PCAzLFxuICBJTVBMWV9SU0FfU0hBMl9TSUdBTEdTOiAxIDw8IDQsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTUVTU0FHRToge1xuICAgIC8vIFRyYW5zcG9ydCBsYXllciBwcm90b2NvbCAtLSBnZW5lcmljICgxLTE5KVxuICAgIERJU0NPTk5FQ1Q6IDEsXG4gICAgSUdOT1JFOiAyLFxuICAgIFVOSU1QTEVNRU5URUQ6IDMsXG4gICAgREVCVUc6IDQsXG4gICAgU0VSVklDRV9SRVFVRVNUOiA1LFxuICAgIFNFUlZJQ0VfQUNDRVBUOiA2LFxuICAgIEVYVF9JTkZPOiA3LCAvLyBSRkMgODMwOFxuXG4gICAgLy8gVHJhbnNwb3J0IGxheWVyIHByb3RvY29sIC0tIGFsZ29yaXRobSBuZWdvdGlhdGlvbiAoMjAtMjkpXG4gICAgS0VYSU5JVDogMjAsXG4gICAgTkVXS0VZUzogMjEsXG5cbiAgICAvLyBUcmFuc3BvcnQgbGF5ZXIgcHJvdG9jb2wgLS0ga2V5IGV4Y2hhbmdlIG1ldGhvZC1zcGVjaWZpYyAoMzAtNDkpXG4gICAgS0VYREhfSU5JVDogMzAsXG4gICAgS0VYREhfUkVQTFk6IDMxLFxuXG4gICAgS0VYREhfR0VYX0dST1VQOiAzMSxcbiAgICBLRVhESF9HRVhfSU5JVDogMzIsXG4gICAgS0VYREhfR0VYX1JFUExZOiAzMyxcbiAgICBLRVhESF9HRVhfUkVRVUVTVDogMzQsXG5cbiAgICBLRVhFQ0RIX0lOSVQ6IDMwLFxuICAgIEtFWEVDREhfUkVQTFk6IDMxLFxuXG4gICAgLy8gVXNlciBhdXRoIHByb3RvY29sIC0tIGdlbmVyaWMgKDUwLTU5KVxuICAgIFVTRVJBVVRIX1JFUVVFU1Q6IDUwLFxuICAgIFVTRVJBVVRIX0ZBSUxVUkU6IDUxLFxuICAgIFVTRVJBVVRIX1NVQ0NFU1M6IDUyLFxuICAgIFVTRVJBVVRIX0JBTk5FUjogNTMsXG5cbiAgICAvLyBVc2VyIGF1dGggcHJvdG9jb2wgLS0gdXNlciBhdXRoIG1ldGhvZC1zcGVjaWZpYyAoNjAtNzkpXG4gICAgVVNFUkFVVEhfUEFTU1dEX0NIQU5HRVJFUTogNjAsXG5cbiAgICBVU0VSQVVUSF9QS19PSzogNjAsXG5cbiAgICBVU0VSQVVUSF9JTkZPX1JFUVVFU1Q6IDYwLFxuICAgIFVTRVJBVVRIX0lORk9fUkVTUE9OU0U6IDYxLFxuXG4gICAgLy8gQ29ubmVjdGlvbiBwcm90b2NvbCAtLSBnZW5lcmljICg4MC04OSlcbiAgICBHTE9CQUxfUkVRVUVTVDogODAsXG4gICAgUkVRVUVTVF9TVUNDRVNTOiA4MSxcbiAgICBSRVFVRVNUX0ZBSUxVUkU6IDgyLFxuXG4gICAgLy8gQ29ubmVjdGlvbiBwcm90b2NvbCAtLSBjaGFubmVsLXJlbGF0ZWQgKDkwLTEyNylcbiAgICBDSEFOTkVMX09QRU46IDkwLFxuICAgIENIQU5ORUxfT1BFTl9DT05GSVJNQVRJT046IDkxLFxuICAgIENIQU5ORUxfT1BFTl9GQUlMVVJFOiA5MixcbiAgICBDSEFOTkVMX1dJTkRPV19BREpVU1Q6IDkzLFxuICAgIENIQU5ORUxfREFUQTogOTQsXG4gICAgQ0hBTk5FTF9FWFRFTkRFRF9EQVRBOiA5NSxcbiAgICBDSEFOTkVMX0VPRjogOTYsXG4gICAgQ0hBTk5FTF9DTE9TRTogOTcsXG4gICAgQ0hBTk5FTF9SRVFVRVNUOiA5OCxcbiAgICBDSEFOTkVMX1NVQ0NFU1M6IDk5LFxuICAgIENIQU5ORUxfRkFJTFVSRTogMTAwXG5cbiAgICAvLyBSZXNlcnZlZCBmb3IgY2xpZW50IHByb3RvY29scyAoMTI4LTE5MSlcblxuICAgIC8vIExvY2FsIGV4dGVuc2lvbnMgKDE5Mi0xNTUpXG4gIH0sXG4gIERJU0NPTk5FQ1RfUkVBU09OOiB7XG4gICAgSE9TVF9OT1RfQUxMT1dFRF9UT19DT05ORUNUOiAxLFxuICAgIFBST1RPQ09MX0VSUk9SOiAyLFxuICAgIEtFWV9FWENIQU5HRV9GQUlMRUQ6IDMsXG4gICAgUkVTRVJWRUQ6IDQsXG4gICAgTUFDX0VSUk9SOiA1LFxuICAgIENPTVBSRVNTSU9OX0VSUk9SOiA2LFxuICAgIFNFUlZJQ0VfTk9UX0FWQUlMQUJMRTogNyxcbiAgICBQUk9UT0NPTF9WRVJTSU9OX05PVF9TVVBQT1JURUQ6IDgsXG4gICAgSE9TVF9LRVlfTk9UX1ZFUklGSUFCTEU6IDksXG4gICAgQ09OTkVDVElPTl9MT1NUOiAxMCxcbiAgICBCWV9BUFBMSUNBVElPTjogMTEsXG4gICAgVE9PX01BTllfQ09OTkVDVElPTlM6IDEyLFxuICAgIEFVVEhfQ0FOQ0VMRURfQllfVVNFUjogMTMsXG4gICAgTk9fTU9SRV9BVVRIX01FVEhPRFNfQVZBSUxBQkxFOiAxNCxcbiAgICBJTExFR0FMX1VTRVJfTkFNRTogMTUsXG4gIH0sXG4gIERJU0NPTk5FQ1RfUkVBU09OX1NUUjogdW5kZWZpbmVkLFxuICBDSEFOTkVMX09QRU5fRkFJTFVSRToge1xuICAgIEFETUlOSVNUUkFUSVZFTFlfUFJPSElCSVRFRDogMSxcbiAgICBDT05ORUNUX0ZBSUxFRDogMixcbiAgICBVTktOT1dOX0NIQU5ORUxfVFlQRTogMyxcbiAgICBSRVNPVVJDRV9TSE9SVEFHRTogNFxuICB9LFxuICBURVJNSU5BTF9NT0RFOiB7XG4gICAgVFRZX09QX0VORDogMCwgICAgICAgIC8vIEluZGljYXRlcyBlbmQgb2Ygb3B0aW9ucy5cbiAgICBWSU5UUjogMSwgICAgICAgICAgICAgLy8gSW50ZXJydXB0IGNoYXJhY3RlcjsgMjU1IGlmIG5vbmUuIFNpbWlsYXJseSBmb3IgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBvdGhlciBjaGFyYWN0ZXJzLiAgTm90IGFsbCBvZiB0aGVzZSBjaGFyYWN0ZXJzIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgc3VwcG9ydGVkIG9uIGFsbCBzeXN0ZW1zLlxuICAgIFZRVUlUOiAyLCAgICAgICAgICAgICAvLyBUaGUgcXVpdCBjaGFyYWN0ZXIgKHNlbmRzIFNJR1FVSVQgc2lnbmFsIG9uIFBPU0lYXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBzeXN0ZW1zKS5cbiAgICBWRVJBU0U6IDMsICAgICAgICAgICAgLy8gRXJhc2UgdGhlIGNoYXJhY3RlciB0byBsZWZ0IG9mIHRoZSBjdXJzb3IuXG4gICAgVktJTEw6IDQsICAgICAgICAgICAgIC8vIEtpbGwgdGhlIGN1cnJlbnQgaW5wdXQgbGluZS5cbiAgICBWRU9GOiA1LCAgICAgICAgICAgICAgLy8gRW5kLW9mLWZpbGUgY2hhcmFjdGVyIChzZW5kcyBFT0YgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHRlcm1pbmFsKS5cbiAgICBWRU9MOiA2LCAgICAgICAgICAgICAgLy8gRW5kLW9mLWxpbmUgY2hhcmFjdGVyIGluIGFkZGl0aW9uIHRvIGNhcnJpYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vICByZXR1cm4gYW5kL29yIGxpbmVmZWVkLlxuICAgIFZFT0wyOiA3LCAgICAgICAgICAgICAvLyBBZGRpdGlvbmFsIGVuZC1vZi1saW5lIGNoYXJhY3Rlci5cbiAgICBWU1RBUlQ6IDgsICAgICAgICAgICAgLy8gQ29udGludWVzIHBhdXNlZCBvdXRwdXQgKG5vcm1hbGx5IGNvbnRyb2wtUSkuXG4gICAgVlNUT1A6IDksICAgICAgICAgICAgIC8vIFBhdXNlcyBvdXRwdXQgKG5vcm1hbGx5IGNvbnRyb2wtUykuXG4gICAgVlNVU1A6IDEwLCAgICAgICAgICAgIC8vIFN1c3BlbmRzIHRoZSBjdXJyZW50IHByb2dyYW0uXG4gICAgVkRTVVNQOiAxMSwgICAgICAgICAgIC8vIEFub3RoZXIgc3VzcGVuZCBjaGFyYWN0ZXIuXG4gICAgVlJFUFJJTlQ6IDEyLCAgICAgICAgIC8vIFJlcHJpbnRzIHRoZSBjdXJyZW50IGlucHV0IGxpbmUuXG4gICAgVldFUkFTRTogMTMsICAgICAgICAgIC8vIEVyYXNlcyBhIHdvcmQgbGVmdCBvZiBjdXJzb3IuXG4gICAgVkxORVhUOiAxNCwgICAgICAgICAgIC8vIEVudGVyIHRoZSBuZXh0IGNoYXJhY3RlciB0eXBlZCBsaXRlcmFsbHksIGV2ZW4gaWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGl0IGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXJcbiAgICBWRkxVU0g6IDE1LCAgICAgICAgICAgLy8gQ2hhcmFjdGVyIHRvIGZsdXNoIG91dHB1dC5cbiAgICBWU1dUQ0g6IDE2LCAgICAgICAgICAgLy8gU3dpdGNoIHRvIGEgZGlmZmVyZW50IHNoZWxsIGxheWVyLlxuICAgIFZTVEFUVVM6IDE3LCAgICAgICAgICAvLyBQcmludHMgc3lzdGVtIHN0YXR1cyBsaW5lIChsb2FkLCBjb21tYW5kLCBwaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBldGMpLlxuICAgIFZESVNDQVJEOiAxOCwgICAgICAgICAvLyBUb2dnbGVzIHRoZSBmbHVzaGluZyBvZiB0ZXJtaW5hbCBvdXRwdXQuXG4gICAgSUdOUEFSOiAzMCwgICAgICAgICAgIC8vIFRoZSBpZ25vcmUgcGFyaXR5IGZsYWcuICBUaGUgcGFyYW1ldGVyIFNIT1VMRCBiZSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBpZiB0aGlzIGZsYWcgaXMgRkFMU0UsIGFuZCAxIGlmIGl0IGlzIFRSVUUuXG4gICAgUEFSTVJLOiAzMSwgICAgICAgICAgIC8vIE1hcmsgcGFyaXR5IGFuZCBmcmFtaW5nIGVycm9ycy5cbiAgICBJTlBDSzogMzIsICAgICAgICAgICAgLy8gRW5hYmxlIGNoZWNraW5nIG9mIHBhcml0eSBlcnJvcnMuXG4gICAgSVNUUklQOiAzMywgICAgICAgICAgIC8vIFN0cmlwIDh0aCBiaXQgb2ZmIGNoYXJhY3RlcnMuXG4gICAgSU5MQ1I6IDM0LCAgICAgICAgICAgIC8vIE1hcCBOTCBpbnRvIENSIG9uIGlucHV0LlxuICAgIElHTkNSOiAzNSwgICAgICAgICAgICAvLyBJZ25vcmUgQ1Igb24gaW5wdXQuXG4gICAgSUNSTkw6IDM2LCAgICAgICAgICAgIC8vIE1hcCBDUiB0byBOTCBvbiBpbnB1dC5cbiAgICBJVUNMQzogMzcsICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHVwcGVyY2FzZSBjaGFyYWN0ZXJzIHRvIGxvd2VyY2FzZS5cbiAgICBJWE9OOiAzOCwgICAgICAgICAgICAgLy8gRW5hYmxlIG91dHB1dCBmbG93IGNvbnRyb2wuXG4gICAgSVhBTlk6IDM5LCAgICAgICAgICAgIC8vIEFueSBjaGFyIHdpbGwgcmVzdGFydCBhZnRlciBzdG9wLlxuICAgIElYT0ZGOiA0MCwgICAgICAgICAgICAvLyBFbmFibGUgaW5wdXQgZmxvdyBjb250cm9sLlxuICAgIElNQVhCRUw6IDQxLCAgICAgICAgICAvLyBSaW5nIGJlbGwgb24gaW5wdXQgcXVldWUgZnVsbC5cbiAgICBJU0lHOiA1MCwgICAgICAgICAgICAgLy8gRW5hYmxlIHNpZ25hbHMgSU5UUiwgUVVJVCwgW0RdU1VTUC5cbiAgICBJQ0FOT046IDUxLCAgICAgICAgICAgLy8gQ2Fub25pY2FsaXplIGlucHV0IGxpbmVzLlxuICAgIFhDQVNFOiA1MiwgICAgICAgICAgICAvLyBFbmFibGUgaW5wdXQgYW5kIG91dHB1dCBvZiB1cHBlcmNhc2UgY2hhcmFjdGVycyBieVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgcHJlY2VkaW5nIHRoZWlyIGxvd2VyY2FzZSBlcXVpdmFsZW50cyB3aXRoIFwiXFxcIi5cbiAgICBFQ0hPOiA1MywgICAgICAgICAgICAgLy8gRW5hYmxlIGVjaG9pbmcuXG4gICAgRUNIT0U6IDU0LCAgICAgICAgICAgIC8vIFZpc3VhbGx5IGVyYXNlIGNoYXJzLlxuICAgIEVDSE9LOiA1NSwgICAgICAgICAgICAvLyBLaWxsIGNoYXJhY3RlciBkaXNjYXJkcyBjdXJyZW50IGxpbmUuXG4gICAgRUNIT05MOiA1NiwgICAgICAgICAgIC8vIEVjaG8gTkwgZXZlbiBpZiBFQ0hPIGlzIG9mZi5cbiAgICBOT0ZMU0g6IDU3LCAgICAgICAgICAgLy8gRG9uJ3QgZmx1c2ggYWZ0ZXIgaW50ZXJydXB0LlxuICAgIFRPU1RPUDogNTgsICAgICAgICAgICAvLyBTdG9wIGJhY2tncm91bmQgam9icyBmcm9tIG91dHB1dC5cbiAgICBJRVhURU46IDU5LCAgICAgICAgICAgLy8gRW5hYmxlIGV4dGVuc2lvbnMuXG4gICAgRUNIT0NUTDogNjAsICAgICAgICAgIC8vIEVjaG8gY29udHJvbCBjaGFyYWN0ZXJzIGFzIF4oQ2hhcikuXG4gICAgRUNIT0tFOiA2MSwgICAgICAgICAgIC8vIFZpc3VhbCBlcmFzZSBmb3IgbGluZSBraWxsLlxuICAgIFBFTkRJTjogNjIsICAgICAgICAgICAvLyBSZXR5cGUgcGVuZGluZyBpbnB1dC5cbiAgICBPUE9TVDogNzAsICAgICAgICAgICAgLy8gRW5hYmxlIG91dHB1dCBwcm9jZXNzaW5nLlxuICAgIE9MQ1VDOiA3MSwgICAgICAgICAgICAvLyBDb252ZXJ0IGxvd2VyY2FzZSB0byB1cHBlcmNhc2UuXG4gICAgT05MQ1I6IDcyLCAgICAgICAgICAgIC8vIE1hcCBOTCB0byBDUi1OTC5cbiAgICBPQ1JOTDogNzMsICAgICAgICAgICAgLy8gVHJhbnNsYXRlIGNhcnJpYWdlIHJldHVybiB0byBuZXdsaW5lIChvdXRwdXQpLlxuICAgIE9OT0NSOiA3NCwgICAgICAgICAgICAvLyBUcmFuc2xhdGUgbmV3bGluZSB0byBjYXJyaWFnZSByZXR1cm4tbmV3bGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgKG91dHB1dCkuXG4gICAgT05MUkVUOiA3NSwgICAgICAgICAgIC8vIE5ld2xpbmUgcGVyZm9ybXMgYSBjYXJyaWFnZSByZXR1cm4gKG91dHB1dCkuXG4gICAgQ1M3OiA5MCwgICAgICAgICAgICAgIC8vIDcgYml0IG1vZGUuXG4gICAgQ1M4OiA5MSwgICAgICAgICAgICAgIC8vIDggYml0IG1vZGUuXG4gICAgUEFSRU5COiA5MiwgICAgICAgICAgIC8vIFBhcml0eSBlbmFibGUuXG4gICAgUEFST0REOiA5MywgICAgICAgICAgIC8vIE9kZCBwYXJpdHksIGVsc2UgZXZlbi5cbiAgICBUVFlfT1BfSVNQRUVEOiAxMjgsICAgLy8gU3BlY2lmaWVzIHRoZSBpbnB1dCBiYXVkIHJhdGUgaW4gYml0cyBwZXIgc2Vjb25kLlxuICAgIFRUWV9PUF9PU1BFRUQ6IDEyOSwgICAvLyBTcGVjaWZpZXMgdGhlIG91dHB1dCBiYXVkIHJhdGUgaW4gYml0cyBwZXIgc2Vjb25kLlxuICB9LFxuICBDSEFOTkVMX0VYVEVOREVEX0RBVEFUWVBFOiB7XG4gICAgU1RERVJSOiAxLFxuICB9LFxuXG4gIFNJR05BTFM6IFtcbiAgICAnQUJSVCcsICdBTFJNJywgJ0ZQRScsICdIVVAnLCAnSUxMJywgJ0lOVCcsICdRVUlUJywgJ1NFR1YnLCAnVEVSTScsICdVU1IxJyxcbiAgICAnVVNSMicsICdLSUxMJywgJ1BJUEUnXG4gIF0ucmVkdWNlKChjdXIsIHZhbCkgPT4gKHsgLi4uY3VyLCBbdmFsXTogMSB9KSwge30pLFxuXG4gIENPTVBBVCxcbiAgQ09NUEFUX0NIRUNLUzogW1xuICAgIFsgJ0Npc2NvLTEuMjUnLCBDT01QQVQuQkFEX0RIR0VYIF0sXG4gICAgWyAvXkNpc2NvLTFbLl0vLCBDT01QQVQuQlVHX0RIR0VYX0xBUkdFIF0sXG4gICAgWyAvXlswLTkuXSskLywgQ09NUEFULk9MRF9FWElUIF0sIC8vIG9sZCBTU0guY29tIGltcGxlbWVudGF0aW9uc1xuICAgIFsgL15PcGVuU1NIXzVbLl1bMC05XSsvLCBDT01QQVQuRFlOX1JQT1JUX0JVRyBdLFxuICAgIFsgL15PcGVuU1NIXzdbLl00LywgQ09NUEFULklNUExZX1JTQV9TSEEyX1NJR0FMR1MgXSxcbiAgXSxcblxuICAvLyBLRVggcHJvcG9zYWwtcmVsYXRlZFxuICBERUZBVUxUX0tFWCxcbiAgU1VQUE9SVEVEX0tFWCxcbiAgREVGQVVMVF9TRVJWRVJfSE9TVF9LRVksXG4gIFNVUFBPUlRFRF9TRVJWRVJfSE9TVF9LRVksXG4gIERFRkFVTFRfQ0lQSEVSLFxuICBTVVBQT1JURURfQ0lQSEVSLFxuICBERUZBVUxUX01BQyxcbiAgU1VQUE9SVEVEX01BQyxcbiAgREVGQVVMVF9DT01QUkVTU0lPTixcbiAgU1VQUE9SVEVEX0NPTVBSRVNTSU9OLFxuXG4gIGN1cnZlMjU1MTlTdXBwb3J0ZWQsXG4gIGVkZHNhU3VwcG9ydGVkLFxufTtcblxubW9kdWxlLmV4cG9ydHMuRElTQ09OTkVDVF9SRUFTT05fQllfVkFMVUUgPVxuICBBcnJheS5mcm9tKE9iamVjdC5lbnRyaWVzKG1vZHVsZS5leHBvcnRzLkRJU0NPTk5FQ1RfUkVBU09OKSlcbiAgICAgICAucmVkdWNlKChvYmosIFtrZXksIHZhbHVlXSkgPT4gKHsgLi4ub2JqLCBbdmFsdWVdOiBrZXkgfSksIHt9KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJlciA9IHJlcXVpcmUoJ2FzbjEnKS5CZXI7XG5cbmxldCBESVNDT05ORUNUX1JFQVNPTjtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5jb25zdCBUeXBlZEFycmF5RmlsbCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSkuZmlsbDtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMkJFKGJ1Ziwgb2Zmc2V0KSB7XG4gIHJldHVybiAoYnVmW29mZnNldCsrXSAqIDE2Nzc3MjE2KVxuICAgICAgICAgKyAoYnVmW29mZnNldCsrXSAqIDY1NTM2KVxuICAgICAgICAgKyAoYnVmW29mZnNldCsrXSAqIDI1NilcbiAgICAgICAgICsgYnVmW29mZnNldF07XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlckNvcHkoc3JjLCBkZXN0LCBzcmNTdGFydCwgc3JjRW5kLCBkZXN0U3RhcnQpIHtcbiAgaWYgKCFkZXN0U3RhcnQpXG4gICAgZGVzdFN0YXJ0ID0gMDtcbiAgaWYgKHNyY0VuZCA+IHNyYy5sZW5ndGgpXG4gICAgc3JjRW5kID0gc3JjLmxlbmd0aDtcbiAgbGV0IG5iID0gc3JjRW5kIC0gc3JjU3RhcnQ7XG4gIGNvbnN0IGRlc3RMZWZ0ID0gKGRlc3QubGVuZ3RoIC0gZGVzdFN0YXJ0KTtcbiAgaWYgKG5iID4gZGVzdExlZnQpXG4gICAgbmIgPSBkZXN0TGVmdDtcbiAgZGVzdC5zZXQobmV3IFVpbnQ4QXJyYXkoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQgKyBzcmNTdGFydCwgbmIpLFxuICAgICAgICAgICBkZXN0U3RhcnQpO1xuICByZXR1cm4gbmI7XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlclNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpXG4gICAgZW5kID0gYnVmLmxlbmd0aDtcbiAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0ICsgc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbn1cblxuZnVuY3Rpb24gbWFrZUJ1ZmZlclBhcnNlcigpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBidWZmZXI7XG5cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0OiAoYnVmLCBzdGFydCkgPT4ge1xuICAgICAgYnVmZmVyID0gYnVmO1xuICAgICAgcG9zID0gKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgPyBzdGFydCA6IDApO1xuICAgIH0sXG4gICAgcG9zOiAoKSA9PiBwb3MsXG4gICAgbGVuZ3RoOiAoKSA9PiAoYnVmZmVyID8gYnVmZmVyLmxlbmd0aCA6IDApLFxuICAgIGF2YWlsOiAoKSA9PiAoYnVmZmVyICYmIHBvcyA8IGJ1ZmZlci5sZW5ndGggPyBidWZmZXIubGVuZ3RoIC0gcG9zIDogMCksXG4gICAgY2xlYXI6ICgpID0+IHtcbiAgICAgIGJ1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHJlYWRVSW50MzJCRTogKCkgPT4ge1xuICAgICAgaWYgKCFidWZmZXIgfHwgcG9zICsgMyA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICByZXR1cm4gKGJ1ZmZlcltwb3MrK10gKiAxNjc3NzIxNilcbiAgICAgICAgICAgICArIChidWZmZXJbcG9zKytdICogNjU1MzYpXG4gICAgICAgICAgICAgKyAoYnVmZmVyW3BvcysrXSAqIDI1NilcbiAgICAgICAgICAgICArIGJ1ZmZlcltwb3MrK107XG4gICAgfSxcbiAgICByZWFkVUludDY0QkU6IChiZWhhdmlvcikgPT4ge1xuICAgICAgaWYgKCFidWZmZXIgfHwgcG9zICsgNyA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBzd2l0Y2ggKGJlaGF2aW9yKSB7XG4gICAgICAgIGNhc2UgJ2Fsd2F5cyc6XG4gICAgICAgICAgcmV0dXJuIEJpZ0ludChgMHgke2J1ZmZlci5oZXhTbGljZShwb3MsIHBvcyArPSA4KX1gKTtcbiAgICAgICAgY2FzZSAnbWF5YmUnOlxuICAgICAgICAgIGlmIChidWZmZXJbcG9zXSA+IDB4MUYpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KGAweCR7YnVmZmVyLmhleFNsaWNlKHBvcywgcG9zICs9IDgpfWApO1xuICAgICAgICAgIC8vIEZBTExUSFJPVUdIXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIChidWZmZXJbcG9zKytdICogNzIwNTc1OTQwMzc5Mjc5NDApXG4gICAgICAgICAgICAgICAgICsgKGJ1ZmZlcltwb3MrK10gKiAyODE0NzQ5NzY3MTA2NTYpXG4gICAgICAgICAgICAgICAgICsgKGJ1ZmZlcltwb3MrK10gKiAxMDk5NTExNjI3Nzc2KVxuICAgICAgICAgICAgICAgICArIChidWZmZXJbcG9zKytdICogNDI5NDk2NzI5NilcbiAgICAgICAgICAgICAgICAgKyAoYnVmZmVyW3BvcysrXSAqIDE2Nzc3MjE2KVxuICAgICAgICAgICAgICAgICArIChidWZmZXJbcG9zKytdICogNjU1MzYpXG4gICAgICAgICAgICAgICAgICsgKGJ1ZmZlcltwb3MrK10gKiAyNTYpXG4gICAgICAgICAgICAgICAgICsgYnVmZmVyW3BvcysrXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNraXA6IChuKSA9PiB7XG4gICAgICBpZiAoYnVmZmVyICYmIG4gPiAwKVxuICAgICAgICBwb3MgKz0gbjtcbiAgICB9LFxuICAgIHNraXBTdHJpbmc6ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlbiA9IHNlbGYucmVhZFVJbnQzMkJFKCk7XG4gICAgICBpZiAobGVuID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHBvcyArPSBsZW47XG4gICAgICByZXR1cm4gKHBvcyA8PSBidWZmZXIubGVuZ3RoID8gbGVuIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlYWRCeXRlOiAoKSA9PiB7XG4gICAgICBpZiAoYnVmZmVyICYmIHBvcyA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBidWZmZXJbcG9zKytdO1xuICAgIH0sXG4gICAgcmVhZEJvb2w6ICgpID0+IHtcbiAgICAgIGlmIChidWZmZXIgJiYgcG9zIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuICEhYnVmZmVyW3BvcysrXTtcbiAgICB9LFxuICAgIHJlYWRMaXN0OiAoKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ID0gc2VsZi5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcmV0dXJuIChsaXN0ID8gbGlzdC5zcGxpdCgnLCcpIDogW10pO1xuICAgIH0sXG4gICAgcmVhZFN0cmluZzogKGRlc3QsIG1heExlbikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkZXN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXhMZW4gPSBkZXN0O1xuICAgICAgICBkZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsZW4gPSBzZWxmLnJlYWRVSW50MzJCRSgpO1xuICAgICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGlmICgoYnVmZmVyLmxlbmd0aCAtIHBvcykgPCBsZW5cbiAgICAgICAgICB8fCAodHlwZW9mIG1heExlbiA9PT0gJ251bWJlcicgJiYgbGVuID4gbWF4TGVuKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXN0KSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGVzdCkpXG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlckNvcHkoYnVmZmVyLCBkZXN0LCBwb3MsIHBvcyArPSBsZW4pO1xuICAgICAgICByZXR1cm4gYnVmZmVyLnV0ZjhTbGljZShwb3MsIHBvcyArPSBsZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlclNsaWNlKGJ1ZmZlciwgcG9zLCBwb3MgKz0gbGVuKTtcbiAgICB9LFxuICAgIHJlYWRSYXc6IChsZW4pID0+IHtcbiAgICAgIGlmICghYnVmZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIGxlbiAhPT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBidWZmZXJTbGljZShidWZmZXIsIHBvcywgcG9zICs9IChidWZmZXIubGVuZ3RoIC0gcG9zKSk7XG4gICAgICBpZiAoKGJ1ZmZlci5sZW5ndGggLSBwb3MpID49IGxlbilcbiAgICAgICAgcmV0dXJuIGJ1ZmZlclNsaWNlKGJ1ZmZlciwgcG9zLCBwb3MgKz0gbGVuKTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBtYWtlRXJyb3IobXNnLCBsZXZlbCwgZmF0YWwpIHtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdib29sZWFuJykge1xuICAgIGZhdGFsID0gbGV2ZWw7XG4gICAgZXJyLmxldmVsID0gJ3Byb3RvY29sJztcbiAgfSBlbHNlIHtcbiAgICBlcnIubGV2ZWwgPSBsZXZlbCB8fCAncHJvdG9jb2wnO1xuICB9XG4gIGVyci5mYXRhbCA9ICEhZmF0YWw7XG4gIHJldHVybiBlcnI7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyQkUoYnVmLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gIGJ1ZltvZmZzZXQrK10gPSAodmFsdWUgPj4+IDI0KTtcbiAgYnVmW29mZnNldCsrXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICBidWZbb2Zmc2V0KytdID0gKHZhbHVlID4+PiA4KTtcbiAgYnVmW29mZnNldCsrXSA9IHZhbHVlO1xuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5jb25zdCB1dGlsQnVmZmVyUGFyc2VyID0gbWFrZUJ1ZmZlclBhcnNlcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVmZmVyQ29weSxcbiAgYnVmZmVyU2xpY2UsXG4gIEZhc3RCdWZmZXIsXG4gIGJ1ZmZlckZpbGw6IChidWYsIHZhbHVlLCBzdGFydCwgZW5kKSA9PiB7XG4gICAgcmV0dXJuIFR5cGVkQXJyYXlGaWxsLmNhbGwoYnVmLCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gIH0sXG4gIG1ha2VFcnJvcixcbiAgZG9GYXRhbEVycm9yOiAocHJvdG9jb2wsIG1zZywgbGV2ZWwsIHJlYXNvbikgPT4ge1xuICAgIGxldCBlcnI7XG4gICAgaWYgKERJU0NPTk5FQ1RfUkVBU09OID09PSB1bmRlZmluZWQpXG4gICAgICAoeyBESVNDT05ORUNUX1JFQVNPTiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMuanMnKSk7XG4gICAgaWYgKG1zZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBkb0ZhdGFsRXJyb3IocHJvdG9jb2wsIGVyclssIHJlYXNvbl0pXG4gICAgICBlcnIgPSBtc2c7XG4gICAgICBpZiAodHlwZW9mIGxldmVsICE9PSAnbnVtYmVyJylcbiAgICAgICAgcmVhc29uID0gRElTQ09OTkVDVF9SRUFTT04uUFJPVE9DT0xfRVJST1I7XG4gICAgICBlbHNlXG4gICAgICAgIHJlYXNvbiA9IGxldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb0ZhdGFsRXJyb3IocHJvdG9jb2wsIG1zZ1ssIGxldmVsWywgcmVhc29uXV0pXG4gICAgICBlcnIgPSBtYWtlRXJyb3IobXNnLCBsZXZlbCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVhc29uICE9PSAnbnVtYmVyJylcbiAgICAgIHJlYXNvbiA9IERJU0NPTk5FQ1RfUkVBU09OLlBST1RPQ09MX0VSUk9SO1xuICAgIHByb3RvY29sLmRpc2Nvbm5lY3QocmVhc29uKTtcbiAgICBwcm90b2NvbC5fZGVzdHJ1Y3QoKTtcbiAgICBwcm90b2NvbC5fb25FcnJvcihlcnIpO1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfSxcbiAgcmVhZFVJbnQzMkJFLFxuICB3cml0ZVVJbnQzMkJFLFxuICB3cml0ZVVJbnQzMkxFOiAoYnVmLCB2YWx1ZSwgb2Zmc2V0KSA9PiB7XG4gICAgYnVmW29mZnNldCsrXSA9IHZhbHVlO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAodmFsdWUgPj4+IDgpO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAodmFsdWUgPj4+IDE2KTtcbiAgICBidWZbb2Zmc2V0KytdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfSxcbiAgbWFrZUJ1ZmZlclBhcnNlcixcbiAgYnVmZmVyUGFyc2VyOiBtYWtlQnVmZmVyUGFyc2VyKCksXG4gIHJlYWRTdHJpbmc6IChidWZmZXIsIHN0YXJ0LCBkZXN0LCBtYXhMZW4pID0+IHtcbiAgICBpZiAodHlwZW9mIGRlc3QgPT09ICdudW1iZXInKSB7XG4gICAgICBtYXhMZW4gPSBkZXN0O1xuICAgICAgZGVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZClcbiAgICAgIHN0YXJ0ID0gMDtcblxuICAgIGNvbnN0IGxlZnQgPSAoYnVmZmVyLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IGJ1ZmZlci5sZW5ndGggfHwgbGVmdCA8IDQpXG4gICAgICByZXR1cm47XG5cbiAgICBjb25zdCBsZW4gPSByZWFkVUludDMyQkUoYnVmZmVyLCBzdGFydCk7XG4gICAgaWYgKGxlZnQgPCAoNCArIGxlbikgfHwgKHR5cGVvZiBtYXhMZW4gPT09ICdudW1iZXInICYmIGxlbiA+IG1heExlbikpXG4gICAgICByZXR1cm47XG5cbiAgICBzdGFydCArPSA0O1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbGVuO1xuICAgIGJ1ZmZlci5fcG9zID0gZW5kO1xuXG4gICAgaWYgKGRlc3QpIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGVzdCkpXG4gICAgICAgIHJldHVybiBidWZmZXJDb3B5KGJ1ZmZlciwgZGVzdCwgc3RhcnQsIGVuZCk7XG4gICAgICByZXR1cm4gYnVmZmVyLnV0ZjhTbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlclNsaWNlKGJ1ZmZlciwgc3RhcnQsIGVuZCk7XG4gIH0sXG4gIHNpZ1NTSFRvQVNOMTogKHNpZywgdHlwZSkgPT4ge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3NoLWRzcyc6IHtcbiAgICAgICAgaWYgKHNpZy5sZW5ndGggPiA0MClcbiAgICAgICAgICByZXR1cm4gc2lnO1xuICAgICAgICAvLyBDaGFuZ2UgYmFyZSBzaWduYXR1cmUgciBhbmQgcyB2YWx1ZXMgdG8gQVNOLjEgQkVSIHZhbHVlcyBmb3IgT3BlblNTTFxuICAgICAgICBjb25zdCBhc25Xcml0ZXIgPSBuZXcgQmVyLldyaXRlcigpO1xuICAgICAgICBhc25Xcml0ZXIuc3RhcnRTZXF1ZW5jZSgpO1xuICAgICAgICBsZXQgciA9IHNpZy5zbGljZSgwLCAyMCk7XG4gICAgICAgIGxldCBzID0gc2lnLnNsaWNlKDIwKTtcbiAgICAgICAgaWYgKHJbMF0gJiAweDgwKSB7XG4gICAgICAgICAgY29uc3Qgck5ldyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMSk7XG4gICAgICAgICAgck5ld1swXSA9IDB4MDA7XG4gICAgICAgICAgci5jb3B5KHJOZXcsIDEpO1xuICAgICAgICAgIHIgPSByTmV3O1xuICAgICAgICB9IGVsc2UgaWYgKHJbMF0gPT09IDB4MDAgJiYgIShyWzFdICYgMHg4MCkpIHtcbiAgICAgICAgICByID0gci5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc1swXSAmIDB4ODApIHtcbiAgICAgICAgICBjb25zdCBzTmV3ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIxKTtcbiAgICAgICAgICBzTmV3WzBdID0gMHgwMDtcbiAgICAgICAgICBzLmNvcHkoc05ldywgMSk7XG4gICAgICAgICAgcyA9IHNOZXc7XG4gICAgICAgIH0gZWxzZSBpZiAoc1swXSA9PT0gMHgwMCAmJiAhKHNbMV0gJiAweDgwKSkge1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihyLCBCZXIuSW50ZWdlcik7XG4gICAgICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihzLCBCZXIuSW50ZWdlcik7XG4gICAgICAgIGFzbldyaXRlci5lbmRTZXF1ZW5jZSgpO1xuICAgICAgICByZXR1cm4gYXNuV3JpdGVyLmJ1ZmZlcjtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2VjZHNhLXNoYTItbmlzdHAyNTYnOlxuICAgICAgY2FzZSAnZWNkc2Etc2hhMi1uaXN0cDM4NCc6XG4gICAgICBjYXNlICdlY2RzYS1zaGEyLW5pc3RwNTIxJzoge1xuICAgICAgICB1dGlsQnVmZmVyUGFyc2VyLmluaXQoc2lnLCAwKTtcbiAgICAgICAgY29uc3QgciA9IHV0aWxCdWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgICAgICBjb25zdCBzID0gdXRpbEJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgICAgIHV0aWxCdWZmZXJQYXJzZXIuY2xlYXIoKTtcbiAgICAgICAgaWYgKHIgPT09IHVuZGVmaW5lZCB8fCBzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGFzbldyaXRlciA9IG5ldyBCZXIuV3JpdGVyKCk7XG4gICAgICAgIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKCk7XG4gICAgICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihyLCBCZXIuSW50ZWdlcik7XG4gICAgICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihzLCBCZXIuSW50ZWdlcik7XG4gICAgICAgIGFzbldyaXRlci5lbmRTZXF1ZW5jZSgpO1xuICAgICAgICByZXR1cm4gYXNuV3JpdGVyLmJ1ZmZlcjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzaWc7XG4gICAgfVxuICB9LFxuICBjb252ZXJ0U2lnbmF0dXJlOiAoc2lnbmF0dXJlLCBrZXlUeXBlKSA9PiB7XG4gICAgc3dpdGNoIChrZXlUeXBlKSB7XG4gICAgICBjYXNlICdzc2gtZHNzJzoge1xuICAgICAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCA8PSA0MClcbiAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICAvLyBUaGlzIGlzIGEgcXVpY2sgYW5kIGRpcnR5IHdheSB0byBnZXQgZnJvbSBCRVIgZW5jb2RlZCByIGFuZCBzIHRoYXRcbiAgICAgICAgLy8gT3BlblNTTCBnaXZlcyB1cywgdG8ganVzdCB0aGUgYmFyZSB2YWx1ZXMgYmFjayB0byBiYWNrICg0MCBieXRlc1xuICAgICAgICAvLyB0b3RhbCkgbGlrZSBPcGVuU1NIIChhbmQgcG9zc2libHkgb3RoZXJzKSBhcmUgZXhwZWN0aW5nXG4gICAgICAgIGNvbnN0IGFzblJlYWRlciA9IG5ldyBCZXIuUmVhZGVyKHNpZ25hdHVyZSk7XG4gICAgICAgIGFzblJlYWRlci5yZWFkU2VxdWVuY2UoKTtcbiAgICAgICAgbGV0IHIgPSBhc25SZWFkZXIucmVhZFN0cmluZyhCZXIuSW50ZWdlciwgdHJ1ZSk7XG4gICAgICAgIGxldCBzID0gYXNuUmVhZGVyLnJlYWRTdHJpbmcoQmVyLkludGVnZXIsIHRydWUpO1xuICAgICAgICBsZXQgck9mZnNldCA9IDA7XG4gICAgICAgIGxldCBzT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHIubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICBjb25zdCByTmV3ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKTtcbiAgICAgICAgICByTmV3LnNldChyLCAxKTtcbiAgICAgICAgICByID0gck5ldztcbiAgICAgICAgICByWzBdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5sZW5ndGggPCAyMCkge1xuICAgICAgICAgIGNvbnN0IHNOZXcgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjApO1xuICAgICAgICAgIHNOZXcuc2V0KHMsIDEpO1xuICAgICAgICAgIHMgPSBzTmV3O1xuICAgICAgICAgIHNbMF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyLmxlbmd0aCA+IDIwICYmIHJbMF0gPT09IDApXG4gICAgICAgICAgck9mZnNldCA9IDE7XG4gICAgICAgIGlmIChzLmxlbmd0aCA+IDIwICYmIHNbMF0gPT09IDApXG4gICAgICAgICAgc09mZnNldCA9IDE7XG4gICAgICAgIGNvbnN0IG5ld1NpZyA9XG4gICAgICAgICAgQnVmZmVyLmFsbG9jVW5zYWZlKChyLmxlbmd0aCAtIHJPZmZzZXQpICsgKHMubGVuZ3RoIC0gc09mZnNldCkpO1xuICAgICAgICBidWZmZXJDb3B5KHIsIG5ld1NpZywgck9mZnNldCwgci5sZW5ndGgsIDApO1xuICAgICAgICBidWZmZXJDb3B5KHMsIG5ld1NpZywgc09mZnNldCwgcy5sZW5ndGgsIHIubGVuZ3RoIC0gck9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXdTaWc7XG4gICAgICB9XG4gICAgICBjYXNlICdlY2RzYS1zaGEyLW5pc3RwMjU2JzpcbiAgICAgIGNhc2UgJ2VjZHNhLXNoYTItbmlzdHAzODQnOlxuICAgICAgY2FzZSAnZWNkc2Etc2hhMi1uaXN0cDUyMSc6IHtcbiAgICAgICAgaWYgKHNpZ25hdHVyZVswXSA9PT0gMClcbiAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICAvLyBDb252ZXJ0IFNTSCBzaWduYXR1cmUgcGFyYW1ldGVycyB0byBBU04uMSBCRVIgdmFsdWVzIGZvciBPcGVuU1NMXG4gICAgICAgIGNvbnN0IGFzblJlYWRlciA9IG5ldyBCZXIuUmVhZGVyKHNpZ25hdHVyZSk7XG4gICAgICAgIGFzblJlYWRlci5yZWFkU2VxdWVuY2UoKTtcbiAgICAgICAgY29uc3QgciA9IGFzblJlYWRlci5yZWFkU3RyaW5nKEJlci5JbnRlZ2VyLCB0cnVlKTtcbiAgICAgICAgY29uc3QgcyA9IGFzblJlYWRlci5yZWFkU3RyaW5nKEJlci5JbnRlZ2VyLCB0cnVlKTtcbiAgICAgICAgaWYgKHIgPT09IG51bGwgfHwgcyA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG5ld1NpZyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgci5sZW5ndGggKyA0ICsgcy5sZW5ndGgpO1xuICAgICAgICB3cml0ZVVJbnQzMkJFKG5ld1NpZywgci5sZW5ndGgsIDApO1xuICAgICAgICBuZXdTaWcuc2V0KHIsIDQpO1xuICAgICAgICB3cml0ZVVJbnQzMkJFKG5ld1NpZywgcy5sZW5ndGgsIDQgKyByLmxlbmd0aCk7XG4gICAgICAgIG5ld1NpZy5zZXQocywgNCArIDQgKyByLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXdTaWc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgfSxcbiAgc2VuZFBhY2tldDogKHByb3RvLCBwYWNrZXQsIGJ5cGFzcykgPT4ge1xuICAgIGlmICghYnlwYXNzICYmIHByb3RvLl9rZXhpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFdlJ3JlIGN1cnJlbnRseSBpbiB0aGUgbWlkZGxlIG9mIGEgaGFuZHNoYWtlXG5cbiAgICAgIGlmIChwcm90by5fcXVldWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcHJvdG8uX3F1ZXVlID0gW107XG4gICAgICBwcm90by5fcXVldWUucHVzaChwYWNrZXQpO1xuICAgICAgcHJvdG8uX2RlYnVnICYmIHByb3RvLl9kZWJ1ZygnT3V0Ym91bmQ6IC4uLiBwYWNrZXQgcXVldWVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHByb3RvLl9jaXBoZXIuZW5jcnlwdChwYWNrZXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxufTtcbiIsICJcbnZhciBjcmVhdGVQb2x5MTMwNSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIF9zY3JpcHREaXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyA6IHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiBfX2ZpbGVuYW1lICE9PSAndW5kZWZpbmVkJykgX3NjcmlwdERpciA9IF9zY3JpcHREaXIgfHwgX19maWxlbmFtZTtcbiAgcmV0dXJuIChcbmZ1bmN0aW9uKGNyZWF0ZVBvbHkxMzA1KSB7XG4gIGNyZWF0ZVBvbHkxMzA1ID0gY3JlYXRlUG9seTEzMDUgfHwge307XG5cblxudmFyIGI7Ynx8KGI9dHlwZW9mIGNyZWF0ZVBvbHkxMzA1ICE9PSAndW5kZWZpbmVkJyA/IGNyZWF0ZVBvbHkxMzA1IDoge30pO3ZhciBxLHI7Yi5yZWFkeT1uZXcgUHJvbWlzZShmdW5jdGlvbihhLGMpe3E9YTtyPWN9KTt2YXIgdT17fSx3O2Zvcih3IGluIGIpYi5oYXNPd25Qcm9wZXJ0eSh3KSYmKHVbd109Ylt3XSk7dmFyIHg9XCJvYmplY3RcIj09PXR5cGVvZiB3aW5kb3cseT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgaW1wb3J0U2NyaXB0cyx6PVwib2JqZWN0XCI9PT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxCPVwiXCIsQyxELEUsRixHO1xuaWYoeilCPXk/cmVxdWlyZShcInBhdGhcIikuZGlybmFtZShCKStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsQz1mdW5jdGlvbihhLGMpe3ZhciBkPUgoYSk7aWYoZClyZXR1cm4gYz9kOmQudG9TdHJpbmcoKTtGfHwoRj1yZXF1aXJlKFwiZnNcIikpO0d8fChHPXJlcXVpcmUoXCJwYXRoXCIpKTthPUcubm9ybWFsaXplKGEpO3JldHVybiBGLnJlYWRGaWxlU3luYyhhLGM/bnVsbDpcInV0ZjhcIil9LEU9ZnVuY3Rpb24oYSl7YT1DKGEsITApO2EuYnVmZmVyfHwoYT1uZXcgVWludDhBcnJheShhKSk7YXNzZXJ0KGEuYnVmZmVyKTtyZXR1cm4gYX0sRD1mdW5jdGlvbihhLGMsZCl7dmFyIGU9SChhKTtlJiZjKGUpO0Z8fChGPXJlcXVpcmUoXCJmc1wiKSk7R3x8KEc9cmVxdWlyZShcInBhdGhcIikpO2E9Ry5ub3JtYWxpemUoYSk7Ri5yZWFkRmlsZShhLGZ1bmN0aW9uKGYsbCl7Zj9kKGYpOmMobC5idWZmZXIpfSl9LDE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmcHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLFxuYi5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifTtlbHNlIGlmKHh8fHkpeT9CPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoQj1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKEI9X3NjcmlwdERpciksMCE9PUIuaW5kZXhPZihcImJsb2I6XCIpP0I9Qi5zdWJzdHIoMCxCLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpCPVwiXCIsQz1mdW5jdGlvbihhKXt0cnl7dmFyIGM9bmV3IFhNTEh0dHBSZXF1ZXN0O2Mub3BlbihcIkdFVFwiLGEsITEpO2Muc2VuZChudWxsKTtyZXR1cm4gYy5yZXNwb25zZVRleHR9Y2F0Y2goZil7aWYoYT1IKGEpKXtjPVtdO2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT1hW2RdOzI1NTxlJiYoYmEmJmFzc2VydCghMSxcIkNoYXJhY3RlciBjb2RlIFwiK2UrXCIgKFwiK1N0cmluZy5mcm9tQ2hhckNvZGUoZSkrXCIpICBhdCBvZmZzZXQgXCIrXG5kK1wiIG5vdCBpbiAweDAwLTB4RkYuXCIpLGUmPTI1NSk7Yy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpfXJldHVybiBjLmpvaW4oXCJcIil9dGhyb3cgZjt9fSx5JiYoRT1mdW5jdGlvbihhKXt0cnl7dmFyIGM9bmV3IFhNTEh0dHBSZXF1ZXN0O2Mub3BlbihcIkdFVFwiLGEsITEpO2MucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIjtjLnNlbmQobnVsbCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KGMucmVzcG9uc2UpfWNhdGNoKGQpe2lmKGE9SChhKSlyZXR1cm4gYTt0aHJvdyBkO319KSxEPWZ1bmN0aW9uKGEsYyxkKXt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7ZS5vcGVuKFwiR0VUXCIsYSwhMCk7ZS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO2Uub25sb2FkPWZ1bmN0aW9uKCl7aWYoMjAwPT1lLnN0YXR1c3x8MD09ZS5zdGF0dXMmJmUucmVzcG9uc2UpYyhlLnJlc3BvbnNlKTtlbHNle3ZhciBmPUgoYSk7Zj9jKGYuYnVmZmVyKTpkKCl9fTtlLm9uZXJyb3I9ZDtlLnNlbmQobnVsbCl9O1xuYi5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKTt2YXIgST1iLnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtmb3IodyBpbiB1KXUuaGFzT3duUHJvcGVydHkodykmJihiW3ddPXVbd10pO3U9bnVsbDt2YXIgSjtiLndhc21CaW5hcnkmJihKPWIud2FzbUJpbmFyeSk7dmFyIG5vRXhpdFJ1bnRpbWU9Yi5ub0V4aXRSdW50aW1lfHwhMDtcIm9iamVjdFwiIT09dHlwZW9mIFdlYkFzc2VtYmx5JiZLKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgTCxNPSExO2Z1bmN0aW9uIGFzc2VydChhLGMpe2F8fEsoXCJBc3NlcnRpb24gZmFpbGVkOiBcIitjKX1mdW5jdGlvbiBOKGEpe3ZhciBjPWJbXCJfXCIrYV07YXNzZXJ0KGMsXCJDYW5ub3QgY2FsbCB1bmtub3duIGZ1bmN0aW9uIFwiK2ErXCIsIG1ha2Ugc3VyZSBpdCBpcyBleHBvcnRlZFwiKTtyZXR1cm4gY31cbmZ1bmN0aW9uIGNhKGEsYyxkLGUpe3ZhciBmPXtzdHJpbmc6ZnVuY3Rpb24oZyl7dmFyIHA9MDtpZihudWxsIT09ZyYmdm9pZCAwIT09ZyYmMCE9PWcpe3ZhciBuPShnLmxlbmd0aDw8MikrMTtwPU8obik7dmFyIGs9cCxoPVA7aWYoMDxuKXtuPWsrbi0xO2Zvcih2YXIgdj0wO3Y8Zy5sZW5ndGg7Kyt2KXt2YXIgbT1nLmNoYXJDb2RlQXQodik7aWYoNTUyOTY8PW0mJjU3MzQzPj1tKXt2YXIgb2E9Zy5jaGFyQ29kZUF0KCsrdik7bT02NTUzNisoKG0mMTAyMyk8PDEwKXxvYSYxMDIzfWlmKDEyNz49bSl7aWYoaz49bilicmVhaztoW2srK109bX1lbHNle2lmKDIwNDc+PW0pe2lmKGsrMT49bilicmVhaztoW2srK109MTkyfG0+PjZ9ZWxzZXtpZig2NTUzNT49bSl7aWYoaysyPj1uKWJyZWFrO2hbaysrXT0yMjR8bT4+MTJ9ZWxzZXtpZihrKzM+PW4pYnJlYWs7aFtrKytdPTI0MHxtPj4xODtoW2srK109MTI4fG0+PjEyJjYzfWhbaysrXT0xMjh8bT4+NiY2M31oW2srK109MTI4fG0mNjN9fWhba109XG4wfX1yZXR1cm4gcH0sYXJyYXk6ZnVuY3Rpb24oZyl7dmFyIHA9TyhnLmxlbmd0aCk7US5zZXQoZyxwKTtyZXR1cm4gcH19LGw9TihhKSxBPVtdO2E9MDtpZihlKWZvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXt2YXIgYWE9ZltkW3RdXTthYT8oMD09PWEmJihhPWRhKCkpLEFbdF09YWEoZVt0XSkpOkFbdF09ZVt0XX1kPWwuYXBwbHkobnVsbCxBKTtkPWZ1bmN0aW9uKGcpe2lmKFwic3RyaW5nXCI9PT1jKWlmKGcpe2Zvcih2YXIgcD1QLG49ZytOYU4saz1nO3Bba10mJiEoaz49bik7KSsraztpZigxNjxrLWcmJnAuc3ViYXJyYXkmJmVhKWc9ZWEuZGVjb2RlKHAuc3ViYXJyYXkoZyxrKSk7ZWxzZXtmb3Iobj1cIlwiO2c8azspe3ZhciBoPXBbZysrXTtpZihoJjEyOCl7dmFyIHY9cFtnKytdJjYzO2lmKDE5Mj09KGgmMjI0KSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChoJjMxKTw8Nnx2KTtlbHNle3ZhciBtPXBbZysrXSY2MztoPTIyND09KGgmMjQwKT8oaCYxNSk8PDEyfHY8PDZ8bTooaCY3KTw8XG4xOHx2PDwxMnxtPDw2fHBbZysrXSY2Mzs2NTUzNj5oP24rPVN0cmluZy5mcm9tQ2hhckNvZGUoaCk6KGgtPTY1NTM2LG4rPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8aD4+MTAsNTYzMjB8aCYxMDIzKSl9fWVsc2Ugbis9U3RyaW5nLmZyb21DaGFyQ29kZShoKX1nPW59fWVsc2UgZz1cIlwiO2Vsc2UgZz1cImJvb2xlYW5cIj09PWM/ISFnOmc7cmV0dXJuIGd9KGQpOzAhPT1hJiZmYShhKTtyZXR1cm4gZH12YXIgZWE9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMCxoYSxRLFA7XG5mdW5jdGlvbiBpYSgpe3ZhciBhPUwuYnVmZmVyO2hhPWE7Yi5IRUFQOD1RPW5ldyBJbnQ4QXJyYXkoYSk7Yi5IRUFQMTY9bmV3IEludDE2QXJyYXkoYSk7Yi5IRUFQMzI9bmV3IEludDMyQXJyYXkoYSk7Yi5IRUFQVTg9UD1uZXcgVWludDhBcnJheShhKTtiLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGEpO2IuSEVBUFUzMj1uZXcgVWludDMyQXJyYXkoYSk7Yi5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoYSk7Yi5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoYSl9dmFyIFIsamE9W10sa2E9W10sbGE9W107ZnVuY3Rpb24gbWEoKXt2YXIgYT1iLnByZVJ1bi5zaGlmdCgpO2phLnVuc2hpZnQoYSl9dmFyIFM9MCxUPW51bGwsVT1udWxsO2IucHJlbG9hZGVkSW1hZ2VzPXt9O2IucHJlbG9hZGVkQXVkaW9zPXt9O1xuZnVuY3Rpb24gSyhhKXtpZihiLm9uQWJvcnQpYi5vbkFib3J0KGEpO0koYSk7TT0hMDthPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoXCJhYm9ydChcIithK1wiKS4gQnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgZm9yIG1vcmUgaW5mby5cIik7cihhKTt0aHJvdyBhO312YXIgVj1cImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIixXO1c9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsQUdGemJRRUFBQUFCSUFaZ0FYOEJmMkFEZjM5L0FHQUJmd0JnQUFCZ0FBRi9ZQVovZjM5L2YzOEFBZ2NCQVdFQllRQUFBd3NLQUFFREFRQUFBZ1FGQWdRRkFYQUJBUUVGQndFQmdBS0FnQUlHQ1FGL0FVR0FqTUFDQ3djbENRRmlBZ0FCWXdBREFXUUFDUUZsQUFnQlpnQUhBV2NBQmdGb0FBVUJhUUFLQVdvQkFBcUdUUXBQQVFKL1FZQUlLQUlBSWdFZ0FFRURha0Y4Y1NJQ2FpRUFBa0FnQWtFQUlBQWdBVTBiRFFBZ0FEOEFRUkIwU3dSQUlBQVFBRVVOQVF0QmdBZ2dBRFlDQUNBQkR3dEJoQWhCTURZQ0FFRi9DNHdGQWc1K0NuOGdBQ2dDSkNFVUlBQW9BaUFoRlNBQUtBSWNJUkVnQUNnQ0dDRVNJQUFvQWhRaEV5QUNRUkJQQkVBZ0FDMEFURVZCR0hRaEZ5QUFLQUlFSWhaQkJXeXRJUThnQUNnQ0NDSVlRUVZzclNFTklBQW9BZ3dpR1VFRmJLMGhDeUFBS0FJUUlocEJCV3l0SVFrZ0FEVUNBQ0VJSUJxdElSQWdHYTBoRGlBWXJTRU1JQmF0SVFvRFFDQVNJQUV0QUFNaUVpQUJMUUFFUVFoMGNpQUJMUUFGUVJCMGNpQUJMUUFHSWhaQkdIUnlRUUoyUWYvLy94OXhhcTBpQXlBT2ZpQUJMd0FBSUFFdEFBSkJFSFJ5SUJOcUlCSkJHSFJCZ0lDQUdIRnFyU0lFSUJCK2ZDQVJJQUV0QUFkQkNIUWdGbklnQVMwQUNFRVFkSElnQVMwQUNTSVJRUmgwY2tFRWRrSC8vLzhmY1dxdElnVWdESDU4SUFFdEFBcEJDSFFnRVhJZ0FTMEFDMEVRZEhJZ0FTMEFERUVZZEhKQkJuWWdGV3F0SWdZZ0NuNThJQlFnRjJvZ0FTOEFEU0FCTFFBUFFSQjBjbXF0SWdjZ0NINThJQU1nREg0Z0JDQU9mbndnQlNBS2Zud2dCaUFJZm53Z0J5QUpmbndnQXlBS2ZpQUVJQXgrZkNBRklBaCtmQ0FHSUFsK2ZDQUhJQXQrZkNBRElBaCtJQVFnQ241OElBVWdDWDU4SUFZZ0MzNThJQWNnRFg1OElBTWdDWDRnQkNBSWZud2dCU0FMZm53Z0JpQU5mbndnQnlBUGZud2lBMElhaUVMLy8vLy9ENE44SWdSQ0dvaEMvLy8vL3crRGZDSUZRaHFJUXYvLy8vOFBnM3dpQmtJYWlFTC8vLy8vRDROOElnZENHb2luUVFWc0lBT25RZi8vL3g5eGFpSVRRUnAySUFTblFmLy8veDl4YWlFU0lBV25RZi8vL3g5eElSRWdCcWRCLy8vL0gzRWhGU0FIcDBILy8vOGZjU0VVSUJOQi8vLy9IM0VoRXlBQlFSQnFJUUVnQWtFUWF5SUNRUTlMRFFBTEN5QUFJQlEyQWlRZ0FDQVZOZ0lnSUFBZ0VUWUNIQ0FBSUJJMkFoZ2dBQ0FUTmdJVUN3TUFBUXUyQkFFR2Z3SkFJQUFvQWpnaUJBUkFJQUJCUEdvaEJRSkFJQUpCRUNBRWF5SURJQUlnQTBrYklnWkZEUUFnQmtFRGNTRUhBa0FnQmtFQmEwRURTUVJBUVFBaEF3d0JDeUFHUVh4eElRaEJBQ0VEQTBBZ0JTQURJQVJxYWlBQklBTnFMUUFBT2dBQUlBVWdBMEVCY2lJRUlBQW9BamhxYWlBQklBUnFMUUFBT2dBQUlBVWdBMEVDY2lJRUlBQW9BamhxYWlBQklBUnFMUUFBT2dBQUlBVWdBMEVEY2lJRUlBQW9BamhxYWlBQklBUnFMUUFBT2dBQUlBTkJCR29oQXlBQUtBSTRJUVFnQ0VFRWF5SUlEUUFMQ3lBSFJRMEFBMEFnQlNBRElBUnFhaUFCSUFOcUxRQUFPZ0FBSUFOQkFXb2hBeUFBS0FJNElRUWdCMEVCYXlJSERRQUxDeUFBSUFRZ0Jtb2lBellDT0NBRFFSQkpEUUVnQUNBRlFSQVFBaUFBUVFBMkFqZ2dBaUFHYXlFQ0lBRWdCbW9oQVFzZ0FrRVFUd1JBSUFBZ0FTQUNRWEJ4SWdNUUFpQUNRUTl4SVFJZ0FTQURhaUVCQ3lBQ1JRMEFJQUpCQTNFaEJDQUFRVHhxSVFWQkFDRURJQUpCQVd0QkEwOEVRQ0FDUVh4eElRY0RRQ0FGSUFBb0FqZ2dBMnBxSUFFZ0Eyb3RBQUE2QUFBZ0JTQURRUUZ5SWdZZ0FDZ0NPR3BxSUFFZ0Jtb3RBQUE2QUFBZ0JTQURRUUp5SWdZZ0FDZ0NPR3BxSUFFZ0Jtb3RBQUE2QUFBZ0JTQURRUU55SWdZZ0FDZ0NPR3BxSUFFZ0Jtb3RBQUE2QUFBZ0EwRUVhaUVESUFkQkJHc2lCdzBBQ3dzZ0JBUkFBMEFnQlNBQUtBSTRJQU5xYWlBQklBTnFMUUFBT2dBQUlBTkJBV29oQXlBRVFRRnJJZ1FOQUFzTElBQWdBQ2dDT0NBQ2FqWUNPQXNMb1MwQkRIOGpBRUVRYXlJTUpBQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FFSDBBVTBFUUVHSUNDZ0NBQ0lGUVJBZ0FFRUxha0Y0Y1NBQVFRdEpHeUlJUVFOMklnSjJJZ0ZCQTNFRVFDQUJRWDl6UVFGeElBSnFJZ05CQTNRaUFVRzRDR29vQWdBaUJFRUlhaUVBQWtBZ0JDZ0NDQ0lDSUFGQnNBaHFJZ0ZHQkVCQmlBZ2dCVUYrSUFOM2NUWUNBQXdCQ3lBQ0lBRTJBZ3dnQVNBQ05nSUlDeUFFSUFOQkEzUWlBVUVEY2pZQ0JDQUJJQVJxSWdFZ0FTZ0NCRUVCY2pZQ0JBd05DeUFJUVpBSUtBSUFJZ3BORFFFZ0FRUkFBa0JCQWlBQ2RDSUFRUUFnQUd0eUlBRWdBblJ4SWdCQkFDQUFhM0ZCQVdzaUFDQUFRUXgyUVJCeElnSjJJZ0ZCQlhaQkNIRWlBQ0FDY2lBQklBQjJJZ0ZCQW5aQkJIRWlBSElnQVNBQWRpSUJRUUYyUVFKeElnQnlJQUVnQUhZaUFVRUJka0VCY1NJQWNpQUJJQUIyYWlJRFFRTjBJZ0JCdUFocUtBSUFJZ1FvQWdnaUFTQUFRYkFJYWlJQVJnUkFRWWdJSUFWQmZpQURkM0VpQlRZQ0FBd0JDeUFCSUFBMkFnd2dBQ0FCTmdJSUN5QUVRUWhxSVFBZ0JDQUlRUU55TmdJRUlBUWdDR29pQWlBRFFRTjBJZ0VnQ0dzaUEwRUJjallDQkNBQklBUnFJQU0yQWdBZ0NnUkFJQXBCQTNZaUFVRURkRUd3Q0dvaEIwR2NDQ2dDQUNFRUFuOGdCVUVCSUFGMElnRnhSUVJBUVlnSUlBRWdCWEkyQWdBZ0J3d0JDeUFIS0FJSUN5RUJJQWNnQkRZQ0NDQUJJQVEyQWd3Z0JDQUhOZ0lNSUFRZ0FUWUNDQXRCbkFnZ0FqWUNBRUdRQ0NBRE5nSUFEQTBMUVl3SUtBSUFJZ1pGRFFFZ0JrRUFJQVpyY1VFQmF5SUFJQUJCREhaQkVIRWlBbllpQVVFRmRrRUljU0lBSUFKeUlBRWdBSFlpQVVFQ2RrRUVjU0lBY2lBQklBQjJJZ0ZCQVhaQkFuRWlBSElnQVNBQWRpSUJRUUYyUVFGeElnQnlJQUVnQUhacVFRSjBRYmdLYWlnQ0FDSUJLQUlFUVhoeElBaHJJUU1nQVNFQ0EwQUNRQ0FDS0FJUUlnQkZCRUFnQWlnQ0ZDSUFSUTBCQ3lBQUtBSUVRWGh4SUFocklnSWdBeUFDSUFOSklnSWJJUU1nQUNBQklBSWJJUUVnQUNFQ0RBRUxDeUFCSUFocUlna2dBVTBOQWlBQktBSVlJUXNnQVNBQktBSU1JZ1JIQkVBZ0FTZ0NDQ0lBUVpnSUtBSUFTUm9nQUNBRU5nSU1JQVFnQURZQ0NBd01DeUFCUVJScUlnSW9BZ0FpQUVVRVFDQUJLQUlRSWdCRkRRUWdBVUVRYWlFQ0N3TkFJQUloQnlBQUlnUkJGR29pQWlnQ0FDSUFEUUFnQkVFUWFpRUNJQVFvQWhBaUFBMEFDeUFIUVFBMkFnQU1Dd3RCZnlFSUlBQkJ2MzlMRFFBZ0FFRUxhaUlBUVhoeElRaEJqQWdvQWdBaUNVVU5BRUVBSUFocklRTUNRQUpBQWtBQ2YwRUFJQWhCZ0FKSkRRQWFRUjhnQ0VILy8vOEhTdzBBR2lBQVFRaDJJZ0FnQUVHQS9qOXFRUkIyUVFoeElnSjBJZ0FnQUVHQTRCOXFRUkIyUVFSeElnRjBJZ0FnQUVHQWdBOXFRUkIyUVFKeElnQjBRUTkySUFFZ0FuSWdBSEpySWdCQkFYUWdDQ0FBUVJWcWRrRUJjWEpCSEdvTElnVkJBblJCdUFwcUtBSUFJZ0pGQkVCQkFDRUFEQUVMUVFBaEFDQUlRUUJCR1NBRlFRRjJheUFGUVI5R0czUWhBUU5BQWtBZ0FpZ0NCRUY0Y1NBSWF5SUhJQU5QRFFBZ0FpRUVJQWNpQXcwQVFRQWhBeUFDSVFBTUF3c2dBQ0FDS0FJVUlnY2dCeUFDSUFGQkhYWkJCSEZxS0FJUUlnSkdHeUFBSUFjYklRQWdBVUVCZENFQklBSU5BQXNMSUFBZ0JISkZCRUJCQUNFRVFRSWdCWFFpQUVFQUlBQnJjaUFKY1NJQVJRMERJQUJCQUNBQWEzRkJBV3NpQUNBQVFReDJRUkJ4SWdKMklnRkJCWFpCQ0hFaUFDQUNjaUFCSUFCMklnRkJBblpCQkhFaUFISWdBU0FBZGlJQlFRRjJRUUp4SWdCeUlBRWdBSFlpQVVFQmRrRUJjU0lBY2lBQklBQjJha0VDZEVHNENtb29BZ0FoQUFzZ0FFVU5BUXNEUUNBQUtBSUVRWGh4SUFocklnRWdBMGtoQWlBQklBTWdBaHNoQXlBQUlBUWdBaHNoQkNBQUtBSVFJZ0VFZnlBQkJTQUFLQUlVQ3lJQURRQUxDeUFFUlEwQUlBTkJrQWdvQWdBZ0NHdFBEUUFnQkNBSWFpSUdJQVJORFFFZ0JDZ0NHQ0VGSUFRZ0JDZ0NEQ0lCUndSQUlBUW9BZ2dpQUVHWUNDZ0NBRWthSUFBZ0FUWUNEQ0FCSUFBMkFnZ01DZ3NnQkVFVWFpSUNLQUlBSWdCRkJFQWdCQ2dDRUNJQVJRMEVJQVJCRUdvaEFnc0RRQ0FDSVFjZ0FDSUJRUlJxSWdJb0FnQWlBQTBBSUFGQkVHb2hBaUFCS0FJUUlnQU5BQXNnQjBFQU5nSUFEQWtMSUFoQmtBZ29BZ0FpQWswRVFFR2NDQ2dDQUNFREFrQWdBaUFJYXlJQlFSQlBCRUJCa0FnZ0FUWUNBRUdjQ0NBRElBaHFJZ0EyQWdBZ0FDQUJRUUZ5TmdJRUlBSWdBMm9nQVRZQ0FDQURJQWhCQTNJMkFnUU1BUXRCbkFoQkFEWUNBRUdRQ0VFQU5nSUFJQU1nQWtFRGNqWUNCQ0FDSUFOcUlnQWdBQ2dDQkVFQmNqWUNCQXNnQTBFSWFpRUFEQXNMSUFoQmxBZ29BZ0FpQmtrRVFFR1VDQ0FHSUFocklnRTJBZ0JCb0FoQm9BZ29BZ0FpQWlBSWFpSUFOZ0lBSUFBZ0FVRUJjallDQkNBQ0lBaEJBM0kyQWdRZ0FrRUlhaUVBREFzTFFRQWhBQ0FJUVM5cUlna0NmMEhnQ3lnQ0FBUkFRZWdMS0FJQURBRUxRZXdMUW44M0FnQkI1QXRDZ0tDQWdJQ0FCRGNDQUVIZ0N5QU1RUXhxUVhCeFFkaXExYW9GY3pZQ0FFSDBDMEVBTmdJQVFjUUxRUUEyQWdCQmdDQUxJZ0ZxSWdWQkFDQUJheUlIY1NJQ0lBaE5EUXBCd0Fzb0FnQWlCQVJBUWJnTEtBSUFJZ01nQW1vaUFTQURUUTBMSUFFZ0JFc05Dd3RCeEFzdEFBQkJCSEVOQlFKQUFrQkJvQWdvQWdBaUF3UkFRY2dMSVFBRFFDQURJQUFvQWdBaUFVOEVRQ0FCSUFBb0FnUnFJQU5MRFFNTElBQW9BZ2dpQUEwQUN3dEJBQkFCSWdGQmYwWU5CaUFDSVFWQjVBc29BZ0FpQTBFQmF5SUFJQUZ4QkVBZ0FpQUJheUFBSUFGcVFRQWdBMnR4YWlFRkN5QUZJQWhORFFZZ0JVSCsvLy8vQjBzTkJrSEFDeWdDQUNJRUJFQkJ1QXNvQWdBaUF5QUZhaUlBSUFOTkRRY2dBQ0FFU3cwSEN5QUZFQUVpQUNBQlJ3MEJEQWdMSUFVZ0Jtc2dCM0VpQlVIKy8vLy9CMHNOQlNBRkVBRWlBU0FBS0FJQUlBQW9BZ1JxUmcwRUlBRWhBQXNDUUNBQVFYOUdEUUFnQ0VFd2FpQUZUUTBBUWVnTEtBSUFJZ0VnQ1NBRmEycEJBQ0FCYTNFaUFVSCsvLy8vQjBzRVFDQUFJUUVNQ0FzZ0FSQUJRWDlIQkVBZ0FTQUZhaUVGSUFBaEFRd0lDMEVBSUFWckVBRWFEQVVMSUFBaUFVRi9SdzBHREFRTEFBdEJBQ0VFREFjTFFRQWhBUXdGQ3lBQlFYOUhEUUlMUWNRTFFjUUxLQUlBUVFSeU5nSUFDeUFDUWY3Ly8vOEhTdzBCSUFJUUFTRUJRUUFRQVNFQUlBRkJmMFlOQVNBQVFYOUdEUUVnQUNBQlRRMEJJQUFnQVdzaUJTQUlRU2hxVFEwQkMwRzRDMEc0Q3lnQ0FDQUZhaUlBTmdJQVFid0xLQUlBSUFCSkJFQkJ2QXNnQURZQ0FBc0NRQUpBQWtCQm9BZ29BZ0FpQndSQVFjZ0xJUUFEUUNBQklBQW9BZ0FpQXlBQUtBSUVJZ0pxUmcwQ0lBQW9BZ2dpQUEwQUN3d0NDMEdZQ0NnQ0FDSUFRUUFnQUNBQlRSdEZCRUJCbUFnZ0FUWUNBQXRCQUNFQVFjd0xJQVUyQWdCQnlBc2dBVFlDQUVHb0NFRi9OZ0lBUWF3SVFlQUxLQUlBTmdJQVFkUUxRUUEyQWdBRFFDQUFRUU4wSWdOQnVBaHFJQU5Cc0FocUlnSTJBZ0FnQTBHOENHb2dBallDQUNBQVFRRnFJZ0JCSUVjTkFBdEJsQWdnQlVFb2F5SURRWGdnQVd0QkIzRkJBQ0FCUVFocVFRZHhHeUlBYXlJQ05nSUFRYUFJSUFBZ0FXb2lBRFlDQUNBQUlBSkJBWEkyQWdRZ0FTQURha0VvTmdJRVFhUUlRZkFMS0FJQU5nSUFEQUlMSUFBdEFBeEJDSEVOQUNBRElBZExEUUFnQVNBSFRRMEFJQUFnQWlBRmFqWUNCRUdnQ0NBSFFYZ2dCMnRCQjNGQkFDQUhRUWhxUVFkeEd5SUFhaUlDTmdJQVFaUUlRWlFJS0FJQUlBVnFJZ0VnQUdzaUFEWUNBQ0FDSUFCQkFYSTJBZ1FnQVNBSGFrRW9OZ0lFUWFRSVFmQUxLQUlBTmdJQURBRUxRWmdJS0FJQUlBRkxCRUJCbUFnZ0FUWUNBQXNnQVNBRmFpRUNRY2dMSVFBQ1FBSkFBa0FDUUFKQUFrQURRQ0FDSUFBb0FnQkhCRUFnQUNnQ0NDSUFEUUVNQWdzTElBQXRBQXhCQ0hGRkRRRUxRY2dMSVFBRFFDQUhJQUFvQWdBaUFrOEVRQ0FDSUFBb0FnUnFJZ1FnQjBzTkF3c2dBQ2dDQ0NFQURBQUxBQXNnQUNBQk5nSUFJQUFnQUNnQ0JDQUZhallDQkNBQlFYZ2dBV3RCQjNGQkFDQUJRUWhxUVFkeEcyb2lDU0FJUVFOeU5nSUVJQUpCZUNBQ2EwRUhjVUVBSUFKQkNHcEJCM0ViYWlJRklBZ2dDV29pQm1zaEFpQUZJQWRHQkVCQm9BZ2dCallDQUVHVUNFR1VDQ2dDQUNBQ2FpSUFOZ0lBSUFZZ0FFRUJjallDQkF3REN5QUZRWndJS0FJQVJnUkFRWndJSUFZMkFnQkJrQWhCa0Fnb0FnQWdBbW9pQURZQ0FDQUdJQUJCQVhJMkFnUWdBQ0FHYWlBQU5nSUFEQU1MSUFVb0FnUWlBRUVEY1VFQlJnUkFJQUJCZUhFaEJ3SkFJQUJCL3dGTkJFQWdCU2dDQ0NJRElBQkJBM1lpQUVFRGRFR3dDR3BHR2lBRElBVW9BZ3dpQVVZRVFFR0lDRUdJQ0NnQ0FFRitJQUIzY1RZQ0FBd0NDeUFESUFFMkFnd2dBU0FETmdJSURBRUxJQVVvQWhnaENBSkFJQVVnQlNnQ0RDSUJSd1JBSUFVb0FnZ2lBQ0FCTmdJTUlBRWdBRFlDQ0F3QkN3SkFJQVZCRkdvaUFDZ0NBQ0lERFFBZ0JVRVFhaUlBS0FJQUlnTU5BRUVBSVFFTUFRc0RRQ0FBSVFRZ0F5SUJRUlJxSWdBb0FnQWlBdzBBSUFGQkVHb2hBQ0FCS0FJUUlnTU5BQXNnQkVFQU5nSUFDeUFJUlEwQUFrQWdCU0FGS0FJY0lnTkJBblJCdUFwcUlnQW9BZ0JHQkVBZ0FDQUJOZ0lBSUFFTkFVR01DRUdNQ0NnQ0FFRitJQU4zY1RZQ0FBd0NDeUFJUVJCQkZDQUlLQUlRSUFWR0cyb2dBVFlDQUNBQlJRMEJDeUFCSUFnMkFoZ2dCU2dDRUNJQUJFQWdBU0FBTmdJUUlBQWdBVFlDR0FzZ0JTZ0NGQ0lBUlEwQUlBRWdBRFlDRkNBQUlBRTJBaGdMSUFVZ0Iyb2hCU0FDSUFkcUlRSUxJQVVnQlNnQ0JFRitjVFlDQkNBR0lBSkJBWEkyQWdRZ0FpQUdhaUFDTmdJQUlBSkIvd0ZOQkVBZ0FrRURkaUlBUVFOMFFiQUlhaUVDQW45QmlBZ29BZ0FpQVVFQklBQjBJZ0J4UlFSQVFZZ0lJQUFnQVhJMkFnQWdBZ3dCQ3lBQ0tBSUlDeUVBSUFJZ0JqWUNDQ0FBSUFZMkFnd2dCaUFDTmdJTUlBWWdBRFlDQ0F3REMwRWZJUUFnQWtILy8vOEhUUVJBSUFKQkNIWWlBQ0FBUVlEK1AycEJFSFpCQ0hFaUEzUWlBQ0FBUVlEZ0gycEJFSFpCQkhFaUFYUWlBQ0FBUVlDQUQycEJFSFpCQW5FaUFIUkJEM1lnQVNBRGNpQUFjbXNpQUVFQmRDQUNJQUJCRldwMlFRRnhja0VjYWlFQUN5QUdJQUEyQWh3Z0JrSUFOd0lRSUFCQkFuUkJ1QXBxSVFRQ1FFR01DQ2dDQUNJRFFRRWdBSFFpQVhGRkJFQkJqQWdnQVNBRGNqWUNBQ0FFSUFZMkFnQWdCaUFFTmdJWURBRUxJQUpCQUVFWklBQkJBWFpySUFCQkgwWWJkQ0VBSUFRb0FnQWhBUU5BSUFFaUF5Z0NCRUY0Y1NBQ1JnMERJQUJCSFhZaEFTQUFRUUYwSVFBZ0F5QUJRUVJ4YWlJRUtBSVFJZ0VOQUFzZ0JDQUdOZ0lRSUFZZ0F6WUNHQXNnQmlBR05nSU1JQVlnQmpZQ0NBd0NDMEdVQ0NBRlFTaHJJZ05CZUNBQmEwRUhjVUVBSUFGQkNHcEJCM0ViSWdCcklnSTJBZ0JCb0FnZ0FDQUJhaUlBTmdJQUlBQWdBa0VCY2pZQ0JDQUJJQU5xUVNnMkFnUkJwQWhCOEFzb0FnQTJBZ0FnQnlBRVFTY2dCR3RCQjNGQkFDQUVRU2RyUVFkeEcycEJMMnNpQUNBQUlBZEJFR3BKR3lJQ1FSczJBZ1FnQWtIUUN5a0NBRGNDRUNBQ1FjZ0xLUUlBTndJSVFkQUxJQUpCQ0dvMkFnQkJ6QXNnQlRZQ0FFSElDeUFCTmdJQVFkUUxRUUEyQWdBZ0FrRVlhaUVBQTBBZ0FFRUhOZ0lFSUFCQkNHb2hBU0FBUVFScUlRQWdBU0FFU1EwQUN5QUNJQWRHRFFNZ0FpQUNLQUlFUVg1eE5nSUVJQWNnQWlBSGF5SUVRUUZ5TmdJRUlBSWdCRFlDQUNBRVFmOEJUUVJBSUFSQkEzWWlBRUVEZEVHd0NHb2hBZ0ovUVlnSUtBSUFJZ0ZCQVNBQWRDSUFjVVVFUUVHSUNDQUFJQUZ5TmdJQUlBSU1BUXNnQWlnQ0NBc2hBQ0FDSUFjMkFnZ2dBQ0FITmdJTUlBY2dBallDRENBSElBQTJBZ2dNQkF0Qkh5RUFJQWRDQURjQ0VDQUVRZi8vL3dkTkJFQWdCRUVJZGlJQUlBQkJnUDQvYWtFUWRrRUljU0lDZENJQUlBQkJnT0FmYWtFUWRrRUVjU0lCZENJQUlBQkJnSUFQYWtFUWRrRUNjU0lBZEVFUGRpQUJJQUp5SUFCeWF5SUFRUUYwSUFRZ0FFRVZhblpCQVhGeVFSeHFJUUFMSUFjZ0FEWUNIQ0FBUVFKMFFiZ0thaUVEQWtCQmpBZ29BZ0FpQWtFQklBQjBJZ0Z4UlFSQVFZd0lJQUVnQW5JMkFnQWdBeUFITmdJQUlBY2dBellDR0F3QkN5QUVRUUJCR1NBQVFRRjJheUFBUVI5R0czUWhBQ0FES0FJQUlRRURRQ0FCSWdJb0FnUkJlSEVnQkVZTkJDQUFRUjEySVFFZ0FFRUJkQ0VBSUFJZ0FVRUVjV29pQXlnQ0VDSUJEUUFMSUFNZ0J6WUNFQ0FISUFJMkFoZ0xJQWNnQnpZQ0RDQUhJQWMyQWdnTUF3c2dBeWdDQ0NJQUlBWTJBZ3dnQXlBR05nSUlJQVpCQURZQ0dDQUdJQU0yQWd3Z0JpQUFOZ0lJQ3lBSlFRaHFJUUFNQlFzZ0FpZ0NDQ0lBSUFjMkFnd2dBaUFITmdJSUlBZEJBRFlDR0NBSElBSTJBZ3dnQnlBQU5nSUlDMEdVQ0NnQ0FDSUFJQWhORFFCQmxBZ2dBQ0FJYXlJQk5nSUFRYUFJUWFBSUtBSUFJZ0lnQ0dvaUFEWUNBQ0FBSUFGQkFYSTJBZ1FnQWlBSVFRTnlOZ0lFSUFKQkNHb2hBQXdEQzBHRUNFRXdOZ0lBUVFBaEFBd0NDd0pBSUFWRkRRQUNRQ0FFS0FJY0lnSkJBblJCdUFwcUlnQW9BZ0FnQkVZRVFDQUFJQUUyQWdBZ0FRMEJRWXdJSUFsQmZpQUNkM0VpQ1RZQ0FBd0NDeUFGUVJCQkZDQUZLQUlRSUFSR0cyb2dBVFlDQUNBQlJRMEJDeUFCSUFVMkFoZ2dCQ2dDRUNJQUJFQWdBU0FBTmdJUUlBQWdBVFlDR0FzZ0JDZ0NGQ0lBUlEwQUlBRWdBRFlDRkNBQUlBRTJBaGdMQWtBZ0EwRVBUUVJBSUFRZ0F5QUlhaUlBUVFOeU5nSUVJQUFnQkdvaUFDQUFLQUlFUVFGeU5nSUVEQUVMSUFRZ0NFRURjallDQkNBR0lBTkJBWEkyQWdRZ0F5QUdhaUFETmdJQUlBTkIvd0ZOQkVBZ0EwRURkaUlBUVFOMFFiQUlhaUVDQW45QmlBZ29BZ0FpQVVFQklBQjBJZ0J4UlFSQVFZZ0lJQUFnQVhJMkFnQWdBZ3dCQ3lBQ0tBSUlDeUVBSUFJZ0JqWUNDQ0FBSUFZMkFnd2dCaUFDTmdJTUlBWWdBRFlDQ0F3QkMwRWZJUUFnQTBILy8vOEhUUVJBSUFOQkNIWWlBQ0FBUVlEK1AycEJFSFpCQ0hFaUFuUWlBQ0FBUVlEZ0gycEJFSFpCQkhFaUFYUWlBQ0FBUVlDQUQycEJFSFpCQW5FaUFIUkJEM1lnQVNBQ2NpQUFjbXNpQUVFQmRDQURJQUJCRldwMlFRRnhja0VjYWlFQUN5QUdJQUEyQWh3Z0JrSUFOd0lRSUFCQkFuUkJ1QXBxSVFJQ1FBSkFJQWxCQVNBQWRDSUJjVVVFUUVHTUNDQUJJQWx5TmdJQUlBSWdCallDQUNBR0lBSTJBaGdNQVFzZ0EwRUFRUmtnQUVFQmRtc2dBRUVmUmh0MElRQWdBaWdDQUNFSUEwQWdDQ0lCS0FJRVFYaHhJQU5HRFFJZ0FFRWRkaUVDSUFCQkFYUWhBQ0FCSUFKQkJIRnFJZ0lvQWhBaUNBMEFDeUFDSUFZMkFoQWdCaUFCTmdJWUN5QUdJQVkyQWd3Z0JpQUdOZ0lJREFFTElBRW9BZ2dpQUNBR05nSU1JQUVnQmpZQ0NDQUdRUUEyQWhnZ0JpQUJOZ0lNSUFZZ0FEWUNDQXNnQkVFSWFpRUFEQUVMQWtBZ0MwVU5BQUpBSUFFb0Fod2lBa0VDZEVHNENtb2lBQ2dDQUNBQlJnUkFJQUFnQkRZQ0FDQUVEUUZCakFnZ0JrRitJQUozY1RZQ0FBd0NDeUFMUVJCQkZDQUxLQUlRSUFGR0cyb2dCRFlDQUNBRVJRMEJDeUFFSUFzMkFoZ2dBU2dDRUNJQUJFQWdCQ0FBTmdJUUlBQWdCRFlDR0FzZ0FTZ0NGQ0lBUlEwQUlBUWdBRFlDRkNBQUlBUTJBaGdMQWtBZ0EwRVBUUVJBSUFFZ0F5QUlhaUlBUVFOeU5nSUVJQUFnQVdvaUFDQUFLQUlFUVFGeU5nSUVEQUVMSUFFZ0NFRURjallDQkNBSklBTkJBWEkyQWdRZ0F5QUphaUFETmdJQUlBb0VRQ0FLUVFOMklnQkJBM1JCc0FocUlRUkJuQWdvQWdBaEFnSi9RUUVnQUhRaUFDQUZjVVVFUUVHSUNDQUFJQVZ5TmdJQUlBUU1BUXNnQkNnQ0NBc2hBQ0FFSUFJMkFnZ2dBQ0FDTmdJTUlBSWdCRFlDRENBQ0lBQTJBZ2dMUVp3SUlBazJBZ0JCa0FnZ0F6WUNBQXNnQVVFSWFpRUFDeUFNUVJCcUpBQWdBQXNRQUNNQUlBQnJRWEJ4SWdBa0FDQUFDd1lBSUFBa0FBc0VBQ01BQzRBSkFnaC9CSDRqQUVHUUFXc2lCaVFBSUFZZ0JTMEFBMEVZZEVHQWdJQVljU0FGTHdBQUlBVXRBQUpCRUhSeWNqWUNBQ0FHSUFVb0FBTkJBblpCZy83L0gzRTJBZ1FnQmlBRktBQUdRUVIyUWYrQi94OXhOZ0lJSUFZZ0JTZ0FDVUVHZGtILy84QWZjVFlDRENBRkx3QU5JUWdnQlMwQUR5RUpJQVpDQURjQ0ZDQUdRZ0EzQWh3Z0JrRUFOZ0lrSUFZZ0NDQUpRUkIwUVlDQVBIRnlOZ0lRSUFZZ0JTZ0FFRFlDS0NBR0lBVW9BQlEyQWl3Z0JpQUZLQUFZTmdJd0lBVW9BQndoQlNBR1FRQTZBRXdnQmtFQU5nSTRJQVlnQlRZQ05DQUdJQUVnQWhBRUlBUUVRQ0FHSUFNZ0JCQUVDeUFHS0FJNElnRUVRQ0FHUVR4cUlnSWdBV3BCQVRvQUFDQUJRUUZxUVE5TkJFQWdBU0FHYWtFOWFpRUVBa0JCRHlBQmF5SURSUTBBSUFNZ0JHb2lBVUVCYTBFQU9nQUFJQVJCQURvQUFDQURRUU5KRFFBZ0FVRUNhMEVBT2dBQUlBUkJBRG9BQVNBQlFRTnJRUUE2QUFBZ0JFRUFPZ0FDSUFOQkIwa05BQ0FCUVFSclFRQTZBQUFnQkVFQU9nQURJQU5CQ1VrTkFDQUVRUUFnQkd0QkEzRWlBV29pQkVFQU5nSUFJQVFnQXlBQmEwRjhjU0lCYWlJRFFRUnJRUUEyQWdBZ0FVRUpTUTBBSUFSQkFEWUNDQ0FFUVFBMkFnUWdBMEVJYTBFQU5nSUFJQU5CREd0QkFEWUNBQ0FCUVJsSkRRQWdCRUVBTmdJWUlBUkJBRFlDRkNBRVFRQTJBaEFnQkVFQU5nSU1JQU5CRUd0QkFEWUNBQ0FEUVJSclFRQTJBZ0FnQTBFWWEwRUFOZ0lBSUFOQkhHdEJBRFlDQUNBQklBUkJCSEZCR0hJaUFXc2lBMEVnU1EwQUlBRWdCR29oQVFOQUlBRkNBRGNER0NBQlFnQTNBeEFnQVVJQU53TUlJQUZDQURjREFDQUJRU0JxSVFFZ0EwRWdheUlEUVI5TERRQUxDd3NnQmtFQk9nQk1JQVlnQWtFUUVBSUxJQVkxQWpRaEVDQUdOUUl3SVJFZ0JqVUNMQ0VPSUFBZ0JqVUNLQ0FHS0FJa0lBWW9BaUFnQmlnQ0hDQUdLQUlZSWdOQkduWnFJZ0pCR25acUlnRkJHblpxSWd0QmdJQ0FZSElnQVVILy8vOGZjU0lOSUFKQi8vLy9IM0VpQ0NBR0tBSVVJQXRCR25aQkJXeHFJZ0ZCLy8vL0gzRWlDVUVGYWlJRlFScDJJQU5CLy8vL0gzRWdBVUVhZG1vaUEyb2lBVUVhZG1vaUFrRWFkbW9pQkVFYWRtb2lERUVmZFNJSElBTnhJQUVnREVFZmRrRUJheUlEUWYvLy94OXhJZ3B4Y2lJQlFScDBJQVVnQ25FZ0J5QUpjWEp5clh3aUR6d0FBQ0FBSUE5Q0dJZzhBQU1nQUNBUFFoQ0lQQUFDSUFBZ0QwSUlpRHdBQVNBQUlBNGdCeUFJY1NBQ0lBcHhjaUlDUVJSMElBRkJCblp5clh3Z0QwSWdpSHdpRGp3QUJDQUFJQTVDR0lnOEFBY2dBQ0FPUWhDSVBBQUdJQUFnRGtJSWlEd0FCU0FBSUJFZ0J5QU5jU0FFSUFweGNpSUJRUTUwSUFKQkRIWnlyWHdnRGtJZ2lId2lEandBQ0NBQUlBNUNHSWc4QUFzZ0FDQU9RaENJUEFBS0lBQWdEa0lJaUR3QUNTQUFJQkFnQXlBTWNTQUhJQXR4Y2tFSWRDQUJRUkoyY3ExOElBNUNJSWg4SWc0OEFBd2dBQ0FPUWhpSVBBQVBJQUFnRGtJUWlEd0FEaUFBSUE1Q0NJZzhBQTBnQmtJQU53SXdJQVpDQURjQ0tDQUdRZ0EzQWlBZ0JrSUFOd0lZSUFaQ0FEY0NFQ0FHUWdBM0FnZ2dCa0lBTndJQUlBWkJrQUZxSkFBTHB3d0JCMzhDUUNBQVJRMEFJQUJCQ0dzaUF5QUFRUVJyS0FJQUlnRkJlSEVpQUdvaEJRSkFJQUZCQVhFTkFDQUJRUU54UlEwQklBTWdBeWdDQUNJQmF5SURRWmdJS0FJQVNRMEJJQUFnQVdvaEFDQURRWndJS0FJQVJ3UkFJQUZCL3dGTkJFQWdBeWdDQ0NJQ0lBRkJBM1lpQkVFRGRFR3dDR3BHR2lBQ0lBTW9BZ3dpQVVZRVFFR0lDRUdJQ0NnQ0FFRitJQVIzY1RZQ0FBd0RDeUFDSUFFMkFnd2dBU0FDTmdJSURBSUxJQU1vQWhnaEJnSkFJQU1nQXlnQ0RDSUJSd1JBSUFNb0FnZ2lBaUFCTmdJTUlBRWdBallDQ0F3QkN3SkFJQU5CRkdvaUFpZ0NBQ0lFRFFBZ0EwRVFhaUlDS0FJQUlnUU5BRUVBSVFFTUFRc0RRQ0FDSVFjZ0JDSUJRUlJxSWdJb0FnQWlCQTBBSUFGQkVHb2hBaUFCS0FJUUlnUU5BQXNnQjBFQU5nSUFDeUFHUlEwQkFrQWdBeUFES0FJY0lnSkJBblJCdUFwcUlnUW9BZ0JHQkVBZ0JDQUJOZ0lBSUFFTkFVR01DRUdNQ0NnQ0FFRitJQUozY1RZQ0FBd0RDeUFHUVJCQkZDQUdLQUlRSUFOR0cyb2dBVFlDQUNBQlJRMENDeUFCSUFZMkFoZ2dBeWdDRUNJQ0JFQWdBU0FDTmdJUUlBSWdBVFlDR0FzZ0F5Z0NGQ0lDUlEwQklBRWdBallDRkNBQ0lBRTJBaGdNQVFzZ0JTZ0NCQ0lCUVFOeFFRTkhEUUJCa0FnZ0FEWUNBQ0FGSUFGQmZuRTJBZ1FnQXlBQVFRRnlOZ0lFSUFBZ0Eyb2dBRFlDQUE4TElBTWdCVThOQUNBRktBSUVJZ0ZCQVhGRkRRQUNRQ0FCUVFKeFJRUkFJQVZCb0Fnb0FnQkdCRUJCb0FnZ0F6WUNBRUdVQ0VHVUNDZ0NBQ0FBYWlJQU5nSUFJQU1nQUVFQmNqWUNCQ0FEUVp3SUtBSUFSdzBEUVpBSVFRQTJBZ0JCbkFoQkFEWUNBQThMSUFWQm5BZ29BZ0JHQkVCQm5BZ2dBellDQUVHUUNFR1FDQ2dDQUNBQWFpSUFOZ0lBSUFNZ0FFRUJjallDQkNBQUlBTnFJQUEyQWdBUEN5QUJRWGh4SUFCcUlRQUNRQ0FCUWY4QlRRUkFJQVVvQWdnaUFpQUJRUU4ySWdSQkEzUkJzQWhxUmhvZ0FpQUZLQUlNSWdGR0JFQkJpQWhCaUFnb0FnQkJmaUFFZDNFMkFnQU1BZ3NnQWlBQk5nSU1JQUVnQWpZQ0NBd0JDeUFGS0FJWUlRWUNRQ0FGSUFVb0Fnd2lBVWNFUUNBRktBSUlJZ0pCbUFnb0FnQkpHaUFDSUFFMkFnd2dBU0FDTmdJSURBRUxBa0FnQlVFVWFpSUNLQUlBSWdRTkFDQUZRUkJxSWdJb0FnQWlCQTBBUVFBaEFRd0JDd05BSUFJaEJ5QUVJZ0ZCRkdvaUFpZ0NBQ0lFRFFBZ0FVRVFhaUVDSUFFb0FoQWlCQTBBQ3lBSFFRQTJBZ0FMSUFaRkRRQUNRQ0FGSUFVb0Fod2lBa0VDZEVHNENtb2lCQ2dDQUVZRVFDQUVJQUUyQWdBZ0FRMEJRWXdJUVl3SUtBSUFRWDRnQW5keE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0JVWWJhaUFCTmdJQUlBRkZEUUVMSUFFZ0JqWUNHQ0FGS0FJUUlnSUVRQ0FCSUFJMkFoQWdBaUFCTmdJWUN5QUZLQUlVSWdKRkRRQWdBU0FDTmdJVUlBSWdBVFlDR0FzZ0F5QUFRUUZ5TmdJRUlBQWdBMm9nQURZQ0FDQURRWndJS0FJQVJ3MEJRWkFJSUFBMkFnQVBDeUFGSUFGQmZuRTJBZ1FnQXlBQVFRRnlOZ0lFSUFBZ0Eyb2dBRFlDQUFzZ0FFSC9BVTBFUUNBQVFRTjJJZ0ZCQTNSQnNBaHFJUUFDZjBHSUNDZ0NBQ0lDUVFFZ0FYUWlBWEZGQkVCQmlBZ2dBU0FDY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJUUlnQUNBRE5nSUlJQUlnQXpZQ0RDQURJQUEyQWd3Z0F5QUNOZ0lJRHd0Qkh5RUNJQU5DQURjQ0VDQUFRZi8vL3dkTkJFQWdBRUVJZGlJQklBRkJnUDQvYWtFUWRrRUljU0lCZENJQ0lBSkJnT0FmYWtFUWRrRUVjU0lDZENJRUlBUkJnSUFQYWtFUWRrRUNjU0lFZEVFUGRpQUJJQUp5SUFSeWF5SUJRUUYwSUFBZ0FVRVZhblpCQVhGeVFSeHFJUUlMSUFNZ0FqWUNIQ0FDUVFKMFFiZ0thaUVCQWtBQ1FBSkFRWXdJS0FJQUlnUkJBU0FDZENJSGNVVUVRRUdNQ0NBRUlBZHlOZ0lBSUFFZ0F6WUNBQ0FESUFFMkFoZ01BUXNnQUVFQVFSa2dBa0VCZG1zZ0FrRWZSaHQwSVFJZ0FTZ0NBQ0VCQTBBZ0FTSUVLQUlFUVhoeElBQkdEUUlnQWtFZGRpRUJJQUpCQVhRaEFpQUVJQUZCQkhGcUlnZEJFR29vQWdBaUFRMEFDeUFISUFNMkFoQWdBeUFFTmdJWUN5QURJQU0yQWd3Z0F5QUROZ0lJREFFTElBUW9BZ2dpQUNBRE5nSU1JQVFnQXpZQ0NDQURRUUEyQWhnZ0F5QUVOZ0lNSUFNZ0FEWUNDQXRCcUFoQnFBZ29BZ0JCQVdzaUFFRi9JQUFiTmdJQUN3c0xDUUVBUVlFSUN3SUdVQT09XCI7aWYoIVcuc3RhcnRzV2l0aChWKSl7dmFyIG5hPVc7Vz1iLmxvY2F0ZUZpbGU/Yi5sb2NhdGVGaWxlKG5hLEIpOkIrbmF9ZnVuY3Rpb24gcGEoKXt2YXIgYT1XO3RyeXtpZihhPT1XJiZKKXJldHVybiBuZXcgVWludDhBcnJheShKKTt2YXIgYz1IKGEpO2lmKGMpcmV0dXJuIGM7aWYoRSlyZXR1cm4gRShhKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIjt9Y2F0Y2goZCl7SyhkKX19XG5mdW5jdGlvbiBxYSgpe2lmKCFKJiYoeHx8eSkpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBmZXRjaCYmIVcuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKFcse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZnVuY3Rpb24oYSl7aWYoIWEub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK1crXCInXCI7cmV0dXJuIGEuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKGZ1bmN0aW9uKCl7cmV0dXJuIHBhKCl9KTtpZihEKXJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhLGMpe0QoVyxmdW5jdGlvbihkKXthKG5ldyBVaW50OEFycmF5KGQpKX0sYyl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBwYSgpfSl9XG5mdW5jdGlvbiBYKGEpe2Zvcig7MDxhLmxlbmd0aDspe3ZhciBjPWEuc2hpZnQoKTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBjKWMoYik7ZWxzZXt2YXIgZD1jLm07XCJudW1iZXJcIj09PXR5cGVvZiBkP3ZvaWQgMD09PWMubD9SLmdldChkKSgpOlIuZ2V0KGQpKGMubCk6ZCh2b2lkIDA9PT1jLmw/bnVsbDpjLmwpfX19XG52YXIgYmE9ITEscmE9XCJmdW5jdGlvblwiPT09dHlwZW9mIGF0b2I/YXRvYjpmdW5jdGlvbihhKXt2YXIgYz1cIlwiLGQ9MDthPWEucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC89XS9nLFwiXCIpO2Rve3ZhciBlPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5pbmRleE9mKGEuY2hhckF0KGQrKykpO3ZhciBmPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5pbmRleE9mKGEuY2hhckF0KGQrKykpO3ZhciBsPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5pbmRleE9mKGEuY2hhckF0KGQrKykpO3ZhciBBPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5pbmRleE9mKGEuY2hhckF0KGQrKykpO2U9ZTw8XG4yfGY+PjQ7Zj0oZiYxNSk8PDR8bD4+Mjt2YXIgdD0obCYzKTw8NnxBO2MrPVN0cmluZy5mcm9tQ2hhckNvZGUoZSk7NjQhPT1sJiYoYys9U3RyaW5nLmZyb21DaGFyQ29kZShmKSk7NjQhPT1BJiYoYys9U3RyaW5nLmZyb21DaGFyQ29kZSh0KSl9d2hpbGUoZDxhLmxlbmd0aCk7cmV0dXJuIGN9O1xuZnVuY3Rpb24gSChhKXtpZihhLnN0YXJ0c1dpdGgoVikpe2E9YS5zbGljZShWLmxlbmd0aCk7aWYoXCJib29sZWFuXCI9PT10eXBlb2YgeiYmeil7dmFyIGM9QnVmZmVyLmZyb20oYSxcImJhc2U2NFwiKTtjPW5ldyBVaW50OEFycmF5KGMuYnVmZmVyLGMuYnl0ZU9mZnNldCxjLmJ5dGVMZW5ndGgpfWVsc2UgdHJ5e3ZhciBkPXJhKGEpLGU9bmV3IFVpbnQ4QXJyYXkoZC5sZW5ndGgpO2ZvcihhPTA7YTxkLmxlbmd0aDsrK2EpZVthXT1kLmNoYXJDb2RlQXQoYSk7Yz1lfWNhdGNoKGYpe3Rocm93IEVycm9yKFwiQ29udmVydGluZyBiYXNlNjQgc3RyaW5nIHRvIGJ5dGVzIGZhaWxlZC5cIik7fXJldHVybiBjfX1cbnZhciBzYT17YTpmdW5jdGlvbihhKXt2YXIgYz1QLmxlbmd0aDthPj4+PTA7aWYoMjE0NzQ4MzY0ODxhKXJldHVybiExO2Zvcih2YXIgZD0xOzQ+PWQ7ZCo9Mil7dmFyIGU9YyooMSsuMi9kKTtlPU1hdGgubWluKGUsYSsxMDA2NjMyOTYpO2U9TWF0aC5tYXgoYSxlKTswPGUlNjU1MzYmJihlKz02NTUzNi1lJTY1NTM2KTthOnt0cnl7TC5ncm93KE1hdGgubWluKDIxNDc0ODM2NDgsZSktaGEuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KTtpYSgpO3ZhciBmPTE7YnJlYWsgYX1jYXRjaChsKXt9Zj12b2lkIDB9aWYoZilyZXR1cm4hMH1yZXR1cm4hMX19O1xuKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShmKXtiLmFzbT1mLmV4cG9ydHM7TD1iLmFzbS5iO2lhKCk7Uj1iLmFzbS5qO2thLnVuc2hpZnQoYi5hc20uYyk7Uy0tO2IubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmYi5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKFMpOzA9PVMmJihudWxsIT09VCYmKGNsZWFySW50ZXJ2YWwoVCksVD1udWxsKSxVJiYoZj1VLFU9bnVsbCxmKCkpKX1mdW5jdGlvbiBjKGYpe2EoZi5pbnN0YW5jZSl9ZnVuY3Rpb24gZChmKXtyZXR1cm4gcWEoKS50aGVuKGZ1bmN0aW9uKGwpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShsLGUpfSkudGhlbihmLGZ1bmN0aW9uKGwpe0koXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitsKTtLKGwpfSl9dmFyIGU9e2E6c2F9O1MrKztiLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmIubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhTKTtpZihiLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGIuaW5zdGFudGlhdGVXYXNtKGUsXG5hKX1jYXRjaChmKXtyZXR1cm4gSShcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK2YpLCExfShmdW5jdGlvbigpe3JldHVybiBKfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fFcuc3RhcnRzV2l0aChWKXx8Vy5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGZldGNoP2QoYyk6ZmV0Y2goVyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihmdW5jdGlvbihmKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZixlKS50aGVuKGMsZnVuY3Rpb24obCl7SShcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitsKTtJKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIik7cmV0dXJuIGQoYyl9KX0pfSkoKS5jYXRjaChyKTtyZXR1cm57fX0pKCk7XG5iLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihiLl9fX3dhc21fY2FsbF9jdG9ycz1iLmFzbS5jKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2IuX3BvbHkxMzA1X2F1dGg9ZnVuY3Rpb24oKXtyZXR1cm4oYi5fcG9seTEzMDVfYXV0aD1iLmFzbS5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBkYT1iLnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihkYT1iLnN0YWNrU2F2ZT1iLmFzbS5lKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGZhPWIuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKGZhPWIuc3RhY2tSZXN0b3JlPWIuYXNtLmYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTz1iLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oTz1iLnN0YWNrQWxsb2M9Yi5hc20uZykuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtiLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oYi5fbWFsbG9jPWIuYXNtLmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07XG5iLl9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKGIuX2ZyZWU9Yi5hc20uaSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtiLmN3cmFwPWZ1bmN0aW9uKGEsYyxkLGUpe2Q9ZHx8W107dmFyIGY9ZC5ldmVyeShmdW5jdGlvbihsKXtyZXR1cm5cIm51bWJlclwiPT09bH0pO3JldHVyblwic3RyaW5nXCIhPT1jJiZmJiYhZT9OKGEpOmZ1bmN0aW9uKCl7cmV0dXJuIGNhKGEsYyxkLGFyZ3VtZW50cyl9fTt2YXIgWTtVPWZ1bmN0aW9uIHRhKCl7WXx8WigpO1l8fChVPXRhKX07XG5mdW5jdGlvbiBaKCl7ZnVuY3Rpb24gYSgpe2lmKCFZJiYoWT0hMCxiLmNhbGxlZFJ1bj0hMCwhTSkpe1goa2EpO3EoYik7aWYoYi5vblJ1bnRpbWVJbml0aWFsaXplZCliLm9uUnVudGltZUluaXRpYWxpemVkKCk7aWYoYi5wb3N0UnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBiLnBvc3RSdW4mJihiLnBvc3RSdW49W2IucG9zdFJ1bl0pO2IucG9zdFJ1bi5sZW5ndGg7KXt2YXIgYz1iLnBvc3RSdW4uc2hpZnQoKTtsYS51bnNoaWZ0KGMpfVgobGEpfX1pZighKDA8Uykpe2lmKGIucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBiLnByZVJ1biYmKGIucHJlUnVuPVtiLnByZVJ1bl0pO2IucHJlUnVuLmxlbmd0aDspbWEoKTtYKGphKTswPFN8fChiLnNldFN0YXR1cz8oYi5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5zZXRTdGF0dXMoXCJcIil9LDEpO2EoKX0sMSkpOmEoKSl9fWIucnVuPVo7XG5pZihiLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGIucHJlSW5pdCYmKGIucHJlSW5pdD1bYi5wcmVJbml0XSk7MDxiLnByZUluaXQubGVuZ3RoOyliLnByZUluaXQucG9wKCkoKTtaKCk7XG5cblxuICByZXR1cm4gY3JlYXRlUG9seTEzMDUucmVhZHlcbn1cbik7XG59KSgpO1xuaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcbiAgbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVQb2x5MTMwNTtcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSlcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZVBvbHkxMzA1OyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcbiAgZXhwb3J0c1tcImNyZWF0ZVBvbHkxMzA1XCJdID0gY3JlYXRlUG9seTEzMDU7XG4iLCAiLy8gVE9ETzpcbi8vICAgICogbWFrZSBtYXggcGFja2V0IHNpemUgY29uZmlndXJhYmxlXG4vLyAgICAqIGlmIGRlY29tcHJlc3Npb24gaXMgZW5hYmxlZCwgdXNlIGAuX3BhY2tldGAgaW4gZGVjaXBoZXIgaW5zdGFuY2VzIGFzXG4vLyAgICAgIGlucHV0IHRvIChzeW5jKSB6bGliIGluZmxhdGVyIHdpdGggYXBwcm9wcmlhdGUgb2Zmc2V0IGFuZCBsZW5ndGggdG9cbi8vICAgICAgYXZvaWQgYW4gYWRkaXRpb25hbCBjb3B5IG9mIHBheWxvYWQgZGF0YSBiZWZvcmUgaW5mbGF0aW9uXG4vLyAgICAqIGZhY3RvciBkZWNvbXByZXNzaW9uIHN0YXR1cyBpbnRvIHBhY2tldCBsZW5ndGggY2hlY2tzXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgY3JlYXRlQ2lwaGVyaXYsIGNyZWF0ZURlY2lwaGVyaXYsIGNyZWF0ZUhtYWMsIHJhbmRvbUZpbGxTeW5jLCB0aW1pbmdTYWZlRXF1YWxcbn0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgeyByZWFkVUludDMyQkUsIHdyaXRlVUludDMyQkUgfSA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5jb25zdCBNQVhfU0VRTk8gPSAyICoqIDMyIC0gMTtcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IEJ1ZmZlci5hbGxvYygwKTtcbmNvbnN0IEJVRl9JTlQgPSBCdWZmZXIuYWxsb2MoNCk7XG5jb25zdCBESVNDQVJEX0NBQ0hFID0gbmV3IE1hcCgpO1xuY29uc3QgTUFYX1BBQ0tFVF9TSVpFID0gMzUwMDA7XG5cbmxldCBiaW5kaW5nO1xubGV0IEFFU0dDTUNpcGhlcjtcbmxldCBDaGFDaGFQb2x5Q2lwaGVyO1xubGV0IEdlbmVyaWNDaXBoZXI7XG5sZXQgQUVTR0NNRGVjaXBoZXI7XG5sZXQgQ2hhQ2hhUG9seURlY2lwaGVyO1xubGV0IEdlbmVyaWNEZWNpcGhlcjtcbnRyeSB7XG4gIGJpbmRpbmcgPSByZXF1aXJlKCcuL2NyeXB0by9idWlsZC9SZWxlYXNlL3NzaGNyeXB0by5ub2RlJyk7XG4gICh7IEFFU0dDTUNpcGhlciwgQ2hhQ2hhUG9seUNpcGhlciwgR2VuZXJpY0NpcGhlcixcbiAgICAgQUVTR0NNRGVjaXBoZXIsIENoYUNoYVBvbHlEZWNpcGhlciwgR2VuZXJpY0RlY2lwaGVyIH0gPSBiaW5kaW5nKTtcbn0gY2F0Y2gge31cblxuY29uc3QgQ0lQSEVSX1NUUkVBTSA9IDEgPDwgMDtcbmNvbnN0IENJUEhFUl9JTkZPID0gKCgpID0+IHtcbiAgZnVuY3Rpb24gaW5mbyhzc2xOYW1lLCBibG9ja0xlbiwga2V5TGVuLCBpdkxlbiwgYXV0aExlbiwgZGlzY2FyZExlbiwgZmxhZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3NsTmFtZSxcbiAgICAgIGJsb2NrTGVuLFxuICAgICAga2V5TGVuLFxuICAgICAgaXZMZW46IChpdkxlbiAhPT0gMCB8fCAoZmxhZ3MgJiBDSVBIRVJfU1RSRUFNKVxuICAgICAgICAgICAgICA/IGl2TGVuXG4gICAgICAgICAgICAgIDogYmxvY2tMZW4pLFxuICAgICAgYXV0aExlbixcbiAgICAgIGRpc2NhcmRMZW4sXG4gICAgICBzdHJlYW06ICEhKGZsYWdzICYgQ0lQSEVSX1NUUkVBTSksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgJ2NoYWNoYTIwLXBvbHkxMzA1QG9wZW5zc2guY29tJzpcbiAgICAgIGluZm8oJ2NoYWNoYTIwJywgOCwgNjQsIDAsIDE2LCAwLCBDSVBIRVJfU1RSRUFNKSxcblxuICAgICdhZXMxMjgtZ2NtJzogaW5mbygnYWVzLTEyOC1nY20nLCAxNiwgMTYsIDEyLCAxNiwgMCwgQ0lQSEVSX1NUUkVBTSksXG4gICAgJ2FlczI1Ni1nY20nOiBpbmZvKCdhZXMtMjU2LWdjbScsIDE2LCAzMiwgMTIsIDE2LCAwLCBDSVBIRVJfU1RSRUFNKSxcbiAgICAnYWVzMTI4LWdjbUBvcGVuc3NoLmNvbSc6XG4gICAgICBpbmZvKCdhZXMtMTI4LWdjbScsIDE2LCAxNiwgMTIsIDE2LCAwLCBDSVBIRVJfU1RSRUFNKSxcbiAgICAnYWVzMjU2LWdjbUBvcGVuc3NoLmNvbSc6XG4gICAgICBpbmZvKCdhZXMtMjU2LWdjbScsIDE2LCAzMiwgMTIsIDE2LCAwLCBDSVBIRVJfU1RSRUFNKSxcblxuICAgICdhZXMxMjgtY2JjJzogaW5mbygnYWVzLTEyOC1jYmMnLCAxNiwgMTYsIDAsIDAsIDAsIDApLFxuICAgICdhZXMxOTItY2JjJzogaW5mbygnYWVzLTE5Mi1jYmMnLCAxNiwgMjQsIDAsIDAsIDAsIDApLFxuICAgICdhZXMyNTYtY2JjJzogaW5mbygnYWVzLTI1Ni1jYmMnLCAxNiwgMzIsIDAsIDAsIDAsIDApLFxuICAgICdyaWpuZGFlbC1jYmNAbHlzYXRvci5saXUuc2UnOiBpbmZvKCdhZXMtMjU2LWNiYycsIDE2LCAzMiwgMCwgMCwgMCwgMCksXG4gICAgJzNkZXMtY2JjJzogaW5mbygnZGVzLWVkZTMtY2JjJywgOCwgMjQsIDAsIDAsIDAsIDApLFxuICAgICdibG93ZmlzaC1jYmMnOiBpbmZvKCdiZi1jYmMnLCA4LCAxNiwgMCwgMCwgMCwgMCksXG4gICAgJ2lkZWEtY2JjJzogaW5mbygnaWRlYS1jYmMnLCA4LCAxNiwgMCwgMCwgMCwgMCksXG4gICAgJ2Nhc3QxMjgtY2JjJzogaW5mbygnY2FzdC1jYmMnLCA4LCAxNiwgMCwgMCwgMCwgMCksXG5cbiAgICAnYWVzMTI4LWN0cic6IGluZm8oJ2Flcy0xMjgtY3RyJywgMTYsIDE2LCAxNiwgMCwgMCwgQ0lQSEVSX1NUUkVBTSksXG4gICAgJ2FlczE5Mi1jdHInOiBpbmZvKCdhZXMtMTkyLWN0cicsIDE2LCAyNCwgMTYsIDAsIDAsIENJUEhFUl9TVFJFQU0pLFxuICAgICdhZXMyNTYtY3RyJzogaW5mbygnYWVzLTI1Ni1jdHInLCAxNiwgMzIsIDE2LCAwLCAwLCBDSVBIRVJfU1RSRUFNKSxcbiAgICAnM2Rlcy1jdHInOiBpbmZvKCdkZXMtZWRlMycsIDgsIDI0LCA4LCAwLCAwLCBDSVBIRVJfU1RSRUFNKSxcbiAgICAnYmxvd2Zpc2gtY3RyJzogaW5mbygnYmYtZWNiJywgOCwgMTYsIDgsIDAsIDAsIENJUEhFUl9TVFJFQU0pLFxuICAgICdjYXN0MTI4LWN0cic6IGluZm8oJ2Nhc3Q1LWVjYicsIDgsIDE2LCA4LCAwLCAwLCBDSVBIRVJfU1RSRUFNKSxcblxuICAgIC8qIFRoZSBcImFyY2ZvdXIxMjhcIiBhbGdvcml0aG0gaXMgdGhlIFJDNCBjaXBoZXIsIGFzIGRlc2NyaWJlZCBpblxuICAgICAgIFtTQ0hORUlFUl0sIHVzaW5nIGEgMTI4LWJpdCBrZXkuICBUaGUgZmlyc3QgMTUzNiBieXRlcyBvZiBrZXlzdHJlYW1cbiAgICAgICBnZW5lcmF0ZWQgYnkgdGhlIGNpcGhlciBNVVNUIGJlIGRpc2NhcmRlZCwgYW5kIHRoZSBmaXJzdCBieXRlIG9mIHRoZVxuICAgICAgIGZpcnN0IGVuY3J5cHRlZCBwYWNrZXQgTVVTVCBiZSBlbmNyeXB0ZWQgdXNpbmcgdGhlIDE1Mzd0aCBieXRlIG9mXG4gICAgICAga2V5c3RyZWFtLlxuXG4gICAgICAgLS0gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDM0NSNzZWN0aW9uLTQgKi9cbiAgICAnYXJjZm91cic6IGluZm8oJ3JjNCcsIDgsIDE2LCAwLCAwLCAxNTM2LCBDSVBIRVJfU1RSRUFNKSxcbiAgICAnYXJjZm91cjEyOCc6IGluZm8oJ3JjNCcsIDgsIDE2LCAwLCAwLCAxNTM2LCBDSVBIRVJfU1RSRUFNKSxcbiAgICAnYXJjZm91cjI1Nic6IGluZm8oJ3JjNCcsIDgsIDMyLCAwLCAwLCAxNTM2LCBDSVBIRVJfU1RSRUFNKSxcbiAgICAnYXJjZm91cjUxMic6IGluZm8oJ3JjNCcsIDgsIDY0LCAwLCAwLCAxNTM2LCBDSVBIRVJfU1RSRUFNKSxcbiAgfTtcbn0pKCk7XG5cbmNvbnN0IE1BQ19JTkZPID0gKCgpID0+IHtcbiAgZnVuY3Rpb24gaW5mbyhzc2xOYW1lLCBsZW4sIGFjdHVhbExlbiwgaXNFVE0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3NsTmFtZSxcbiAgICAgIGxlbixcbiAgICAgIGFjdHVhbExlbixcbiAgICAgIGlzRVRNLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgICdobWFjLW1kNSc6IGluZm8oJ21kNScsIDE2LCAxNiwgZmFsc2UpLFxuICAgICdobWFjLW1kNS05Nic6IGluZm8oJ21kNScsIDE2LCAxMiwgZmFsc2UpLFxuICAgICdobWFjLXJpcGVtZDE2MCc6IGluZm8oJ3JpcGVtZDE2MCcsIDIwLCAyMCwgZmFsc2UpLFxuICAgICdobWFjLXNoYTEnOiBpbmZvKCdzaGExJywgMjAsIDIwLCBmYWxzZSksXG4gICAgJ2htYWMtc2hhMS1ldG1Ab3BlbnNzaC5jb20nOiBpbmZvKCdzaGExJywgMjAsIDIwLCB0cnVlKSxcbiAgICAnaG1hYy1zaGExLTk2JzogaW5mbygnc2hhMScsIDIwLCAxMiwgZmFsc2UpLFxuICAgICdobWFjLXNoYTItMjU2JzogaW5mbygnc2hhMjU2JywgMzIsIDMyLCBmYWxzZSksXG4gICAgJ2htYWMtc2hhMi0yNTYtZXRtQG9wZW5zc2guY29tJzogaW5mbygnc2hhMjU2JywgMzIsIDMyLCB0cnVlKSxcbiAgICAnaG1hYy1zaGEyLTI1Ni05Nic6IGluZm8oJ3NoYTI1NicsIDMyLCAxMiwgZmFsc2UpLFxuICAgICdobWFjLXNoYTItNTEyJzogaW5mbygnc2hhNTEyJywgNjQsIDY0LCBmYWxzZSksXG4gICAgJ2htYWMtc2hhMi01MTItZXRtQG9wZW5zc2guY29tJzogaW5mbygnc2hhNTEyJywgNjQsIDY0LCB0cnVlKSxcbiAgICAnaG1hYy1zaGEyLTUxMi05Nic6IGluZm8oJ3NoYTUxMicsIDY0LCAxMiwgZmFsc2UpLFxuICB9O1xufSkoKTtcblxuXG4vLyBTaG91bGQgb25seV9iZSB1c2VkIGR1cmluZyB0aGUgaW5pdGlhbCBoYW5kc2hha2VcbmNsYXNzIE51bGxDaXBoZXIge1xuICBjb25zdHJ1Y3RvcihzZXFubywgb25Xcml0ZSkge1xuICAgIHRoaXMub3V0U2Vxbm8gPSBzZXFubztcbiAgICB0aGlzLl9vbldyaXRlID0gb25Xcml0ZTtcbiAgICB0aGlzLl9kZWFkID0gZmFsc2U7XG4gIH1cbiAgZnJlZSgpIHtcbiAgICB0aGlzLl9kZWFkID0gdHJ1ZTtcbiAgfVxuICBhbGxvY1BhY2tldChwYXlsb2FkTGVuKSB7XG4gICAgbGV0IHBrdExlbiA9IDQgKyAxICsgcGF5bG9hZExlbjtcbiAgICBsZXQgcGFkTGVuID0gOCAtIChwa3RMZW4gJiAoOCAtIDEpKTtcbiAgICBpZiAocGFkTGVuIDwgNClcbiAgICAgIHBhZExlbiArPSA4O1xuICAgIHBrdExlbiArPSBwYWRMZW47XG5cbiAgICBjb25zdCBwYWNrZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUocGt0TGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBwa3RMZW4gLSA0LCAwKTtcbiAgICBwYWNrZXRbNF0gPSBwYWRMZW47XG5cbiAgICByYW5kb21GaWxsU3luYyhwYWNrZXQsIDUgKyBwYXlsb2FkTGVuLCBwYWRMZW4pO1xuXG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICBlbmNyeXB0KHBhY2tldCkge1xuICAgIC8vIGBwYWNrZXRgID09PSB1bmVuY3J5cHRlZCBwYWNrZXRcblxuICAgIGlmICh0aGlzLl9kZWFkKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdGhpcy5fb25Xcml0ZShwYWNrZXQpO1xuXG4gICAgdGhpcy5vdXRTZXFubyA9ICh0aGlzLm91dFNlcW5vICsgMSkgPj4+IDA7XG4gIH1cbn1cblxuXG5jb25zdCBQT0xZMTMwNV9aRVJPUyA9IEJ1ZmZlci5hbGxvYygzMik7XG5jb25zdCBQT0xZMTMwNV9PVVRfQ09NUFVURSA9IEJ1ZmZlci5hbGxvYygxNik7XG5sZXQgUE9MWTEzMDVfV0FTTV9NT0RVTEU7XG5sZXQgUE9MWTEzMDVfUkVTVUxUX01BTExPQztcbmxldCBwb2x5MTMwNV9hdXRoO1xuY2xhc3MgQ2hhQ2hhUG9seUNpcGhlck5hdGl2ZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IGVuYyA9IGNvbmZpZy5vdXRib3VuZDtcbiAgICB0aGlzLm91dFNlcW5vID0gZW5jLnNlcW5vO1xuICAgIHRoaXMuX29uV3JpdGUgPSBlbmMub25Xcml0ZTtcbiAgICB0aGlzLl9lbmNLZXlNYWluID0gZW5jLmNpcGhlcktleS5zbGljZSgwLCAzMik7XG4gICAgdGhpcy5fZW5jS2V5UGt0TGVuID0gZW5jLmNpcGhlcktleS5zbGljZSgzMik7XG4gICAgdGhpcy5fZGVhZCA9IGZhbHNlO1xuICB9XG4gIGZyZWUoKSB7XG4gICAgdGhpcy5fZGVhZCA9IHRydWU7XG4gIH1cbiAgYWxsb2NQYWNrZXQocGF5bG9hZExlbikge1xuICAgIGxldCBwa3RMZW4gPSA0ICsgMSArIHBheWxvYWRMZW47XG4gICAgbGV0IHBhZExlbiA9IDggLSAoKHBrdExlbiAtIDQpICYgKDggLSAxKSk7XG4gICAgaWYgKHBhZExlbiA8IDQpXG4gICAgICBwYWRMZW4gKz0gODtcbiAgICBwa3RMZW4gKz0gcGFkTGVuO1xuXG4gICAgY29uc3QgcGFja2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBrdExlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcGt0TGVuIC0gNCwgMCk7XG4gICAgcGFja2V0WzRdID0gcGFkTGVuO1xuXG4gICAgcmFuZG9tRmlsbFN5bmMocGFja2V0LCA1ICsgcGF5bG9hZExlbiwgcGFkTGVuKTtcblxuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgZW5jcnlwdChwYWNrZXQpIHtcbiAgICAvLyBgcGFja2V0YCA9PT0gdW5lbmNyeXB0ZWQgcGFja2V0XG5cbiAgICBpZiAodGhpcy5fZGVhZClcbiAgICAgIHJldHVybjtcblxuICAgIC8vIEdlbmVyYXRlIFBvbHkxMzA1IGtleVxuICAgIFBPTFkxMzA1X09VVF9DT01QVVRFWzBdID0gMDsgLy8gU2V0IGNvdW50ZXIgdG8gMCAobGl0dGxlIGVuZGlhbilcbiAgICB3cml0ZVVJbnQzMkJFKFBPTFkxMzA1X09VVF9DT01QVVRFLCB0aGlzLm91dFNlcW5vLCAxMik7XG4gICAgY29uc3QgcG9seUtleSA9XG4gICAgICBjcmVhdGVDaXBoZXJpdignY2hhY2hhMjAnLCB0aGlzLl9lbmNLZXlNYWluLCBQT0xZMTMwNV9PVVRfQ09NUFVURSlcbiAgICAgIC51cGRhdGUoUE9MWTEzMDVfWkVST1MpO1xuXG4gICAgLy8gRW5jcnlwdCBwYWNrZXQgbGVuZ3RoXG4gICAgY29uc3QgcGt0TGVuRW5jID1cbiAgICAgIGNyZWF0ZUNpcGhlcml2KCdjaGFjaGEyMCcsIHRoaXMuX2VuY0tleVBrdExlbiwgUE9MWTEzMDVfT1VUX0NPTVBVVEUpXG4gICAgICAudXBkYXRlKHBhY2tldC5zbGljZSgwLCA0KSk7XG4gICAgdGhpcy5fb25Xcml0ZShwa3RMZW5FbmMpO1xuXG4gICAgLy8gRW5jcnlwdCByZXN0IG9mIHBhY2tldFxuICAgIFBPTFkxMzA1X09VVF9DT01QVVRFWzBdID0gMTsgLy8gU2V0IGNvdW50ZXIgdG8gMSAobGl0dGxlIGVuZGlhbilcbiAgICBjb25zdCBwYXlsb2FkRW5jID1cbiAgICAgIGNyZWF0ZUNpcGhlcml2KCdjaGFjaGEyMCcsIHRoaXMuX2VuY0tleU1haW4sIFBPTFkxMzA1X09VVF9DT01QVVRFKVxuICAgICAgLnVwZGF0ZShwYWNrZXQuc2xpY2UoNCkpO1xuICAgIHRoaXMuX29uV3JpdGUocGF5bG9hZEVuYyk7XG5cbiAgICAvLyBDYWxjdWxhdGUgUG9seTEzMDUgTUFDXG4gICAgcG9seTEzMDVfYXV0aChQT0xZMTMwNV9SRVNVTFRfTUFMTE9DLFxuICAgICAgICAgICAgICAgICAgcGt0TGVuRW5jLFxuICAgICAgICAgICAgICAgICAgcGt0TGVuRW5jLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWRFbmMsXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkRW5jLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIHBvbHlLZXkpO1xuICAgIGNvbnN0IG1hYyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNik7XG4gICAgbWFjLnNldChcbiAgICAgIG5ldyBVaW50OEFycmF5KFBPTFkxMzA1X1dBU01fTU9EVUxFLkhFQVBVOC5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICBQT0xZMTMwNV9SRVNVTFRfTUFMTE9DLFxuICAgICAgICAgICAgICAgICAgICAgMTYpLFxuICAgICAgMFxuICAgICk7XG4gICAgdGhpcy5fb25Xcml0ZShtYWMpO1xuXG4gICAgdGhpcy5vdXRTZXFubyA9ICh0aGlzLm91dFNlcW5vICsgMSkgPj4+IDA7XG4gIH1cbn1cblxuY2xhc3MgQ2hhQ2hhUG9seUNpcGhlckJpbmRpbmcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCBlbmMgPSBjb25maWcub3V0Ym91bmQ7XG4gICAgdGhpcy5vdXRTZXFubyA9IGVuYy5zZXFubztcbiAgICB0aGlzLl9vbldyaXRlID0gZW5jLm9uV3JpdGU7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgQ2hhQ2hhUG9seUNpcGhlcihlbmMuY2lwaGVyS2V5KTtcbiAgICB0aGlzLl9kZWFkID0gZmFsc2U7XG4gIH1cbiAgZnJlZSgpIHtcbiAgICB0aGlzLl9kZWFkID0gdHJ1ZTtcbiAgICB0aGlzLl9pbnN0YW5jZS5mcmVlKCk7XG4gIH1cbiAgYWxsb2NQYWNrZXQocGF5bG9hZExlbikge1xuICAgIGxldCBwa3RMZW4gPSA0ICsgMSArIHBheWxvYWRMZW47XG4gICAgbGV0IHBhZExlbiA9IDggLSAoKHBrdExlbiAtIDQpICYgKDggLSAxKSk7XG4gICAgaWYgKHBhZExlbiA8IDQpXG4gICAgICBwYWRMZW4gKz0gODtcbiAgICBwa3RMZW4gKz0gcGFkTGVuO1xuXG4gICAgY29uc3QgcGFja2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBrdExlbiArIDE2LyogTUFDICovKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBwa3RMZW4gLSA0LCAwKTtcbiAgICBwYWNrZXRbNF0gPSBwYWRMZW47XG5cbiAgICByYW5kb21GaWxsU3luYyhwYWNrZXQsIDUgKyBwYXlsb2FkTGVuLCBwYWRMZW4pO1xuXG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICBlbmNyeXB0KHBhY2tldCkge1xuICAgIC8vIGBwYWNrZXRgID09PSB1bmVuY3J5cHRlZCBwYWNrZXRcblxuICAgIGlmICh0aGlzLl9kZWFkKVxuICAgICAgcmV0dXJuO1xuXG4gICAgLy8gRW5jcnlwdHMgaW4tcGxhY2VcbiAgICB0aGlzLl9pbnN0YW5jZS5lbmNyeXB0KHBhY2tldCwgdGhpcy5vdXRTZXFubyk7XG5cbiAgICB0aGlzLl9vbldyaXRlKHBhY2tldCk7XG5cbiAgICB0aGlzLm91dFNlcW5vID0gKHRoaXMub3V0U2Vxbm8gKyAxKSA+Pj4gMDtcbiAgfVxufVxuXG5cbmNsYXNzIEFFU0dDTUNpcGhlck5hdGl2ZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IGVuYyA9IGNvbmZpZy5vdXRib3VuZDtcbiAgICB0aGlzLm91dFNlcW5vID0gZW5jLnNlcW5vO1xuICAgIHRoaXMuX29uV3JpdGUgPSBlbmMub25Xcml0ZTtcbiAgICB0aGlzLl9lbmNTU0xOYW1lID0gZW5jLmNpcGhlckluZm8uc3NsTmFtZTtcbiAgICB0aGlzLl9lbmNLZXkgPSBlbmMuY2lwaGVyS2V5O1xuICAgIHRoaXMuX2VuY0lWID0gZW5jLmNpcGhlcklWO1xuICAgIHRoaXMuX2RlYWQgPSBmYWxzZTtcbiAgfVxuICBmcmVlKCkge1xuICAgIHRoaXMuX2RlYWQgPSB0cnVlO1xuICB9XG4gIGFsbG9jUGFja2V0KHBheWxvYWRMZW4pIHtcbiAgICBsZXQgcGt0TGVuID0gNCArIDEgKyBwYXlsb2FkTGVuO1xuICAgIGxldCBwYWRMZW4gPSAxNiAtICgocGt0TGVuIC0gNCkgJiAoMTYgLSAxKSk7XG4gICAgaWYgKHBhZExlbiA8IDQpXG4gICAgICBwYWRMZW4gKz0gMTY7XG4gICAgcGt0TGVuICs9IHBhZExlbjtcblxuICAgIGNvbnN0IHBhY2tldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShwa3RMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHBrdExlbiAtIDQsIDApO1xuICAgIHBhY2tldFs0XSA9IHBhZExlbjtcblxuICAgIHJhbmRvbUZpbGxTeW5jKHBhY2tldCwgNSArIHBheWxvYWRMZW4sIHBhZExlbik7XG5cbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIGVuY3J5cHQocGFja2V0KSB7XG4gICAgLy8gYHBhY2tldGAgPT09IHVuZW5jcnlwdGVkIHBhY2tldFxuXG4gICAgaWYgKHRoaXMuX2RlYWQpXG4gICAgICByZXR1cm47XG5cbiAgICBjb25zdCBjaXBoZXIgPSBjcmVhdGVDaXBoZXJpdih0aGlzLl9lbmNTU0xOYW1lLCB0aGlzLl9lbmNLZXksIHRoaXMuX2VuY0lWKTtcbiAgICBjaXBoZXIuc2V0QXV0b1BhZGRpbmcoZmFsc2UpO1xuXG4gICAgY29uc3QgbGVuRGF0YSA9IHBhY2tldC5zbGljZSgwLCA0KTtcbiAgICBjaXBoZXIuc2V0QUFEKGxlbkRhdGEpO1xuICAgIHRoaXMuX29uV3JpdGUobGVuRGF0YSk7XG5cbiAgICAvLyBFbmNyeXB0IHBhZCBsZW5ndGgsIHBheWxvYWQsIGFuZCBwYWRkaW5nXG4gICAgY29uc3QgZW5jcnlwdGVkID0gY2lwaGVyLnVwZGF0ZShwYWNrZXQuc2xpY2UoNCkpO1xuICAgIHRoaXMuX29uV3JpdGUoZW5jcnlwdGVkKTtcbiAgICBjb25zdCBmaW5hbCA9IGNpcGhlci5maW5hbCgpO1xuICAgIC8vIFhYWDogZmluYWwubGVuZ3RoID09PSAwIGFsd2F5cz9cbiAgICBpZiAoZmluYWwubGVuZ3RoKVxuICAgICAgdGhpcy5fb25Xcml0ZShmaW5hbCk7XG5cbiAgICAvLyBHZW5lcmF0ZSBNQUNcbiAgICBjb25zdCB0YWcgPSBjaXBoZXIuZ2V0QXV0aFRhZygpO1xuICAgIHRoaXMuX29uV3JpdGUodGFnKTtcblxuICAgIC8vIEluY3JlbWVudCBjb3VudGVyIGluIElWIGJ5IDEgZm9yIG5leHQgcGFja2V0XG4gICAgaXZJbmNyZW1lbnQodGhpcy5fZW5jSVYpO1xuXG4gICAgdGhpcy5vdXRTZXFubyA9ICh0aGlzLm91dFNlcW5vICsgMSkgPj4+IDA7XG4gIH1cbn1cblxuY2xhc3MgQUVTR0NNQ2lwaGVyQmluZGluZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IGVuYyA9IGNvbmZpZy5vdXRib3VuZDtcbiAgICB0aGlzLm91dFNlcW5vID0gZW5jLnNlcW5vO1xuICAgIHRoaXMuX29uV3JpdGUgPSBlbmMub25Xcml0ZTtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBBRVNHQ01DaXBoZXIoZW5jLmNpcGhlckluZm8uc3NsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jLmNpcGhlcktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jLmNpcGhlcklWKTtcbiAgICB0aGlzLl9kZWFkID0gZmFsc2U7XG4gIH1cbiAgZnJlZSgpIHtcbiAgICB0aGlzLl9kZWFkID0gdHJ1ZTtcbiAgICB0aGlzLl9pbnN0YW5jZS5mcmVlKCk7XG4gIH1cbiAgYWxsb2NQYWNrZXQocGF5bG9hZExlbikge1xuICAgIGxldCBwa3RMZW4gPSA0ICsgMSArIHBheWxvYWRMZW47XG4gICAgbGV0IHBhZExlbiA9IDE2IC0gKChwa3RMZW4gLSA0KSAmICgxNiAtIDEpKTtcbiAgICBpZiAocGFkTGVuIDwgNClcbiAgICAgIHBhZExlbiArPSAxNjtcbiAgICBwa3RMZW4gKz0gcGFkTGVuO1xuXG4gICAgY29uc3QgcGFja2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBrdExlbiArIDE2LyogYXV0aFRhZyAqLyk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcGt0TGVuIC0gNCwgMCk7XG4gICAgcGFja2V0WzRdID0gcGFkTGVuO1xuXG4gICAgcmFuZG9tRmlsbFN5bmMocGFja2V0LCA1ICsgcGF5bG9hZExlbiwgcGFkTGVuKTtcblxuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgZW5jcnlwdChwYWNrZXQpIHtcbiAgICAvLyBgcGFja2V0YCA9PT0gdW5lbmNyeXB0ZWQgcGFja2V0XG5cbiAgICBpZiAodGhpcy5fZGVhZClcbiAgICAgIHJldHVybjtcblxuICAgIC8vIEVuY3J5cHRzIGluLXBsYWNlXG4gICAgdGhpcy5faW5zdGFuY2UuZW5jcnlwdChwYWNrZXQpO1xuXG4gICAgdGhpcy5fb25Xcml0ZShwYWNrZXQpO1xuXG4gICAgdGhpcy5vdXRTZXFubyA9ICh0aGlzLm91dFNlcW5vICsgMSkgPj4+IDA7XG4gIH1cbn1cblxuXG5jbGFzcyBHZW5lcmljQ2lwaGVyTmF0aXZlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3QgZW5jID0gY29uZmlnLm91dGJvdW5kO1xuICAgIHRoaXMub3V0U2Vxbm8gPSBlbmMuc2Vxbm87XG4gICAgdGhpcy5fb25Xcml0ZSA9IGVuYy5vbldyaXRlO1xuICAgIHRoaXMuX2VuY0Jsb2NrTGVuID0gZW5jLmNpcGhlckluZm8uYmxvY2tMZW47XG4gICAgdGhpcy5fY2lwaGVySW5zdGFuY2UgPSBjcmVhdGVDaXBoZXJpdihlbmMuY2lwaGVySW5mby5zc2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jLmNpcGhlcktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYy5jaXBoZXJJVik7XG4gICAgdGhpcy5fbWFjU1NMTmFtZSA9IGVuYy5tYWNJbmZvLnNzbE5hbWU7XG4gICAgdGhpcy5fbWFjS2V5ID0gZW5jLm1hY0tleTtcbiAgICB0aGlzLl9tYWNBY3R1YWxMZW4gPSBlbmMubWFjSW5mby5hY3R1YWxMZW47XG4gICAgdGhpcy5fbWFjRVRNID0gZW5jLm1hY0luZm8uaXNFVE07XG4gICAgdGhpcy5fYWFkTGVuID0gKHRoaXMuX21hY0VUTSA/IDQgOiAwKTtcbiAgICB0aGlzLl9kZWFkID0gZmFsc2U7XG5cbiAgICBjb25zdCBkaXNjYXJkTGVuID0gZW5jLmNpcGhlckluZm8uZGlzY2FyZExlbjtcbiAgICBpZiAoZGlzY2FyZExlbikge1xuICAgICAgbGV0IGRpc2NhcmQgPSBESVNDQVJEX0NBQ0hFLmdldChkaXNjYXJkTGVuKTtcbiAgICAgIGlmIChkaXNjYXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY2FyZCA9IEJ1ZmZlci5hbGxvYyhkaXNjYXJkTGVuKTtcbiAgICAgICAgRElTQ0FSRF9DQUNIRS5zZXQoZGlzY2FyZExlbiwgZGlzY2FyZCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jaXBoZXJJbnN0YW5jZS51cGRhdGUoZGlzY2FyZCk7XG4gICAgfVxuICB9XG4gIGZyZWUoKSB7XG4gICAgdGhpcy5fZGVhZCA9IHRydWU7XG4gIH1cbiAgYWxsb2NQYWNrZXQocGF5bG9hZExlbikge1xuICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5fZW5jQmxvY2tMZW47XG5cbiAgICBsZXQgcGt0TGVuID0gNCArIDEgKyBwYXlsb2FkTGVuO1xuICAgIGxldCBwYWRMZW4gPSBibG9ja0xlbiAtICgocGt0TGVuIC0gdGhpcy5fYWFkTGVuKSAmIChibG9ja0xlbiAtIDEpKTtcbiAgICBpZiAocGFkTGVuIDwgNClcbiAgICAgIHBhZExlbiArPSBibG9ja0xlbjtcbiAgICBwa3RMZW4gKz0gcGFkTGVuO1xuXG4gICAgY29uc3QgcGFja2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBrdExlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcGt0TGVuIC0gNCwgMCk7XG4gICAgcGFja2V0WzRdID0gcGFkTGVuO1xuXG4gICAgcmFuZG9tRmlsbFN5bmMocGFja2V0LCA1ICsgcGF5bG9hZExlbiwgcGFkTGVuKTtcblxuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgZW5jcnlwdChwYWNrZXQpIHtcbiAgICAvLyBgcGFja2V0YCA9PT0gdW5lbmNyeXB0ZWQgcGFja2V0XG5cbiAgICBpZiAodGhpcy5fZGVhZClcbiAgICAgIHJldHVybjtcblxuICAgIGxldCBtYWM7XG4gICAgaWYgKHRoaXMuX21hY0VUTSkge1xuICAgICAgLy8gRW5jcnlwdCBwYWQgbGVuZ3RoLCBwYXlsb2FkLCBhbmQgcGFkZGluZ1xuICAgICAgY29uc3QgbGVuQnl0ZXMgPSBuZXcgVWludDhBcnJheShwYWNrZXQuYnVmZmVyLCBwYWNrZXQuYnl0ZU9mZnNldCwgNCk7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSB0aGlzLl9jaXBoZXJJbnN0YW5jZS51cGRhdGUoXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHBhY2tldC5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgIHBhY2tldC5ieXRlT2Zmc2V0ICsgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0Lmxlbmd0aCAtIDQpXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9vbldyaXRlKGxlbkJ5dGVzKTtcbiAgICAgIHRoaXMuX29uV3JpdGUoZW5jcnlwdGVkKTtcblxuICAgICAgLy8gVE9ETzogbG9vayBpbnRvIHN0b3Jpbmcgc2Vxbm8gYXMgNC1ieXRlIGJ1ZmZlciBhbmQgaW5jcmVtZW50aW5nIGxpa2Ugd2VcbiAgICAgIC8vIGRvIGZvciBBRVMtR0NNIElWcyB0byBhdm9pZCBoYXZpbmcgdG8gKHJlKXdyaXRlIGFsbCA0IGJ5dGVzIGV2ZXJ5IHRpbWVcbiAgICAgIG1hYyA9IGNyZWF0ZUhtYWModGhpcy5fbWFjU1NMTmFtZSwgdGhpcy5fbWFjS2V5KTtcbiAgICAgIHdyaXRlVUludDMyQkUoQlVGX0lOVCwgdGhpcy5vdXRTZXFubywgMCk7XG4gICAgICBtYWMudXBkYXRlKEJVRl9JTlQpO1xuICAgICAgbWFjLnVwZGF0ZShsZW5CeXRlcyk7XG4gICAgICBtYWMudXBkYXRlKGVuY3J5cHRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVuY3J5cHQgbGVuZ3RoIGZpZWxkLCBwYWQgbGVuZ3RoLCBwYXlsb2FkLCBhbmQgcGFkZGluZ1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gdGhpcy5fY2lwaGVySW5zdGFuY2UudXBkYXRlKHBhY2tldCk7XG4gICAgICB0aGlzLl9vbldyaXRlKGVuY3J5cHRlZCk7XG5cbiAgICAgIC8vIFRPRE86IGxvb2sgaW50byBzdG9yaW5nIHNlcW5vIGFzIDQtYnl0ZSBidWZmZXIgYW5kIGluY3JlbWVudGluZyBsaWtlIHdlXG4gICAgICAvLyBkbyBmb3IgQUVTLUdDTSBJVnMgdG8gYXZvaWQgaGF2aW5nIHRvIChyZSl3cml0ZSBhbGwgNCBieXRlcyBldmVyeSB0aW1lXG4gICAgICBtYWMgPSBjcmVhdGVIbWFjKHRoaXMuX21hY1NTTE5hbWUsIHRoaXMuX21hY0tleSk7XG4gICAgICB3cml0ZVVJbnQzMkJFKEJVRl9JTlQsIHRoaXMub3V0U2Vxbm8sIDApO1xuICAgICAgbWFjLnVwZGF0ZShCVUZfSU5UKTtcbiAgICAgIG1hYy51cGRhdGUocGFja2V0KTtcbiAgICB9XG5cbiAgICBsZXQgZGlnZXN0ID0gbWFjLmRpZ2VzdCgpO1xuICAgIGlmIChkaWdlc3QubGVuZ3RoID4gdGhpcy5fbWFjQWN0dWFsTGVuKVxuICAgICAgZGlnZXN0ID0gZGlnZXN0LnNsaWNlKDAsIHRoaXMuX21hY0FjdHVhbExlbik7XG4gICAgdGhpcy5fb25Xcml0ZShkaWdlc3QpO1xuXG4gICAgdGhpcy5vdXRTZXFubyA9ICh0aGlzLm91dFNlcW5vICsgMSkgPj4+IDA7XG4gIH1cbn1cblxuY2xhc3MgR2VuZXJpY0NpcGhlckJpbmRpbmcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCBlbmMgPSBjb25maWcub3V0Ym91bmQ7XG4gICAgdGhpcy5vdXRTZXFubyA9IGVuYy5zZXFubztcbiAgICB0aGlzLl9vbldyaXRlID0gZW5jLm9uV3JpdGU7XG4gICAgdGhpcy5fZW5jQmxvY2tMZW4gPSBlbmMuY2lwaGVySW5mby5ibG9ja0xlbjtcbiAgICB0aGlzLl9tYWNMZW4gPSBlbmMubWFjSW5mby5sZW47XG4gICAgdGhpcy5fbWFjQWN0dWFsTGVuID0gZW5jLm1hY0luZm8uYWN0dWFsTGVuO1xuICAgIHRoaXMuX2FhZExlbiA9IChlbmMubWFjSW5mby5pc0VUTSA/IDQgOiAwKTtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBHZW5lcmljQ2lwaGVyKGVuYy5jaXBoZXJJbmZvLnNzbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmMuY2lwaGVyS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jLmNpcGhlcklWLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jLm1hY0luZm8uc3NsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYy5tYWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmMubWFjSW5mby5pc0VUTSk7XG4gICAgdGhpcy5fZGVhZCA9IGZhbHNlO1xuICB9XG4gIGZyZWUoKSB7XG4gICAgdGhpcy5fZGVhZCA9IHRydWU7XG4gICAgdGhpcy5faW5zdGFuY2UuZnJlZSgpO1xuICB9XG4gIGFsbG9jUGFja2V0KHBheWxvYWRMZW4pIHtcbiAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuX2VuY0Jsb2NrTGVuO1xuXG4gICAgbGV0IHBrdExlbiA9IDQgKyAxICsgcGF5bG9hZExlbjtcbiAgICBsZXQgcGFkTGVuID0gYmxvY2tMZW4gLSAoKHBrdExlbiAtIHRoaXMuX2FhZExlbikgJiAoYmxvY2tMZW4gLSAxKSk7XG4gICAgaWYgKHBhZExlbiA8IDQpXG4gICAgICBwYWRMZW4gKz0gYmxvY2tMZW47XG4gICAgcGt0TGVuICs9IHBhZExlbjtcblxuICAgIGNvbnN0IHBhY2tldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShwa3RMZW4gKyB0aGlzLl9tYWNMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHBrdExlbiAtIDQsIDApO1xuICAgIHBhY2tldFs0XSA9IHBhZExlbjtcblxuICAgIHJhbmRvbUZpbGxTeW5jKHBhY2tldCwgNSArIHBheWxvYWRMZW4sIHBhZExlbik7XG5cbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIGVuY3J5cHQocGFja2V0KSB7XG4gICAgLy8gYHBhY2tldGAgPT09IHVuZW5jcnlwdGVkIHBhY2tldFxuXG4gICAgaWYgKHRoaXMuX2RlYWQpXG4gICAgICByZXR1cm47XG5cbiAgICAvLyBFbmNyeXB0cyBpbi1wbGFjZVxuICAgIHRoaXMuX2luc3RhbmNlLmVuY3J5cHQocGFja2V0LCB0aGlzLm91dFNlcW5vKTtcblxuICAgIGlmICh0aGlzLl9tYWNBY3R1YWxMZW4gPCB0aGlzLl9tYWNMZW4pIHtcbiAgICAgIHBhY2tldCA9IG5ldyBGYXN0QnVmZmVyKHBhY2tldC5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXQuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwYWNrZXQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gKHRoaXMuX21hY0xlbiAtIHRoaXMuX21hY0FjdHVhbExlbikpKTtcbiAgICB9XG4gICAgdGhpcy5fb25Xcml0ZShwYWNrZXQpO1xuXG4gICAgdGhpcy5vdXRTZXFubyA9ICh0aGlzLm91dFNlcW5vICsgMSkgPj4+IDA7XG4gIH1cbn1cblxuXG5jbGFzcyBOdWxsRGVjaXBoZXIge1xuICBjb25zdHJ1Y3RvcihzZXFubywgb25QYXlsb2FkKSB7XG4gICAgdGhpcy5pblNlcW5vID0gc2Vxbm87XG4gICAgdGhpcy5fb25QYXlsb2FkID0gb25QYXlsb2FkO1xuICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgdGhpcy5fbGVuQnl0ZXMgPSAwO1xuICAgIHRoaXMuX3BhY2tldCA9IG51bGw7XG4gICAgdGhpcy5fcGFja2V0UG9zID0gMDtcbiAgfVxuICBmcmVlKCkge31cbiAgZGVjcnlwdChkYXRhLCBwLCBkYXRhTGVuKSB7XG4gICAgd2hpbGUgKHAgPCBkYXRhTGVuKSB7XG4gICAgICAvLyBSZWFkIHBhY2tldCBsZW5ndGhcbiAgICAgIGlmICh0aGlzLl9sZW5CeXRlcyA8IDQpIHtcbiAgICAgICAgbGV0IG5iID0gTWF0aC5taW4oNCAtIHRoaXMuX2xlbkJ5dGVzLCBkYXRhTGVuIC0gcCk7XG5cbiAgICAgICAgdGhpcy5fbGVuQnl0ZXMgKz0gbmI7XG4gICAgICAgIHdoaWxlIChuYi0tKVxuICAgICAgICAgIHRoaXMuX2xlbiA9ICh0aGlzLl9sZW4gPDwgOCkgKyBkYXRhW3ArK107XG5cbiAgICAgICAgaWYgKHRoaXMuX2xlbkJ5dGVzIDwgNClcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMuX2xlbiA+IE1BWF9QQUNLRVRfU0laRVxuICAgICAgICAgICAgfHwgdGhpcy5fbGVuIDwgOFxuICAgICAgICAgICAgfHwgKDQgKyB0aGlzLl9sZW4gJiA3KSAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHBhY2tldCBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA+PSBkYXRhTGVuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVhZCBwYWRkaW5nIGxlbmd0aCwgcGF5bG9hZCwgYW5kIHBhZGRpbmdcbiAgICAgIGlmICh0aGlzLl9wYWNrZXRQb3MgPCB0aGlzLl9sZW4pIHtcbiAgICAgICAgY29uc3QgbmIgPSBNYXRoLm1pbih0aGlzLl9sZW4gLSB0aGlzLl9wYWNrZXRQb3MsIGRhdGFMZW4gLSBwKTtcbiAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbilcbiAgICAgICAgICBjaHVuayA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQgKyBwLCBuYik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjaHVuayA9IGRhdGE7XG4gICAgICAgIGlmIChuYiA9PT0gdGhpcy5fbGVuKSB7XG4gICAgICAgICAgdGhpcy5fcGFja2V0ID0gY2h1bms7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9wYWNrZXQpXG4gICAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fbGVuKTtcbiAgICAgICAgICB0aGlzLl9wYWNrZXQuc2V0KGNodW5rLCB0aGlzLl9wYWNrZXRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHAgKz0gbmI7XG4gICAgICAgIHRoaXMuX3BhY2tldFBvcyArPSBuYjtcbiAgICAgICAgaWYgKHRoaXMuX3BhY2tldFBvcyA8IHRoaXMuX2xlbilcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBheWxvYWQgPSAoIXRoaXMuX3BhY2tldFxuICAgICAgICAgICAgICAgICAgICAgICA/IEVNUFRZX0JVRkZFUlxuICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBGYXN0QnVmZmVyKHRoaXMuX3BhY2tldC5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFja2V0LmJ5dGVPZmZzZXQgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhY2tldC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gdGhpcy5fcGFja2V0WzBdIC0gMSkpO1xuXG4gICAgICAvLyBQcmVwYXJlIGZvciBuZXh0IHBhY2tldFxuICAgICAgdGhpcy5pblNlcW5vID0gKHRoaXMuaW5TZXFubyArIDEpID4+PiAwO1xuICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICAgIHRoaXMuX2xlbkJ5dGVzID0gMDtcbiAgICAgIHRoaXMuX3BhY2tldCA9IG51bGw7XG4gICAgICB0aGlzLl9wYWNrZXRQb3MgPSAwO1xuXG4gICAgICB7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMuX29uUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiAocmV0ID09PSBmYWxzZSA/IHAgOiByZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBDaGFDaGFQb2x5RGVjaXBoZXJOYXRpdmUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCBkZWMgPSBjb25maWcuaW5ib3VuZDtcbiAgICB0aGlzLmluU2Vxbm8gPSBkZWMuc2Vxbm87XG4gICAgdGhpcy5fb25QYXlsb2FkID0gZGVjLm9uUGF5bG9hZDtcbiAgICB0aGlzLl9kZWNLZXlNYWluID0gZGVjLmRlY2lwaGVyS2V5LnNsaWNlKDAsIDMyKTtcbiAgICB0aGlzLl9kZWNLZXlQa3RMZW4gPSBkZWMuZGVjaXBoZXJLZXkuc2xpY2UoMzIpO1xuICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgdGhpcy5fbGVuQnVmID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIHRoaXMuX2xlblBvcyA9IDA7XG4gICAgdGhpcy5fcGFja2V0ID0gbnVsbDtcbiAgICB0aGlzLl9wa3RMZW4gPSAwO1xuICAgIHRoaXMuX21hYyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNik7XG4gICAgdGhpcy5fY2FsY01hYyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNik7XG4gICAgdGhpcy5fbWFjUG9zID0gMDtcbiAgfVxuICBmcmVlKCkge31cbiAgZGVjcnlwdChkYXRhLCBwLCBkYXRhTGVuKSB7XG4gICAgLy8gYGRhdGFgID09PSBlbmNyeXB0ZWQgZGF0YVxuXG4gICAgd2hpbGUgKHAgPCBkYXRhTGVuKSB7XG4gICAgICAvLyBSZWFkIHBhY2tldCBsZW5ndGhcbiAgICAgIGlmICh0aGlzLl9sZW5Qb3MgPCA0KSB7XG4gICAgICAgIGxldCBuYiA9IE1hdGgubWluKDQgLSB0aGlzLl9sZW5Qb3MsIGRhdGFMZW4gLSBwKTtcbiAgICAgICAgd2hpbGUgKG5iLS0pXG4gICAgICAgICAgdGhpcy5fbGVuQnVmW3RoaXMuX2xlblBvcysrXSA9IGRhdGFbcCsrXTtcbiAgICAgICAgaWYgKHRoaXMuX2xlblBvcyA8IDQpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIFBPTFkxMzA1X09VVF9DT01QVVRFWzBdID0gMDsgLy8gU2V0IGNvdW50ZXIgdG8gMCAobGl0dGxlIGVuZGlhbilcbiAgICAgICAgd3JpdGVVSW50MzJCRShQT0xZMTMwNV9PVVRfQ09NUFVURSwgdGhpcy5pblNlcW5vLCAxMik7XG5cbiAgICAgICAgY29uc3QgZGVjTGVuQnl0ZXMgPVxuICAgICAgICAgIGNyZWF0ZURlY2lwaGVyaXYoJ2NoYWNoYTIwJywgdGhpcy5fZGVjS2V5UGt0TGVuLCBQT0xZMTMwNV9PVVRfQ09NUFVURSlcbiAgICAgICAgICAudXBkYXRlKHRoaXMuX2xlbkJ1Zik7XG4gICAgICAgIHRoaXMuX2xlbiA9IHJlYWRVSW50MzJCRShkZWNMZW5CeXRlcywgMCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xlbiA+IE1BWF9QQUNLRVRfU0laRVxuICAgICAgICAgICAgfHwgdGhpcy5fbGVuIDwgOFxuICAgICAgICAgICAgfHwgKHRoaXMuX2xlbiAmIDcpICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgcGFja2V0IGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlYWQgcGFkZGluZyBsZW5ndGgsIHBheWxvYWQsIGFuZCBwYWRkaW5nXG4gICAgICBpZiAodGhpcy5fcGt0TGVuIDwgdGhpcy5fbGVuKSB7XG4gICAgICAgIGlmIChwID49IGRhdGFMZW4pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuYiA9IE1hdGgubWluKHRoaXMuX2xlbiAtIHRoaXMuX3BrdExlbiwgZGF0YUxlbiAtIHApO1xuICAgICAgICBsZXQgZW5jcnlwdGVkO1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbilcbiAgICAgICAgICBlbmNyeXB0ZWQgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgcCwgbmIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZW5jcnlwdGVkID0gZGF0YTtcbiAgICAgICAgaWYgKG5iID09PSB0aGlzLl9sZW4pIHtcbiAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBlbmNyeXB0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9wYWNrZXQpXG4gICAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fbGVuKTtcbiAgICAgICAgICB0aGlzLl9wYWNrZXQuc2V0KGVuY3J5cHRlZCwgdGhpcy5fcGt0TGVuKTtcbiAgICAgICAgfVxuICAgICAgICBwICs9IG5iO1xuICAgICAgICB0aGlzLl9wa3RMZW4gKz0gbmI7XG4gICAgICAgIGlmICh0aGlzLl9wa3RMZW4gPCB0aGlzLl9sZW4gfHwgcCA+PSBkYXRhTGVuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVhZCBQb2x5MTMwNSBNQUNcbiAgICAgIHtcbiAgICAgICAgY29uc3QgbmIgPSBNYXRoLm1pbigxNiAtIHRoaXMuX21hY1BvcywgZGF0YUxlbiAtIHApO1xuICAgICAgICAvLyBUT0RPOiBhdm9pZCBjb3B5aW5nIGlmIGVudGlyZSBNQUMgaXMgaW4gY3VycmVudCBjaHVua1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbikge1xuICAgICAgICAgIHRoaXMuX21hYy5zZXQoXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgcCwgbmIpLFxuICAgICAgICAgICAgdGhpcy5fbWFjUG9zXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9tYWMuc2V0KGRhdGEsIHRoaXMuX21hY1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcCArPSBuYjtcbiAgICAgICAgdGhpcy5fbWFjUG9zICs9IG5iO1xuICAgICAgICBpZiAodGhpcy5fbWFjUG9zIDwgMTYpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBHZW5lcmF0ZSBQb2x5MTMwNSBrZXlcbiAgICAgIFBPTFkxMzA1X09VVF9DT01QVVRFWzBdID0gMDsgLy8gU2V0IGNvdW50ZXIgdG8gMCAobGl0dGxlIGVuZGlhbilcbiAgICAgIHdyaXRlVUludDMyQkUoUE9MWTEzMDVfT1VUX0NPTVBVVEUsIHRoaXMuaW5TZXFubywgMTIpO1xuICAgICAgY29uc3QgcG9seUtleSA9XG4gICAgICAgIGNyZWF0ZUNpcGhlcml2KCdjaGFjaGEyMCcsIHRoaXMuX2RlY0tleU1haW4sIFBPTFkxMzA1X09VVF9DT01QVVRFKVxuICAgICAgICAudXBkYXRlKFBPTFkxMzA1X1pFUk9TKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGFuZCBjb21wYXJlIFBvbHkxMzA1IE1BQ3NcbiAgICAgIHBvbHkxMzA1X2F1dGgoUE9MWTEzMDVfUkVTVUxUX01BTExPQyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVuQnVmLFxuICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWNrZXQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhY2tldC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHBvbHlLZXkpO1xuXG4gICAgICB0aGlzLl9jYWxjTWFjLnNldChcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoUE9MWTEzMDVfV0FTTV9NT0RVTEUuSEVBUFU4LmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgUE9MWTEzMDVfUkVTVUxUX01BTExPQyxcbiAgICAgICAgICAgICAgICAgICAgICAgMTYpLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgaWYgKCF0aW1pbmdTYWZlRXF1YWwodGhpcy5fY2FsY01hYywgdGhpcy5fbWFjKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE1BQycpO1xuXG4gICAgICAvLyBEZWNyeXB0IHBhY2tldFxuICAgICAgUE9MWTEzMDVfT1VUX0NPTVBVVEVbMF0gPSAxOyAvLyBTZXQgY291bnRlciB0byAxIChsaXR0bGUgZW5kaWFuKVxuICAgICAgY29uc3QgcGFja2V0ID1cbiAgICAgICAgY3JlYXRlRGVjaXBoZXJpdignY2hhY2hhMjAnLCB0aGlzLl9kZWNLZXlNYWluLCBQT0xZMTMwNV9PVVRfQ09NUFVURSlcbiAgICAgICAgLnVwZGF0ZSh0aGlzLl9wYWNrZXQpO1xuXG4gICAgICBjb25zdCBwYXlsb2FkID0gbmV3IEZhc3RCdWZmZXIocGFja2V0LmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXQuYnl0ZU9mZnNldCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0Lmxlbmd0aCAtIHBhY2tldFswXSAtIDEpO1xuXG4gICAgICAvLyBQcmVwYXJlIGZvciBuZXh0IHBhY2tldFxuICAgICAgdGhpcy5pblNlcW5vID0gKHRoaXMuaW5TZXFubyArIDEpID4+PiAwO1xuICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICAgIHRoaXMuX2xlblBvcyA9IDA7XG4gICAgICB0aGlzLl9wYWNrZXQgPSBudWxsO1xuICAgICAgdGhpcy5fcGt0TGVuID0gMDtcbiAgICAgIHRoaXMuX21hY1BvcyA9IDA7XG5cbiAgICAgIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5fb25QYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIChyZXQgPT09IGZhbHNlID8gcCA6IHJldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIENoYUNoYVBvbHlEZWNpcGhlckJpbmRpbmcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCBkZWMgPSBjb25maWcuaW5ib3VuZDtcbiAgICB0aGlzLmluU2Vxbm8gPSBkZWMuc2Vxbm87XG4gICAgdGhpcy5fb25QYXlsb2FkID0gZGVjLm9uUGF5bG9hZDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBDaGFDaGFQb2x5RGVjaXBoZXIoZGVjLmRlY2lwaGVyS2V5KTtcbiAgICB0aGlzLl9sZW4gPSAwO1xuICAgIHRoaXMuX2xlbkJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICB0aGlzLl9sZW5Qb3MgPSAwO1xuICAgIHRoaXMuX3BhY2tldCA9IG51bGw7XG4gICAgdGhpcy5fcGt0TGVuID0gMDtcbiAgICB0aGlzLl9tYWMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpO1xuICAgIHRoaXMuX21hY1BvcyA9IDA7XG4gIH1cbiAgZnJlZSgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZS5mcmVlKCk7XG4gIH1cbiAgZGVjcnlwdChkYXRhLCBwLCBkYXRhTGVuKSB7XG4gICAgLy8gYGRhdGFgID09PSBlbmNyeXB0ZWQgZGF0YVxuXG4gICAgd2hpbGUgKHAgPCBkYXRhTGVuKSB7XG4gICAgICAvLyBSZWFkIHBhY2tldCBsZW5ndGhcbiAgICAgIGlmICh0aGlzLl9sZW5Qb3MgPCA0KSB7XG4gICAgICAgIGxldCBuYiA9IE1hdGgubWluKDQgLSB0aGlzLl9sZW5Qb3MsIGRhdGFMZW4gLSBwKTtcbiAgICAgICAgd2hpbGUgKG5iLS0pXG4gICAgICAgICAgdGhpcy5fbGVuQnVmW3RoaXMuX2xlblBvcysrXSA9IGRhdGFbcCsrXTtcbiAgICAgICAgaWYgKHRoaXMuX2xlblBvcyA8IDQpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2xlbiA9IHRoaXMuX2luc3RhbmNlLmRlY3J5cHRMZW4odGhpcy5fbGVuQnVmLCB0aGlzLmluU2Vxbm8pO1xuXG4gICAgICAgIGlmICh0aGlzLl9sZW4gPiBNQVhfUEFDS0VUX1NJWkVcbiAgICAgICAgICAgIHx8IHRoaXMuX2xlbiA8IDhcbiAgICAgICAgICAgIHx8ICh0aGlzLl9sZW4gJiA3KSAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHBhY2tldCBsZW5ndGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwID49IGRhdGFMZW4pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWFkIHBhZGRpbmcgbGVuZ3RoLCBwYXlsb2FkLCBhbmQgcGFkZGluZ1xuICAgICAgaWYgKHRoaXMuX3BrdExlbiA8IHRoaXMuX2xlbikge1xuICAgICAgICBjb25zdCBuYiA9IE1hdGgubWluKHRoaXMuX2xlbiAtIHRoaXMuX3BrdExlbiwgZGF0YUxlbiAtIHApO1xuICAgICAgICBsZXQgZW5jcnlwdGVkO1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbilcbiAgICAgICAgICBlbmNyeXB0ZWQgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgcCwgbmIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZW5jcnlwdGVkID0gZGF0YTtcbiAgICAgICAgaWYgKG5iID09PSB0aGlzLl9sZW4pIHtcbiAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBlbmNyeXB0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9wYWNrZXQpXG4gICAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fbGVuKTtcbiAgICAgICAgICB0aGlzLl9wYWNrZXQuc2V0KGVuY3J5cHRlZCwgdGhpcy5fcGt0TGVuKTtcbiAgICAgICAgfVxuICAgICAgICBwICs9IG5iO1xuICAgICAgICB0aGlzLl9wa3RMZW4gKz0gbmI7XG4gICAgICAgIGlmICh0aGlzLl9wa3RMZW4gPCB0aGlzLl9sZW4gfHwgcCA+PSBkYXRhTGVuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVhZCBQb2x5MTMwNSBNQUNcbiAgICAgIHtcbiAgICAgICAgY29uc3QgbmIgPSBNYXRoLm1pbigxNiAtIHRoaXMuX21hY1BvcywgZGF0YUxlbiAtIHApO1xuICAgICAgICAvLyBUT0RPOiBhdm9pZCBjb3B5aW5nIGlmIGVudGlyZSBNQUMgaXMgaW4gY3VycmVudCBjaHVua1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbikge1xuICAgICAgICAgIHRoaXMuX21hYy5zZXQoXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgcCwgbmIpLFxuICAgICAgICAgICAgdGhpcy5fbWFjUG9zXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9tYWMuc2V0KGRhdGEsIHRoaXMuX21hY1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcCArPSBuYjtcbiAgICAgICAgdGhpcy5fbWFjUG9zICs9IG5iO1xuICAgICAgICBpZiAodGhpcy5fbWFjUG9zIDwgMTYpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnN0YW5jZS5kZWNyeXB0KHRoaXMuX3BhY2tldCwgdGhpcy5fbWFjLCB0aGlzLmluU2Vxbm8pO1xuXG4gICAgICBjb25zdCBwYXlsb2FkID0gbmV3IEZhc3RCdWZmZXIodGhpcy5fcGFja2V0LmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWNrZXQuYnl0ZU9mZnNldCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFja2V0Lmxlbmd0aCAtIHRoaXMuX3BhY2tldFswXSAtIDEpO1xuXG4gICAgICAvLyBQcmVwYXJlIGZvciBuZXh0IHBhY2tldFxuICAgICAgdGhpcy5pblNlcW5vID0gKHRoaXMuaW5TZXFubyArIDEpID4+PiAwO1xuICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICAgIHRoaXMuX2xlblBvcyA9IDA7XG4gICAgICB0aGlzLl9wYWNrZXQgPSBudWxsO1xuICAgICAgdGhpcy5fcGt0TGVuID0gMDtcbiAgICAgIHRoaXMuX21hY1BvcyA9IDA7XG5cbiAgICAgIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5fb25QYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIChyZXQgPT09IGZhbHNlID8gcCA6IHJldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEFFU0dDTURlY2lwaGVyTmF0aXZlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3QgZGVjID0gY29uZmlnLmluYm91bmQ7XG4gICAgdGhpcy5pblNlcW5vID0gZGVjLnNlcW5vO1xuICAgIHRoaXMuX29uUGF5bG9hZCA9IGRlYy5vblBheWxvYWQ7XG4gICAgdGhpcy5fZGVjaXBoZXJJbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5fZGVjaXBoZXJTU0xOYW1lID0gZGVjLmRlY2lwaGVySW5mby5zc2xOYW1lO1xuICAgIHRoaXMuX2RlY2lwaGVyS2V5ID0gZGVjLmRlY2lwaGVyS2V5O1xuICAgIHRoaXMuX2RlY2lwaGVySVYgPSBkZWMuZGVjaXBoZXJJVjtcbiAgICB0aGlzLl9sZW4gPSAwO1xuICAgIHRoaXMuX2xlbkJ5dGVzID0gMDtcbiAgICB0aGlzLl9wYWNrZXQgPSBudWxsO1xuICAgIHRoaXMuX3BhY2tldFBvcyA9IDA7XG4gICAgdGhpcy5fcGt0TGVuID0gMDtcbiAgICB0aGlzLl90YWcgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpO1xuICAgIHRoaXMuX3RhZ1BvcyA9IDA7XG4gIH1cbiAgZnJlZSgpIHt9XG4gIGRlY3J5cHQoZGF0YSwgcCwgZGF0YUxlbikge1xuICAgIC8vIGBkYXRhYCA9PT0gZW5jcnlwdGVkIGRhdGFcblxuICAgIHdoaWxlIChwIDwgZGF0YUxlbikge1xuICAgICAgLy8gUmVhZCBwYWNrZXQgbGVuZ3RoICh1bmVuY3J5cHRlZCwgYnV0IEFBRClcbiAgICAgIGlmICh0aGlzLl9sZW5CeXRlcyA8IDQpIHtcbiAgICAgICAgbGV0IG5iID0gTWF0aC5taW4oNCAtIHRoaXMuX2xlbkJ5dGVzLCBkYXRhTGVuIC0gcCk7XG4gICAgICAgIHRoaXMuX2xlbkJ5dGVzICs9IG5iO1xuICAgICAgICB3aGlsZSAobmItLSlcbiAgICAgICAgICB0aGlzLl9sZW4gPSAodGhpcy5fbGVuIDw8IDgpICsgZGF0YVtwKytdO1xuICAgICAgICBpZiAodGhpcy5fbGVuQnl0ZXMgPCA0KVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAoKHRoaXMuX2xlbiArIDIwKSA+IE1BWF9QQUNLRVRfU0laRVxuICAgICAgICAgICAgfHwgdGhpcy5fbGVuIDwgMTZcbiAgICAgICAgICAgIHx8ICh0aGlzLl9sZW4gJiAxNSkgIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBwYWNrZXQgbGVuZ3RoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kZWNpcGhlckluc3RhbmNlID0gY3JlYXRlRGVjaXBoZXJpdihcbiAgICAgICAgICB0aGlzLl9kZWNpcGhlclNTTE5hbWUsXG4gICAgICAgICAgdGhpcy5fZGVjaXBoZXJLZXksXG4gICAgICAgICAgdGhpcy5fZGVjaXBoZXJJVlxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9kZWNpcGhlckluc3RhbmNlLnNldEF1dG9QYWRkaW5nKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZGVjaXBoZXJJbnN0YW5jZS5zZXRBQUQoaW50VG9CeXRlcyh0aGlzLl9sZW4pKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVhZCBwYWRkaW5nIGxlbmd0aCwgcGF5bG9hZCwgYW5kIHBhZGRpbmdcbiAgICAgIGlmICh0aGlzLl9wa3RMZW4gPCB0aGlzLl9sZW4pIHtcbiAgICAgICAgaWYgKHAgPj0gZGF0YUxlbilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG5iID0gTWF0aC5taW4odGhpcy5fbGVuIC0gdGhpcy5fcGt0TGVuLCBkYXRhTGVuIC0gcCk7XG4gICAgICAgIGxldCBkZWNyeXB0ZWQ7XG4gICAgICAgIGlmIChwICE9PSAwIHx8IG5iICE9PSBkYXRhTGVuKSB7XG4gICAgICAgICAgZGVjcnlwdGVkID0gdGhpcy5fZGVjaXBoZXJJbnN0YW5jZS51cGRhdGUoXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgcCwgbmIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWNyeXB0ZWQgPSB0aGlzLl9kZWNpcGhlckluc3RhbmNlLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjcnlwdGVkLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gdGhpcy5fbGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBkZWNyeXB0ZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGFja2V0KVxuICAgICAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fbGVuKTtcbiAgICAgICAgICAgIHRoaXMuX3BhY2tldC5zZXQoZGVjcnlwdGVkLCB0aGlzLl9wYWNrZXRQb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9wYWNrZXRQb3MgKz0gZGVjcnlwdGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBwICs9IG5iO1xuICAgICAgICB0aGlzLl9wa3RMZW4gKz0gbmI7XG4gICAgICAgIGlmICh0aGlzLl9wa3RMZW4gPCB0aGlzLl9sZW4gfHwgcCA+PSBkYXRhTGVuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVhZCBhdXRoZW50aWNhdGlvbiB0YWdcbiAgICAgIHtcbiAgICAgICAgY29uc3QgbmIgPSBNYXRoLm1pbigxNiAtIHRoaXMuX3RhZ1BvcywgZGF0YUxlbiAtIHApO1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbikge1xuICAgICAgICAgIHRoaXMuX3RhZy5zZXQoXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgcCwgbmIpLFxuICAgICAgICAgICAgdGhpcy5fdGFnUG9zXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90YWcuc2V0KGRhdGEsIHRoaXMuX3RhZ1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcCArPSBuYjtcbiAgICAgICAgdGhpcy5fdGFnUG9zICs9IG5iO1xuICAgICAgICBpZiAodGhpcy5fdGFnUG9zIDwgMTYpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIC8vIFZlcmlmeSBhdXRoZW50aWNhdGlvbiB0YWdcbiAgICAgICAgdGhpcy5fZGVjaXBoZXJJbnN0YW5jZS5zZXRBdXRoVGFnKHRoaXMuX3RhZyk7XG5cbiAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gdGhpcy5fZGVjaXBoZXJJbnN0YW5jZS5maW5hbCgpO1xuXG4gICAgICAgIC8vIFhYWDogdGhpcyBzaG91bGQgbmV2ZXIgb3V0cHV0IGFueSBkYXRhIHNpbmNlIHN0cmVhbSBjaXBoZXJzIGFsd2F5c1xuICAgICAgICAvLyByZXR1cm4gZGF0YSBmcm9tIC51cGRhdGUoKSBhbmQgYmxvY2sgY2lwaGVycyBtdXN0IGVuZCBvbiBhIG11bHRpcGxlXG4gICAgICAgIC8vIG9mIHRoZSBibG9jayBsZW5ndGgsIHdoaWNoIHdvdWxkIGhhdmUgY2F1c2VkIGFuIGV4Y2VwdGlvbiB0byBiZVxuICAgICAgICAvLyB0aHJvd24gaWYgdGhlIHRvdGFsIGlucHV0IHdhcyBub3QuLi5cbiAgICAgICAgaWYgKGRlY3J5cHRlZC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcGFja2V0KVxuICAgICAgICAgICAgdGhpcy5fcGFja2V0LnNldChkZWNyeXB0ZWQsIHRoaXMuX3BhY2tldFBvcyk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fcGFja2V0ID0gZGVjcnlwdGVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBheWxvYWQgPSAoIXRoaXMuX3BhY2tldFxuICAgICAgICAgICAgICAgICAgICAgICA/IEVNUFRZX0JVRkZFUlxuICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBGYXN0QnVmZmVyKHRoaXMuX3BhY2tldC5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFja2V0LmJ5dGVPZmZzZXQgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhY2tldC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gdGhpcy5fcGFja2V0WzBdIC0gMSkpO1xuXG4gICAgICAvLyBQcmVwYXJlIGZvciBuZXh0IHBhY2tldFxuICAgICAgdGhpcy5pblNlcW5vID0gKHRoaXMuaW5TZXFubyArIDEpID4+PiAwO1xuICAgICAgaXZJbmNyZW1lbnQodGhpcy5fZGVjaXBoZXJJVik7XG4gICAgICB0aGlzLl9sZW4gPSAwO1xuICAgICAgdGhpcy5fbGVuQnl0ZXMgPSAwO1xuICAgICAgdGhpcy5fcGFja2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3BhY2tldFBvcyA9IDA7XG4gICAgICB0aGlzLl9wa3RMZW4gPSAwO1xuICAgICAgdGhpcy5fdGFnUG9zID0gMDtcblxuICAgICAge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLl9vblBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gKHJldCA9PT0gZmFsc2UgPyBwIDogcmV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQUVTR0NNRGVjaXBoZXJCaW5kaW5nIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3QgZGVjID0gY29uZmlnLmluYm91bmQ7XG4gICAgdGhpcy5pblNlcW5vID0gZGVjLnNlcW5vO1xuICAgIHRoaXMuX29uUGF5bG9hZCA9IGRlYy5vblBheWxvYWQ7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgQUVTR0NNRGVjaXBoZXIoZGVjLmRlY2lwaGVySW5mby5zc2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYy5kZWNpcGhlcktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWMuZGVjaXBoZXJJVik7XG4gICAgdGhpcy5fbGVuID0gMDtcbiAgICB0aGlzLl9sZW5CeXRlcyA9IDA7XG4gICAgdGhpcy5fcGFja2V0ID0gbnVsbDtcbiAgICB0aGlzLl9wa3RMZW4gPSAwO1xuICAgIHRoaXMuX3RhZyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNik7XG4gICAgdGhpcy5fdGFnUG9zID0gMDtcbiAgfVxuICBmcmVlKCkge31cbiAgZGVjcnlwdChkYXRhLCBwLCBkYXRhTGVuKSB7XG4gICAgLy8gYGRhdGFgID09PSBlbmNyeXB0ZWQgZGF0YVxuXG4gICAgd2hpbGUgKHAgPCBkYXRhTGVuKSB7XG4gICAgICAvLyBSZWFkIHBhY2tldCBsZW5ndGggKHVuZW5jcnlwdGVkLCBidXQgQUFEKVxuICAgICAgaWYgKHRoaXMuX2xlbkJ5dGVzIDwgNCkge1xuICAgICAgICBsZXQgbmIgPSBNYXRoLm1pbig0IC0gdGhpcy5fbGVuQnl0ZXMsIGRhdGFMZW4gLSBwKTtcbiAgICAgICAgdGhpcy5fbGVuQnl0ZXMgKz0gbmI7XG4gICAgICAgIHdoaWxlIChuYi0tKVxuICAgICAgICAgIHRoaXMuX2xlbiA9ICh0aGlzLl9sZW4gPDwgOCkgKyBkYXRhW3ArK107XG4gICAgICAgIGlmICh0aGlzLl9sZW5CeXRlcyA8IDQpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmICgodGhpcy5fbGVuICsgMjApID4gTUFYX1BBQ0tFVF9TSVpFXG4gICAgICAgICAgICB8fCB0aGlzLl9sZW4gPCAxNlxuICAgICAgICAgICAgfHwgKHRoaXMuX2xlbiAmIDE1KSAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHBhY2tldCBsZW5ndGg6ICR7dGhpcy5fbGVufWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlYWQgcGFkZGluZyBsZW5ndGgsIHBheWxvYWQsIGFuZCBwYWRkaW5nXG4gICAgICBpZiAodGhpcy5fcGt0TGVuIDwgdGhpcy5fbGVuKSB7XG4gICAgICAgIGlmIChwID49IGRhdGFMZW4pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuYiA9IE1hdGgubWluKHRoaXMuX2xlbiAtIHRoaXMuX3BrdExlbiwgZGF0YUxlbiAtIHApO1xuICAgICAgICBsZXQgZW5jcnlwdGVkO1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbilcbiAgICAgICAgICBlbmNyeXB0ZWQgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgcCwgbmIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZW5jcnlwdGVkID0gZGF0YTtcbiAgICAgICAgaWYgKG5iID09PSB0aGlzLl9sZW4pIHtcbiAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBlbmNyeXB0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9wYWNrZXQpXG4gICAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fbGVuKTtcbiAgICAgICAgICB0aGlzLl9wYWNrZXQuc2V0KGVuY3J5cHRlZCwgdGhpcy5fcGt0TGVuKTtcbiAgICAgICAgfVxuICAgICAgICBwICs9IG5iO1xuICAgICAgICB0aGlzLl9wa3RMZW4gKz0gbmI7XG4gICAgICAgIGlmICh0aGlzLl9wa3RMZW4gPCB0aGlzLl9sZW4gfHwgcCA+PSBkYXRhTGVuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVhZCBhdXRoZW50aWNhdGlvbiB0YWdcbiAgICAgIHtcbiAgICAgICAgY29uc3QgbmIgPSBNYXRoLm1pbigxNiAtIHRoaXMuX3RhZ1BvcywgZGF0YUxlbiAtIHApO1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbikge1xuICAgICAgICAgIHRoaXMuX3RhZy5zZXQoXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgcCwgbmIpLFxuICAgICAgICAgICAgdGhpcy5fdGFnUG9zXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90YWcuc2V0KGRhdGEsIHRoaXMuX3RhZ1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcCArPSBuYjtcbiAgICAgICAgdGhpcy5fdGFnUG9zICs9IG5iO1xuICAgICAgICBpZiAodGhpcy5fdGFnUG9zIDwgMTYpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnN0YW5jZS5kZWNyeXB0KHRoaXMuX3BhY2tldCwgdGhpcy5fbGVuLCB0aGlzLl90YWcpO1xuXG4gICAgICBjb25zdCBwYXlsb2FkID0gbmV3IEZhc3RCdWZmZXIodGhpcy5fcGFja2V0LmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWNrZXQuYnl0ZU9mZnNldCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFja2V0Lmxlbmd0aCAtIHRoaXMuX3BhY2tldFswXSAtIDEpO1xuXG4gICAgICAvLyBQcmVwYXJlIGZvciBuZXh0IHBhY2tldFxuICAgICAgdGhpcy5pblNlcW5vID0gKHRoaXMuaW5TZXFubyArIDEpID4+PiAwO1xuICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICAgIHRoaXMuX2xlbkJ5dGVzID0gMDtcbiAgICAgIHRoaXMuX3BhY2tldCA9IG51bGw7XG4gICAgICB0aGlzLl9wa3RMZW4gPSAwO1xuICAgICAgdGhpcy5fdGFnUG9zID0gMDtcblxuICAgICAge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLl9vblBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gKHJldCA9PT0gZmFsc2UgPyBwIDogcmV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETzogdGVzdCBpbmNyZW1lbnRhbCAudXBkYXRlKClzIHZzLiBjb3B5aW5nIHRvIF9wYWNrZXQgYW5kIGRvaW5nIGEgc2luZ2xlXG4vLyAudXBkYXRlKCkgYWZ0ZXIgZW50aXJlIHBhY2tldCByZWFkIC0tIGEgc2luZ2xlIC51cGRhdGUoKSB3b3VsZCBhbGxvd1xuLy8gdmVyaWZ5aW5nIE1BQyBiZWZvcmUgZGVjcnlwdGluZyBmb3IgRVRNIE1BQ3NcbmNsYXNzIEdlbmVyaWNEZWNpcGhlck5hdGl2ZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IGRlYyA9IGNvbmZpZy5pbmJvdW5kO1xuICAgIHRoaXMuaW5TZXFubyA9IGRlYy5zZXFubztcbiAgICB0aGlzLl9vblBheWxvYWQgPSBkZWMub25QYXlsb2FkO1xuICAgIHRoaXMuX2RlY2lwaGVySW5zdGFuY2UgPSBjcmVhdGVEZWNpcGhlcml2KGRlYy5kZWNpcGhlckluZm8uc3NsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWMuZGVjaXBoZXJLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjLmRlY2lwaGVySVYpO1xuICAgIHRoaXMuX2RlY2lwaGVySW5zdGFuY2Uuc2V0QXV0b1BhZGRpbmcoZmFsc2UpO1xuICAgIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgICAgZGVjLm1hY0luZm8uaXNFVE0gPyA0IDogZGVjLmRlY2lwaGVySW5mby5ibG9ja0xlblxuICAgICk7XG4gICAgdGhpcy5fYmxvY2tTaXplID0gZGVjLmRlY2lwaGVySW5mby5ibG9ja0xlbjtcbiAgICB0aGlzLl9ibG9ja1BvcyA9IDA7XG4gICAgdGhpcy5fbGVuID0gMDtcbiAgICB0aGlzLl9wYWNrZXQgPSBudWxsO1xuICAgIHRoaXMuX3BhY2tldFBvcyA9IDA7XG4gICAgdGhpcy5fcGt0TGVuID0gMDtcbiAgICB0aGlzLl9tYWMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZGVjLm1hY0luZm8uYWN0dWFsTGVuKTtcbiAgICB0aGlzLl9tYWNQb3MgPSAwO1xuICAgIHRoaXMuX21hY1NTTE5hbWUgPSBkZWMubWFjSW5mby5zc2xOYW1lO1xuICAgIHRoaXMuX21hY0tleSA9IGRlYy5tYWNLZXk7XG4gICAgdGhpcy5fbWFjQWN0dWFsTGVuID0gZGVjLm1hY0luZm8uYWN0dWFsTGVuO1xuICAgIHRoaXMuX21hY0VUTSA9IGRlYy5tYWNJbmZvLmlzRVRNO1xuICAgIHRoaXMuX21hY0luc3RhbmNlID0gbnVsbDtcblxuICAgIGNvbnN0IGRpc2NhcmRMZW4gPSBkZWMuZGVjaXBoZXJJbmZvLmRpc2NhcmRMZW47XG4gICAgaWYgKGRpc2NhcmRMZW4pIHtcbiAgICAgIGxldCBkaXNjYXJkID0gRElTQ0FSRF9DQUNIRS5nZXQoZGlzY2FyZExlbik7XG4gICAgICBpZiAoZGlzY2FyZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NhcmQgPSBCdWZmZXIuYWxsb2MoZGlzY2FyZExlbik7XG4gICAgICAgIERJU0NBUkRfQ0FDSEUuc2V0KGRpc2NhcmRMZW4sIGRpc2NhcmQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGVjaXBoZXJJbnN0YW5jZS51cGRhdGUoZGlzY2FyZCk7XG4gICAgfVxuICB9XG4gIGZyZWUoKSB7fVxuICBkZWNyeXB0KGRhdGEsIHAsIGRhdGFMZW4pIHtcbiAgICAvLyBgZGF0YWAgPT09IGVuY3J5cHRlZCBkYXRhXG5cbiAgICB3aGlsZSAocCA8IGRhdGFMZW4pIHtcbiAgICAgIC8vIFJlYWQgZmlyc3QgZW5jcnlwdGVkIGJsb2NrXG4gICAgICBpZiAodGhpcy5fYmxvY2tQb3MgPCB0aGlzLl9ibG9jay5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbmIgPSBNYXRoLm1pbih0aGlzLl9ibG9jay5sZW5ndGggLSB0aGlzLl9ibG9ja1BvcywgZGF0YUxlbiAtIHApO1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbiB8fCBuYiA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fYmxvY2suc2V0KFxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCArIHAsIG5iKSxcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrUG9zXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ibG9jay5zZXQoZGF0YSwgdGhpcy5fYmxvY2tQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcCArPSBuYjtcbiAgICAgICAgdGhpcy5fYmxvY2tQb3MgKz0gbmI7XG4gICAgICAgIGlmICh0aGlzLl9ibG9ja1BvcyA8IHRoaXMuX2Jsb2NrLmxlbmd0aClcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgbGV0IGRlY3J5cHRlZDtcbiAgICAgICAgbGV0IG5lZWQ7XG4gICAgICAgIGlmICh0aGlzLl9tYWNFVE0pIHtcbiAgICAgICAgICB0aGlzLl9sZW4gPSBuZWVkID0gcmVhZFVJbnQzMkJFKHRoaXMuX2Jsb2NrLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZWNyeXB0IGZpcnN0IGJsb2NrIHRvIGdldCBwYWNrZXQgbGVuZ3RoXG4gICAgICAgICAgZGVjcnlwdGVkID0gdGhpcy5fZGVjaXBoZXJJbnN0YW5jZS51cGRhdGUodGhpcy5fYmxvY2spO1xuICAgICAgICAgIHRoaXMuX2xlbiA9IHJlYWRVSW50MzJCRShkZWNyeXB0ZWQsIDApO1xuICAgICAgICAgIG5lZWQgPSA0ICsgdGhpcy5fbGVuIC0gdGhpcy5fYmxvY2tTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xlbiA+IE1BWF9QQUNLRVRfU0laRVxuICAgICAgICAgICAgfHwgdGhpcy5fbGVuIDwgNVxuICAgICAgICAgICAgfHwgKG5lZWQgJiAodGhpcy5fYmxvY2tTaXplIC0gMSkpICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgcGFja2V0IGxlbmd0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIE1BQyB1cCBmcm9udCB0byBjYWxjdWxhdGUgaW4gcGFyYWxsZWwgd2l0aCBkZWNyeXB0aW9uXG4gICAgICAgIHRoaXMuX21hY0luc3RhbmNlID0gY3JlYXRlSG1hYyh0aGlzLl9tYWNTU0xOYW1lLCB0aGlzLl9tYWNLZXkpO1xuXG4gICAgICAgIHdyaXRlVUludDMyQkUoQlVGX0lOVCwgdGhpcy5pblNlcW5vLCAwKTtcbiAgICAgICAgdGhpcy5fbWFjSW5zdGFuY2UudXBkYXRlKEJVRl9JTlQpO1xuICAgICAgICBpZiAodGhpcy5fbWFjRVRNKSB7XG4gICAgICAgICAgdGhpcy5fbWFjSW5zdGFuY2UudXBkYXRlKHRoaXMuX2Jsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9tYWNJbnN0YW5jZS51cGRhdGUobmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkLmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcnlwdGVkLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQpKTtcbiAgICAgICAgICB0aGlzLl9wa3RMZW4gPSBkZWNyeXB0ZWQubGVuZ3RoIC0gNDtcbiAgICAgICAgICB0aGlzLl9wYWNrZXRQb3MgPSB0aGlzLl9wa3RMZW47XG4gICAgICAgICAgdGhpcy5fcGFja2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRoaXMuX2xlbik7XG4gICAgICAgICAgdGhpcy5fcGFja2V0LnNldChcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZC5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNyeXB0ZWQuYnl0ZU9mZnNldCArIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWNrZXRQb3MpLFxuICAgICAgICAgICAgMFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocCA+PSBkYXRhTGVuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVhZCBwYWRkaW5nIGxlbmd0aCwgcGF5bG9hZCwgYW5kIHBhZGRpbmdcbiAgICAgIGlmICh0aGlzLl9wa3RMZW4gPCB0aGlzLl9sZW4pIHtcbiAgICAgICAgY29uc3QgbmIgPSBNYXRoLm1pbih0aGlzLl9sZW4gLSB0aGlzLl9wa3RMZW4sIGRhdGFMZW4gLSBwKTtcbiAgICAgICAgbGV0IGVuY3J5cHRlZDtcbiAgICAgICAgaWYgKHAgIT09IDAgfHwgbmIgIT09IGRhdGFMZW4pXG4gICAgICAgICAgZW5jcnlwdGVkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCArIHAsIG5iKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVuY3J5cHRlZCA9IGRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9tYWNFVE0pXG4gICAgICAgICAgdGhpcy5fbWFjSW5zdGFuY2UudXBkYXRlKGVuY3J5cHRlZCk7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IHRoaXMuX2RlY2lwaGVySW5zdGFuY2UudXBkYXRlKGVuY3J5cHRlZCk7XG4gICAgICAgIGlmIChkZWNyeXB0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG5iID09PSB0aGlzLl9sZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhY2tldCA9IGRlY3J5cHRlZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYWNrZXQpXG4gICAgICAgICAgICAgIHRoaXMuX3BhY2tldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLl9sZW4pO1xuICAgICAgICAgICAgdGhpcy5fcGFja2V0LnNldChkZWNyeXB0ZWQsIHRoaXMuX3BhY2tldFBvcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3BhY2tldFBvcyArPSBkZWNyeXB0ZWQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHAgKz0gbmI7XG4gICAgICAgIHRoaXMuX3BrdExlbiArPSBuYjtcbiAgICAgICAgaWYgKHRoaXMuX3BrdExlbiA8IHRoaXMuX2xlbiB8fCBwID49IGRhdGFMZW4pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWFkIE1BQ1xuICAgICAge1xuICAgICAgICBjb25zdCBuYiA9IE1hdGgubWluKHRoaXMuX21hY0FjdHVhbExlbiAtIHRoaXMuX21hY1BvcywgZGF0YUxlbiAtIHApO1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbikge1xuICAgICAgICAgIHRoaXMuX21hYy5zZXQoXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgcCwgbmIpLFxuICAgICAgICAgICAgdGhpcy5fbWFjUG9zXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9tYWMuc2V0KGRhdGEsIHRoaXMuX21hY1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcCArPSBuYjtcbiAgICAgICAgdGhpcy5fbWFjUG9zICs9IG5iO1xuICAgICAgICBpZiAodGhpcy5fbWFjUG9zIDwgdGhpcy5fbWFjQWN0dWFsTGVuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IE1BQ1xuICAgICAgaWYgKCF0aGlzLl9tYWNFVE0pXG4gICAgICAgIHRoaXMuX21hY0luc3RhbmNlLnVwZGF0ZSh0aGlzLl9wYWNrZXQpO1xuICAgICAgbGV0IGNhbGN1bGF0ZWQgPSB0aGlzLl9tYWNJbnN0YW5jZS5kaWdlc3QoKTtcbiAgICAgIGlmICh0aGlzLl9tYWNBY3R1YWxMZW4gPCBjYWxjdWxhdGVkLmxlbmd0aCkge1xuICAgICAgICBjYWxjdWxhdGVkID0gbmV3IFVpbnQ4QXJyYXkoY2FsY3VsYXRlZC5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVkLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWNBY3R1YWxMZW4pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aW1pbmdTYWZlRXF1YWxzKGNhbGN1bGF0ZWQsIHRoaXMuX21hYykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBNQUMnKTtcblxuICAgICAgY29uc3QgcGF5bG9hZCA9IG5ldyBGYXN0QnVmZmVyKHRoaXMuX3BhY2tldC5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFja2V0LmJ5dGVPZmZzZXQgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhY2tldC5sZW5ndGggLSB0aGlzLl9wYWNrZXRbMF0gLSAxKTtcblxuICAgICAgLy8gUHJlcGFyZSBmb3IgbmV4dCBwYWNrZXRcbiAgICAgIHRoaXMuaW5TZXFubyA9ICh0aGlzLmluU2Vxbm8gKyAxKSA+Pj4gMDtcbiAgICAgIHRoaXMuX2Jsb2NrUG9zID0gMDtcbiAgICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgICB0aGlzLl9wYWNrZXQgPSBudWxsO1xuICAgICAgdGhpcy5fcGFja2V0UG9zID0gMDtcbiAgICAgIHRoaXMuX3BrdExlbiA9IDA7XG4gICAgICB0aGlzLl9tYWNQb3MgPSAwO1xuICAgICAgdGhpcy5fbWFjSW5zdGFuY2UgPSBudWxsO1xuXG4gICAgICB7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMuX29uUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiAocmV0ID09PSBmYWxzZSA/IHAgOiByZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBHZW5lcmljRGVjaXBoZXJCaW5kaW5nIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3QgZGVjID0gY29uZmlnLmluYm91bmQ7XG4gICAgdGhpcy5pblNlcW5vID0gZGVjLnNlcW5vO1xuICAgIHRoaXMuX29uUGF5bG9hZCA9IGRlYy5vblBheWxvYWQ7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgR2VuZXJpY0RlY2lwaGVyKGRlYy5kZWNpcGhlckluZm8uc3NsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjLmRlY2lwaGVyS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWMuZGVjaXBoZXJJVixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjLm1hY0luZm8uc3NsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjLm1hY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjLm1hY0luZm8uaXNFVE0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYy5tYWNJbmZvLmFjdHVhbExlbik7XG4gICAgdGhpcy5fYmxvY2sgPSBCdWZmZXIuYWxsb2NVbnNhZmUoXG4gICAgICBkZWMubWFjSW5mby5pc0VUTSB8fCBkZWMuZGVjaXBoZXJJbmZvLnN0cmVhbVxuICAgICAgPyA0XG4gICAgICA6IGRlYy5kZWNpcGhlckluZm8uYmxvY2tMZW5cbiAgICApO1xuICAgIHRoaXMuX2Jsb2NrUG9zID0gMDtcbiAgICB0aGlzLl9sZW4gPSAwO1xuICAgIHRoaXMuX3BhY2tldCA9IG51bGw7XG4gICAgdGhpcy5fcGt0TGVuID0gMDtcbiAgICB0aGlzLl9tYWMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZGVjLm1hY0luZm8uYWN0dWFsTGVuKTtcbiAgICB0aGlzLl9tYWNQb3MgPSAwO1xuICAgIHRoaXMuX21hY0FjdHVhbExlbiA9IGRlYy5tYWNJbmZvLmFjdHVhbExlbjtcbiAgICB0aGlzLl9tYWNFVE0gPSBkZWMubWFjSW5mby5pc0VUTTtcbiAgfVxuICBmcmVlKCkge1xuICAgIHRoaXMuX2luc3RhbmNlLmZyZWUoKTtcbiAgfVxuICBkZWNyeXB0KGRhdGEsIHAsIGRhdGFMZW4pIHtcbiAgICAvLyBgZGF0YWAgPT09IGVuY3J5cHRlZCBkYXRhXG5cbiAgICB3aGlsZSAocCA8IGRhdGFMZW4pIHtcbiAgICAgIC8vIFJlYWQgZmlyc3QgZW5jcnlwdGVkIGJsb2NrXG4gICAgICBpZiAodGhpcy5fYmxvY2tQb3MgPCB0aGlzLl9ibG9jay5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbmIgPSBNYXRoLm1pbih0aGlzLl9ibG9jay5sZW5ndGggLSB0aGlzLl9ibG9ja1BvcywgZGF0YUxlbiAtIHApO1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbiB8fCBuYiA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fYmxvY2suc2V0KFxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCArIHAsIG5iKSxcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrUG9zXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ibG9jay5zZXQoZGF0YSwgdGhpcy5fYmxvY2tQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcCArPSBuYjtcbiAgICAgICAgdGhpcy5fYmxvY2tQb3MgKz0gbmI7XG4gICAgICAgIGlmICh0aGlzLl9ibG9ja1BvcyA8IHRoaXMuX2Jsb2NrLmxlbmd0aClcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgbGV0IG5lZWQ7XG4gICAgICAgIGlmICh0aGlzLl9tYWNFVE0pIHtcbiAgICAgICAgICB0aGlzLl9sZW4gPSBuZWVkID0gcmVhZFVJbnQzMkJFKHRoaXMuX2Jsb2NrLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZWNyeXB0IGZpcnN0IGJsb2NrIHRvIGdldCBwYWNrZXQgbGVuZ3RoXG4gICAgICAgICAgdGhpcy5faW5zdGFuY2UuZGVjcnlwdEJsb2NrKHRoaXMuX2Jsb2NrKTtcbiAgICAgICAgICB0aGlzLl9sZW4gPSByZWFkVUludDMyQkUodGhpcy5fYmxvY2ssIDApO1xuICAgICAgICAgIG5lZWQgPSA0ICsgdGhpcy5fbGVuIC0gdGhpcy5fYmxvY2subGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xlbiA+IE1BWF9QQUNLRVRfU0laRVxuICAgICAgICAgICAgfHwgdGhpcy5fbGVuIDwgNVxuICAgICAgICAgICAgfHwgKG5lZWQgJiAodGhpcy5fYmxvY2subGVuZ3RoIC0gMSkpICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgcGFja2V0IGxlbmd0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tYWNFVE0pIHtcbiAgICAgICAgICB0aGlzLl9wa3RMZW4gPSAodGhpcy5fYmxvY2subGVuZ3RoIC0gNCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3BrdExlbikge1xuICAgICAgICAgICAgdGhpcy5fcGFja2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRoaXMuX2xlbik7XG4gICAgICAgICAgICB0aGlzLl9wYWNrZXQuc2V0KFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheSh0aGlzLl9ibG9jay5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrLmJ5dGVPZmZzZXQgKyA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wa3RMZW4pLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwID49IGRhdGFMZW4pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWFkIHBhZGRpbmcgbGVuZ3RoLCBwYXlsb2FkLCBhbmQgcGFkZGluZ1xuICAgICAgaWYgKHRoaXMuX3BrdExlbiA8IHRoaXMuX2xlbikge1xuICAgICAgICBjb25zdCBuYiA9IE1hdGgubWluKHRoaXMuX2xlbiAtIHRoaXMuX3BrdExlbiwgZGF0YUxlbiAtIHApO1xuICAgICAgICBsZXQgZW5jcnlwdGVkO1xuICAgICAgICBpZiAocCAhPT0gMCB8fCBuYiAhPT0gZGF0YUxlbilcbiAgICAgICAgICBlbmNyeXB0ZWQgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgcCwgbmIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZW5jcnlwdGVkID0gZGF0YTtcbiAgICAgICAgaWYgKG5iID09PSB0aGlzLl9sZW4pIHtcbiAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBlbmNyeXB0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9wYWNrZXQpXG4gICAgICAgICAgICB0aGlzLl9wYWNrZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fbGVuKTtcbiAgICAgICAgICB0aGlzLl9wYWNrZXQuc2V0KGVuY3J5cHRlZCwgdGhpcy5fcGt0TGVuKTtcbiAgICAgICAgfVxuICAgICAgICBwICs9IG5iO1xuICAgICAgICB0aGlzLl9wa3RMZW4gKz0gbmI7XG4gICAgICAgIGlmICh0aGlzLl9wa3RMZW4gPCB0aGlzLl9sZW4gfHwgcCA+PSBkYXRhTGVuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVhZCBNQUNcbiAgICAgIHtcbiAgICAgICAgY29uc3QgbmIgPSBNYXRoLm1pbih0aGlzLl9tYWNBY3R1YWxMZW4gLSB0aGlzLl9tYWNQb3MsIGRhdGFMZW4gLSBwKTtcbiAgICAgICAgaWYgKHAgIT09IDAgfHwgbmIgIT09IGRhdGFMZW4pIHtcbiAgICAgICAgICB0aGlzLl9tYWMuc2V0KFxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCArIHAsIG5iKSxcbiAgICAgICAgICAgIHRoaXMuX21hY1Bvc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbWFjLnNldChkYXRhLCB0aGlzLl9tYWNQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHAgKz0gbmI7XG4gICAgICAgIHRoaXMuX21hY1BvcyArPSBuYjtcbiAgICAgICAgaWYgKHRoaXMuX21hY1BvcyA8IHRoaXMuX21hY0FjdHVhbExlbilcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIERlY3J5cHQgYW5kIHZlcmlmeSBNQUNcbiAgICAgIHRoaXMuX2luc3RhbmNlLmRlY3J5cHQodGhpcy5fcGFja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluU2Vxbm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWMpO1xuXG4gICAgICBjb25zdCBwYXlsb2FkID0gbmV3IEZhc3RCdWZmZXIodGhpcy5fcGFja2V0LmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWNrZXQuYnl0ZU9mZnNldCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFja2V0Lmxlbmd0aCAtIHRoaXMuX3BhY2tldFswXSAtIDEpO1xuXG4gICAgICAvLyBQcmVwYXJlIGZvciBuZXh0IHBhY2tldFxuICAgICAgdGhpcy5pblNlcW5vID0gKHRoaXMuaW5TZXFubyArIDEpID4+PiAwO1xuICAgICAgdGhpcy5fYmxvY2tQb3MgPSAwO1xuICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICAgIHRoaXMuX3BhY2tldCA9IG51bGw7XG4gICAgICB0aGlzLl9wa3RMZW4gPSAwO1xuICAgICAgdGhpcy5fbWFjUG9zID0gMDtcbiAgICAgIHRoaXMuX21hY0luc3RhbmNlID0gbnVsbDtcblxuICAgICAge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLl9vblBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gKHJldCA9PT0gZmFsc2UgPyBwIDogcmV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gSW5jcmVtZW50cyB1bnNpZ25lZCwgYmlnIGVuZGlhbiBjb3VudGVyIChsYXN0IDggYnl0ZXMpIG9mIEFFUy1HQ00gSVZcbmZ1bmN0aW9uIGl2SW5jcmVtZW50KGl2KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgKytpdlsxMV0gPj4+IDhcbiAgJiYgKytpdlsxMF0gPj4+IDhcbiAgJiYgKytpdls5XSA+Pj4gOFxuICAmJiArK2l2WzhdID4+PiA4XG4gICYmICsraXZbN10gPj4+IDhcbiAgJiYgKytpdls2XSA+Pj4gOFxuICAmJiArK2l2WzVdID4+PiA4XG4gICYmICsraXZbNF0gPj4+IDg7XG59XG5cbmNvbnN0IGludFRvQnl0ZXMgPSAoKCkgPT4ge1xuICBjb25zdCByZXQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gIHJldHVybiAobikgPT4ge1xuICAgIHJldFswXSA9IChuID4+PiAyNCk7XG4gICAgcmV0WzFdID0gKG4gPj4+IDE2KTtcbiAgICByZXRbMl0gPSAobiA+Pj4gOCk7XG4gICAgcmV0WzNdID0gbjtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xufSkoKTtcblxuZnVuY3Rpb24gdGltaW5nU2FmZUVxdWFscyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICB0aW1pbmdTYWZlRXF1YWwoYSwgYSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0aW1pbmdTYWZlRXF1YWwoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlcihjb25maWcpIHtcbiAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnIHx8IGNvbmZpZyA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29uZmlnJyk7XG5cbiAgaWYgKHR5cGVvZiBjb25maWcub3V0Ym91bmQgIT09ICdvYmplY3QnIHx8IGNvbmZpZy5vdXRib3VuZCA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3V0Ym91bmQnKTtcblxuICBjb25zdCBvdXRib3VuZCA9IGNvbmZpZy5vdXRib3VuZDtcblxuICBpZiAodHlwZW9mIG91dGJvdW5kLm9uV3JpdGUgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG91dGJvdW5kLm9uV3JpdGUnKTtcblxuICBpZiAodHlwZW9mIG91dGJvdW5kLmNpcGhlckluZm8gIT09ICdvYmplY3QnIHx8IG91dGJvdW5kLmNpcGhlckluZm8gPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG91dGJvdW5kLmNpcGhlckluZm8nKTtcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvdXRib3VuZC5jaXBoZXJLZXkpXG4gICAgICB8fCBvdXRib3VuZC5jaXBoZXJLZXkubGVuZ3RoICE9PSBvdXRib3VuZC5jaXBoZXJJbmZvLmtleUxlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvdXRib3VuZC5jaXBoZXJLZXknKTtcbiAgfVxuXG4gIGlmIChvdXRib3VuZC5jaXBoZXJJbmZvLml2TGVuXG4gICAgICAmJiAoIUJ1ZmZlci5pc0J1ZmZlcihvdXRib3VuZC5jaXBoZXJJVilcbiAgICAgICAgICB8fCBvdXRib3VuZC5jaXBoZXJJVi5sZW5ndGggIT09IG91dGJvdW5kLmNpcGhlckluZm8uaXZMZW4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG91dGJvdW5kLmNpcGhlcklWJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG91dGJvdW5kLnNlcW5vICE9PSAnbnVtYmVyJ1xuICAgICAgfHwgb3V0Ym91bmQuc2Vxbm8gPCAwXG4gICAgICB8fCBvdXRib3VuZC5zZXFubyA+IE1BWF9TRVFOTykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvdXRib3VuZC5zZXFubycpO1xuICB9XG5cbiAgY29uc3QgZm9yY2VOYXRpdmUgPSAhIW91dGJvdW5kLmZvcmNlTmF0aXZlO1xuXG4gIHN3aXRjaCAob3V0Ym91bmQuY2lwaGVySW5mby5zc2xOYW1lKSB7XG4gICAgY2FzZSAnYWVzLTEyOC1nY20nOlxuICAgIGNhc2UgJ2Flcy0yNTYtZ2NtJzpcbiAgICAgIHJldHVybiAoQUVTR0NNQ2lwaGVyICYmICFmb3JjZU5hdGl2ZVxuICAgICAgICAgICAgICA/IG5ldyBBRVNHQ01DaXBoZXJCaW5kaW5nKGNvbmZpZylcbiAgICAgICAgICAgICAgOiBuZXcgQUVTR0NNQ2lwaGVyTmF0aXZlKGNvbmZpZykpO1xuICAgIGNhc2UgJ2NoYWNoYTIwJzpcbiAgICAgIHJldHVybiAoQ2hhQ2hhUG9seUNpcGhlciAmJiAhZm9yY2VOYXRpdmVcbiAgICAgICAgICAgICAgPyBuZXcgQ2hhQ2hhUG9seUNpcGhlckJpbmRpbmcoY29uZmlnKVxuICAgICAgICAgICAgICA6IG5ldyBDaGFDaGFQb2x5Q2lwaGVyTmF0aXZlKGNvbmZpZykpO1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGlmICh0eXBlb2Ygb3V0Ym91bmQubWFjSW5mbyAhPT0gJ29iamVjdCcgfHwgb3V0Ym91bmQubWFjSW5mbyA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG91dGJvdW5kLm1hY0luZm8nKTtcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG91dGJvdW5kLm1hY0tleSlcbiAgICAgICAgICB8fCBvdXRib3VuZC5tYWNLZXkubGVuZ3RoICE9PSBvdXRib3VuZC5tYWNJbmZvLmxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3V0Ym91bmQubWFjS2V5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKEdlbmVyaWNDaXBoZXIgJiYgIWZvcmNlTmF0aXZlXG4gICAgICAgICAgICAgID8gbmV3IEdlbmVyaWNDaXBoZXJCaW5kaW5nKGNvbmZpZylcbiAgICAgICAgICAgICAgOiBuZXcgR2VuZXJpY0NpcGhlck5hdGl2ZShjb25maWcpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXIoY29uZmlnKSB7XG4gIGlmICh0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0JyB8fCBjb25maWcgPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbmZpZycpO1xuXG4gIGlmICh0eXBlb2YgY29uZmlnLmluYm91bmQgIT09ICdvYmplY3QnIHx8IGNvbmZpZy5pbmJvdW5kID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmJvdW5kJyk7XG5cbiAgY29uc3QgaW5ib3VuZCA9IGNvbmZpZy5pbmJvdW5kO1xuXG4gIGlmICh0eXBlb2YgaW5ib3VuZC5vblBheWxvYWQgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluYm91bmQub25QYXlsb2FkJyk7XG5cbiAgaWYgKHR5cGVvZiBpbmJvdW5kLmRlY2lwaGVySW5mbyAhPT0gJ29iamVjdCdcbiAgICAgIHx8IGluYm91bmQuZGVjaXBoZXJJbmZvID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluYm91bmQuZGVjaXBoZXJJbmZvJyk7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihpbmJvdW5kLmRlY2lwaGVyS2V5KVxuICAgICAgfHwgaW5ib3VuZC5kZWNpcGhlcktleS5sZW5ndGggIT09IGluYm91bmQuZGVjaXBoZXJJbmZvLmtleUxlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmJvdW5kLmRlY2lwaGVyS2V5Jyk7XG4gIH1cblxuICBpZiAoaW5ib3VuZC5kZWNpcGhlckluZm8uaXZMZW5cbiAgICAgICYmICghQnVmZmVyLmlzQnVmZmVyKGluYm91bmQuZGVjaXBoZXJJVilcbiAgICAgICAgICB8fCBpbmJvdW5kLmRlY2lwaGVySVYubGVuZ3RoICE9PSBpbmJvdW5kLmRlY2lwaGVySW5mby5pdkxlbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5ib3VuZC5kZWNpcGhlcklWJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluYm91bmQuc2Vxbm8gIT09ICdudW1iZXInXG4gICAgICB8fCBpbmJvdW5kLnNlcW5vIDwgMFxuICAgICAgfHwgaW5ib3VuZC5zZXFubyA+IE1BWF9TRVFOTykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmJvdW5kLnNlcW5vJyk7XG4gIH1cblxuICBjb25zdCBmb3JjZU5hdGl2ZSA9ICEhaW5ib3VuZC5mb3JjZU5hdGl2ZTtcblxuICBzd2l0Y2ggKGluYm91bmQuZGVjaXBoZXJJbmZvLnNzbE5hbWUpIHtcbiAgICBjYXNlICdhZXMtMTI4LWdjbSc6XG4gICAgY2FzZSAnYWVzLTI1Ni1nY20nOlxuICAgICAgcmV0dXJuIChBRVNHQ01EZWNpcGhlciAmJiAhZm9yY2VOYXRpdmVcbiAgICAgICAgICAgICAgPyBuZXcgQUVTR0NNRGVjaXBoZXJCaW5kaW5nKGNvbmZpZylcbiAgICAgICAgICAgICAgOiBuZXcgQUVTR0NNRGVjaXBoZXJOYXRpdmUoY29uZmlnKSk7XG4gICAgY2FzZSAnY2hhY2hhMjAnOlxuICAgICAgcmV0dXJuIChDaGFDaGFQb2x5RGVjaXBoZXIgJiYgIWZvcmNlTmF0aXZlXG4gICAgICAgICAgICAgID8gbmV3IENoYUNoYVBvbHlEZWNpcGhlckJpbmRpbmcoY29uZmlnKVxuICAgICAgICAgICAgICA6IG5ldyBDaGFDaGFQb2x5RGVjaXBoZXJOYXRpdmUoY29uZmlnKSk7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKHR5cGVvZiBpbmJvdW5kLm1hY0luZm8gIT09ICdvYmplY3QnIHx8IGluYm91bmQubWFjSW5mbyA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluYm91bmQubWFjSW5mbycpO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaW5ib3VuZC5tYWNLZXkpXG4gICAgICAgICAgfHwgaW5ib3VuZC5tYWNLZXkubGVuZ3RoICE9PSBpbmJvdW5kLm1hY0luZm8ubGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmJvdW5kLm1hY0tleScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChHZW5lcmljRGVjaXBoZXIgJiYgIWZvcmNlTmF0aXZlXG4gICAgICAgICAgICAgID8gbmV3IEdlbmVyaWNEZWNpcGhlckJpbmRpbmcoY29uZmlnKVxuICAgICAgICAgICAgICA6IG5ldyBHZW5lcmljRGVjaXBoZXJOYXRpdmUoY29uZmlnKSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDSVBIRVJfSU5GTyxcbiAgTUFDX0lORk8sXG4gIGJpbmRpbmdBdmFpbGFibGU6ICEhYmluZGluZyxcbiAgaW5pdDogKCgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBQT0xZMTMwNV9XQVNNX01PRFVMRSA9IGF3YWl0IHJlcXVpcmUoJy4vY3J5cHRvL3BvbHkxMzA1LmpzJykoKTtcbiAgICAgICAgUE9MWTEzMDVfUkVTVUxUX01BTExPQyA9IFBPTFkxMzA1X1dBU01fTU9EVUxFLl9tYWxsb2MoMTYpO1xuICAgICAgICBwb2x5MTMwNV9hdXRoID0gUE9MWTEzMDVfV0FTTV9NT0RVTEUuY3dyYXAoXG4gICAgICAgICAgJ3BvbHkxMzA1X2F1dGgnLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgWydudW1iZXInLCAnYXJyYXknLCAnbnVtYmVyJywgJ2FycmF5JywgJ251bWJlcicsICdhcnJheSddXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSkoKSxcblxuICBOdWxsQ2lwaGVyLFxuICBjcmVhdGVDaXBoZXIsXG4gIE51bGxEZWNpcGhlcixcbiAgY3JlYXRlRGVjaXBoZXIsXG59O1xuIiwgIi8vIFRPRE86XG4vLyAgICAqIHV0aWxpemUgYGNyeXB0by5jcmVhdGUoUHJpdmF0ZXxQdWJsaWMpS2V5KClgIGFuZCBga2V5T2JqZWN0LmV4cG9ydCgpYFxuLy8gICAgKiBoYW5kbGUgbXVsdGktbGluZSBoZWFkZXIgdmFsdWVzIChPcGVuU1NIKT9cbi8vICAgICogbW9yZSB0aG9yb3VnaCB2YWxpZGF0aW9uP1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG4gIGNyZWF0ZURlY2lwaGVyaXYsXG4gIGNyZWF0ZUVDREgsXG4gIGNyZWF0ZUhhc2gsXG4gIGNyZWF0ZUhtYWMsXG4gIGNyZWF0ZVNpZ24sXG4gIGNyZWF0ZVZlcmlmeSxcbiAgZ2V0Q2lwaGVycyxcbiAgc2lnbjogc2lnbl8sXG4gIHZlcmlmeTogdmVyaWZ5Xyxcbn0gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHN1cHBvcnRlZE9wZW5TU0xDaXBoZXJzID0gZ2V0Q2lwaGVycygpO1xuXG5jb25zdCB7IEJlciB9ID0gcmVxdWlyZSgnYXNuMScpO1xuY29uc3QgYmNyeXB0X3Bia2RmID0gcmVxdWlyZSgnYmNyeXB0LXBia2RmJykucGJrZGY7XG5cbmNvbnN0IHsgQ0lQSEVSX0lORk8gfSA9IHJlcXVpcmUoJy4vY3J5cHRvLmpzJyk7XG5jb25zdCB7IGVkZHNhU3VwcG9ydGVkLCBTVVBQT1JURURfQ0lQSEVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cy5qcycpO1xuY29uc3Qge1xuICBidWZmZXJTbGljZSxcbiAgbWFrZUJ1ZmZlclBhcnNlcixcbiAgcmVhZFN0cmluZyxcbiAgcmVhZFVJbnQzMkJFLFxuICB3cml0ZVVJbnQzMkJFLFxufSA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcblxuY29uc3QgU1lNX0hBU0hfQUxHTyA9IFN5bWJvbCgnSGFzaCBBbGdvcml0aG0nKTtcbmNvbnN0IFNZTV9QUklWX1BFTSA9IFN5bWJvbCgnUHJpdmF0ZSBrZXkgUEVNJyk7XG5jb25zdCBTWU1fUFVCX1BFTSA9IFN5bWJvbCgnUHVibGljIGtleSBQRU0nKTtcbmNvbnN0IFNZTV9QVUJfU1NIID0gU3ltYm9sKCdQdWJsaWMga2V5IFNTSCcpO1xuY29uc3QgU1lNX0RFQ1JZUFRFRCA9IFN5bWJvbCgnRGVjcnlwdGVkIEtleScpO1xuXG4vLyBDcmVhdGUgT3BlblNTTCBjaXBoZXIgbmFtZSAtPiBTU0ggY2lwaGVyIG5hbWUgY29udmVyc2lvbiB0YWJsZVxuY29uc3QgQ0lQSEVSX0lORk9fT1BFTlNTTCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG57XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhDSVBIRVJfSU5GTyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNpcGhlck5hbWUgPSBDSVBIRVJfSU5GT1trZXlzW2ldXS5zc2xOYW1lO1xuICAgIGlmICghY2lwaGVyTmFtZSB8fCBDSVBIRVJfSU5GT19PUEVOU1NMW2NpcGhlck5hbWVdKVxuICAgICAgY29udGludWU7XG4gICAgQ0lQSEVSX0lORk9fT1BFTlNTTFtjaXBoZXJOYW1lXSA9IENJUEhFUl9JTkZPW2tleXNbaV1dO1xuICB9XG59XG5cbmNvbnN0IGJpbmFyeUtleVBhcnNlciA9IG1ha2VCdWZmZXJQYXJzZXIoKTtcblxuZnVuY3Rpb24gbWFrZVBFTSh0eXBlLCBkYXRhKSB7XG4gIGRhdGEgPSBkYXRhLmJhc2U2NFNsaWNlKDAsIGRhdGEubGVuZ3RoKTtcbiAgbGV0IGZvcm1hdHRlZCA9IGRhdGEucmVwbGFjZSgvLns2NH0vZywgJyQmXFxuJyk7XG4gIGlmIChkYXRhLmxlbmd0aCAmIDYzKVxuICAgIGZvcm1hdHRlZCArPSAnXFxuJztcbiAgcmV0dXJuIGAtLS0tLUJFR0lOICR7dHlwZX0gS0VZLS0tLS1cXG4ke2Zvcm1hdHRlZH0tLS0tLUVORCAke3R5cGV9IEtFWS0tLS0tYDtcbn1cblxuZnVuY3Rpb24gY29tYmluZUJ1ZmZlcnMoYnVmMSwgYnVmMikge1xuICBjb25zdCByZXN1bHQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmMS5sZW5ndGggKyBidWYyLmxlbmd0aCk7XG4gIHJlc3VsdC5zZXQoYnVmMSwgMCk7XG4gIHJlc3VsdC5zZXQoYnVmMiwgYnVmMS5sZW5ndGgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBza2lwRmllbGRzKGJ1ZiwgbmZpZWxkcykge1xuICBjb25zdCBidWZMZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgcG9zID0gKGJ1Zi5fcG9zIHx8IDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5maWVsZHM7ICsraSkge1xuICAgIGNvbnN0IGxlZnQgPSAoYnVmTGVuIC0gcG9zKTtcbiAgICBpZiAocG9zID49IGJ1ZkxlbiB8fCBsZWZ0IDwgNClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBsZW4gPSByZWFkVUludDMyQkUoYnVmLCBwb3MpO1xuICAgIGlmIChsZWZ0IDwgNCArIGxlbilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBwb3MgKz0gNCArIGxlbjtcbiAgfVxuICBidWYuX3BvcyA9IHBvcztcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdlbk9wZW5TU0xSU0FQdWIobiwgZSkge1xuICBjb25zdCBhc25Xcml0ZXIgPSBuZXcgQmVyLldyaXRlcigpO1xuICBhc25Xcml0ZXIuc3RhcnRTZXF1ZW5jZSgpO1xuICAgIC8vIGFsZ29yaXRobVxuICAgIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKCk7XG4gICAgICBhc25Xcml0ZXIud3JpdGVPSUQoJzEuMi44NDAuMTEzNTQ5LjEuMS4xJyk7IC8vIHJzYUVuY3J5cHRpb25cbiAgICAgIC8vIGFsZ29yaXRobSBwYXJhbWV0ZXJzIChSU0EgaGFzIG5vbmUpXG4gICAgICBhc25Xcml0ZXIud3JpdGVOdWxsKCk7XG4gICAgYXNuV3JpdGVyLmVuZFNlcXVlbmNlKCk7XG5cbiAgICAvLyBzdWJqZWN0UHVibGljS2V5XG4gICAgYXNuV3JpdGVyLnN0YXJ0U2VxdWVuY2UoQmVyLkJpdFN0cmluZyk7XG4gICAgICBhc25Xcml0ZXIud3JpdGVCeXRlKDB4MDApO1xuICAgICAgYXNuV3JpdGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgICAgICAgYXNuV3JpdGVyLndyaXRlQnVmZmVyKG4sIEJlci5JbnRlZ2VyKTtcbiAgICAgICAgYXNuV3JpdGVyLndyaXRlQnVmZmVyKGUsIEJlci5JbnRlZ2VyKTtcbiAgICAgIGFzbldyaXRlci5lbmRTZXF1ZW5jZSgpO1xuICAgIGFzbldyaXRlci5lbmRTZXF1ZW5jZSgpO1xuICBhc25Xcml0ZXIuZW5kU2VxdWVuY2UoKTtcbiAgcmV0dXJuIG1ha2VQRU0oJ1BVQkxJQycsIGFzbldyaXRlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBnZW5PcGVuU1NIUlNBUHViKG4sIGUpIHtcbiAgY29uc3QgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyA3ICsgNCArIGUubGVuZ3RoICsgNCArIG4ubGVuZ3RoKTtcblxuICB3cml0ZVVJbnQzMkJFKHB1YmxpY0tleSwgNywgMCk7XG4gIHB1YmxpY0tleS51dGY4V3JpdGUoJ3NzaC1yc2EnLCA0LCA3KTtcblxuICBsZXQgaSA9IDQgKyA3O1xuICB3cml0ZVVJbnQzMkJFKHB1YmxpY0tleSwgZS5sZW5ndGgsIGkpO1xuICBwdWJsaWNLZXkuc2V0KGUsIGkgKz0gNCk7XG5cbiAgd3JpdGVVSW50MzJCRShwdWJsaWNLZXksIG4ubGVuZ3RoLCBpICs9IGUubGVuZ3RoKTtcbiAgcHVibGljS2V5LnNldChuLCBpICsgNCk7XG5cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn1cblxuY29uc3QgZ2VuT3BlblNTTFJTQVByaXYgPSAoKCkgPT4ge1xuICBmdW5jdGlvbiBnZW5SU0FBU04xQnVmKG4sIGUsIGQsIHAsIHEsIGRtcDEsIGRtcTEsIGlxbXApIHtcbiAgICBjb25zdCBhc25Xcml0ZXIgPSBuZXcgQmVyLldyaXRlcigpO1xuICAgIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKCk7XG4gICAgICBhc25Xcml0ZXIud3JpdGVJbnQoMHgwMCwgQmVyLkludGVnZXIpO1xuICAgICAgYXNuV3JpdGVyLndyaXRlQnVmZmVyKG4sIEJlci5JbnRlZ2VyKTtcbiAgICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihlLCBCZXIuSW50ZWdlcik7XG4gICAgICBhc25Xcml0ZXIud3JpdGVCdWZmZXIoZCwgQmVyLkludGVnZXIpO1xuICAgICAgYXNuV3JpdGVyLndyaXRlQnVmZmVyKHAsIEJlci5JbnRlZ2VyKTtcbiAgICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihxLCBCZXIuSW50ZWdlcik7XG4gICAgICBhc25Xcml0ZXIud3JpdGVCdWZmZXIoZG1wMSwgQmVyLkludGVnZXIpO1xuICAgICAgYXNuV3JpdGVyLndyaXRlQnVmZmVyKGRtcTEsIEJlci5JbnRlZ2VyKTtcbiAgICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihpcW1wLCBCZXIuSW50ZWdlcik7XG4gICAgYXNuV3JpdGVyLmVuZFNlcXVlbmNlKCk7XG4gICAgcmV0dXJuIGFzbldyaXRlci5idWZmZXI7XG4gIH1cblxuICBmdW5jdGlvbiBiaWdJbnRGcm9tQnVmZmVyKGJ1Zikge1xuICAgIHJldHVybiBCaWdJbnQoYDB4JHtidWYuaGV4U2xpY2UoMCwgYnVmLmxlbmd0aCl9YCk7XG4gIH1cblxuICBmdW5jdGlvbiBiaWdJbnRUb0J1ZmZlcihibikge1xuICAgIGxldCBoZXggPSBibi50b1N0cmluZygxNik7XG4gICAgaWYgKChoZXgubGVuZ3RoICYgMSkgIT09IDApIHtcbiAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2lnYml0ID0gaGV4LmNoYXJDb2RlQXQoMCk7XG4gICAgICAvLyBCRVIvREVSIGludGVnZXJzIHJlcXVpcmUgbGVhZGluZyB6ZXJvIGJ5dGUgdG8gZGVub3RlIGEgcG9zaXRpdmUgdmFsdWVcbiAgICAgIC8vIHdoZW4gZmlyc3QgYnl0ZSA+PSAweDgwXG4gICAgICBpZiAoc2lnYml0ID09PSA1Ni8qICc4JyAqL1xuICAgICAgICAgIHx8IHNpZ2JpdCA9PT0gNTcvKiAnOScgKi9cbiAgICAgICAgICB8fCAoc2lnYml0ID49IDk3LyogJ2EnICovICYmIHNpZ2JpdCA8PSAxMDIvKiAnZicgKi8pKSB7XG4gICAgICAgIGhleCA9IGAwMCR7aGV4fWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBnZW5PcGVuU1NMUlNBUHJpdihuLCBlLCBkLCBpcW1wLCBwLCBxKSB7XG4gICAgY29uc3QgYm5fZCA9IGJpZ0ludEZyb21CdWZmZXIoZCk7XG4gICAgY29uc3QgZG1wMSA9IGJpZ0ludFRvQnVmZmVyKGJuX2QgJSAoYmlnSW50RnJvbUJ1ZmZlcihwKSAtIDFuKSk7XG4gICAgY29uc3QgZG1xMSA9IGJpZ0ludFRvQnVmZmVyKGJuX2QgJSAoYmlnSW50RnJvbUJ1ZmZlcihxKSAtIDFuKSk7XG4gICAgcmV0dXJuIG1ha2VQRU0oJ1JTQSBQUklWQVRFJyxcbiAgICAgICAgICAgICAgICAgICBnZW5SU0FBU04xQnVmKG4sIGUsIGQsIHAsIHEsIGRtcDEsIGRtcTEsIGlxbXApKTtcbiAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGdlbk9wZW5TU0xEU0FQdWIocCwgcSwgZywgeSkge1xuICBjb25zdCBhc25Xcml0ZXIgPSBuZXcgQmVyLldyaXRlcigpO1xuICBhc25Xcml0ZXIuc3RhcnRTZXF1ZW5jZSgpO1xuICAgIC8vIGFsZ29yaXRobVxuICAgIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKCk7XG4gICAgICBhc25Xcml0ZXIud3JpdGVPSUQoJzEuMi44NDAuMTAwNDAuNC4xJyk7IC8vIGlkLWRzYVxuICAgICAgLy8gYWxnb3JpdGhtIHBhcmFtZXRlcnNcbiAgICAgIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKCk7XG4gICAgICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihwLCBCZXIuSW50ZWdlcik7XG4gICAgICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihxLCBCZXIuSW50ZWdlcik7XG4gICAgICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihnLCBCZXIuSW50ZWdlcik7XG4gICAgICBhc25Xcml0ZXIuZW5kU2VxdWVuY2UoKTtcbiAgICBhc25Xcml0ZXIuZW5kU2VxdWVuY2UoKTtcblxuICAgIC8vIHN1YmplY3RQdWJsaWNLZXlcbiAgICBhc25Xcml0ZXIuc3RhcnRTZXF1ZW5jZShCZXIuQml0U3RyaW5nKTtcbiAgICAgIGFzbldyaXRlci53cml0ZUJ5dGUoMHgwMCk7XG4gICAgICBhc25Xcml0ZXIud3JpdGVCdWZmZXIoeSwgQmVyLkludGVnZXIpO1xuICAgIGFzbldyaXRlci5lbmRTZXF1ZW5jZSgpO1xuICBhc25Xcml0ZXIuZW5kU2VxdWVuY2UoKTtcbiAgcmV0dXJuIG1ha2VQRU0oJ1BVQkxJQycsIGFzbldyaXRlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBnZW5PcGVuU1NIRFNBUHViKHAsIHEsIGcsIHkpIHtcbiAgY29uc3QgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgIDQgKyA3ICsgNCArIHAubGVuZ3RoICsgNCArIHEubGVuZ3RoICsgNCArIGcubGVuZ3RoICsgNCArIHkubGVuZ3RoXG4gICk7XG5cbiAgd3JpdGVVSW50MzJCRShwdWJsaWNLZXksIDcsIDApO1xuICBwdWJsaWNLZXkudXRmOFdyaXRlKCdzc2gtZHNzJywgNCwgNyk7XG5cbiAgbGV0IGkgPSA0ICsgNztcbiAgd3JpdGVVSW50MzJCRShwdWJsaWNLZXksIHAubGVuZ3RoLCBpKTtcbiAgcHVibGljS2V5LnNldChwLCBpICs9IDQpO1xuXG4gIHdyaXRlVUludDMyQkUocHVibGljS2V5LCBxLmxlbmd0aCwgaSArPSBwLmxlbmd0aCk7XG4gIHB1YmxpY0tleS5zZXQocSwgaSArPSA0KTtcblxuICB3cml0ZVVJbnQzMkJFKHB1YmxpY0tleSwgZy5sZW5ndGgsIGkgKz0gcS5sZW5ndGgpO1xuICBwdWJsaWNLZXkuc2V0KGcsIGkgKz0gNCk7XG5cbiAgd3JpdGVVSW50MzJCRShwdWJsaWNLZXksIHkubGVuZ3RoLCBpICs9IGcubGVuZ3RoKTtcbiAgcHVibGljS2V5LnNldCh5LCBpICsgNCk7XG5cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn1cblxuZnVuY3Rpb24gZ2VuT3BlblNTTERTQVByaXYocCwgcSwgZywgeSwgeCkge1xuICBjb25zdCBhc25Xcml0ZXIgPSBuZXcgQmVyLldyaXRlcigpO1xuICBhc25Xcml0ZXIuc3RhcnRTZXF1ZW5jZSgpO1xuICAgIGFzbldyaXRlci53cml0ZUludCgweDAwLCBCZXIuSW50ZWdlcik7XG4gICAgYXNuV3JpdGVyLndyaXRlQnVmZmVyKHAsIEJlci5JbnRlZ2VyKTtcbiAgICBhc25Xcml0ZXIud3JpdGVCdWZmZXIocSwgQmVyLkludGVnZXIpO1xuICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihnLCBCZXIuSW50ZWdlcik7XG4gICAgYXNuV3JpdGVyLndyaXRlQnVmZmVyKHksIEJlci5JbnRlZ2VyKTtcbiAgICBhc25Xcml0ZXIud3JpdGVCdWZmZXIoeCwgQmVyLkludGVnZXIpO1xuICBhc25Xcml0ZXIuZW5kU2VxdWVuY2UoKTtcbiAgcmV0dXJuIG1ha2VQRU0oJ0RTQSBQUklWQVRFJywgYXNuV3JpdGVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGdlbk9wZW5TU0xFZFB1YihwdWIpIHtcbiAgY29uc3QgYXNuV3JpdGVyID0gbmV3IEJlci5Xcml0ZXIoKTtcbiAgYXNuV3JpdGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgICAvLyBhbGdvcml0aG1cbiAgICBhc25Xcml0ZXIuc3RhcnRTZXF1ZW5jZSgpO1xuICAgICAgYXNuV3JpdGVyLndyaXRlT0lEKCcxLjMuMTAxLjExMicpOyAvLyBpZC1FZDI1NTE5XG4gICAgYXNuV3JpdGVyLmVuZFNlcXVlbmNlKCk7XG5cbiAgICAvLyBQdWJsaWNLZXlcbiAgICBhc25Xcml0ZXIuc3RhcnRTZXF1ZW5jZShCZXIuQml0U3RyaW5nKTtcbiAgICAgIGFzbldyaXRlci53cml0ZUJ5dGUoMHgwMCk7XG4gICAgICAvLyBYWFg6IGhhY2sgdG8gd3JpdGUgYSByYXcgYnVmZmVyIHdpdGhvdXQgYSB0YWcgLS0geXVja1xuICAgICAgYXNuV3JpdGVyLl9lbnN1cmUocHViLmxlbmd0aCk7XG4gICAgICBhc25Xcml0ZXIuX2J1Zi5zZXQocHViLCBhc25Xcml0ZXIuX29mZnNldCk7XG4gICAgICBhc25Xcml0ZXIuX29mZnNldCArPSBwdWIubGVuZ3RoO1xuICAgIGFzbldyaXRlci5lbmRTZXF1ZW5jZSgpO1xuICBhc25Xcml0ZXIuZW5kU2VxdWVuY2UoKTtcbiAgcmV0dXJuIG1ha2VQRU0oJ1BVQkxJQycsIGFzbldyaXRlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBnZW5PcGVuU1NIRWRQdWIocHViKSB7XG4gIGNvbnN0IHB1YmxpY0tleSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgMTEgKyA0ICsgcHViLmxlbmd0aCk7XG5cbiAgd3JpdGVVSW50MzJCRShwdWJsaWNLZXksIDExLCAwKTtcbiAgcHVibGljS2V5LnV0ZjhXcml0ZSgnc3NoLWVkMjU1MTknLCA0LCAxMSk7XG5cbiAgd3JpdGVVSW50MzJCRShwdWJsaWNLZXksIHB1Yi5sZW5ndGgsIDE1KTtcbiAgcHVibGljS2V5LnNldChwdWIsIDE5KTtcblxuICByZXR1cm4gcHVibGljS2V5O1xufVxuXG5mdW5jdGlvbiBnZW5PcGVuU1NMRWRQcml2KHByaXYpIHtcbiAgY29uc3QgYXNuV3JpdGVyID0gbmV3IEJlci5Xcml0ZXIoKTtcbiAgYXNuV3JpdGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuV3JpdGVyLndyaXRlSW50KDB4MDAsIEJlci5JbnRlZ2VyKTtcblxuICAgIC8vIGFsZ29yaXRobVxuICAgIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKCk7XG4gICAgICBhc25Xcml0ZXIud3JpdGVPSUQoJzEuMy4xMDEuMTEyJyk7IC8vIGlkLUVkMjU1MTlcbiAgICBhc25Xcml0ZXIuZW5kU2VxdWVuY2UoKTtcblxuICAgIC8vIFByaXZhdGVLZXlcbiAgICBhc25Xcml0ZXIuc3RhcnRTZXF1ZW5jZShCZXIuT2N0ZXRTdHJpbmcpO1xuICAgICAgYXNuV3JpdGVyLndyaXRlQnVmZmVyKHByaXYsIEJlci5PY3RldFN0cmluZyk7XG4gICAgYXNuV3JpdGVyLmVuZFNlcXVlbmNlKCk7XG4gIGFzbldyaXRlci5lbmRTZXF1ZW5jZSgpO1xuICByZXR1cm4gbWFrZVBFTSgnUFJJVkFURScsIGFzbldyaXRlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBnZW5PcGVuU1NMRUNEU0FQdWIob2lkLCBRKSB7XG4gIGNvbnN0IGFzbldyaXRlciA9IG5ldyBCZXIuV3JpdGVyKCk7XG4gIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKCk7XG4gICAgLy8gYWxnb3JpdGhtXG4gICAgYXNuV3JpdGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgICAgIGFzbldyaXRlci53cml0ZU9JRCgnMS4yLjg0MC4xMDA0NS4yLjEnKTsgLy8gaWQtZWNQdWJsaWNLZXlcbiAgICAgIC8vIGFsZ29yaXRobSBwYXJhbWV0ZXJzIChuYW1lZEN1cnZlKVxuICAgICAgYXNuV3JpdGVyLndyaXRlT0lEKG9pZCk7XG4gICAgYXNuV3JpdGVyLmVuZFNlcXVlbmNlKCk7XG5cbiAgICAvLyBzdWJqZWN0UHVibGljS2V5XG4gICAgYXNuV3JpdGVyLnN0YXJ0U2VxdWVuY2UoQmVyLkJpdFN0cmluZyk7XG4gICAgICBhc25Xcml0ZXIud3JpdGVCeXRlKDB4MDApO1xuICAgICAgLy8gWFhYOiBoYWNrIHRvIHdyaXRlIGEgcmF3IGJ1ZmZlciB3aXRob3V0IGEgdGFnIC0tIHl1Y2tcbiAgICAgIGFzbldyaXRlci5fZW5zdXJlKFEubGVuZ3RoKTtcbiAgICAgIGFzbldyaXRlci5fYnVmLnNldChRLCBhc25Xcml0ZXIuX29mZnNldCk7XG4gICAgICBhc25Xcml0ZXIuX29mZnNldCArPSBRLmxlbmd0aDtcbiAgICAgIC8vIGVuZCBoYWNrXG4gICAgYXNuV3JpdGVyLmVuZFNlcXVlbmNlKCk7XG4gIGFzbldyaXRlci5lbmRTZXF1ZW5jZSgpO1xuICByZXR1cm4gbWFrZVBFTSgnUFVCTElDJywgYXNuV3JpdGVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGdlbk9wZW5TU0hFQ0RTQVB1YihvaWQsIFEpIHtcbiAgbGV0IGN1cnZlTmFtZTtcbiAgc3dpdGNoIChvaWQpIHtcbiAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjMuMS43JzpcbiAgICAgIC8vIHByaW1lMjU2djEvc2VjcDI1NnIxXG4gICAgICBjdXJ2ZU5hbWUgPSAnbmlzdHAyNTYnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnMS4zLjEzMi4wLjM0JzpcbiAgICAgIC8vIHNlY3AzODRyMVxuICAgICAgY3VydmVOYW1lID0gJ25pc3RwMzg0JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzEuMy4xMzIuMC4zNSc6XG4gICAgICAvLyBzZWNwNTIxcjFcbiAgICAgIGN1cnZlTmFtZSA9ICduaXN0cDUyMSc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxOSArIDQgKyA4ICsgNCArIFEubGVuZ3RoKTtcblxuICB3cml0ZVVJbnQzMkJFKHB1YmxpY0tleSwgMTksIDApO1xuICBwdWJsaWNLZXkudXRmOFdyaXRlKGBlY2RzYS1zaGEyLSR7Y3VydmVOYW1lfWAsIDQsIDE5KTtcblxuICB3cml0ZVVJbnQzMkJFKHB1YmxpY0tleSwgOCwgMjMpO1xuICBwdWJsaWNLZXkudXRmOFdyaXRlKGN1cnZlTmFtZSwgMjcsIDgpO1xuXG4gIHdyaXRlVUludDMyQkUocHVibGljS2V5LCBRLmxlbmd0aCwgMzUpO1xuICBwdWJsaWNLZXkuc2V0KFEsIDM5KTtcblxuICByZXR1cm4gcHVibGljS2V5O1xufVxuXG5mdW5jdGlvbiBnZW5PcGVuU1NMRUNEU0FQcml2KG9pZCwgcHViLCBwcml2KSB7XG4gIGNvbnN0IGFzbldyaXRlciA9IG5ldyBCZXIuV3JpdGVyKCk7XG4gIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKCk7XG4gICAgLy8gdmVyc2lvblxuICAgIGFzbldyaXRlci53cml0ZUludCgweDAxLCBCZXIuSW50ZWdlcik7XG4gICAgLy8gcHJpdmF0ZUtleVxuICAgIGFzbldyaXRlci53cml0ZUJ1ZmZlcihwcml2LCBCZXIuT2N0ZXRTdHJpbmcpO1xuICAgIC8vIHBhcmFtZXRlcnMgKG9wdGlvbmFsKVxuICAgIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKDB4QTApO1xuICAgICAgYXNuV3JpdGVyLndyaXRlT0lEKG9pZCk7XG4gICAgYXNuV3JpdGVyLmVuZFNlcXVlbmNlKCk7XG4gICAgLy8gcHVibGljS2V5IChvcHRpb25hbClcbiAgICBhc25Xcml0ZXIuc3RhcnRTZXF1ZW5jZSgweEExKTtcbiAgICAgIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKEJlci5CaXRTdHJpbmcpO1xuICAgICAgICBhc25Xcml0ZXIud3JpdGVCeXRlKDB4MDApO1xuICAgICAgICAvLyBYWFg6IGhhY2sgdG8gd3JpdGUgYSByYXcgYnVmZmVyIHdpdGhvdXQgYSB0YWcgLS0geXVja1xuICAgICAgICBhc25Xcml0ZXIuX2Vuc3VyZShwdWIubGVuZ3RoKTtcbiAgICAgICAgYXNuV3JpdGVyLl9idWYuc2V0KHB1YiwgYXNuV3JpdGVyLl9vZmZzZXQpO1xuICAgICAgICBhc25Xcml0ZXIuX29mZnNldCArPSBwdWIubGVuZ3RoO1xuICAgICAgICAvLyBlbmQgaGFja1xuICAgICAgYXNuV3JpdGVyLmVuZFNlcXVlbmNlKCk7XG4gICAgYXNuV3JpdGVyLmVuZFNlcXVlbmNlKCk7XG4gIGFzbldyaXRlci5lbmRTZXF1ZW5jZSgpO1xuICByZXR1cm4gbWFrZVBFTSgnRUMgUFJJVkFURScsIGFzbldyaXRlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBnZW5PcGVuU1NMRUNEU0FQdWJGcm9tUHJpdihjdXJ2ZU5hbWUsIHByaXYpIHtcbiAgY29uc3QgdGVtcEVDREggPSBjcmVhdGVFQ0RIKGN1cnZlTmFtZSk7XG4gIHRlbXBFQ0RILnNldFByaXZhdGVLZXkocHJpdik7XG4gIHJldHVybiB0ZW1wRUNESC5nZXRQdWJsaWNLZXkoKTtcbn1cblxuY29uc3QgQmFzZUtleSA9IHtcbiAgc2lnbjogKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHNpZ25fID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2lnbihkYXRhLCBhbGdvKSB7XG4gICAgICAgIGNvbnN0IHBlbSA9IHRoaXNbU1lNX1BSSVZfUEVNXTtcbiAgICAgICAgaWYgKHBlbSA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdObyBwcml2YXRlIGtleSBhdmFpbGFibGUnKTtcbiAgICAgICAgaWYgKCFhbGdvIHx8IHR5cGVvZiBhbGdvICE9PSAnc3RyaW5nJylcbiAgICAgICAgICBhbGdvID0gdGhpc1tTWU1fSEFTSF9BTEdPXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gc2lnbl8oYWxnbywgZGF0YSwgcGVtKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZXR1cm4gZXg7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBzaWduKGRhdGEsIGFsZ28pIHtcbiAgICAgIGNvbnN0IHBlbSA9IHRoaXNbU1lNX1BSSVZfUEVNXTtcbiAgICAgIGlmIChwZW0gPT09IG51bGwpXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ05vIHByaXZhdGUga2V5IGF2YWlsYWJsZScpO1xuICAgICAgaWYgKCFhbGdvIHx8IHR5cGVvZiBhbGdvICE9PSAnc3RyaW5nJylcbiAgICAgICAgYWxnbyA9IHRoaXNbU1lNX0hBU0hfQUxHT107XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBjcmVhdGVTaWduKGFsZ28pO1xuICAgICAgc2lnbmF0dXJlLnVwZGF0ZShkYXRhKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmUuc2lnbihwZW0pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIGV4O1xuICAgICAgfVxuICAgIH07XG4gIH0pKCksXG4gIHZlcmlmeTogKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZlcmlmeV8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiB2ZXJpZnkoZGF0YSwgc2lnbmF0dXJlLCBhbGdvKSB7XG4gICAgICAgIGNvbnN0IHBlbSA9IHRoaXNbU1lNX1BVQl9QRU1dO1xuICAgICAgICBpZiAocGVtID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ05vIHB1YmxpYyBrZXkgYXZhaWxhYmxlJyk7XG4gICAgICAgIGlmICghYWxnbyB8fCB0eXBlb2YgYWxnbyAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgYWxnbyA9IHRoaXNbU1lNX0hBU0hfQUxHT107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHZlcmlmeV8oYWxnbywgZGF0YSwgcGVtLCBzaWduYXR1cmUpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJldHVybiBleDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHZlcmlmeShkYXRhLCBzaWduYXR1cmUsIGFsZ28pIHtcbiAgICAgIGNvbnN0IHBlbSA9IHRoaXNbU1lNX1BVQl9QRU1dO1xuICAgICAgaWYgKHBlbSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTm8gcHVibGljIGtleSBhdmFpbGFibGUnKTtcbiAgICAgIGlmICghYWxnbyB8fCB0eXBlb2YgYWxnbyAhPT0gJ3N0cmluZycpXG4gICAgICAgIGFsZ28gPSB0aGlzW1NZTV9IQVNIX0FMR09dO1xuICAgICAgY29uc3QgdmVyaWZpZXIgPSBjcmVhdGVWZXJpZnkoYWxnbyk7XG4gICAgICB2ZXJpZmllci51cGRhdGUoZGF0YSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdmVyaWZpZXIudmVyaWZ5KHBlbSwgc2lnbmF0dXJlKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBleDtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpLFxuICBpc1ByaXZhdGVLZXk6IGZ1bmN0aW9uIGlzUHJpdmF0ZUtleSgpIHtcbiAgICByZXR1cm4gKHRoaXNbU1lNX1BSSVZfUEVNXSAhPT0gbnVsbCk7XG4gIH0sXG4gIGdldFByaXZhdGVQRU06IGZ1bmN0aW9uIGdldFByaXZhdGVQRU0oKSB7XG4gICAgcmV0dXJuIHRoaXNbU1lNX1BSSVZfUEVNXTtcbiAgfSxcbiAgZ2V0UHVibGljUEVNOiBmdW5jdGlvbiBnZXRQdWJsaWNQRU0oKSB7XG4gICAgcmV0dXJuIHRoaXNbU1lNX1BVQl9QRU1dO1xuICB9LFxuICBnZXRQdWJsaWNTU0g6IGZ1bmN0aW9uIGdldFB1YmxpY1NTSCgpIHtcbiAgICByZXR1cm4gdGhpc1tTWU1fUFVCX1NTSF07XG4gIH0sXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKGtleSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlS2V5KGtleSk7XG4gICAgaWYgKHBhcnNlZCBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnR5cGUgPT09IHBhcnNlZC50eXBlXG4gICAgICAmJiB0aGlzW1NZTV9QUklWX1BFTV0gPT09IHBhcnNlZFtTWU1fUFJJVl9QRU1dXG4gICAgICAmJiB0aGlzW1NZTV9QVUJfUEVNXSA9PT0gcGFyc2VkW1NZTV9QVUJfUEVNXVxuICAgICAgJiYgdGhpc1tTWU1fUFVCX1NTSF0gPT09IHBhcnNlZFtTWU1fUFVCX1NTSF1cbiAgICApO1xuICB9LFxufTtcblxuXG5mdW5jdGlvbiBPcGVuU1NIX1ByaXZhdGUodHlwZSwgY29tbWVudCwgcHJpdlBFTSwgcHViUEVNLCBwdWJTU0gsIGFsZ28sXG4gICAgICAgICAgICAgICAgICAgICAgICAgZGVjcnlwdGVkKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG4gIHRoaXNbU1lNX1BSSVZfUEVNXSA9IHByaXZQRU07XG4gIHRoaXNbU1lNX1BVQl9QRU1dID0gcHViUEVNO1xuICB0aGlzW1NZTV9QVUJfU1NIXSA9IHB1YlNTSDtcbiAgdGhpc1tTWU1fSEFTSF9BTEdPXSA9IGFsZ287XG4gIHRoaXNbU1lNX0RFQ1JZUFRFRF0gPSBkZWNyeXB0ZWQ7XG59XG5PcGVuU1NIX1ByaXZhdGUucHJvdG90eXBlID0gQmFzZUtleTtcbntcbiAgY29uc3QgcmVnZXhwID0gL14tLS0tLUJFR0lOIE9QRU5TU0ggUFJJVkFURSBLRVktLS0tLSg/OlxcclxcbnxcXG4pKFtcXHNcXFNdKykoPzpcXHJcXG58XFxuKS0tLS0tRU5EIE9QRU5TU0ggUFJJVkFURSBLRVktLS0tLSQvO1xuICBPcGVuU1NIX1ByaXZhdGUucGFyc2UgPSAoc3RyLCBwYXNzcGhyYXNlKSA9PiB7XG4gICAgY29uc3QgbSA9IHJlZ2V4cC5leGVjKHN0cik7XG4gICAgaWYgKG0gPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcmV0O1xuICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShtWzFdLCAnYmFzZTY0Jyk7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgMzEpIC8vIG1hZ2ljICgrIG1hZ2ljIG51bGwgdGVybS4pICsgbWluaW11bSBmaWVsZCBsZW5ndGhzXG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgIGNvbnN0IG1hZ2ljID0gZGF0YS51dGY4U2xpY2UoMCwgMTUpO1xuICAgIGlmIChtYWdpYyAhPT0gJ29wZW5zc2gta2V5LXYxXFwwJylcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9wZW5TU0gga2V5IG1hZ2ljOiAke21hZ2ljfWApO1xuXG4gICAgY29uc3QgY2lwaGVyTmFtZSA9IHJlYWRTdHJpbmcoZGF0YSwgMTUsIHRydWUpO1xuICAgIGlmIChjaXBoZXJOYW1lID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgIGlmIChjaXBoZXJOYW1lICE9PSAnbm9uZScgJiYgU1VQUE9SVEVEX0NJUEhFUi5pbmRleE9mKGNpcGhlck5hbWUpID09PSAtMSlcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNpcGhlciBmb3IgT3BlblNTSCBrZXk6ICR7Y2lwaGVyTmFtZX1gKTtcblxuICAgIGNvbnN0IGtkZk5hbWUgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3BvcywgdHJ1ZSk7XG4gICAgaWYgKGtkZk5hbWUgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgaWYgKGtkZk5hbWUgIT09ICdub25lJykge1xuICAgICAgaWYgKGNpcGhlck5hbWUgPT09ICdub25lJylcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIE9wZW5TU0ggcHJpdmF0ZSBrZXknKTtcbiAgICAgIGlmIChrZGZOYW1lICE9PSAnYmNyeXB0JylcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQga2RmIG5hbWUgZm9yIE9wZW5TU0gga2V5OiAke2tkZk5hbWV9YCk7XG4gICAgICBpZiAoIXBhc3NwaHJhc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgICAnRW5jcnlwdGVkIHByaXZhdGUgT3BlblNTSCBrZXkgZGV0ZWN0ZWQsIGJ1dCBubyBwYXNzcGhyYXNlIGdpdmVuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2lwaGVyTmFtZSAhPT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgIH1cblxuICAgIGxldCBlbmNJbmZvO1xuICAgIGxldCBjaXBoZXJLZXk7XG4gICAgbGV0IGNpcGhlcklWO1xuICAgIGlmIChjaXBoZXJOYW1lICE9PSAnbm9uZScpXG4gICAgICBlbmNJbmZvID0gQ0lQSEVSX0lORk9bY2lwaGVyTmFtZV07XG4gICAgY29uc3Qga2RmT3B0aW9ucyA9IHJlYWRTdHJpbmcoZGF0YSwgZGF0YS5fcG9zKTtcbiAgICBpZiAoa2RmT3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIE9wZW5TU0ggcHJpdmF0ZSBrZXknKTtcbiAgICBpZiAoa2RmT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoa2RmTmFtZSkge1xuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgICAgICBjYXNlICdiY3J5cHQnOiB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgIHN0cmluZyBzYWx0XG4gICAgICAgICAgICB1aW50MzIgcm91bmRzXG4gICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBzYWx0ID0gcmVhZFN0cmluZyhrZGZPcHRpb25zLCAwKTtcbiAgICAgICAgICBpZiAoc2FsdCA9PT0gdW5kZWZpbmVkIHx8IGtkZk9wdGlvbnMuX3BvcyArIDQgPiBrZGZPcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgY29uc3Qgcm91bmRzID0gcmVhZFVJbnQzMkJFKGtkZk9wdGlvbnMsIGtkZk9wdGlvbnMuX3Bvcyk7XG4gICAgICAgICAgY29uc3QgZ2VuID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY0luZm8ua2V5TGVuICsgZW5jSW5mby5pdkxlbik7XG4gICAgICAgICAgY29uc3QgciA9IGJjcnlwdF9wYmtkZihwYXNzcGhyYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3BocmFzZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FsdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRzKTtcbiAgICAgICAgICBpZiAociAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSBpbmZvcm1hdGlvbiB0byBkZWNyeXB0IGtleScpO1xuICAgICAgICAgIGNpcGhlcktleSA9IGJ1ZmZlclNsaWNlKGdlbiwgMCwgZW5jSW5mby5rZXlMZW4pO1xuICAgICAgICAgIGNpcGhlcklWID0gYnVmZmVyU2xpY2UoZ2VuLCBlbmNJbmZvLmtleUxlbiwgZ2VuLmxlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtkZk5hbWUgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIE9wZW5TU0ggcHJpdmF0ZSBrZXknKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5fcG9zICsgMyA+PSBkYXRhLmxlbmd0aClcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgY29uc3Qga2V5Q291bnQgPSByZWFkVUludDMyQkUoZGF0YSwgZGF0YS5fcG9zKTtcbiAgICBkYXRhLl9wb3MgKz0gNDtcblxuICAgIGlmIChrZXlDb3VudCA+IDApIHtcbiAgICAgIC8vIFRPRE86IHBsYWNlIHNlbnNpYmxlIGxpbWl0IG9uIG1heCBga2V5Q291bnRgXG5cbiAgICAgIC8vIFJlYWQgcHVibGljIGtleXMgZmlyc3RcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q291bnQ7ICsraSkge1xuICAgICAgICBjb25zdCBwdWJEYXRhID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MpO1xuICAgICAgICBpZiAocHViRGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSByZWFkU3RyaW5nKHB1YkRhdGEsIDAsIHRydWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBwcml2QmxvYiA9IHJlYWRTdHJpbmcoZGF0YSwgZGF0YS5fcG9zKTtcbiAgICAgIGlmIChwcml2QmxvYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuXG4gICAgICBpZiAoY2lwaGVyS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRW5jcnlwdGVkIHByaXZhdGUga2V5KHMpXG4gICAgICAgIGlmIChwcml2QmxvYi5sZW5ndGggPCBlbmNJbmZvLmJsb2NrTGVuXG4gICAgICAgICAgICB8fCAocHJpdkJsb2IubGVuZ3RoICUgZW5jSW5mby5ibG9ja0xlbikgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgYXV0aFRhZ0xlbmd0aDogZW5jSW5mby5hdXRoTGVuIH07XG4gICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlcml2KGVuY0luZm8uc3NsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lwaGVyS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXBoZXJJVixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyk7XG4gICAgICAgICAgZGVjaXBoZXIuc2V0QXV0b1BhZGRpbmcoZmFsc2UpO1xuICAgICAgICAgIGlmIChlbmNJbmZvLmF1dGhMZW4gPiAwKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggLSBkYXRhLl9wb3MgPCBlbmNJbmZvLmF1dGhMZW4pXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgICBkZWNpcGhlci5zZXRBdXRoVGFnKFxuICAgICAgICAgICAgICBidWZmZXJTbGljZShkYXRhLCBkYXRhLl9wb3MsIGRhdGEuX3BvcyArPSBlbmNJbmZvLmF1dGhMZW4pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcml2QmxvYiA9IGNvbWJpbmVCdWZmZXJzKGRlY2lwaGVyLnVwZGF0ZShwcml2QmxvYiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpcGhlci5maW5hbCgpKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZXR1cm4gZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE5vdGhpbmcgc2hvdWxkIHdlIGZvbGxvdyB0aGUgcHJpdmF0ZSBrZXkocyksIGV4Y2VwdCBhIHBvc3NpYmxlXG4gICAgICAvLyBhdXRoZW50aWNhdGlvbiB0YWcgZm9yIHJlbGV2YW50IGNpcGhlcnNcbiAgICAgIGlmIChkYXRhLl9wb3MgIT09IGRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuXG4gICAgICByZXQgPSBwYXJzZU9wZW5TU0hQcml2S2V5cyhwcml2QmxvYiwga2V5Q291bnQsIGNpcGhlcktleSAhPT0gdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ID0gW107XG4gICAgfVxuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgIHJldHVybiByZXQ7XG4gICAgLy8gVGhpcyB3aWxsIG5lZWQgdG8gY2hhbmdlIGlmL3doZW4gT3BlblNTSCBldmVyIHN0YXJ0cyBzdG9yaW5nIG11bHRpcGxlXG4gICAgLy8ga2V5cyBpbiB0aGVpciBrZXkgZmlsZXNcbiAgICByZXR1cm4gcmV0WzBdO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlT3BlblNTSFByaXZLZXlzKGRhdGEsIG5rZXlzLCBkZWNyeXB0ZWQpIHtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgLypcbiAgICAgIHVpbnQzMiAgY2hlY2tpbnRcbiAgICAgIHVpbnQzMiAgY2hlY2tpbnRcbiAgICAgIHN0cmluZyAgcHJpdmF0ZWtleTFcbiAgICAgIHN0cmluZyAgY29tbWVudDFcbiAgICAgIHN0cmluZyAgcHJpdmF0ZWtleTJcbiAgICAgIHN0cmluZyAgY29tbWVudDJcbiAgICAgIC4uLlxuICAgICAgc3RyaW5nICBwcml2YXRla2V5TlxuICAgICAgc3RyaW5nICBjb21tZW50TlxuICAgICAgY2hhciAgMVxuICAgICAgY2hhciAgMlxuICAgICAgY2hhciAgM1xuICAgICAgLi4uXG4gICAgICBjaGFyICBwYWRsZW4gJSAyNTVcbiAgICAqL1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDgpXG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgIGNvbnN0IGNoZWNrMSA9IHJlYWRVSW50MzJCRShkYXRhLCAwKTtcbiAgICBjb25zdCBjaGVjazIgPSByZWFkVUludDMyQkUoZGF0YSwgNCk7XG4gICAgaWYgKGNoZWNrMSAhPT0gY2hlY2syKSB7XG4gICAgICBpZiAoZGVjcnlwdGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgICAgJ09wZW5TU0gga2V5IGludGVncml0eSBjaGVjayBmYWlsZWQgLS0gYmFkIHBhc3NwaHJhc2U/J1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignT3BlblNTSCBrZXkgaW50ZWdyaXR5IGNoZWNrIGZhaWxlZCcpO1xuICAgIH1cbiAgICBkYXRhLl9wb3MgPSA4O1xuICAgIGxldCBpO1xuICAgIGxldCBvaWQ7XG4gICAgZm9yIChpID0gMDsgaSA8IG5rZXlzOyArK2kpIHtcbiAgICAgIGxldCBhbGdvO1xuICAgICAgbGV0IHByaXZQRU07XG4gICAgICBsZXQgcHViUEVNO1xuICAgICAgbGV0IHB1YlNTSDtcbiAgICAgIC8vIFRoZSBPcGVuU1NIIGRvY3VtZW50YXRpb24gZm9yIHRoZSBrZXkgZm9ybWF0IGFjdHVhbGx5IGxpZXMsIHRoZVxuICAgICAgLy8gZW50aXJldHkgb2YgdGhlIHByaXZhdGUga2V5IGNvbnRlbnQgaXMgbm90IGNvbnRhaW5lZCB3aXRoIGEgc3RyaW5nXG4gICAgICAvLyBmaWVsZCwgaXQncyBhY3R1YWxseSB0aGUgbGl0ZXJhbCBjb250ZW50cyBvZiB0aGUgcHJpdmF0ZSBrZXksIHNvIHRvIGJlXG4gICAgICAvLyBhYmxlIHRvIGZpbmQgdGhlIGVuZCBvZiB0aGUga2V5IGRhdGEgeW91IG5lZWQgdG8ga25vdyB0aGUgbGF5b3V0L2Zvcm1hdFxuICAgICAgLy8gb2YgZWFjaCBrZXkgdHlwZSAuLi5cbiAgICAgIGNvbnN0IHR5cGUgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3BvcywgdHJ1ZSk7XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3NoLXJzYSc6IHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgc3RyaW5nICBuIC0tIHB1YmxpY1xuICAgICAgICAgICAgc3RyaW5nICBlIC0tIHB1YmxpY1xuICAgICAgICAgICAgc3RyaW5nICBkIC0tIHByaXZhdGVcbiAgICAgICAgICAgIHN0cmluZyAgaXFtcCAtLSBwcml2YXRlXG4gICAgICAgICAgICBzdHJpbmcgIHAgLS0gcHJpdmF0ZVxuICAgICAgICAgICAgc3RyaW5nICBxIC0tIHByaXZhdGVcbiAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IG4gPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgY29uc3QgZSA9IHJlYWRTdHJpbmcoZGF0YSwgZGF0YS5fcG9zKTtcbiAgICAgICAgICBpZiAoZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIE9wZW5TU0ggcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICBjb25zdCBkID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MpO1xuICAgICAgICAgIGlmIChkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgICAgICAgIGNvbnN0IGlxbXAgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICAgICAgaWYgKGlxbXAgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgY29uc3QgcCA9IHJlYWRTdHJpbmcoZGF0YSwgZGF0YS5fcG9zKTtcbiAgICAgICAgICBpZiAocCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIE9wZW5TU0ggcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICBjb25zdCBxID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MpO1xuICAgICAgICAgIGlmIChxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuXG4gICAgICAgICAgcHViUEVNID0gZ2VuT3BlblNTTFJTQVB1YihuLCBlKTtcbiAgICAgICAgICBwdWJTU0ggPSBnZW5PcGVuU1NIUlNBUHViKG4sIGUpO1xuICAgICAgICAgIHByaXZQRU0gPSBnZW5PcGVuU1NMUlNBUHJpdihuLCBlLCBkLCBpcW1wLCBwLCBxKTtcbiAgICAgICAgICBhbGdvID0gJ3NoYTEnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NzaC1kc3MnOiB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgIHN0cmluZyAgcCAtLSBwdWJsaWNcbiAgICAgICAgICAgIHN0cmluZyAgcSAtLSBwdWJsaWNcbiAgICAgICAgICAgIHN0cmluZyAgZyAtLSBwdWJsaWNcbiAgICAgICAgICAgIHN0cmluZyAgeSAtLSBwdWJsaWNcbiAgICAgICAgICAgIHN0cmluZyAgeCAtLSBwcml2YXRlXG4gICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBwID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MpO1xuICAgICAgICAgIGlmIChwID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgICAgICAgIGNvbnN0IHEgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICAgICAgaWYgKHEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgY29uc3QgZyA9IHJlYWRTdHJpbmcoZGF0YSwgZGF0YS5fcG9zKTtcbiAgICAgICAgICBpZiAoZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIE9wZW5TU0ggcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICBjb25zdCB5ID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MpO1xuICAgICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgICAgICAgIGNvbnN0IHggPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG5cbiAgICAgICAgICBwdWJQRU0gPSBnZW5PcGVuU1NMRFNBUHViKHAsIHEsIGcsIHkpO1xuICAgICAgICAgIHB1YlNTSCA9IGdlbk9wZW5TU0hEU0FQdWIocCwgcSwgZywgeSk7XG4gICAgICAgICAgcHJpdlBFTSA9IGdlbk9wZW5TU0xEU0FQcml2KHAsIHEsIGcsIHksIHgpO1xuICAgICAgICAgIGFsZ28gPSAnc2hhMSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3NoLWVkMjU1MTknOiB7XG4gICAgICAgICAgaWYgKCFlZGRzYVN1cHBvcnRlZClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9wZW5TU0ggcHJpdmF0ZSBrZXkgdHlwZTogJHt0eXBlfWApO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICAqIHN0cmluZyAgcHVibGljIGtleVxuICAgICAgICAgICAgKiBzdHJpbmcgIHByaXZhdGUga2V5ICsgcHVibGljIGtleVxuICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgZWRwdWIgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICAgICAgaWYgKGVkcHViID09PSB1bmRlZmluZWQgfHwgZWRwdWIubGVuZ3RoICE9PSAzMilcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgY29uc3QgZWRwcml2ID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MpO1xuICAgICAgICAgIGlmIChlZHByaXYgPT09IHVuZGVmaW5lZCB8fCBlZHByaXYubGVuZ3RoICE9PSA2NClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG5cbiAgICAgICAgICBwdWJQRU0gPSBnZW5PcGVuU1NMRWRQdWIoZWRwdWIpO1xuICAgICAgICAgIHB1YlNTSCA9IGdlbk9wZW5TU0hFZFB1YihlZHB1Yik7XG4gICAgICAgICAgcHJpdlBFTSA9IGdlbk9wZW5TU0xFZFByaXYoYnVmZmVyU2xpY2UoZWRwcml2LCAwLCAzMikpO1xuICAgICAgICAgIGFsZ28gPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VjZHNhLXNoYTItbmlzdHAyNTYnOlxuICAgICAgICAgIGFsZ28gPSAnc2hhMjU2JztcbiAgICAgICAgICBvaWQgPSAnMS4yLjg0MC4xMDA0NS4zLjEuNyc7XG4gICAgICAgIC8vIEZBTExUSFJPVUdIXG4gICAgICAgIGNhc2UgJ2VjZHNhLXNoYTItbmlzdHAzODQnOlxuICAgICAgICAgIGlmIChhbGdvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFsZ28gPSAnc2hhMzg0JztcbiAgICAgICAgICAgIG9pZCA9ICcxLjMuMTMyLjAuMzQnO1xuICAgICAgICAgIH1cbiAgICAgICAgLy8gRkFMTFRIUk9VR0hcbiAgICAgICAgY2FzZSAnZWNkc2Etc2hhMi1uaXN0cDUyMSc6IHtcbiAgICAgICAgICBpZiAoYWxnbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbGdvID0gJ3NoYTUxMic7XG4gICAgICAgICAgICBvaWQgPSAnMS4zLjEzMi4wLjM1JztcbiAgICAgICAgICB9XG4gICAgICAgICAgLypcbiAgICAgICAgICAgIHN0cmluZyAgY3VydmUgbmFtZVxuICAgICAgICAgICAgc3RyaW5nICBRIC0tIHB1YmxpY1xuICAgICAgICAgICAgc3RyaW5nICBkIC0tIHByaXZhdGVcbiAgICAgICAgICAqL1xuICAgICAgICAgIC8vIFRPRE86IHZhbGlkYXRlIGN1cnZlIG5hbWUgYWdhaW5zdCB0eXBlXG4gICAgICAgICAgaWYgKCFza2lwRmllbGRzKGRhdGEsIDEpKSAvLyBTa2lwIGN1cnZlIG5hbWVcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgY29uc3QgZWNwdWIgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICAgICAgaWYgKGVjcHViID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgICAgICAgIGNvbnN0IGVjcHJpdiA9IHJlYWRTdHJpbmcoZGF0YSwgZGF0YS5fcG9zKTtcbiAgICAgICAgICBpZiAoZWNwcml2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuXG4gICAgICAgICAgcHViUEVNID0gZ2VuT3BlblNTTEVDRFNBUHViKG9pZCwgZWNwdWIpO1xuICAgICAgICAgIHB1YlNTSCA9IGdlbk9wZW5TU0hFQ0RTQVB1YihvaWQsIGVjcHViKTtcbiAgICAgICAgICBwcml2UEVNID0gZ2VuT3BlblNTTEVDRFNBUHJpdihvaWQsIGVjcHViLCBlY3ByaXYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgT3BlblNTSCBwcml2YXRlIGtleSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByaXZDb21tZW50ID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MsIHRydWUpO1xuICAgICAgaWYgKHByaXZDb21tZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG5cbiAgICAgIGtleXMucHVzaChcbiAgICAgICAgbmV3IE9wZW5TU0hfUHJpdmF0ZSh0eXBlLCBwcml2Q29tbWVudCwgcHJpdlBFTSwgcHViUEVNLCBwdWJTU0gsIGFsZ28sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcnlwdGVkKVxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IGNudCA9IDA7XG4gICAgZm9yIChpID0gZGF0YS5fcG9zOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGRhdGFbaV0gIT09ICgrK2NudCAlIDI1NSkpXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBPcGVuU1NIX09sZF9Qcml2YXRlKHR5cGUsIGNvbW1lbnQsIHByaXZQRU0sIHB1YlBFTSwgcHViU1NILCBhbGdvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNyeXB0ZWQpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbiAgdGhpc1tTWU1fUFJJVl9QRU1dID0gcHJpdlBFTTtcbiAgdGhpc1tTWU1fUFVCX1BFTV0gPSBwdWJQRU07XG4gIHRoaXNbU1lNX1BVQl9TU0hdID0gcHViU1NIO1xuICB0aGlzW1NZTV9IQVNIX0FMR09dID0gYWxnbztcbiAgdGhpc1tTWU1fREVDUllQVEVEXSA9IGRlY3J5cHRlZDtcbn1cbk9wZW5TU0hfT2xkX1ByaXZhdGUucHJvdG90eXBlID0gQmFzZUtleTtcbntcbiAgY29uc3QgcmVnZXhwID0gL14tLS0tLUJFR0lOIChSU0F8RFNBfEVDKSBQUklWQVRFIEtFWS0tLS0tKD86XFxyXFxufFxcbikoKD86W146XSs6XFxzKltcXFNdLiooPzpcXHJcXG58XFxuKSkqKShbXFxzXFxTXSspKD86XFxyXFxufFxcbiktLS0tLUVORCAoUlNBfERTQXxFQykgUFJJVkFURSBLRVktLS0tLSQvO1xuICBPcGVuU1NIX09sZF9Qcml2YXRlLnBhcnNlID0gKHN0ciwgcGFzc3BocmFzZSkgPT4ge1xuICAgIGNvbnN0IG0gPSByZWdleHAuZXhlYyhzdHIpO1xuICAgIGlmIChtID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHByaXZCbG9iID0gQnVmZmVyLmZyb20obVszXSwgJ2Jhc2U2NCcpO1xuICAgIGxldCBoZWFkZXJzID0gbVsyXTtcbiAgICBsZXQgZGVjcnlwdGVkID0gZmFsc2U7XG4gICAgaWYgKGhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZW5jcnlwdGVkIGtleVxuICAgICAgaGVhZGVycyA9IGhlYWRlcnMuc3BsaXQoL1xcclxcbnxcXG4vZyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgbGV0IHNlcElkeCA9IGhlYWRlci5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGlmIChoZWFkZXIuc2xpY2UoMCwgc2VwSWR4KSA9PT0gJ0RFSy1JbmZvJykge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IGhlYWRlci5zbGljZShzZXBJZHggKyAyKTtcbiAgICAgICAgICBzZXBJZHggPSB2YWwuaW5kZXhPZignLCcpO1xuICAgICAgICAgIGlmIChzZXBJZHggPT09IC0xKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3QgY2lwaGVyTmFtZSA9IHZhbC5zbGljZSgwLCBzZXBJZHgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZE9wZW5TU0xDaXBoZXJzLmluZGV4T2YoY2lwaGVyTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQ2lwaGVyICgke2NpcGhlck5hbWV9KSBub3Qgc3VwcG9ydGVkIGBcbiAgICAgICAgICAgICAgICArICdmb3IgZW5jcnlwdGVkIE9wZW5TU0ggcHJpdmF0ZSBrZXknXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlbmNJbmZvID0gQ0lQSEVSX0lORk9fT1BFTlNTTFtjaXBoZXJOYW1lXTtcbiAgICAgICAgICBpZiAoIWVuY0luZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBDaXBoZXIgKCR7Y2lwaGVyTmFtZX0pIG5vdCBzdXBwb3J0ZWQgYFxuICAgICAgICAgICAgICAgICsgJ2ZvciBlbmNyeXB0ZWQgT3BlblNTSCBwcml2YXRlIGtleSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNpcGhlcklWID0gQnVmZmVyLmZyb20odmFsLnNsaWNlKHNlcElkeCArIDEpLCAnaGV4Jyk7XG4gICAgICAgICAgaWYgKGNpcGhlcklWLmxlbmd0aCAhPT0gZW5jSW5mby5pdkxlbilcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBlbmNyeXB0ZWQgT3BlblNTSCBwcml2YXRlIGtleScpO1xuICAgICAgICAgIGlmICghcGFzc3BocmFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ0VuY3J5cHRlZCBPcGVuU1NIIHByaXZhdGUga2V5IGRldGVjdGVkLCBidXQgbm8gcGFzc3BocmFzZSBnaXZlbidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGl2U2xpY2UgPSBidWZmZXJTbGljZShjaXBoZXJJViwgMCwgOCk7XG4gICAgICAgICAgbGV0IGNpcGhlcktleSA9IGNyZWF0ZUhhc2goJ21kNScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZShwYXNzcGhyYXNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGUoaXZTbGljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGlnZXN0KCk7XG4gICAgICAgICAgd2hpbGUgKGNpcGhlcktleS5sZW5ndGggPCBlbmNJbmZvLmtleUxlbikge1xuICAgICAgICAgICAgY2lwaGVyS2V5ID0gY29tYmluZUJ1ZmZlcnMoXG4gICAgICAgICAgICAgIGNpcGhlcktleSxcbiAgICAgICAgICAgICAgY3JlYXRlSGFzaCgnbWQ1JylcbiAgICAgICAgICAgICAgICAudXBkYXRlKGNpcGhlcktleSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKHBhc3NwaHJhc2UpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShpdlNsaWNlKVxuICAgICAgICAgICAgICAgIC5kaWdlc3QoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNpcGhlcktleS5sZW5ndGggPiBlbmNJbmZvLmtleUxlbilcbiAgICAgICAgICAgIGNpcGhlcktleSA9IGJ1ZmZlclNsaWNlKGNpcGhlcktleSwgMCwgZW5jSW5mby5rZXlMZW4pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyaXYoY2lwaGVyTmFtZSwgY2lwaGVyS2V5LCBjaXBoZXJJVik7XG4gICAgICAgICAgICBkZWNpcGhlci5zZXRBdXRvUGFkZGluZyhmYWxzZSk7XG4gICAgICAgICAgICBwcml2QmxvYiA9IGNvbWJpbmVCdWZmZXJzKGRlY2lwaGVyLnVwZGF0ZShwcml2QmxvYiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2lwaGVyLmZpbmFsKCkpO1xuICAgICAgICAgICAgZGVjcnlwdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0eXBlO1xuICAgIGxldCBwcml2UEVNO1xuICAgIGxldCBwdWJQRU07XG4gICAgbGV0IHB1YlNTSDtcbiAgICBsZXQgYWxnbztcbiAgICBsZXQgcmVhZGVyO1xuICAgIGxldCBlcnJNc2cgPSAnTWFsZm9ybWVkIE9wZW5TU0ggcHJpdmF0ZSBrZXknO1xuICAgIGlmIChkZWNyeXB0ZWQpXG4gICAgICBlcnJNc2cgKz0gJy4gQmFkIHBhc3NwaHJhc2U/JztcbiAgICBzd2l0Y2ggKG1bMV0pIHtcbiAgICAgIGNhc2UgJ1JTQSc6XG4gICAgICAgIHR5cGUgPSAnc3NoLXJzYSc7XG4gICAgICAgIHByaXZQRU0gPSBtYWtlUEVNKCdSU0EgUFJJVkFURScsIHByaXZCbG9iKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWFkZXIgPSBuZXcgQmVyLlJlYWRlcihwcml2QmxvYik7XG4gICAgICAgICAgcmVhZGVyLnJlYWRTZXF1ZW5jZSgpO1xuICAgICAgICAgIHJlYWRlci5yZWFkSW50KCk7IC8vIHNraXAgdmVyc2lvblxuICAgICAgICAgIGNvbnN0IG4gPSByZWFkZXIucmVhZFN0cmluZyhCZXIuSW50ZWdlciwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKG4gPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgY29uc3QgZSA9IHJlYWRlci5yZWFkU3RyaW5nKEJlci5JbnRlZ2VyLCB0cnVlKTtcbiAgICAgICAgICBpZiAoZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICBwdWJQRU0gPSBnZW5PcGVuU1NMUlNBUHViKG4sIGUpO1xuICAgICAgICAgIHB1YlNTSCA9IGdlbk9wZW5TU0hSU0FQdWIobiwgZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBhbGdvID0gJ3NoYTEnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0RTQSc6XG4gICAgICAgIHR5cGUgPSAnc3NoLWRzcyc7XG4gICAgICAgIHByaXZQRU0gPSBtYWtlUEVNKCdEU0EgUFJJVkFURScsIHByaXZCbG9iKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWFkZXIgPSBuZXcgQmVyLlJlYWRlcihwcml2QmxvYik7XG4gICAgICAgICAgcmVhZGVyLnJlYWRTZXF1ZW5jZSgpO1xuICAgICAgICAgIHJlYWRlci5yZWFkSW50KCk7IC8vIHNraXAgdmVyc2lvblxuICAgICAgICAgIGNvbnN0IHAgPSByZWFkZXIucmVhZFN0cmluZyhCZXIuSW50ZWdlciwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHAgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgY29uc3QgcSA9IHJlYWRlci5yZWFkU3RyaW5nKEJlci5JbnRlZ2VyLCB0cnVlKTtcbiAgICAgICAgICBpZiAocSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICBjb25zdCBnID0gcmVhZGVyLnJlYWRTdHJpbmcoQmVyLkludGVnZXIsIHRydWUpO1xuICAgICAgICAgIGlmIChnID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgIGNvbnN0IHkgPSByZWFkZXIucmVhZFN0cmluZyhCZXIuSW50ZWdlciwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHkgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgcHViUEVNID0gZ2VuT3BlblNTTERTQVB1YihwLCBxLCBnLCB5KTtcbiAgICAgICAgICBwdWJTU0ggPSBnZW5PcGVuU1NIRFNBUHViKHAsIHEsIGcsIHkpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgYWxnbyA9ICdzaGExJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFQyc6IHtcbiAgICAgICAgbGV0IGVjU1NMTmFtZTtcbiAgICAgICAgbGV0IGVjUHJpdjtcbiAgICAgICAgbGV0IGVjT0lEO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlYWRlciA9IG5ldyBCZXIuUmVhZGVyKHByaXZCbG9iKTtcbiAgICAgICAgICByZWFkZXIucmVhZFNlcXVlbmNlKCk7XG4gICAgICAgICAgcmVhZGVyLnJlYWRJbnQoKTsgLy8gc2tpcCB2ZXJzaW9uXG4gICAgICAgICAgZWNQcml2ID0gcmVhZGVyLnJlYWRTdHJpbmcoQmVyLk9jdGV0U3RyaW5nLCB0cnVlKTtcbiAgICAgICAgICByZWFkZXIucmVhZEJ5dGUoKTsgLy8gU2tpcCBcImNvbXBsZXhcIiBjb250ZXh0IHR5cGUgYnl0ZVxuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHJlYWRlci5yZWFkTGVuZ3RoKCk7IC8vIFNraXAgY29udGV4dCBsZW5ndGhcbiAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkZXIuX29mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGVjT0lEID0gcmVhZGVyLnJlYWRPSUQoKTtcbiAgICAgICAgICAgIGlmIChlY09JRCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgc3dpdGNoIChlY09JRCkge1xuICAgICAgICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjMuMS43JzpcbiAgICAgICAgICAgICAgICAvLyBwcmltZTI1NnYxL3NlY3AyNTZyMVxuICAgICAgICAgICAgICAgIGVjU1NMTmFtZSA9ICdwcmltZTI1NnYxJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2VjZHNhLXNoYTItbmlzdHAyNTYnO1xuICAgICAgICAgICAgICAgIGFsZ28gPSAnc2hhMjU2JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnMS4zLjEzMi4wLjM0JzpcbiAgICAgICAgICAgICAgICAvLyBzZWNwMzg0cjFcbiAgICAgICAgICAgICAgICBlY1NTTE5hbWUgPSAnc2VjcDM4NHIxJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2VjZHNhLXNoYTItbmlzdHAzODQnO1xuICAgICAgICAgICAgICAgIGFsZ28gPSAnc2hhMzg0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnMS4zLjEzMi4wLjM1JzpcbiAgICAgICAgICAgICAgICAvLyBzZWNwNTIxcjFcbiAgICAgICAgICAgICAgICBlY1NTTE5hbWUgPSAnc2VjcDUyMXIxJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2VjZHNhLXNoYTItbmlzdHA1MjEnO1xuICAgICAgICAgICAgICAgIGFsZ28gPSAnc2hhNTEyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcml2YXRlIGtleSBFQyBPSUQ6ICR7ZWNPSUR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBwcml2UEVNID0gbWFrZVBFTSgnRUMgUFJJVkFURScsIHByaXZCbG9iKTtcbiAgICAgICAgY29uc3QgcHViQmxvYiA9IGdlbk9wZW5TU0xFQ0RTQVB1YkZyb21Qcml2KGVjU1NMTmFtZSwgZWNQcml2KTtcbiAgICAgICAgcHViUEVNID0gZ2VuT3BlblNTTEVDRFNBUHViKGVjT0lELCBwdWJCbG9iKTtcbiAgICAgICAgcHViU1NIID0gZ2VuT3BlblNTSEVDRFNBUHViKGVjT0lELCBwdWJCbG9iKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBPcGVuU1NIX09sZF9Qcml2YXRlKHR5cGUsICcnLCBwcml2UEVNLCBwdWJQRU0sIHB1YlNTSCwgYWxnbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcnlwdGVkKTtcbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBQUEtfUHJpdmF0ZSh0eXBlLCBjb21tZW50LCBwcml2UEVNLCBwdWJQRU0sIHB1YlNTSCwgYWxnbywgZGVjcnlwdGVkKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG4gIHRoaXNbU1lNX1BSSVZfUEVNXSA9IHByaXZQRU07XG4gIHRoaXNbU1lNX1BVQl9QRU1dID0gcHViUEVNO1xuICB0aGlzW1NZTV9QVUJfU1NIXSA9IHB1YlNTSDtcbiAgdGhpc1tTWU1fSEFTSF9BTEdPXSA9IGFsZ287XG4gIHRoaXNbU1lNX0RFQ1JZUFRFRF0gPSBkZWNyeXB0ZWQ7XG59XG5QUEtfUHJpdmF0ZS5wcm90b3R5cGUgPSBCYXNlS2V5O1xue1xuICBjb25zdCBFTVBUWV9QQVNTUEhSQVNFID0gQnVmZmVyLmFsbG9jKDApO1xuICBjb25zdCBQUEtfSVYgPSBCdWZmZXIuZnJvbShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICBjb25zdCBQUEtfUFAxID0gQnVmZmVyLmZyb20oWzAsIDAsIDAsIDBdKTtcbiAgY29uc3QgUFBLX1BQMiA9IEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAxXSk7XG4gIGNvbnN0IHJlZ2V4cCA9IC9eUHVUVFktVXNlci1LZXktRmlsZS0yOiAoc3NoLSg/OnJzYXxkc3MpKVxccj9cXG5FbmNyeXB0aW9uOiAoYWVzMjU2LWNiY3xub25lKVxccj9cXG5Db21tZW50OiAoW15cXHJcXG5dKilcXHI/XFxuUHVibGljLUxpbmVzOiBcXGQrXFxyP1xcbihbXFxzXFxTXSs/KVxccj9cXG5Qcml2YXRlLUxpbmVzOiBcXGQrXFxyP1xcbihbXFxzXFxTXSs/KVxccj9cXG5Qcml2YXRlLU1BQzogKFteXFxyXFxuXSspLztcbiAgUFBLX1ByaXZhdGUucGFyc2UgPSAoc3RyLCBwYXNzcGhyYXNlKSA9PiB7XG4gICAgY29uc3QgbSA9IHJlZ2V4cC5leGVjKHN0cik7XG4gICAgaWYgKG0gPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBtWzFdID0ga2V5IHR5cGVcbiAgICAvLyBtWzJdID0gZW5jcnlwdGlvbiB0eXBlXG4gICAgLy8gbVszXSA9IGNvbW1lbnRcbiAgICAvLyBtWzRdID0gYmFzZTY0LWVuY29kZWQgcHVibGljIGtleSBkYXRhOlxuICAgIC8vICAgICAgICAgZm9yIFwic3NoLXJzYVwiOlxuICAgIC8vICAgICAgICAgIHN0cmluZyBcInNzaC1yc2FcIlxuICAgIC8vICAgICAgICAgIG1waW50ICBlICAgIChwdWJsaWMgZXhwb25lbnQpXG4gICAgLy8gICAgICAgICAgbXBpbnQgIG4gICAgKG1vZHVsdXMpXG4gICAgLy8gICAgICAgICBmb3IgXCJzc2gtZHNzXCI6XG4gICAgLy8gICAgICAgICAgc3RyaW5nIFwic3NoLWRzc1wiXG4gICAgLy8gICAgICAgICAgbXBpbnQgcCAgICAgKG1vZHVsdXMpXG4gICAgLy8gICAgICAgICAgbXBpbnQgcSAgICAgKHByaW1lKVxuICAgIC8vICAgICAgICAgIG1waW50IGcgICAgIChiYXNlIG51bWJlcilcbiAgICAvLyAgICAgICAgICBtcGludCB5ICAgICAocHVibGljIGtleSBwYXJhbWV0ZXI6IGdeeCBtb2QgcClcbiAgICAvLyBtWzVdID0gYmFzZTY0LWVuY29kZWQgcHJpdmF0ZSBrZXkgZGF0YTpcbiAgICAvLyAgICAgICAgIGZvciBcInNzaC1yc2FcIjpcbiAgICAvLyAgICAgICAgICBtcGludCAgZCAgICAocHJpdmF0ZSBleHBvbmVudClcbiAgICAvLyAgICAgICAgICBtcGludCAgcCAgICAocHJpbWUgMSlcbiAgICAvLyAgICAgICAgICBtcGludCAgcSAgICAocHJpbWUgMilcbiAgICAvLyAgICAgICAgICBtcGludCAgaXFtcCAoW2ludmVyc2Ugb2YgcV0gbW9kIHApXG4gICAgLy8gICAgICAgICBmb3IgXCJzc2gtZHNzXCI6XG4gICAgLy8gICAgICAgICAgbXBpbnQgeCAgICAgKHByaXZhdGUga2V5IHBhcmFtZXRlcilcbiAgICAvLyBtWzZdID0gU0hBMSBITUFDIG92ZXI6XG4gICAgLy8gICAgICAgICAgc3RyaW5nICBuYW1lIG9mIGFsZ29yaXRobSAoXCJzc2gtZHNzXCIsIFwic3NoLXJzYVwiKVxuICAgIC8vICAgICAgICAgIHN0cmluZyAgZW5jcnlwdGlvbiB0eXBlXG4gICAgLy8gICAgICAgICAgc3RyaW5nICBjb21tZW50XG4gICAgLy8gICAgICAgICAgc3RyaW5nICBwdWJsaWMga2V5IGRhdGFcbiAgICAvLyAgICAgICAgICBzdHJpbmcgIHByaXZhdGUtcGxhaW50ZXh0IChpbmNsdWRpbmcgdGhlIGZpbmFsIHBhZGRpbmcpXG4gICAgY29uc3QgY2lwaGVyTmFtZSA9IG1bMl07XG4gICAgY29uc3QgZW5jcnlwdGVkID0gKGNpcGhlck5hbWUgIT09ICdub25lJyk7XG4gICAgaWYgKGVuY3J5cHRlZCAmJiAhcGFzc3BocmFzZSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgJ0VuY3J5cHRlZCBQUEsgcHJpdmF0ZSBrZXkgZGV0ZWN0ZWQsIGJ1dCBubyBwYXNzcGhyYXNlIGdpdmVuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgcHJpdkJsb2IgPSBCdWZmZXIuZnJvbShtWzVdLCAnYmFzZTY0Jyk7XG5cbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICBjb25zdCBlbmNJbmZvID0gQ0lQSEVSX0lORk9bY2lwaGVyTmFtZV07XG4gICAgICBsZXQgY2lwaGVyS2V5ID0gY29tYmluZUJ1ZmZlcnMoXG4gICAgICAgIGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoUFBLX1BQMSkudXBkYXRlKHBhc3NwaHJhc2UpLmRpZ2VzdCgpLFxuICAgICAgICBjcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKFBQS19QUDIpLnVwZGF0ZShwYXNzcGhyYXNlKS5kaWdlc3QoKVxuICAgICAgKTtcbiAgICAgIGlmIChjaXBoZXJLZXkubGVuZ3RoID4gZW5jSW5mby5rZXlMZW4pXG4gICAgICAgIGNpcGhlcktleSA9IGJ1ZmZlclNsaWNlKGNpcGhlcktleSwgMCwgZW5jSW5mby5rZXlMZW4pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlcml2KGVuY0luZm8uc3NsTmFtZSwgY2lwaGVyS2V5LCBQUEtfSVYpO1xuICAgICAgICBkZWNpcGhlci5zZXRBdXRvUGFkZGluZyhmYWxzZSk7XG4gICAgICAgIHByaXZCbG9iID0gY29tYmluZUJ1ZmZlcnMoZGVjaXBoZXIudXBkYXRlKHByaXZCbG9iKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpcGhlci5maW5hbCgpKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gbVsxXTtcbiAgICBjb25zdCBjb21tZW50ID0gbVszXTtcbiAgICBjb25zdCBwdWJCbG9iID0gQnVmZmVyLmZyb20obVs0XSwgJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgbWFjID0gbVs2XTtcbiAgICBjb25zdCB0eXBlTGVuID0gdHlwZS5sZW5ndGg7XG4gICAgY29uc3QgY2lwaGVyTmFtZUxlbiA9IGNpcGhlck5hbWUubGVuZ3RoO1xuICAgIGNvbnN0IGNvbW1lbnRMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChjb21tZW50KTtcbiAgICBjb25zdCBwdWJMZW4gPSBwdWJCbG9iLmxlbmd0aDtcbiAgICBjb25zdCBwcml2TGVuID0gcHJpdkJsb2IubGVuZ3RoO1xuICAgIGNvbnN0IG1hY0RhdGEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIHR5cGVMZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgNCArIGNpcGhlck5hbWVMZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgNCArIGNvbW1lbnRMZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgNCArIHB1YkxlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyA0ICsgcHJpdkxlbik7XG4gICAgbGV0IHAgPSAwO1xuXG4gICAgd3JpdGVVSW50MzJCRShtYWNEYXRhLCB0eXBlTGVuLCBwKTtcbiAgICBtYWNEYXRhLnV0ZjhXcml0ZSh0eXBlLCBwICs9IDQsIHR5cGVMZW4pO1xuICAgIHdyaXRlVUludDMyQkUobWFjRGF0YSwgY2lwaGVyTmFtZUxlbiwgcCArPSB0eXBlTGVuKTtcbiAgICBtYWNEYXRhLnV0ZjhXcml0ZShjaXBoZXJOYW1lLCBwICs9IDQsIGNpcGhlck5hbWVMZW4pO1xuICAgIHdyaXRlVUludDMyQkUobWFjRGF0YSwgY29tbWVudExlbiwgcCArPSBjaXBoZXJOYW1lTGVuKTtcbiAgICBtYWNEYXRhLnV0ZjhXcml0ZShjb21tZW50LCBwICs9IDQsIGNvbW1lbnRMZW4pO1xuICAgIHdyaXRlVUludDMyQkUobWFjRGF0YSwgcHViTGVuLCBwICs9IGNvbW1lbnRMZW4pO1xuICAgIG1hY0RhdGEuc2V0KHB1YkJsb2IsIHAgKz0gNCk7XG4gICAgd3JpdGVVSW50MzJCRShtYWNEYXRhLCBwcml2TGVuLCBwICs9IHB1Ykxlbik7XG4gICAgbWFjRGF0YS5zZXQocHJpdkJsb2IsIHAgKyA0KTtcblxuICAgIGlmICghcGFzc3BocmFzZSlcbiAgICAgIHBhc3NwaHJhc2UgPSBFTVBUWV9QQVNTUEhSQVNFO1xuXG4gICAgY29uc3QgY2FsY01BQyA9IGNyZWF0ZUhtYWMoXG4gICAgICAnc2hhMScsXG4gICAgICAgY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAgICAudXBkYXRlKCdwdXR0eS1wcml2YXRlLWtleS1maWxlLW1hYy1rZXknKVxuICAgICAgICAgLnVwZGF0ZShwYXNzcGhyYXNlKVxuICAgICAgICAgLmRpZ2VzdCgpXG4gICAgKS51cGRhdGUobWFjRGF0YSkuZGlnZXN0KCdoZXgnKTtcblxuICAgIGlmIChjYWxjTUFDICE9PSBtYWMpIHtcbiAgICAgIGlmIChlbmNyeXB0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgICAnUFBLIHByaXZhdGUga2V5IGludGVncml0eSBjaGVjayBmYWlsZWQgLS0gYmFkIHBhc3NwaHJhc2U/J1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignUFBLIHByaXZhdGUga2V5IGludGVncml0eSBjaGVjayBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICBsZXQgcHViUEVNO1xuICAgIGxldCBwdWJTU0g7XG4gICAgbGV0IHByaXZQRU07XG4gICAgcHViQmxvYi5fcG9zID0gMDtcbiAgICBza2lwRmllbGRzKHB1YkJsb2IsIDEpOyAvLyBza2lwIChkdXBsaWNhdGUpIGtleSB0eXBlXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzc2gtcnNhJzoge1xuICAgICAgICBjb25zdCBlID0gcmVhZFN0cmluZyhwdWJCbG9iLCBwdWJCbG9iLl9wb3MpO1xuICAgICAgICBpZiAoZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBQUEsgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBuID0gcmVhZFN0cmluZyhwdWJCbG9iLCBwdWJCbG9iLl9wb3MpO1xuICAgICAgICBpZiAobiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBQUEsgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBkID0gcmVhZFN0cmluZyhwcml2QmxvYiwgMCk7XG4gICAgICAgIGlmIChkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIFBQSyBwcml2YXRlIGtleScpO1xuICAgICAgICBjb25zdCBwID0gcmVhZFN0cmluZyhwcml2QmxvYiwgcHJpdkJsb2IuX3Bvcyk7XG4gICAgICAgIGlmIChwID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIFBQSyBwcml2YXRlIGtleScpO1xuICAgICAgICBjb25zdCBxID0gcmVhZFN0cmluZyhwcml2QmxvYiwgcHJpdkJsb2IuX3Bvcyk7XG4gICAgICAgIGlmIChxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIFBQSyBwcml2YXRlIGtleScpO1xuICAgICAgICBjb25zdCBpcW1wID0gcmVhZFN0cmluZyhwcml2QmxvYiwgcHJpdkJsb2IuX3Bvcyk7XG4gICAgICAgIGlmIChpcW1wID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIFBQSyBwcml2YXRlIGtleScpO1xuICAgICAgICBwdWJQRU0gPSBnZW5PcGVuU1NMUlNBUHViKG4sIGUpO1xuICAgICAgICBwdWJTU0ggPSBnZW5PcGVuU1NIUlNBUHViKG4sIGUpO1xuICAgICAgICBwcml2UEVNID0gZ2VuT3BlblNTTFJTQVByaXYobiwgZSwgZCwgaXFtcCwgcCwgcSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnc3NoLWRzcyc6IHtcbiAgICAgICAgY29uc3QgcCA9IHJlYWRTdHJpbmcocHViQmxvYiwgcHViQmxvYi5fcG9zKTtcbiAgICAgICAgaWYgKHAgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgUFBLIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgcSA9IHJlYWRTdHJpbmcocHViQmxvYiwgcHViQmxvYi5fcG9zKTtcbiAgICAgICAgaWYgKHEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgUFBLIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgZyA9IHJlYWRTdHJpbmcocHViQmxvYiwgcHViQmxvYi5fcG9zKTtcbiAgICAgICAgaWYgKGcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgUFBLIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgeSA9IHJlYWRTdHJpbmcocHViQmxvYiwgcHViQmxvYi5fcG9zKTtcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgUFBLIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgeCA9IHJlYWRTdHJpbmcocHJpdkJsb2IsIDApO1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBQUEsgcHJpdmF0ZSBrZXknKTtcblxuICAgICAgICBwdWJQRU0gPSBnZW5PcGVuU1NMRFNBUHViKHAsIHEsIGcsIHkpO1xuICAgICAgICBwdWJTU0ggPSBnZW5PcGVuU1NIRFNBUHViKHAsIHEsIGcsIHkpO1xuICAgICAgICBwcml2UEVNID0gZ2VuT3BlblNTTERTQVByaXYocCwgcSwgZywgeSwgeCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUFBLX1ByaXZhdGUodHlwZSwgY29tbWVudCwgcHJpdlBFTSwgcHViUEVNLCBwdWJTU0gsICdzaGExJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZCk7XG4gIH07XG59XG5cblxuZnVuY3Rpb24gT3BlblNTSF9QdWJsaWModHlwZSwgY29tbWVudCwgcHViUEVNLCBwdWJTU0gsIGFsZ28pIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbiAgdGhpc1tTWU1fUFJJVl9QRU1dID0gbnVsbDtcbiAgdGhpc1tTWU1fUFVCX1BFTV0gPSBwdWJQRU07XG4gIHRoaXNbU1lNX1BVQl9TU0hdID0gcHViU1NIO1xuICB0aGlzW1NZTV9IQVNIX0FMR09dID0gYWxnbztcbiAgdGhpc1tTWU1fREVDUllQVEVEXSA9IGZhbHNlO1xufVxuT3BlblNTSF9QdWJsaWMucHJvdG90eXBlID0gQmFzZUtleTtcbntcbiAgbGV0IHJlZ2V4cDtcbiAgaWYgKGVkZHNhU3VwcG9ydGVkKVxuICAgIHJlZ2V4cCA9IC9eKCgoPzpzc2gtKD86cnNhfGRzc3xlZDI1NTE5KSl8ZWNkc2Etc2hhMi1uaXN0cCg/OjI1NnwzODR8NTIxKSkoPzotY2VydC12MFswMV1Ab3BlbnNzaC5jb20pPykgKFtBLVowLTlhLXovKz1dKykoPzokfFxccysoW1xcU10uKik/KSQvO1xuICBlbHNlXG4gICAgcmVnZXhwID0gL14oKCg/OnNzaC0oPzpyc2F8ZHNzKSl8ZWNkc2Etc2hhMi1uaXN0cCg/OjI1NnwzODR8NTIxKSkoPzotY2VydC12MFswMV1Ab3BlbnNzaC5jb20pPykgKFtBLVowLTlhLXovKz1dKykoPzokfFxccysoW1xcU10uKik/KSQvO1xuICBPcGVuU1NIX1B1YmxpYy5wYXJzZSA9IChzdHIpID0+IHtcbiAgICBjb25zdCBtID0gcmVnZXhwLmV4ZWMoc3RyKTtcbiAgICBpZiAobSA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIG1bMV0gPSBmdWxsIHR5cGVcbiAgICAvLyBtWzJdID0gYmFzZSB0eXBlXG4gICAgLy8gbVszXSA9IGJhc2U2NC1lbmNvZGVkIHB1YmxpYyBrZXlcbiAgICAvLyBtWzRdID0gY29tbWVudFxuXG4gICAgY29uc3QgZnVsbFR5cGUgPSBtWzFdO1xuICAgIGNvbnN0IGJhc2VUeXBlID0gbVsyXTtcbiAgICBjb25zdCBkYXRhID0gQnVmZmVyLmZyb20obVszXSwgJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IGNvbW1lbnQgPSAobVs0XSB8fCAnJyk7XG5cbiAgICBjb25zdCB0eXBlID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MsIHRydWUpO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZS5pbmRleE9mKGJhc2VUeXBlKSAhPT0gMClcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHB1YmxpYyBrZXknKTtcblxuICAgIHJldHVybiBwYXJzZURFUihkYXRhLCBiYXNlVHlwZSwgY29tbWVudCwgZnVsbFR5cGUpO1xuICB9O1xufVxuXG5cbmZ1bmN0aW9uIFJGQzQ3MTZfUHVibGljKHR5cGUsIGNvbW1lbnQsIHB1YlBFTSwgcHViU1NILCBhbGdvKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG4gIHRoaXNbU1lNX1BSSVZfUEVNXSA9IG51bGw7XG4gIHRoaXNbU1lNX1BVQl9QRU1dID0gcHViUEVNO1xuICB0aGlzW1NZTV9QVUJfU1NIXSA9IHB1YlNTSDtcbiAgdGhpc1tTWU1fSEFTSF9BTEdPXSA9IGFsZ287XG4gIHRoaXNbU1lNX0RFQ1JZUFRFRF0gPSBmYWxzZTtcbn1cblJGQzQ3MTZfUHVibGljLnByb3RvdHlwZSA9IEJhc2VLZXk7XG57XG4gIGNvbnN0IHJlZ2V4cCA9IC9eLS0tLSBCRUdJTiBTU0gyIFBVQkxJQyBLRVkgLS0tLSg/Olxccj9cXG4pKCg/Oi57MCw3Mn1cXHI/XFxuKSspLS0tLSBFTkQgU1NIMiBQVUJMSUMgS0VZIC0tLS0kLztcbiAgY29uc3QgUkVfREFUQSA9IC9eW0EtWjAtOWEtei8rPVxcclxcbl0rJC87XG4gIGNvbnN0IFJFX0hFQURFUiA9IC9eKFtcXHgyMS1cXHgzOVxceDNCLVxceDdFXXsxLDY0fSk6ICgoPzpbXlxcXFxdKlxcXFxcXHI/XFxuKSpbXlxcclxcbl0rKVxccj9cXG4vZ207XG4gIGNvbnN0IFJFX0hFQURFUl9FTkRTID0gL1xcXFxcXHI/XFxuL2c7XG4gIFJGQzQ3MTZfUHVibGljLnBhcnNlID0gKHN0cikgPT4ge1xuICAgIGxldCBtID0gcmVnZXhwLmV4ZWMoc3RyKTtcbiAgICBpZiAobSA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgYm9keSA9IG1bMV07XG4gICAgbGV0IGRhdGFTdGFydCA9IDA7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcblxuICAgIHdoaWxlIChtID0gUkVfSEVBREVSLmV4ZWMoYm9keSkpIHtcbiAgICAgIGNvbnN0IGhlYWRlck5hbWUgPSBtWzFdO1xuICAgICAgY29uc3QgaGVhZGVyVmFsdWUgPSBtWzJdLnJlcGxhY2UoUkVfSEVBREVSX0VORFMsICcnKTtcbiAgICAgIGlmIChoZWFkZXJWYWx1ZS5sZW5ndGggPiAxMDI0KSB7XG4gICAgICAgIFJFX0hFQURFUi5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgUkZDNDcxNiBwdWJsaWMga2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFTdGFydCA9IFJFX0hFQURFUi5sYXN0SW5kZXg7XG5cbiAgICAgIGlmIChoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjb21tZW50Jykge1xuICAgICAgICBjb21tZW50ID0gaGVhZGVyVmFsdWU7XG4gICAgICAgIGlmIChjb21tZW50Lmxlbmd0aCA+IDFcbiAgICAgICAgICAgICYmIGNvbW1lbnQuY2hhckNvZGVBdCgwKSA9PT0gMzQvKiAnXCInICovXG4gICAgICAgICAgICAmJiBjb21tZW50LmNoYXJDb2RlQXQoY29tbWVudC5sZW5ndGggLSAxKSA9PT0gMzQvKiAnXCInICovKSB7XG4gICAgICAgICAgY29tbWVudCA9IGNvbW1lbnQuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRhdGEgPSBib2R5LnNsaWNlKGRhdGFTdGFydCk7XG4gICAgaWYgKCFSRV9EQVRBLnRlc3QoZGF0YSkpXG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgUkZDNDcxNiBwdWJsaWMga2V5Jyk7XG5cbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgdHlwZSA9IHJlYWRTdHJpbmcoZGF0YSwgMCwgdHJ1ZSk7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBSRkM0NzE2IHB1YmxpYyBrZXknKTtcblxuICAgIGxldCBwdWJQRU0gPSBudWxsO1xuICAgIGxldCBwdWJTU0ggPSBudWxsO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3NoLXJzYSc6IHtcbiAgICAgICAgY29uc3QgZSA9IHJlYWRTdHJpbmcoZGF0YSwgZGF0YS5fcG9zKTtcbiAgICAgICAgaWYgKGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgUkZDNDcxNiBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IG4gPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICAgIGlmIChuID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIFJGQzQ3MTYgcHVibGljIGtleScpO1xuICAgICAgICBwdWJQRU0gPSBnZW5PcGVuU1NMUlNBUHViKG4sIGUpO1xuICAgICAgICBwdWJTU0ggPSBnZW5PcGVuU1NIUlNBUHViKG4sIGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3NzaC1kc3MnOiB7XG4gICAgICAgIGNvbnN0IHAgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICAgIGlmIChwID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIFJGQzQ3MTYgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBxID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MpO1xuICAgICAgICBpZiAocSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBSRkM0NzE2IHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgZyA9IHJlYWRTdHJpbmcoZGF0YSwgZGF0YS5fcG9zKTtcbiAgICAgICAgaWYgKGcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgUkZDNDcxNiBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IHkgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIFJGQzQ3MTYgcHVibGljIGtleScpO1xuICAgICAgICBwdWJQRU0gPSBnZW5PcGVuU1NMRFNBUHViKHAsIHEsIGcsIHkpO1xuICAgICAgICBwdWJTU0ggPSBnZW5PcGVuU1NIRFNBUHViKHAsIHEsIGcsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBSRkM0NzE2IHB1YmxpYyBrZXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJGQzQ3MTZfUHVibGljKHR5cGUsIGNvbW1lbnQsIHB1YlBFTSwgcHViU1NILCAnc2hhMScpO1xuICB9O1xufVxuXG5cbmZ1bmN0aW9uIHBhcnNlREVSKGRhdGEsIGJhc2VUeXBlLCBjb21tZW50LCBmdWxsVHlwZSkge1xuICBpZiAoIWlzU3VwcG9ydGVkS2V5VHlwZShiYXNlVHlwZSkpXG4gICAgcmV0dXJuIG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgT3BlblNTSCBwdWJsaWMga2V5IHR5cGU6ICR7YmFzZVR5cGV9YCk7XG5cbiAgbGV0IGFsZ287XG4gIGxldCBvaWQ7XG4gIGxldCBwdWJQRU0gPSBudWxsO1xuICBsZXQgcHViU1NIID0gbnVsbDtcblxuICBzd2l0Y2ggKGJhc2VUeXBlKSB7XG4gICAgY2FzZSAnc3NoLXJzYSc6IHtcbiAgICAgIGNvbnN0IGUgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3BvcyB8fCAwKTtcbiAgICAgIGlmIChlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHB1YmxpYyBrZXknKTtcbiAgICAgIGNvbnN0IG4gPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICBpZiAobiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwdWJsaWMga2V5Jyk7XG4gICAgICBwdWJQRU0gPSBnZW5PcGVuU1NMUlNBUHViKG4sIGUpO1xuICAgICAgcHViU1NIID0gZ2VuT3BlblNTSFJTQVB1YihuLCBlKTtcbiAgICAgIGFsZ28gPSAnc2hhMSc7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnc3NoLWRzcyc6IHtcbiAgICAgIGNvbnN0IHAgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3BvcyB8fCAwKTtcbiAgICAgIGlmIChwID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHB1YmxpYyBrZXknKTtcbiAgICAgIGNvbnN0IHEgPSByZWFkU3RyaW5nKGRhdGEsIGRhdGEuX3Bvcyk7XG4gICAgICBpZiAocSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwdWJsaWMga2V5Jyk7XG4gICAgICBjb25zdCBnID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MpO1xuICAgICAgaWYgKGcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIE9wZW5TU0ggcHVibGljIGtleScpO1xuICAgICAgY29uc3QgeSA9IHJlYWRTdHJpbmcoZGF0YSwgZGF0YS5fcG9zKTtcbiAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHB1YmxpYyBrZXknKTtcbiAgICAgIHB1YlBFTSA9IGdlbk9wZW5TU0xEU0FQdWIocCwgcSwgZywgeSk7XG4gICAgICBwdWJTU0ggPSBnZW5PcGVuU1NIRFNBUHViKHAsIHEsIGcsIHkpO1xuICAgICAgYWxnbyA9ICdzaGExJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdzc2gtZWQyNTUxOSc6IHtcbiAgICAgIGNvbnN0IGVkcHViID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MgfHwgMCk7XG4gICAgICBpZiAoZWRwdWIgPT09IHVuZGVmaW5lZCB8fCBlZHB1Yi5sZW5ndGggIT09IDMyKVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYWxmb3JtZWQgT3BlblNTSCBwdWJsaWMga2V5Jyk7XG4gICAgICBwdWJQRU0gPSBnZW5PcGVuU1NMRWRQdWIoZWRwdWIpO1xuICAgICAgcHViU1NIID0gZ2VuT3BlblNTSEVkUHViKGVkcHViKTtcbiAgICAgIGFsZ28gPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ2VjZHNhLXNoYTItbmlzdHAyNTYnOlxuICAgICAgYWxnbyA9ICdzaGEyNTYnO1xuICAgICAgb2lkID0gJzEuMi44NDAuMTAwNDUuMy4xLjcnO1xuICAgIC8vIEZBTExUSFJPVUdIXG4gICAgY2FzZSAnZWNkc2Etc2hhMi1uaXN0cDM4NCc6XG4gICAgICBpZiAoYWxnbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFsZ28gPSAnc2hhMzg0JztcbiAgICAgICAgb2lkID0gJzEuMy4xMzIuMC4zNCc7XG4gICAgICB9XG4gICAgLy8gRkFMTFRIUk9VR0hcbiAgICBjYXNlICdlY2RzYS1zaGEyLW5pc3RwNTIxJzoge1xuICAgICAgaWYgKGFsZ28gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbGdvID0gJ3NoYTUxMic7XG4gICAgICAgIG9pZCA9ICcxLjMuMTMyLjAuMzUnO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogdmFsaWRhdGUgY3VydmUgbmFtZSBhZ2FpbnN0IHR5cGVcbiAgICAgIGlmICghc2tpcEZpZWxkcyhkYXRhLCAxKSkgLy8gU2tpcCBjdXJ2ZSBuYW1lXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHB1YmxpYyBrZXknKTtcbiAgICAgIGNvbnN0IGVjcHViID0gcmVhZFN0cmluZyhkYXRhLCBkYXRhLl9wb3MgfHwgMCk7XG4gICAgICBpZiAoZWNwdWIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWFsZm9ybWVkIE9wZW5TU0ggcHVibGljIGtleScpO1xuICAgICAgcHViUEVNID0gZ2VuT3BlblNTTEVDRFNBUHViKG9pZCwgZWNwdWIpO1xuICAgICAgcHViU1NIID0gZ2VuT3BlblNTSEVDRFNBUHViKG9pZCwgZWNwdWIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPcGVuU1NIIHB1YmxpYyBrZXkgdHlwZTogJHtiYXNlVHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgT3BlblNTSF9QdWJsaWMoZnVsbFR5cGUsIGNvbW1lbnQsIHB1YlBFTSwgcHViU1NILCBhbGdvKTtcbn1cblxuZnVuY3Rpb24gaXNTdXBwb3J0ZWRLZXlUeXBlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3NoLXJzYSc6XG4gICAgY2FzZSAnc3NoLWRzcyc6XG4gICAgY2FzZSAnZWNkc2Etc2hhMi1uaXN0cDI1Nic6XG4gICAgY2FzZSAnZWNkc2Etc2hhMi1uaXN0cDM4NCc6XG4gICAgY2FzZSAnZWNkc2Etc2hhMi1uaXN0cDUyMSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdzc2gtZWQyNTUxOSc6XG4gICAgICBpZiAoZWRkc2FTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIEZBTExUSFJPVUdIXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1BhcnNlZEtleSh2YWwpIHtcbiAgaWYgKCF2YWwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKHR5cGVvZiB2YWxbU1lNX0RFQ1JZUFRFRF0gPT09ICdib29sZWFuJyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlS2V5KGRhdGEsIHBhc3NwaHJhc2UpIHtcbiAgaWYgKGlzUGFyc2VkS2V5KGRhdGEpKVxuICAgIHJldHVybiBkYXRhO1xuXG4gIGxldCBvcmlnQnVmZmVyO1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgb3JpZ0J1ZmZlciA9IGRhdGE7XG4gICAgZGF0YSA9IGRhdGEudXRmOFNsaWNlKDAsIGRhdGEubGVuZ3RoKS50cmltKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IGRhdGEudHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0tleSBkYXRhIG11c3QgYmUgYSBCdWZmZXIgb3Igc3RyaW5nJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gIGlmIChwYXNzcGhyYXNlICE9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcGFzc3BocmFzZSA9PT0gJ3N0cmluZycpXG4gICAgICBwYXNzcGhyYXNlID0gQnVmZmVyLmZyb20ocGFzc3BocmFzZSk7XG4gICAgZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzcGhyYXNlKSlcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1Bhc3NwaHJhc2UgbXVzdCBiZSBhIHN0cmluZyBvciBCdWZmZXIgd2hlbiBzdXBwbGllZCcpO1xuICB9XG5cbiAgbGV0IHJldDtcblxuICAvLyBGaXJzdCB0cnkgYXMgcHJpbnRhYmxlIHN0cmluZyBmb3JtYXQgKGUuZy4gUEVNKVxuXG4gIC8vIFByaXZhdGUga2V5c1xuICBpZiAoKHJldCA9IE9wZW5TU0hfUHJpdmF0ZS5wYXJzZShkYXRhLCBwYXNzcGhyYXNlKSkgIT09IG51bGwpXG4gICAgcmV0dXJuIHJldDtcbiAgaWYgKChyZXQgPSBPcGVuU1NIX09sZF9Qcml2YXRlLnBhcnNlKGRhdGEsIHBhc3NwaHJhc2UpKSAhPT0gbnVsbClcbiAgICByZXR1cm4gcmV0O1xuICBpZiAoKHJldCA9IFBQS19Qcml2YXRlLnBhcnNlKGRhdGEsIHBhc3NwaHJhc2UpKSAhPT0gbnVsbClcbiAgICByZXR1cm4gcmV0O1xuXG4gIC8vIFB1YmxpYyBrZXlzXG4gIGlmICgocmV0ID0gT3BlblNTSF9QdWJsaWMucGFyc2UoZGF0YSkpICE9PSBudWxsKVxuICAgIHJldHVybiByZXQ7XG4gIGlmICgocmV0ID0gUkZDNDcxNl9QdWJsaWMucGFyc2UoZGF0YSkpICE9PSBudWxsKVxuICAgIHJldHVybiByZXQ7XG5cbiAgLy8gRmluYWxseSB0cnkgYXMgYSBiaW5hcnkgZm9ybWF0IGlmIHdlIHdlcmUgb3JpZ2luYWxseSBwYXNzZWQgYmluYXJ5IGRhdGFcbiAgaWYgKG9yaWdCdWZmZXIpIHtcbiAgICBiaW5hcnlLZXlQYXJzZXIuaW5pdChvcmlnQnVmZmVyLCAwKTtcbiAgICBjb25zdCB0eXBlID0gYmluYXJ5S2V5UGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGF0YSA9IGJpbmFyeUtleVBhcnNlci5yZWFkUmF3KCk7XG4gICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldCA9IHBhcnNlREVSKGRhdGEsIHR5cGUsICcnLCB0eXBlKTtcbiAgICAgICAgLy8gSWdub3JlIHBvdGVudGlhbGx5IHVzZWxlc3MgZXJyb3JzIGluIGNhc2UgdGhlIGRhdGEgd2FzIG5vdCBhY3R1YWxseVxuICAgICAgICAvLyBpbiB0aGUgYmluYXJ5IGZvcm1hdFxuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgICAgcmV0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgYmluYXJ5S2V5UGFyc2VyLmNsZWFyKCk7XG4gIH1cblxuICBpZiAocmV0KVxuICAgIHJldHVybiByZXQ7XG5cbiAgcmV0dXJuIG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2V5IGZvcm1hdCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNQYXJzZWRLZXksXG4gIGlzU3VwcG9ydGVkS2V5VHlwZSxcbiAgcGFyc2VERVJLZXk6IChkYXRhLCB0eXBlKSA9PiBwYXJzZURFUihkYXRhLCB0eXBlLCAnJywgdHlwZSksXG4gIHBhcnNlS2V5LFxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgU29ja2V0IH0gPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcmVzb2x2ZSB9ID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgeyByZWFkRmlsZSB9ID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgZXhlY0ZpbGUsIHNwYXduIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG5cbmNvbnN0IHsgaXNQYXJzZWRLZXksIHBhcnNlS2V5IH0gPSByZXF1aXJlKCcuL3Byb3RvY29sL2tleVBhcnNlci5qcycpO1xuXG5jb25zdCB7XG4gIG1ha2VCdWZmZXJQYXJzZXIsXG4gIHJlYWRVSW50MzJCRSxcbiAgd3JpdGVVSW50MzJCRSxcbiAgd3JpdGVVSW50MzJMRSxcbn0gPSByZXF1aXJlKCcuL3Byb3RvY29sL3V0aWxzLmpzJyk7XG5cbmZ1bmN0aW9uIG9uY2UoY2IpIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoY2FsbGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgY2IoLi4uYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbmNhdChidWYxLCBidWYyKSB7XG4gIGNvbnN0IGNvbWJpbmVkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1ZjEubGVuZ3RoICsgYnVmMi5sZW5ndGgpO1xuICBidWYxLmNvcHkoY29tYmluZWQsIDApO1xuICBidWYyLmNvcHkoY29tYmluZWQsIGJ1ZjEubGVuZ3RoKTtcbiAgcmV0dXJuIGNvbWJpbmVkO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuY29uc3QgRU1QVFlfQlVGID0gQnVmZmVyLmFsbG9jKDApO1xuXG5jb25zdCBiaW5hcnlQYXJzZXIgPSBtYWtlQnVmZmVyUGFyc2VyKCk7XG5cbmNsYXNzIEJhc2VBZ2VudCB7XG4gIGdldElkZW50aXRpZXMoY2IpIHtcbiAgICBjYihuZXcgRXJyb3IoJ01pc3NpbmcgZ2V0SWRlbnRpdGllcygpIGltcGxlbWVudGF0aW9uJykpO1xuICB9XG4gIHNpZ24ocHViS2V5LCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICBjYihuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbigpIGltcGxlbWVudGF0aW9uJykpO1xuICB9XG59XG5cbmNsYXNzIE9wZW5TU0hBZ2VudCBleHRlbmRzIEJhc2VBZ2VudCB7XG4gIGNvbnN0cnVjdG9yKHNvY2tldFBhdGgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc29ja2V0UGF0aCA9IHNvY2tldFBhdGg7XG4gIH1cblxuICBnZXRTdHJlYW0oY2IpIHtcbiAgICBjYiA9IG9uY2UoY2IpO1xuICAgIGNvbnN0IHNvY2sgPSBuZXcgU29ja2V0KCk7XG4gICAgc29jay5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGNiKG51bGwsIHNvY2spO1xuICAgIH0pO1xuICAgIHNvY2sub24oJ2Nsb3NlJywgb25GYWlsKVxuICAgICAgICAub24oJ2VuZCcsIG9uRmFpbClcbiAgICAgICAgLm9uKCdlcnJvcicsIG9uRmFpbCk7XG4gICAgc29jay5jb25uZWN0KHRoaXMuc29ja2V0UGF0aCk7XG5cbiAgICBmdW5jdGlvbiBvbkZhaWwoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzb2NrLmRlc3Ryb3koKTtcbiAgICAgIH0gY2F0Y2gge31cblxuICAgICAgY2IobmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCB0byBhZ2VudCcpKTtcbiAgICB9XG4gIH1cblxuICBnZXRJZGVudGl0aWVzKGNiKSB7XG4gICAgY2IgPSBvbmNlKGNiKTtcbiAgICB0aGlzLmdldFN0cmVhbSgoZXJyLCBzdHJlYW0pID0+IHtcbiAgICAgIGZ1bmN0aW9uIG9uRmFpbChlcnIpIHtcbiAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVycilcbiAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXRyaWV2ZSBpZGVudGl0aWVzIGZyb20gYWdlbnQnKTtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycilcbiAgICAgICAgcmV0dXJuIG9uRmFpbChlcnIpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IG5ldyBBZ2VudFByb3RvY29sKHRydWUpO1xuICAgICAgcHJvdG9jb2wub24oJ2Vycm9yJywgb25GYWlsKTtcbiAgICAgIHByb3RvY29sLnBpcGUoc3RyZWFtKS5waXBlKHByb3RvY29sKTtcblxuICAgICAgc3RyZWFtLm9uKCdjbG9zZScsIG9uRmFpbClcbiAgICAgICAgICAgIC5vbignZW5kJywgb25GYWlsKVxuICAgICAgICAgICAgLm9uKCdlcnJvcicsIG9uRmFpbCk7XG5cbiAgICAgIHByb3RvY29sLmdldElkZW50aXRpZXMoKGVyciwga2V5cykgPT4ge1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgIHJldHVybiBvbkZhaWwoZXJyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgIGNiKG51bGwsIGtleXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzaWduKHB1YktleSwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjYiA9IG9uY2UoY2IpO1xuICAgIHRoaXMuZ2V0U3RyZWFtKChlcnIsIHN0cmVhbSkgPT4ge1xuICAgICAgZnVuY3Rpb24gb25GYWlsKGVycikge1xuICAgICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICB9XG4gICAgICAgIGlmICghZXJyKVxuICAgICAgICAgIGVyciA9IG5ldyBFcnJvcignRmFpbGVkIHRvIHNpZ24gZGF0YSB3aXRoIGFnZW50Jyk7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIpXG4gICAgICAgIHJldHVybiBvbkZhaWwoZXJyKTtcblxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBuZXcgQWdlbnRQcm90b2NvbCh0cnVlKTtcbiAgICAgIHByb3RvY29sLm9uKCdlcnJvcicsIG9uRmFpbCk7XG4gICAgICBwcm90b2NvbC5waXBlKHN0cmVhbSkucGlwZShwcm90b2NvbCk7XG5cbiAgICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbkZhaWwpXG4gICAgICAgICAgICAub24oJ2VuZCcsIG9uRmFpbClcbiAgICAgICAgICAgIC5vbignZXJyb3InLCBvbkZhaWwpO1xuXG4gICAgICBwcm90b2NvbC5zaWduKHB1YktleSwgZGF0YSwgb3B0aW9ucywgKGVyciwgc2lnKSA9PiB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgcmV0dXJuIG9uRmFpbChlcnIpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfSBjYXRjaCB7fVxuXG4gICAgICAgIGNiKG51bGwsIHNpZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBQYWdlYW50QWdlbnQgPSAoKCkgPT4ge1xuICBjb25zdCBSRVRfRVJSX0JBREFSR1MgPSAxMDtcbiAgY29uc3QgUkVUX0VSUl9VTkFWQUlMQUJMRSA9IDExO1xuICBjb25zdCBSRVRfRVJSX05PTUFQID0gMTI7XG4gIGNvbnN0IFJFVF9FUlJfQklOU1RESU4gPSAxMztcbiAgY29uc3QgUkVUX0VSUl9CSU5TVERPVVQgPSAxNDtcbiAgY29uc3QgUkVUX0VSUl9CQURMRU4gPSAxNTtcblxuICBjb25zdCBFWEVQQVRIID0gcmVzb2x2ZShfX2Rpcm5hbWUsICcuLicsICd1dGlsL3BhZ2VudC5leGUnKTtcbiAgY29uc3QgRVJST1IgPSB7XG4gICAgW1JFVF9FUlJfQkFEQVJHU106IG5ldyBFcnJvcignSW52YWxpZCBwYWdlbnQuZXhlIGFyZ3VtZW50cycpLFxuICAgIFtSRVRfRVJSX1VOQVZBSUxBQkxFXTogbmV3IEVycm9yKCdQYWdlYW50IGlzIG5vdCBydW5uaW5nJyksXG4gICAgW1JFVF9FUlJfTk9NQVBdOiBuZXcgRXJyb3IoJ3BhZ2VudC5leGUgY291bGQgbm90IGNyZWF0ZSBhbiBtbWFwJyksXG4gICAgW1JFVF9FUlJfQklOU1RESU5dOiBuZXcgRXJyb3IoJ3BhZ2VudC5leGUgY291bGQgbm90IHNldCBtb2RlIGZvciBzdGRpbicpLFxuICAgIFtSRVRfRVJSX0JJTlNURE9VVF06IG5ldyBFcnJvcigncGFnZW50LmV4ZSBjb3VsZCBub3Qgc2V0IG1vZGUgZm9yIHN0ZG91dCcpLFxuICAgIFtSRVRfRVJSX0JBRExFTl06XG4gICAgICBuZXcgRXJyb3IoJ3BhZ2VudC5leGUgZGlkIG5vdCBnZXQgZXhwZWN0ZWQgaW5wdXQgcGF5bG9hZCcpLFxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koc3RyZWFtKSB7XG4gICAgc3RyZWFtLmJ1ZmZlciA9IG51bGw7XG4gICAgaWYgKHN0cmVhbS5wcm9jKSB7XG4gICAgICBzdHJlYW0ucHJvYy5raWxsKCk7XG4gICAgICBzdHJlYW0ucHJvYyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBQYWdlYW50U29ja2V0IGV4dGVuZHMgRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnByb2MgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgfVxuICAgIF9yZWFkKG4pIHt9XG4gICAgX3dyaXRlKGRhdGEsIGVuY29kaW5nLCBjYikge1xuICAgICAgaWYgKHRoaXMuYnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld0J1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLmJ1ZmZlci5sZW5ndGggKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmNvcHkobmV3QnVmZmVyLCAwKTtcbiAgICAgICAgZGF0YS5jb3B5KG5ld0J1ZmZlciwgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgICB9XG4gICAgICAvLyBXYWl0IGZvciBhdCBsZWFzdCBhbGwgbGVuZ3RoIGJ5dGVzXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgNClcbiAgICAgICAgcmV0dXJuIGNiKCk7XG5cbiAgICAgIGNvbnN0IGxlbiA9IHJlYWRVSW50MzJCRSh0aGlzLmJ1ZmZlciwgMCk7XG4gICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGZ1bGwgbWVzc2FnZSBiZWZvcmUgcXVlcnlpbmcgcGFnZWFudFxuICAgICAgaWYgKCh0aGlzLmJ1ZmZlci5sZW5ndGggLSA0KSA8IGxlbilcbiAgICAgICAgcmV0dXJuIGNiKCk7XG5cbiAgICAgIGRhdGEgPSB0aGlzLmJ1ZmZlci5zbGljZSgwLCA0ICsgbGVuKTtcbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAoNCArIGxlbikpXG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgbXVsdGlwbGUgYWdlbnQgcmVxdWVzdHMnKSk7XG4gICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG5cbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIGNvbnN0IHByb2MgPSB0aGlzLnByb2MgPSBzcGF3bihFWEVQQVRILCBbIGRhdGEubGVuZ3RoIF0pO1xuICAgICAgcHJvYy5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHByb2Mub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICBwcm9jLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XG4gICAgICAgIHRoaXMucHJvYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvciA9IEVSUk9SW2NvZGVdKVxuICAgICAgICAgICAgcmV0dXJuIGNiKGVycm9yKTtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHByb2Muc3RkaW4uZW5kKGRhdGEpO1xuICAgIH1cbiAgICBfZmluYWwoY2IpIHtcbiAgICAgIGRlc3Ryb3kodGhpcyk7XG4gICAgICBjYigpO1xuICAgIH1cbiAgICBfZGVzdHJveShlcnIsIGNiKSB7XG4gICAgICBkZXN0cm95KHRoaXMpO1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xhc3MgUGFnZWFudEFnZW50IGV4dGVuZHMgT3BlblNTSEFnZW50IHtcbiAgICBnZXRTdHJlYW0oY2IpIHtcbiAgICAgIGNiKG51bGwsIG5ldyBQYWdlYW50U29ja2V0KCkpO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbmNvbnN0IEN5Z3dpbkFnZW50ID0gKCgpID0+IHtcbiAgY29uc3QgUkVfQ1lHV0lOX1NPQ0sgPSAvXiE8c29ja2V0ID4oXFxkKykgcyAoW0EtWjAtOV17OH0tW0EtWjAtOV17OH0tW0EtWjAtOV17OH0tW0EtWjAtOV17OH0pLztcblxuICByZXR1cm4gY2xhc3MgQ3lnd2luQWdlbnQgZXh0ZW5kcyBPcGVuU1NIQWdlbnQge1xuICAgIGdldFN0cmVhbShjYikge1xuICAgICAgY2IgPSBvbmNlKGNiKTtcblxuICAgICAgLy8gVGhlIGN5Z3dpbiBzc2gtYWdlbnQgY29ubmVjdGlvbiBwcm9jZXNzIGxvb2tzIGxpa2UgdGhpczpcbiAgICAgIC8vICAgMS4gUmVhZCB0aGUgXCJzb2NrZXRcIiBhcyBhIGZpbGUgdG8gZ2V0IHRoZSB1bmRlcmx5aW5nIFRDUCBwb3J0IGFuZCBhXG4gICAgICAvLyAgICAgIHNwZWNpYWwgXCJzZWNyZXRcIiB0aGF0IG11c3QgYmUgc2VudCB0byB0aGUgVENQIHNlcnZlci5cbiAgICAgIC8vICAgMi4gQ29ubmVjdCB0byB0aGUgc2VydmVyIGxpc3RlbmluZyBvbiBsb2NhbGhvc3QgYXQgdGhlIFRDUCBwb3J0LlxuICAgICAgLy8gICAzLiBTZW5kIHRoZSBcInNlY3JldFwiIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICAvLyAgIDQuIFRoZSBzZXJ2ZXIgc2VuZHMgYmFjayB0aGUgc2FtZSBcInNlY3JldFwiLlxuICAgICAgLy8gICA1LiBTZW5kIHRocmVlIDMyLWJpdCBpbnRlZ2VyIHZhbHVlcyBvZiB6ZXJvLiBUaGlzIGlzIG9yZGluYXJpbHkgdGhlXG4gICAgICAvLyAgICAgIHBpZCwgdWlkLCBhbmQgZ2lkIG9mIHRoaXMgcHJvY2VzcywgYnV0IGN5Z3dpbiB3aWxsIGFjdHVhbGx5XG4gICAgICAvLyAgICAgIHNlbmQgdXMgdGhlIGNvcnJlY3QgdmFsdWVzIGFzIGEgcmVzcG9uc2UuXG4gICAgICAvLyAgIDYuIFRoZSBzZXJ2ZXIgc2VuZHMgYmFjayB0aGUgcGlkLCB1aWQsIGdpZC5cbiAgICAgIC8vICAgNy4gRGlzY29ubmVjdC5cbiAgICAgIC8vICAgOC4gUmVwZWF0IHN0ZXBzIDItNiwgZXhjZXB0IHNlbmQgdGhlIHJlY2VpdmVkIHBpZCwgdWlkLCBhbmQgZ2lkIGluXG4gICAgICAvLyAgICAgIHN0ZXAgNSBpbnN0ZWFkIG9mIHplcm9lcy5cbiAgICAgIC8vICAgOS4gQ29ubmVjdGlvbiBpcyByZWFkeSB0byBiZSB1c2VkLlxuXG4gICAgICBsZXQgc29ja2V0UGF0aCA9IHRoaXMuc29ja2V0UGF0aDtcbiAgICAgIGxldCB0cmllZEN5Z3BhdGggPSBmYWxzZTtcbiAgICAgIHJlYWRGaWxlKHNvY2tldFBhdGgsIGZ1bmN0aW9uIHJlYWRDeWdzb2NrZXQoZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAodHJpZWRDeWdwYXRoKVxuICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignSW52YWxpZCBjeWd3aW4gdW5peCBzb2NrZXQgcGF0aCcpKTtcblxuICAgICAgICAgIC8vIFRyeSB1c2luZyBgY3lncGF0aGAgdG8gY29udmVydCBhIHBvc3NpYmxlICpuaXgtc3R5bGUgcGF0aCB0byB0aGVcbiAgICAgICAgICAvLyByZWFsIFdpbmRvd3MgcGF0aCBiZWZvcmUgZ2l2aW5nIHVwIC4uLlxuICAgICAgICAgIGV4ZWNGaWxlKCdjeWdwYXRoJywgWyctdycsIHNvY2tldFBhdGhdLCAoZXJyLCBzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVyciB8fCBzdGRvdXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdJbnZhbGlkIGN5Z3dpbiB1bml4IHNvY2tldCBwYXRoJykpO1xuXG4gICAgICAgICAgICB0cmllZEN5Z3BhdGggPSB0cnVlO1xuICAgICAgICAgICAgc29ja2V0UGF0aCA9IHN0ZG91dC50b1N0cmluZygpLnJlcGxhY2UoL1tcXHJcXG5dL2csICcnKTtcbiAgICAgICAgICAgIHJlYWRGaWxlKHNvY2tldFBhdGgsIHJlYWRDeWdzb2NrZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG0gPSBSRV9DWUdXSU5fU09DSy5leGVjKGRhdGEudG9TdHJpbmcoJ2FzY2lpJykpO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignTWFsZm9ybWVkIGN5Z3dpbiB1bml4IHNvY2tldCBmaWxlJykpO1xuXG4gICAgICAgIGxldCBzdGF0ZTtcbiAgICAgICAgbGV0IGJjID0gMDtcbiAgICAgICAgbGV0IGlzUmV0cnlpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaW5CdWYgPSBbXTtcbiAgICAgICAgbGV0IHNvY2s7XG5cbiAgICAgICAgLy8gVXNlIDAgZm9yIHBpZCwgdWlkLCBhbmQgZ2lkIHRvIGVuc3VyZSB3ZSBnZXQgYW4gZXJyb3IgYW5kIGFsc29cbiAgICAgICAgLy8gYSB2YWxpZCB1aWQgYW5kIGdpZCBmcm9tIGN5Z3dpbiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gZmlndXJlIGl0XG4gICAgICAgIC8vIG91dCBvdXJzZWx2ZXNcbiAgICAgICAgbGV0IGNyZWRzQnVmID0gQnVmZmVyLmFsbG9jKDEyKTtcblxuICAgICAgICAvLyBQYXJzZSBjeWd3aW4gdW5peCBzb2NrZXQgZmlsZSBjb250ZW50c1xuICAgICAgICBjb25zdCBwb3J0ID0gcGFyc2VJbnQobVsxXSwgMTApO1xuICAgICAgICBjb25zdCBzZWNyZXQgPSBtWzJdLnJlcGxhY2UoLy0vZywgJycpO1xuICAgICAgICBjb25zdCBzZWNyZXRCdWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGogPCAzMjsgKytpLCBqICs9IDIpXG4gICAgICAgICAgc2VjcmV0QnVmW2ldID0gcGFyc2VJbnQoc2VjcmV0LnN1YnN0cmluZyhqLCBqICsgMiksIDE2KTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRvIGhvc3Qgb3JkZXIgKGFsd2F5cyBMRSBmb3IgV2luZG93cylcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSArPSA0KVxuICAgICAgICAgIHdyaXRlVUludDMyTEUoc2VjcmV0QnVmLCByZWFkVUludDMyQkUoc2VjcmV0QnVmLCBpKSwgaSk7XG5cbiAgICAgICAgdHJ5Q29ubmVjdCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9vbmNvbm5lY3QoKSB7XG4gICAgICAgICAgYmMgPSAwO1xuICAgICAgICAgIHN0YXRlID0gJ3NlY3JldCc7XG4gICAgICAgICAgc29jay53cml0ZShzZWNyZXRCdWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX29uZGF0YShkYXRhKSB7XG4gICAgICAgICAgYmMgKz0gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoc3RhdGUgPT09ICdzZWNyZXQnKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2VjcmV0IHdlIHNlbnQgaXMgZWNob2VkIGJhY2sgdG8gdXMgYnkgY3lnd2luLCBub3Qgc3VyZSBvZlxuICAgICAgICAgICAgLy8gdGhlIHJlYXNvbiBmb3IgdGhhdCwgYnV0IHdlIGlnbm9yZSBpdCBub25ldGhlbGVzcyAuLi5cbiAgICAgICAgICAgIGlmIChiYyA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgYmMgPSAwO1xuICAgICAgICAgICAgICBzdGF0ZSA9ICdjcmVkcyc7XG4gICAgICAgICAgICAgIHNvY2sud3JpdGUoY3JlZHNCdWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2NyZWRzJykge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgYXR0ZW1wdCwgbWFrZSBzdXJlIHRvIGdhdGhlciB0aGUgdmFsaWRcbiAgICAgICAgICAgIC8vIHVpZCBhbmQgZ2lkIGZvciBvdXIgbmV4dCBhdHRlbXB0XG4gICAgICAgICAgICBpZiAoIWlzUmV0cnlpbmcpXG4gICAgICAgICAgICAgIGluQnVmLnB1c2goZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChiYyA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgc29jay5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIF9vbmNvbm5lY3QpO1xuICAgICAgICAgICAgICBzb2NrLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgX29uZGF0YSk7XG4gICAgICAgICAgICAgIHNvY2sucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25GYWlsKTtcbiAgICAgICAgICAgICAgc29jay5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25GYWlsKTtcbiAgICAgICAgICAgICAgc29jay5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkZhaWwpO1xuXG4gICAgICAgICAgICAgIGlmIChpc1JldHJ5aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBzb2NrKTtcblxuICAgICAgICAgICAgICBpc1JldHJ5aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3JlZHNCdWYgPSBCdWZmZXIuY29uY2F0KGluQnVmKTtcbiAgICAgICAgICAgICAgd3JpdGVVSW50MzJMRShjcmVkc0J1ZiwgcHJvY2Vzcy5waWQsIDApO1xuICAgICAgICAgICAgICBzb2NrLm9uKCdlcnJvcicsICgpID0+IHt9KTtcbiAgICAgICAgICAgICAgc29jay5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgICAgdHJ5Q29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uRmFpbCgpIHtcbiAgICAgICAgICBjYihuZXcgRXJyb3IoJ1Byb2JsZW0gbmVnb3RpYXRpbmcgY3lnd2luIHVuaXggc29ja2V0IHNlY3VyaXR5JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdHJ5Q29ubmVjdCgpIHtcbiAgICAgICAgICBzb2NrID0gbmV3IFNvY2tldCgpO1xuICAgICAgICAgIHNvY2sub24oJ2Nvbm5lY3QnLCBfb25jb25uZWN0KTtcbiAgICAgICAgICBzb2NrLm9uKCdkYXRhJywgX29uZGF0YSk7XG4gICAgICAgICAgc29jay5vbignZXJyb3InLCBvbkZhaWwpO1xuICAgICAgICAgIHNvY2sub24oJ2VuZCcsIG9uRmFpbCk7XG4gICAgICAgICAgc29jay5vbignY2xvc2UnLCBvbkZhaWwpO1xuICAgICAgICAgIHNvY2suY29ubmVjdChwb3J0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSkoKTtcblxuLy8gRm9ybWF0IG9mIGAvLy4vcGlwZS9BTllUSElOR2AsIHdpdGggZm9yd2FyZCBzbGFzaGVzIGFuZCBiYWNrd2FyZCBzbGFzaGVzXG4vLyBiZWluZyBpbnRlcmNoYW5nZWFibGVcbmNvbnN0IFdJTkRPV1NfUElQRV9SRUdFWCA9IC9eWy9cXFxcXVsvXFxcXF1cXC5bL1xcXFxdcGlwZVsvXFxcXF0uKy87XG5mdW5jdGlvbiBjcmVhdGVBZ2VudChwYXRoKSB7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmICFXSU5ET1dTX1BJUEVfUkVHRVgudGVzdChwYXRoKSkge1xuICAgIHJldHVybiAocGF0aCA9PT0gJ3BhZ2VhbnQnXG4gICAgICAgICAgICA/IG5ldyBQYWdlYW50QWdlbnQoKVxuICAgICAgICAgICAgOiBuZXcgQ3lnd2luQWdlbnQocGF0aCkpO1xuICB9XG4gIHJldHVybiBuZXcgT3BlblNTSEFnZW50KHBhdGgpO1xufVxuXG5jb25zdCBBZ2VudFByb3RvY29sID0gKCgpID0+IHtcbiAgLy8gQ2xpZW50LT5TZXJ2ZXIgbWVzc2FnZXNcbiAgY29uc3QgU1NIX0FHRU5UQ19SRVFVRVNUX0lERU5USVRJRVMgPSAxMTtcbiAgY29uc3QgU1NIX0FHRU5UQ19TSUdOX1JFUVVFU1QgPSAxMztcbiAgLy8gY29uc3QgU1NIX0FHRU5UQ19BRERfSURFTlRJVFkgPSAxNztcbiAgLy8gY29uc3QgU1NIX0FHRU5UQ19SRU1PVkVfSURFTlRJVFkgPSAxODtcbiAgLy8gY29uc3QgU1NIX0FHRU5UQ19SRU1PVkVfQUxMX0lERU5USVRJRVMgPSAxOTtcbiAgLy8gY29uc3QgU1NIX0FHRU5UQ19BRERfU01BUlRDQVJEX0tFWSA9IDIwO1xuICAvLyBjb25zdCBTU0hfQUdFTlRDX1JFTU9WRV9TTUFSVENBUkRfS0VZID0gMjE7XG4gIC8vIGNvbnN0IFNTSF9BR0VOVENfTE9DSyA9IDIyO1xuICAvLyBjb25zdCBTU0hfQUdFTlRDX1VOTE9DSyA9IDIzO1xuICAvLyBjb25zdCBTU0hfQUdFTlRDX0FERF9JRF9DT05TVFJBSU5FRCA9IDI1O1xuICAvLyBjb25zdCBTU0hfQUdFTlRDX0FERF9TTUFSVENBUkRfS0VZX0NPTlNUUkFJTkVEID0gMjY7XG4gIC8vIGNvbnN0IFNTSF9BR0VOVENfRVhURU5TSU9OID0gMjc7XG4gIC8vIFNlcnZlci0+Q2xpZW50IG1lc3NhZ2VzXG4gIGNvbnN0IFNTSF9BR0VOVF9GQUlMVVJFID0gNTtcbiAgLy8gY29uc3QgU1NIX0FHRU5UX1NVQ0NFU1MgPSA2O1xuICBjb25zdCBTU0hfQUdFTlRfSURFTlRJVElFU19BTlNXRVIgPSAxMjtcbiAgY29uc3QgU1NIX0FHRU5UX1NJR05fUkVTUE9OU0UgPSAxNDtcbiAgLy8gY29uc3QgU1NIX0FHRU5UX0VYVEVOU0lPTl9GQUlMVVJFID0gMjg7XG5cbiAgLy8gY29uc3QgU1NIX0FHRU5UX0NPTlNUUkFJTl9MSUZFVElNRSA9IDE7XG4gIC8vIGNvbnN0IFNTSF9BR0VOVF9DT05TVFJBSU5fQ09ORklSTSA9IDI7XG4gIC8vIGNvbnN0IFNTSF9BR0VOVF9DT05TVFJBSU5fRVhURU5TSU9OID0gMjU1O1xuXG4gIGNvbnN0IFNTSF9BR0VOVF9SU0FfU0hBMl8yNTYgPSAoMSA8PCAxKTtcbiAgY29uc3QgU1NIX0FHRU5UX1JTQV9TSEEyXzUxMiA9ICgxIDw8IDIpO1xuXG4gIGNvbnN0IFJPTEVfQ0xJRU5UID0gMDtcbiAgY29uc3QgUk9MRV9TRVJWRVIgPSAxO1xuXG4gIC8vIEVuc3VyZXMgdGhhdCByZXNwb25zZXMgZ2V0IHNlbnQgYmFjayBpbiB0aGUgc2FtZSBvcmRlciB0aGUgcmVxdWVzdHMgd2VyZVxuICAvLyByZWNlaXZlZFxuICBmdW5jdGlvbiBwcm9jZXNzUmVzcG9uc2VzKHByb3RvY29sKSB7XG4gICAgbGV0IHJldDtcbiAgICB3aGlsZSAocHJvdG9jb2xbU1lNX1JFUVNdLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV4dFJlc3BvbnNlID0gcHJvdG9jb2xbU1lNX1JFUVNdWzBdW1NZTV9SRVNQXTtcbiAgICAgIGlmIChuZXh0UmVzcG9uc2UgPT09IHVuZGVmaW5lZClcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIHByb3RvY29sW1NZTV9SRVFTXS5zaGlmdCgpO1xuICAgICAgcmV0ID0gcHJvdG9jb2wucHVzaChuZXh0UmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgY29uc3QgU1lNX1RZUEUgPSBTeW1ib2woJ0luYm91bmQgUmVxdWVzdCBUeXBlJyk7XG4gIGNvbnN0IFNZTV9SRVNQID0gU3ltYm9sKCdJbmJvdW5kIFJlcXVlc3QgUmVzcG9uc2UnKTtcbiAgY29uc3QgU1lNX0NUWCA9IFN5bWJvbCgnSW5ib3VuZCBSZXF1ZXN0IENvbnRleHQnKTtcbiAgY2xhc3MgQWdlbnRJbmJvdW5kUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgY3R4KSB7XG4gICAgICB0aGlzW1NZTV9UWVBFXSA9IHR5cGU7XG4gICAgICB0aGlzW1NZTV9SRVNQXSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXNbU1lNX0NUWF0gPSBjdHg7XG4gICAgfVxuICAgIGhhc1Jlc3BvbmRlZCgpIHtcbiAgICAgIHJldHVybiAodGhpc1tTWU1fUkVTUF0gIT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGdldFR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpc1tTWU1fVFlQRV07XG4gICAgfVxuICAgIGdldENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tTWU1fQ1RYXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzcG9uZChwcm90b2NvbCwgcmVxLCBkYXRhKSB7XG4gICAgcmVxW1NZTV9SRVNQXSA9IGRhdGE7XG4gICAgcmV0dXJuIHByb2Nlc3NSZXNwb25zZXMocHJvdG9jb2wpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cChwcm90b2NvbCkge1xuICAgIHByb3RvY29sW1NZTV9CVUZGRVJdID0gbnVsbDtcbiAgICBpZiAocHJvdG9jb2xbU1lNX01PREVdID09PSBST0xFX0NMSUVOVCkge1xuICAgICAgY29uc3QgcmVxcyA9IHByb3RvY29sW1NZTV9SRVFTXTtcbiAgICAgIGlmIChyZXFzICYmIHJlcXMubGVuZ3RoKSB7XG4gICAgICAgIHByb3RvY29sW1NZTV9SRVFTXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlcSBvZiByZXFzKVxuICAgICAgICAgIHJlcS5jYihuZXcgRXJyb3IoJ05vIHJlcGx5IGZyb20gc2VydmVyJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vZGUgc3RyZWFtcyBoYWNrZXJ5IHRvIG1ha2Ugc3RyZWFtcyBkbyB0aGUgXCJyaWdodCB0aGluZ1wiXG4gICAgdHJ5IHtcbiAgICAgIHByb3RvY29sLmVuZCgpO1xuICAgIH0gY2F0Y2gge31cbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgaWYgKCFwcm90b2NvbFtTWU1fRU5ERURdKVxuICAgICAgICBwcm90b2NvbC5lbWl0KCdlbmQnKTtcbiAgICAgIGlmICghcHJvdG9jb2xbU1lNX0NMT1NFRF0pXG4gICAgICAgIHByb3RvY29sLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNsb3NlKCkge1xuICAgIHRoaXNbU1lNX0NMT1NFRF0gPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgdGhpc1tTWU1fRU5ERURdID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IFNZTV9SRVFTID0gU3ltYm9sKCdSZXF1ZXN0cycpO1xuICBjb25zdCBTWU1fTU9ERSA9IFN5bWJvbCgnQWdlbnQgUHJvdG9jb2wgUm9sZScpO1xuICBjb25zdCBTWU1fQlVGRkVSID0gU3ltYm9sKCdBZ2VudCBQcm90b2NvbCBCdWZmZXInKTtcbiAgY29uc3QgU1lNX01TR0xFTiA9IFN5bWJvbCgnQWdlbnQgUHJvdG9jb2wgQ3VycmVudCBNZXNzYWdlIExlbmd0aCcpO1xuICBjb25zdCBTWU1fQ0xPU0VEID0gU3ltYm9sKCdBZ2VudCBQcm90b2NvbCBDbG9zZWQnKTtcbiAgY29uc3QgU1lNX0VOREVEID0gU3ltYm9sKCdBZ2VudCBQcm90b2NvbCBFbmRlZCcpO1xuICAvLyBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbjpcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW1pbGxlci1zc2gtYWdlbnQtMDRcbiAgcmV0dXJuIGNsYXNzIEFnZW50UHJvdG9jb2wgZXh0ZW5kcyBEdXBsZXgge1xuICAgIC8qXG4gICAgICAgIE5vdGVzOlxuICAgICAgICAgIC0gYGNvbnN0cmFpbnRgIHR5cGUgY29uc2lzdHMgb2Y6XG4gICAgICAgICAgICAgICBieXRlICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50X3R5cGVcbiAgICAgICAgICAgICAgIGJ5dGVbXSAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRfZGF0YVxuICAgICAgICAgICAgd2hlcmUgYGNvbnN0cmFpbnRfdHlwZWAgaXMgb25lIG9mOlxuICAgICAgICAgICAgICAqIFNTSF9BR0VOVF9DT05TVFJBSU5fTElGRVRJTUVcbiAgICAgICAgICAgICAgICAtIGBjb25zdHJhaW50X2RhdGFgIGNvbnNpc3RzIG9mOlxuICAgICAgICAgICAgICAgICAgICAgdWludDMyICAgICAgICAgICAgICAgICAgc2Vjb25kc1xuICAgICAgICAgICAgICAqIFNTSF9BR0VOVF9DT05TVFJBSU5fQ09ORklSTVxuICAgICAgICAgICAgICAgIC0gYGNvbnN0cmFpbnRfZGF0YWAgTi9BXG4gICAgICAgICAgICAgICogU1NIX0FHRU5UX0NPTlNUUkFJTl9FWFRFTlNJT05cbiAgICAgICAgICAgICAgICAtIGBjb25zdHJhaW50X2RhdGFgIGNvbnNpc3RzIG9mOlxuICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgIGJ5dGVbXSAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbi1zcGVjaWZpYyBkZXRhaWxzXG4gICAgKi9cblxuICAgIGNvbnN0cnVjdG9yKGlzQ2xpZW50KSB7XG4gICAgICBzdXBlcih7IGF1dG9EZXN0cm95OiB0cnVlLCBlbWl0Q2xvc2U6IGZhbHNlIH0pO1xuICAgICAgdGhpc1tTWU1fTU9ERV0gPSAoaXNDbGllbnQgPyBST0xFX0NMSUVOVCA6IFJPTEVfU0VSVkVSKTtcbiAgICAgIHRoaXNbU1lNX1JFUVNdID0gW107XG4gICAgICB0aGlzW1NZTV9CVUZGRVJdID0gbnVsbDtcbiAgICAgIHRoaXNbU1lNX01TR0xFTl0gPSAtMTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25FbmQpO1xuICAgICAgdGhpcy5vbmNlKCdjbG9zZScsIG9uQ2xvc2UpO1xuICAgIH1cblxuICAgIF9yZWFkKG4pIHt9XG5cbiAgICBfd3JpdGUoZGF0YSwgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAvKlxuICAgICAgICAgIE1lc3NhZ2VzIGFyZSBvZiB0aGUgZm9ybWF0OlxuICAgICAgICAgICAgdWludDMyICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIGxlbmd0aFxuICAgICAgICAgICAgYnl0ZSAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIHR5cGVcbiAgICAgICAgICAgIGJ5dGVbbWVzc2FnZSBsZW5ndGggLSAxXSAgbWVzc2FnZSBjb250ZW50c1xuICAgICAgKi9cbiAgICAgIGlmICh0aGlzW1NZTV9CVUZGRVJdID09PSBudWxsKVxuICAgICAgICB0aGlzW1NZTV9CVUZGRVJdID0gZGF0YTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpc1tTWU1fQlVGRkVSXSA9IGNvbmNhdCh0aGlzW1NZTV9CVUZGRVJdLCBkYXRhKTtcblxuICAgICAgbGV0IGJ1ZmZlciA9IHRoaXNbU1lNX0JVRkZFUl07XG4gICAgICBsZXQgYnVmZmVyTGVuID0gYnVmZmVyLmxlbmd0aDtcblxuICAgICAgbGV0IHAgPSAwO1xuICAgICAgd2hpbGUgKHAgPCBidWZmZXJMZW4pIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgbGVuZ3RoICsgdHlwZVxuICAgICAgICBpZiAoYnVmZmVyTGVuIDwgNSlcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBpZiAodGhpc1tTWU1fTVNHTEVOXSA9PT0gLTEpXG4gICAgICAgICAgdGhpc1tTWU1fTVNHTEVOXSA9IHJlYWRVSW50MzJCRShidWZmZXIsIHApO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhlIGVudGlyZSBtZXNzYWdlXG4gICAgICAgIGlmIChidWZmZXJMZW4gPCAoNCArIHRoaXNbU1lNX01TR0xFTl0pKVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNvbnN0IG1zZ1R5cGUgPSBidWZmZXJbcCArPSA0XTtcbiAgICAgICAgKytwO1xuXG4gICAgICAgIGlmICh0aGlzW1NZTV9NT0RFXSA9PT0gUk9MRV9DTElFTlQpIHtcbiAgICAgICAgICBpZiAodGhpc1tTWU1fUkVRU10ubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignUmVjZWl2ZWQgdW5leHBlY3RlZCBtZXNzYWdlIGZyb20gc2VydmVyJykpO1xuXG4gICAgICAgICAgY29uc3QgcmVxID0gdGhpc1tTWU1fUkVRU10uc2hpZnQoKTtcblxuICAgICAgICAgIHN3aXRjaCAobXNnVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTU0hfQUdFTlRfRkFJTFVSRTpcbiAgICAgICAgICAgICAgcmVxLmNiKG5ldyBFcnJvcignQWdlbnQgcmVzcG9uZGVkIHdpdGggZmFpbHVyZScpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNTSF9BR0VOVF9JREVOVElUSUVTX0FOU1dFUjoge1xuICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09IFNTSF9BR0VOVENfUkVRVUVTVF9JREVOVElUSUVTKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0FnZW50IHJlc3BvbmRlZCB3aXRoIHdyb25nIG1lc3NhZ2UgdHlwZScpKTtcblxuICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICBieXRlICAgICAgICBTU0hfQUdFTlRfSURFTlRJVElFU19BTlNXRVJcbiAgICAgICAgICAgICAgICAgdWludDMyICAgICAgbmtleXNcblxuICAgICAgICAgICAgICAgIHdoZXJlIGBua2V5c2AgaXMgMCBvciBtb3JlIG9mOlxuICAgICAgICAgICAgICAgICBzdHJpbmcgICAgICBrZXkgYmxvYlxuICAgICAgICAgICAgICAgICBzdHJpbmcgICAgICBjb21tZW50XG4gICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLmluaXQoYnVmZmVyLCBwKTtcblxuICAgICAgICAgICAgICBjb25zdCBudW1LZXlzID0gYmluYXJ5UGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuXG4gICAgICAgICAgICAgIGlmIChudW1LZXlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdNYWxmb3JtZWQgYWdlbnQgcmVzcG9uc2UnKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHB1YktleSA9IGJpbmFyeVBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHB1YktleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ01hbGZvcm1lZCBhZ2VudCByZXNwb25zZScpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gYmluYXJ5UGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdNYWxmb3JtZWQgYWdlbnQgcmVzcG9uc2UnKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHViS2V5ID0gcGFyc2VLZXkocHViS2V5KTtcbiAgICAgICAgICAgICAgICAvLyBXZSBjb250aW51ZSBwYXJzaW5nIHRoZSBwYWNrZXQgaWYgd2UgZW5jb3VudGVyIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgZXJyb3IgaXMgZHVlIHRvIHRoZSBrZXkgYmVpbmcgYW4gdW5zdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAvLyB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKHB1YktleSBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBwdWJLZXkuY29tbWVudCA9IHB1YktleS5jb21tZW50IHx8IGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBrZXlzLnB1c2gocHViS2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwID0gYmluYXJ5UGFyc2VyLnBvcygpO1xuICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgICByZXEuY2IobnVsbCwga2V5cyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTU0hfQUdFTlRfU0lHTl9SRVNQT05TRToge1xuICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09IFNTSF9BR0VOVENfU0lHTl9SRVFVRVNUKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0FnZW50IHJlc3BvbmRlZCB3aXRoIHdyb25nIG1lc3NhZ2UgdHlwZScpKTtcblxuICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICBieXRlICAgICAgICBTU0hfQUdFTlRfU0lHTl9SRVNQT05TRVxuICAgICAgICAgICAgICAgICBzdHJpbmcgICAgICBzaWduYXR1cmVcbiAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIuaW5pdChidWZmZXIsIHApO1xuICAgICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gYmluYXJ5UGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgICAgICAgcCA9IGJpbmFyeVBhcnNlci5wb3MoKTtcbiAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ01hbGZvcm1lZCBhZ2VudCByZXNwb25zZScpKTtcblxuICAgICAgICAgICAgICAvLyBXZSBzdHJpcCB0aGUgYWxnb3JpdGhtIGZyb20gT3BlblNTSCdzIG91dHB1dCBhbmQgYXNzdW1lIGl0J3NcbiAgICAgICAgICAgICAgLy8gdXNpbmcgdGhlIGFsZ29yaXRobSB3ZSBzcGVjaWZpZWQuIFRoaXMgbWFrZXMgaXQgZWFzaWVyIG9uXG4gICAgICAgICAgICAgIC8vIGN1c3RvbSBBZ2VudCBpbXBsZW1lbnRhdGlvbnMgc28gdGhleSBkb24ndCBoYXZlIHRvIGNvbnN0cnVjdFxuICAgICAgICAgICAgICAvLyB0aGUgY29ycmVjdCBiaW5hcnkgZm9ybWF0IGZvciBhIChPcGVuU1NILXN0eWxlKSBzaWduYXR1cmUuXG5cbiAgICAgICAgICAgICAgLy8gVE9ETzogdmVyaWZ5IHNpZ25hdHVyZSB0eXBlIGJhc2VkIG9uIGtleSBhbmQgb3B0aW9ucyB1c2VkXG4gICAgICAgICAgICAgIC8vIGR1cmluZyBpbml0aWFsIHNpZ24gcmVxdWVzdFxuICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIuaW5pdChzaWduYXR1cmUsIDApO1xuICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlID0gYmluYXJ5UGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ01hbGZvcm1lZCBPcGVuU1NIIHNpZ25hdHVyZSBmb3JtYXQnKSk7XG5cbiAgICAgICAgICAgICAgcmVxLmNiKG51bGwsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcignQWdlbnQgcmVzcG9uZGVkIHdpdGggdW5zdXBwb3J0ZWQgbWVzc2FnZSB0eXBlJylcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChtc2dUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNTSF9BR0VOVENfUkVRVUVTVF9JREVOVElUSUVTOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBBZ2VudEluYm91bmRSZXF1ZXN0KG1zZ1R5cGUpO1xuICAgICAgICAgICAgICB0aGlzW1NZTV9SRVFTXS5wdXNoKHJlcSk7XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgYnl0ZSAgICAgICAgU1NIX0FHRU5UQ19SRVFVRVNUX0lERU5USVRJRVNcbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpZGVudGl0aWVzJywgcmVxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNTSF9BR0VOVENfU0lHTl9SRVFVRVNUOiB7XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgYnl0ZSAgICAgICAgU1NIX0FHRU5UQ19TSUdOX1JFUVVFU1RcbiAgICAgICAgICAgICAgICBzdHJpbmcgICAgICBrZXlfYmxvYlxuICAgICAgICAgICAgICAgIHN0cmluZyAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICB1aW50MzIgICAgICBmbGFnc1xuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIuaW5pdChidWZmZXIsIHApO1xuICAgICAgICAgICAgICBsZXQgcHViS2V5ID0gYmluYXJ5UGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGJpbmFyeVBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGZsYWdzVmFsID0gYmluYXJ5UGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICAgICAgICBwID0gYmluYXJ5UGFyc2VyLnBvcygpO1xuICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgaWYgKGZsYWdzVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgQWdlbnRJbmJvdW5kUmVxdWVzdChtc2dUeXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzW1NZTV9SRVFTXS5wdXNoKHJlcSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbHVyZVJlcGx5KHJlcSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwdWJLZXkgPSBwYXJzZUtleShwdWJLZXkpO1xuICAgICAgICAgICAgICBpZiAocHViS2V5IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgQWdlbnRJbmJvdW5kUmVxdWVzdChtc2dUeXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzW1NZTV9SRVFTXS5wdXNoKHJlcSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbHVyZVJlcGx5KHJlcSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBmbGFncyA9IHtcbiAgICAgICAgICAgICAgICBoYXNoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGxldCBjdHg7XG4gICAgICAgICAgICAgIGlmIChwdWJLZXkudHlwZSA9PT0gJ3NzaC1yc2EnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzVmFsICYgU1NIX0FHRU5UX1JTQV9TSEEyXzI1Nikge1xuICAgICAgICAgICAgICAgICAgY3R4ID0gJ3JzYS1zaGEyLTI1Nic7XG4gICAgICAgICAgICAgICAgICBmbGFncy5oYXNoID0gJ3NoYTI1Nic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmbGFnc1ZhbCAmIFNTSF9BR0VOVF9SU0FfU0hBMl81MTIpIHtcbiAgICAgICAgICAgICAgICAgIGN0eCA9ICdyc2Etc2hhMi01MTInO1xuICAgICAgICAgICAgICAgICAgZmxhZ3MuaGFzaCA9ICdzaGE1MTInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY3R4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY3R4ID0gcHViS2V5LnR5cGU7XG5cbiAgICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IEFnZW50SW5ib3VuZFJlcXVlc3QobXNnVHlwZSwgY3R4KTtcbiAgICAgICAgICAgICAgdGhpc1tTWU1fUkVRU10ucHVzaChyZXEpO1xuXG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnc2lnbicsIHJlcSwgcHViS2V5LCBkYXRhLCBmbGFncyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgQWdlbnRJbmJvdW5kUmVxdWVzdChtc2dUeXBlKTtcbiAgICAgICAgICAgICAgdGhpc1tTWU1fUkVRU10ucHVzaChyZXEpO1xuICAgICAgICAgICAgICB0aGlzLmZhaWx1cmVSZXBseShyZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCByZWFkeSBmb3IgbmV4dCBtZXNzYWdlXG4gICAgICAgIHRoaXNbU1lNX01TR0xFTl0gPSAtMTtcbiAgICAgICAgaWYgKHAgPT09IGJ1ZmZlckxlbikge1xuICAgICAgICAgIC8vIE5vdGhpbmcgbGVmdCB0byBwcm9jZXNzIGZvciBub3dcbiAgICAgICAgICB0aGlzW1NZTV9CVUZGRVJdID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW1NZTV9CVUZGRVJdID0gYnVmZmVyID0gYnVmZmVyLnNsaWNlKHApO1xuICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2IoKTtcbiAgICB9XG5cbiAgICBfZGVzdHJveShlcnIsIGNiKSB7XG4gICAgICBjbGVhbnVwKHRoaXMpO1xuICAgICAgY2IoKTtcbiAgICB9XG5cbiAgICBfZmluYWwoY2IpIHtcbiAgICAgIGNsZWFudXAodGhpcyk7XG4gICAgICBjYigpO1xuICAgIH1cblxuICAgIC8vIENsaWVudC0+U2VydmVyIG1lc3NhZ2VzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBzaWduKHB1YktleSwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICAgIGlmICh0aGlzW1NZTV9NT0RFXSAhPT0gUk9MRV9DTElFTlQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCB3aXRoIHNlcnZlciByb2xlJyk7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGxldCBmbGFncyA9IDA7XG5cbiAgICAgIHB1YktleSA9IHBhcnNlS2V5KHB1YktleSk7XG4gICAgICBpZiAocHViS2V5IGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwdWJsaWMga2V5IGFyZ3VtZW50Jyk7XG5cbiAgICAgIGlmIChwdWJLZXkudHlwZSA9PT0gJ3NzaC1yc2EnICYmIG9wdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLmhhc2gpIHtcbiAgICAgICAgICBjYXNlICdzaGEyNTYnOlxuICAgICAgICAgICAgZmxhZ3MgPSBTU0hfQUdFTlRfUlNBX1NIQTJfMjU2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2hhNTEyJzpcbiAgICAgICAgICAgIGZsYWdzID0gU1NIX0FHRU5UX1JTQV9TSEEyXzUxMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwdWJLZXkgPSBwdWJLZXkuZ2V0UHVibGljU1NIKCk7XG5cbiAgICAgIC8qXG4gICAgICAgIGJ5dGUgICAgICAgIFNTSF9BR0VOVENfU0lHTl9SRVFVRVNUXG4gICAgICAgIHN0cmluZyAgICAgIGtleV9ibG9iXG4gICAgICAgIHN0cmluZyAgICAgIGRhdGFcbiAgICAgICAgdWludDMyICAgICAgZmxhZ3NcbiAgICAgICovXG4gICAgICBjb25zdCB0eXBlID0gU1NIX0FHRU5UQ19TSUdOX1JFUVVFU1Q7XG4gICAgICBjb25zdCBrZXlMZW4gPSBwdWJLZXkubGVuZ3RoO1xuICAgICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgbGV0IHAgPSAwO1xuICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIGtleUxlbiArIDQgKyBkYXRhTGVuICsgNCk7XG5cbiAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgcCk7XG5cbiAgICAgIGJ1ZltwICs9IDRdID0gdHlwZTtcblxuICAgICAgd3JpdGVVSW50MzJCRShidWYsIGtleUxlbiwgKytwKTtcbiAgICAgIHB1YktleS5jb3B5KGJ1ZiwgcCArPSA0KTtcblxuICAgICAgd3JpdGVVSW50MzJCRShidWYsIGRhdGFMZW4sIHAgKz0ga2V5TGVuKTtcbiAgICAgIGRhdGEuY29weShidWYsIHAgKz0gNCk7XG5cbiAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBmbGFncywgcCArPSBkYXRhTGVuKTtcblxuICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgY2IgPSBub29wO1xuXG4gICAgICB0aGlzW1NZTV9SRVFTXS5wdXNoKHsgdHlwZSwgY2IgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnB1c2goYnVmKTtcbiAgICB9XG4gICAgZ2V0SWRlbnRpdGllcyhjYikge1xuICAgICAgaWYgKHRoaXNbU1lNX01PREVdICE9PSBST0xFX0NMSUVOVClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIHdpdGggc2VydmVyIHJvbGUnKTtcblxuICAgICAgLypcbiAgICAgICAgYnl0ZSAgICAgICAgU1NIX0FHRU5UQ19SRVFVRVNUX0lERU5USVRJRVNcbiAgICAgICovXG4gICAgICBjb25zdCB0eXBlID0gU1NIX0FHRU5UQ19SRVFVRVNUX0lERU5USVRJRVM7XG5cbiAgICAgIGxldCBwID0gMDtcbiAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgMSk7XG5cbiAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgcCk7XG5cbiAgICAgIGJ1ZltwICs9IDRdID0gdHlwZTtcblxuICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgY2IgPSBub29wO1xuXG4gICAgICB0aGlzW1NZTV9SRVFTXS5wdXNoKHsgdHlwZSwgY2IgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnB1c2goYnVmKTtcbiAgICB9XG5cbiAgICAvLyBTZXJ2ZXItPkNsaWVudCBtZXNzYWdlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgZmFpbHVyZVJlcGx5KHJlcSkge1xuICAgICAgaWYgKHRoaXNbU1lNX01PREVdICE9PSBST0xFX1NFUlZFUilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXItb25seSBtZXRob2QgY2FsbGVkIHdpdGggY2xpZW50IHJvbGUnKTtcblxuICAgICAgaWYgKCEocmVxIGluc3RhbmNlb2YgQWdlbnRJbmJvdW5kUmVxdWVzdCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgcmVxdWVzdCBhcmd1bWVudCcpO1xuXG4gICAgICBpZiAocmVxLmhhc1Jlc3BvbmRlZCgpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgbGV0IHAgPSAwO1xuICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxKTtcblxuICAgICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCBwKTtcblxuICAgICAgYnVmW3AgKz0gNF0gPSBTU0hfQUdFTlRfRkFJTFVSRTtcblxuICAgICAgcmV0dXJuIHJlc3BvbmQodGhpcywgcmVxLCBidWYpO1xuICAgIH1cbiAgICBnZXRJZGVudGl0aWVzUmVwbHkocmVxLCBrZXlzKSB7XG4gICAgICBpZiAodGhpc1tTWU1fTU9ERV0gIT09IFJPTEVfU0VSVkVSKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgd2l0aCBjbGllbnQgcm9sZScpO1xuXG4gICAgICBpZiAoIShyZXEgaW5zdGFuY2VvZiBBZ2VudEluYm91bmRSZXF1ZXN0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyByZXF1ZXN0IGFyZ3VtZW50Jyk7XG5cbiAgICAgIGlmIChyZXEuaGFzUmVzcG9uZGVkKCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAvKlxuICAgICAgICAgYnl0ZSAgICAgICAgU1NIX0FHRU5UX0lERU5USVRJRVNfQU5TV0VSXG4gICAgICAgICB1aW50MzIgICAgICBua2V5c1xuXG4gICAgICAgIHdoZXJlIGBua2V5c2AgaXMgMCBvciBtb3JlIG9mOlxuICAgICAgICAgc3RyaW5nICAgICAga2V5IGJsb2JcbiAgICAgICAgIHN0cmluZyAgICAgIGNvbW1lbnRcbiAgICAgICovXG5cbiAgICAgIGlmIChyZXEuZ2V0VHlwZSgpICE9PSBTU0hfQUdFTlRDX1JFUVVFU1RfSURFTlRJVElFUylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIHRvIHJlcXVlc3QnKTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXMgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheScpO1xuXG4gICAgICBsZXQgdG90YWxLZXlzTGVuID0gNDsgLy8gSW5jbHVkZSBgbmtleXNgIHNpemVcblxuICAgICAgY29uc3QgbmV3S2V5cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gJ29iamVjdCcgfHwgZW50cnkgPT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGtleSBlbnRyeTogJHtlbnRyeX1gKTtcblxuICAgICAgICBsZXQgcHViS2V5O1xuICAgICAgICBsZXQgY29tbWVudDtcbiAgICAgICAgaWYgKGlzUGFyc2VkS2V5KGVudHJ5KSkge1xuICAgICAgICAgIHB1YktleSA9IGVudHJ5O1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyc2VkS2V5KGVudHJ5LnB1YktleSkpIHtcbiAgICAgICAgICBwdWJLZXkgPSBlbnRyeS5wdWJLZXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeS5wdWJLZXkgIT09ICdvYmplY3QnIHx8IGVudHJ5LnB1YktleSA9PT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICh7IHB1YktleSwgY29tbWVudCB9ID0gZW50cnkucHViS2V5KTtcbiAgICAgICAgICBwdWJLZXkgPSBwYXJzZUtleShwdWJLZXkpO1xuICAgICAgICAgIGlmIChwdWJLZXkgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBUT0RPOiBhZGQgZGVidWcgb3V0cHV0XG4gICAgICAgIH1cbiAgICAgICAgY29tbWVudCA9IHB1YktleS5jb21tZW50IHx8IGNvbW1lbnQ7XG4gICAgICAgIHB1YktleSA9IHB1YktleS5nZXRQdWJsaWNTU0goKTtcblxuICAgICAgICB0b3RhbEtleXNMZW4gKz0gNCArIHB1YktleS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGNvbW1lbnQgJiYgdHlwZW9mIGNvbW1lbnQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgIGNvbW1lbnQgPSBCdWZmZXIuZnJvbShjb21tZW50KTtcbiAgICAgICAgZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjb21tZW50KSlcbiAgICAgICAgICBjb21tZW50ID0gRU1QVFlfQlVGO1xuXG4gICAgICAgIHRvdGFsS2V5c0xlbiArPSA0ICsgY29tbWVudC5sZW5ndGg7XG5cbiAgICAgICAgbmV3S2V5cy5wdXNoKHsgcHViS2V5LCBjb21tZW50IH0pO1xuICAgICAgfVxuXG4gICAgICBsZXQgcCA9IDA7XG4gICAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyB0b3RhbEtleXNMZW4pO1xuXG4gICAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgYnVmLmxlbmd0aCAtIDQsIHApO1xuXG4gICAgICBidWZbcCArPSA0XSA9IFNTSF9BR0VOVF9JREVOVElUSUVTX0FOU1dFUjtcblxuICAgICAgd3JpdGVVSW50MzJCRShidWYsIG5ld0tleXMubGVuZ3RoLCArK3ApO1xuICAgICAgcCArPSA0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHsgcHViS2V5LCBjb21tZW50IH0gPSBuZXdLZXlzW2ldO1xuXG4gICAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBwdWJLZXkubGVuZ3RoLCBwKTtcbiAgICAgICAgcHViS2V5LmNvcHkoYnVmLCBwICs9IDQpO1xuXG4gICAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBjb21tZW50Lmxlbmd0aCwgcCArPSBwdWJLZXkubGVuZ3RoKTtcbiAgICAgICAgcCArPSA0O1xuICAgICAgICBpZiAoY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICBjb21tZW50LmNvcHkoYnVmLCBwKTtcbiAgICAgICAgICBwICs9IGNvbW1lbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25kKHRoaXMsIHJlcSwgYnVmKTtcbiAgICB9XG4gICAgc2lnblJlcGx5KHJlcSwgc2lnbmF0dXJlKSB7XG4gICAgICBpZiAodGhpc1tTWU1fTU9ERV0gIT09IFJPTEVfU0VSVkVSKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgd2l0aCBjbGllbnQgcm9sZScpO1xuXG4gICAgICBpZiAoIShyZXEgaW5zdGFuY2VvZiBBZ2VudEluYm91bmRSZXF1ZXN0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyByZXF1ZXN0IGFyZ3VtZW50Jyk7XG5cbiAgICAgIGlmIChyZXEuaGFzUmVzcG9uZGVkKCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAvKlxuICAgICAgICAgYnl0ZSAgICAgICAgU1NIX0FHRU5UX1NJR05fUkVTUE9OU0VcbiAgICAgICAgIHN0cmluZyAgICAgIHNpZ25hdHVyZVxuICAgICAgKi9cblxuICAgICAgaWYgKHJlcS5nZXRUeXBlKCkgIT09IFNTSF9BR0VOVENfU0lHTl9SRVFVRVNUKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgdG8gcmVxdWVzdCcpO1xuXG4gICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzaWduYXR1cmUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJyk7XG5cbiAgICAgIGlmIChzaWduYXR1cmUubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBhcmd1bWVudCBtdXN0IGJlIG5vbi1lbXB0eScpO1xuXG4gICAgICAvKlxuICAgICAgICBPcGVuU1NIIGFnZW50IHNpZ25hdHVyZXMgYXJlIGVuY29kZWQgYXM6XG5cbiAgICAgICAgICBzdHJpbmcgICAgc2lnbmF0dXJlIGZvcm1hdCBpZGVudGlmaWVyIChhcyBzcGVjaWZpZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpYyBrZXkvY2VydGlmaWNhdGUgZm9ybWF0KVxuICAgICAgICAgIGJ5dGVbbl0gICBzaWduYXR1cmUgYmxvYiBpbiBmb3JtYXQgc3BlY2lmaWMgZW5jb2RpbmcuXG4gICAgICAgICAgICAtIFRoaXMgaXMgYWN0dWFsbHkgYSBgc3RyaW5nYCBmb3I6IHJzYSwgZHNzLCBlY2RzYSwgYW5kIGVkMjU1MTlcbiAgICAgICAgICAgICAgdHlwZXNcbiAgICAgICovXG5cbiAgICAgIGxldCBwID0gMDtcbiAgICAgIGNvbnN0IHNpZ0Zvcm1hdCA9IHJlcS5nZXRDb250ZXh0KCk7XG4gICAgICBjb25zdCBzaWdGb3JtYXRMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChzaWdGb3JtYXQpO1xuICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgICAgICA0ICsgMSArIDQgKyA0ICsgc2lnRm9ybWF0TGVuICsgNCArIHNpZ25hdHVyZS5sZW5ndGhcbiAgICAgICk7XG5cbiAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgcCk7XG5cbiAgICAgIGJ1ZltwICs9IDRdID0gU1NIX0FHRU5UX1NJR05fUkVTUE9OU0U7XG5cbiAgICAgIHdyaXRlVUludDMyQkUoYnVmLCA0ICsgc2lnRm9ybWF0TGVuICsgNCArIHNpZ25hdHVyZS5sZW5ndGgsICsrcCk7XG4gICAgICB3cml0ZVVJbnQzMkJFKGJ1Ziwgc2lnRm9ybWF0TGVuLCBwICs9IDQpO1xuICAgICAgYnVmLnV0ZjhXcml0ZShzaWdGb3JtYXQsIHAgKz0gNCwgc2lnRm9ybWF0TGVuKTtcbiAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBzaWduYXR1cmUubGVuZ3RoLCBwICs9IHNpZ0Zvcm1hdExlbik7XG4gICAgICBzaWduYXR1cmUuY29weShidWYsIHAgKz0gNCk7XG5cbiAgICAgIHJldHVybiByZXNwb25kKHRoaXMsIHJlcSwgYnVmKTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG5jb25zdCBTWU1fQUdFTlQgPSBTeW1ib2woJ0FnZW50Jyk7XG5jb25zdCBTWU1fQUdFTlRfS0VZUyA9IFN5bWJvbCgnQWdlbnQgS2V5cycpO1xuY29uc3QgU1lNX0FHRU5UX0tFWVNfSURYID0gU3ltYm9sKCdBZ2VudCBLZXlzIEluZGV4Jyk7XG5jb25zdCBTWU1fQUdFTlRfQ0JTID0gU3ltYm9sKCdBZ2VudCBJbml0IENhbGxiYWNrcycpO1xuY2xhc3MgQWdlbnRDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoYWdlbnQpIHtcbiAgICBpZiAodHlwZW9mIGFnZW50ID09PSAnc3RyaW5nJylcbiAgICAgIGFnZW50ID0gY3JlYXRlQWdlbnQoYWdlbnQpO1xuICAgIGVsc2UgaWYgKCFpc0FnZW50KGFnZW50KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZ2VudCBhcmd1bWVudCcpO1xuICAgIHRoaXNbU1lNX0FHRU5UXSA9IGFnZW50O1xuICAgIHRoaXNbU1lNX0FHRU5UX0tFWVNdID0gbnVsbDtcbiAgICB0aGlzW1NZTV9BR0VOVF9LRVlTX0lEWF0gPSAtMTtcbiAgICB0aGlzW1NZTV9BR0VOVF9DQlNdID0gbnVsbDtcbiAgfVxuICBpbml0KGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gbm9vcDtcblxuICAgIGlmICh0aGlzW1NZTV9BR0VOVF9LRVlTXSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXNbU1lNX0FHRU5UX0NCU10gPT09IG51bGwpIHtcbiAgICAgICAgdGhpc1tTWU1fQUdFTlRfQ0JTXSA9IFtjYl07XG5cbiAgICAgICAgY29uc3QgZG9DYnMgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2JzID0gdGhpc1tTWU1fQUdFTlRfQ0JTXTtcbiAgICAgICAgICAgIHRoaXNbU1lNX0FHRU5UX0NCU10gPSBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYiBvZiBjYnMpXG4gICAgICAgICAgICAgIGNiKC4uLmFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXNbU1lNX0FHRU5UXS5nZXRJZGVudGl0aWVzKG9uY2UoKGVyciwga2V5cykgPT4ge1xuICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICByZXR1cm4gZG9DYnMoZXJyKTtcblxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvQ2JzKG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ0FnZW50IGltcGxlbWVudGF0aW9uIGZhaWxlZCB0byBwcm92aWRlIGtleXMnXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXdLZXlzID0gW107XG4gICAgICAgICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGtleSA9IHBhcnNlS2V5KGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogYWRkIGRlYnVnIG91dHB1dFxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0tleXMucHVzaChrZXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXNbU1lNX0FHRU5UX0tFWVNdID0gbmV3S2V5cztcbiAgICAgICAgICB0aGlzW1NZTV9BR0VOVF9LRVlTX0lEWF0gPSAtMTtcbiAgICAgICAgICBkb0NicygpO1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW1NZTV9BR0VOVF9DQlNdLnB1c2goY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICB9XG4gIH1cbiAgbmV4dEtleSgpIHtcbiAgICBpZiAodGhpc1tTWU1fQUdFTlRfS0VZU10gPT09IG51bGxcbiAgICAgICAgfHwgKyt0aGlzW1NZTV9BR0VOVF9LRVlTX0lEWF0gPj0gdGhpc1tTWU1fQUdFTlRfS0VZU10ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNbU1lNX0FHRU5UX0tFWVNdW3RoaXNbU1lNX0FHRU5UX0tFWVNfSURYXV07XG4gIH1cbiAgY3VycmVudEtleSgpIHtcbiAgICBpZiAodGhpc1tTWU1fQUdFTlRfS0VZU10gPT09IG51bGxcbiAgICAgICAgfHwgdGhpc1tTWU1fQUdFTlRfS0VZU19JRFhdID49IHRoaXNbU1lNX0FHRU5UX0tFWVNdLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNbU1lNX0FHRU5UX0tFWVNdW3RoaXNbU1lNX0FHRU5UX0tFWVNfSURYXV07XG4gIH1cbiAgcG9zKCkge1xuICAgIGlmICh0aGlzW1NZTV9BR0VOVF9LRVlTXSA9PT0gbnVsbFxuICAgICAgICB8fCB0aGlzW1NZTV9BR0VOVF9LRVlTX0lEWF0gPj0gdGhpc1tTWU1fQUdFTlRfS0VZU10ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNbU1lNX0FHRU5UX0tFWVNfSURYXTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzW1NZTV9BR0VOVF9LRVlTX0lEWF0gPSAtMTtcbiAgfVxuXG4gIHNpZ24oLi4uYXJncykge1xuICAgIHRoaXNbU1lNX0FHRU5UXS5zaWduKC4uLmFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQWdlbnQodmFsKSB7XG4gIHJldHVybiAodmFsIGluc3RhbmNlb2YgQmFzZUFnZW50KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFnZW50Q29udGV4dCxcbiAgQWdlbnRQcm90b2NvbCxcbiAgQmFzZUFnZW50LFxuICBjcmVhdGVBZ2VudCxcbiAgQ3lnd2luQWdlbnQsXG4gIGlzQWdlbnQsXG4gIE9wZW5TU0hBZ2VudCxcbiAgUGFnZWFudEFnZW50LFxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsga01heExlbmd0aCB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5jb25zdCB7XG4gIGNyZWF0ZUluZmxhdGUsXG4gIGNvbnN0YW50czoge1xuICAgIERFRkxBVEUsXG4gICAgSU5GTEFURSxcbiAgICBaX0RFRkFVTFRfQ0hVTkssXG4gICAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIFpfREVGQVVMVF9NRU1MRVZFTCxcbiAgICBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gICAgWl9ERUZBVUxUX1dJTkRPV0JJVFMsXG4gICAgWl9QQVJUSUFMX0ZMVVNILFxuICB9XG59ID0gcmVxdWlyZSgnemxpYicpO1xuY29uc3QgWmxpYkhhbmRsZSA9IGNyZWF0ZUluZmxhdGUoKS5faGFuZGxlLmNvbnN0cnVjdG9yO1xuXG5mdW5jdGlvbiBwcm9jZXNzQ2FsbGJhY2soKSB7XG4gIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBnZXQgaGVyZScpO1xufVxuXG5mdW5jdGlvbiB6bGliT25FcnJvcihtZXNzYWdlLCBlcnJubywgY29kZSkge1xuICBjb25zdCBzZWxmID0gdGhpcy5fb3duZXI7XG4gIC8vIFRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gIC8vIENvbnRpbnVpbmcgb25seSBvYnNjdXJlcyBwcm9ibGVtcy5cblxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IuZXJybm8gPSBlcnJubztcbiAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIHNlbGYuX2VyciA9IGVycm9yO1xufVxuXG5mdW5jdGlvbiBfY2xvc2UoZW5naW5lKSB7XG4gIC8vIENhbGxlciBtYXkgaW52b2tlIC5jbG9zZSBhZnRlciBhIHpsaWIgZXJyb3IgKHdoaWNoIHdpbGwgbnVsbCBfaGFuZGxlKS5cbiAgaWYgKCFlbmdpbmUuX2hhbmRsZSlcbiAgICByZXR1cm47XG5cbiAgZW5naW5lLl9oYW5kbGUuY2xvc2UoKTtcbiAgZW5naW5lLl9oYW5kbGUgPSBudWxsO1xufVxuXG5jbGFzcyBabGliIHtcbiAgY29uc3RydWN0b3IobW9kZSkge1xuICAgIGNvbnN0IHdpbmRvd0JpdHMgPSBaX0RFRkFVTFRfV0lORE9XQklUUztcbiAgICBjb25zdCBsZXZlbCA9IFpfREVGQVVMVF9DT01QUkVTU0lPTjtcbiAgICBjb25zdCBtZW1MZXZlbCA9IFpfREVGQVVMVF9NRU1MRVZFTDtcbiAgICBjb25zdCBzdHJhdGVneSA9IFpfREVGQVVMVF9TVFJBVEVHWTtcbiAgICBjb25zdCBkaWN0aW9uYXJ5ID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fZXJyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3dyaXRlU3RhdGUgPSBuZXcgVWludDMyQXJyYXkoMik7XG4gICAgdGhpcy5fY2h1bmtTaXplID0gWl9ERUZBVUxUX0NIVU5LO1xuICAgIHRoaXMuX21heE91dHB1dExlbmd0aCA9IGtNYXhMZW5ndGg7XG4gICAgdGhpcy5fb3V0QnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRoaXMuX2NodW5rU2l6ZSk7XG4gICAgdGhpcy5fb3V0T2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuX2hhbmRsZSA9IG5ldyBabGliSGFuZGxlKG1vZGUpO1xuICAgIHRoaXMuX2hhbmRsZS5fb3duZXIgPSB0aGlzO1xuICAgIHRoaXMuX2hhbmRsZS5vbmVycm9yID0gemxpYk9uRXJyb3I7XG4gICAgdGhpcy5faGFuZGxlLmluaXQod2luZG93Qml0cyxcbiAgICAgICAgICAgICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICBtZW1MZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICBzdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93cml0ZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5KTtcbiAgfVxuXG4gIHdyaXRlU3luYyhjaHVuaywgcmV0Q2h1bmtzKSB7XG4gICAgY29uc3QgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuICAgIGlmICghaGFuZGxlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFpsaWIgaW5zdGFuY2UnKTtcblxuICAgIGxldCBhdmFpbEluQmVmb3JlID0gY2h1bmsubGVuZ3RoO1xuICAgIGxldCBhdmFpbE91dEJlZm9yZSA9IHRoaXMuX2NodW5rU2l6ZSAtIHRoaXMuX291dE9mZnNldDtcbiAgICBsZXQgaW5PZmYgPSAwO1xuICAgIGxldCBhdmFpbE91dEFmdGVyO1xuICAgIGxldCBhdmFpbEluQWZ0ZXI7XG5cbiAgICBsZXQgYnVmZmVycztcbiAgICBsZXQgbnJlYWQgPSAwO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fd3JpdGVTdGF0ZTtcbiAgICBsZXQgYnVmZmVyID0gdGhpcy5fb3V0QnVmZmVyO1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLl9vdXRPZmZzZXQ7XG4gICAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5fY2h1bmtTaXplO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGhhbmRsZS53cml0ZVN5bmMoWl9QQVJUSUFMX0ZMVVNILFxuICAgICAgICAgICAgICAgICAgICAgICBjaHVuaywgLy8gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsIC8vIGluX29mZlxuICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLCAvLyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LCAvLyBvdXRfb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgIGF2YWlsT3V0QmVmb3JlKTsgLy8gb3V0X2xlblxuICAgICAgaWYgKHRoaXMuX2VycilcbiAgICAgICAgdGhyb3cgdGhpcy5fZXJyO1xuXG4gICAgICBhdmFpbE91dEFmdGVyID0gc3RhdGVbMF07XG4gICAgICBhdmFpbEluQWZ0ZXIgPSBzdGF0ZVsxXTtcblxuICAgICAgY29uc3QgaW5EZWx0YSA9IGF2YWlsSW5CZWZvcmUgLSBhdmFpbEluQWZ0ZXI7XG4gICAgICBjb25zdCBoYXZlID0gYXZhaWxPdXRCZWZvcmUgLSBhdmFpbE91dEFmdGVyO1xuXG4gICAgICBpZiAoaGF2ZSA+IDApIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gKG9mZnNldCA9PT0gMCAmJiBoYXZlID09PSBidWZmZXIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICA/IGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgOiBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBoYXZlKSk7XG4gICAgICAgIG9mZnNldCArPSBoYXZlO1xuICAgICAgICBpZiAoIWJ1ZmZlcnMpXG4gICAgICAgICAgYnVmZmVycyA9IG91dDtcbiAgICAgICAgZWxzZSBpZiAoYnVmZmVycy5wdXNoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgYnVmZmVycyA9IFtidWZmZXJzLCBvdXRdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmZmVycy5wdXNoKG91dCk7XG4gICAgICAgIG5yZWFkICs9IG91dC5ieXRlTGVuZ3RoO1xuXG4gICAgICAgIGlmIChucmVhZCA+IHRoaXMuX21heE91dHB1dExlbmd0aCkge1xuICAgICAgICAgIF9jbG9zZSh0aGlzKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgT3V0cHV0IGxlbmd0aCBleGNlZWRlZCBtYXhpbXVtIG9mICR7dGhpcy5fbWF4T3V0cHV0TGVuZ3RofWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhdmUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXZlIHNob3VsZCBub3QgZ28gZG93bicpO1xuICAgICAgfVxuXG4gICAgICAvLyBFeGhhdXN0ZWQgdGhlIG91dHB1dCBidWZmZXIsIG9yIHVzZWQgYWxsIHRoZSBpbnB1dCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDAgfHwgb2Zmc2V0ID49IGNodW5rU2l6ZSkge1xuICAgICAgICBhdmFpbE91dEJlZm9yZSA9IGNodW5rU2l6ZTtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGNodW5rU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwKSB7XG4gICAgICAgIC8vIE5vdCBhY3R1YWxseSBkb25lLiBOZWVkIHRvIHJlcHJvY2Vzcy5cbiAgICAgICAgLy8gQWxzbywgdXBkYXRlIHRoZSBhdmFpbEluQmVmb3JlIHRvIHRoZSBhdmFpbEluQWZ0ZXIgdmFsdWUsXG4gICAgICAgIC8vIHNvIHRoYXQgaWYgd2UgaGF2ZSB0byBoaXQgaXQgYSB0aGlyZCAoZm91cnRoLCBldGMuKSB0aW1lLFxuICAgICAgICAvLyBpdCdsbCBoYXZlIHRoZSBjb3JyZWN0IGJ5dGUgY291bnRzLlxuICAgICAgICBpbk9mZiArPSBpbkRlbHRhO1xuICAgICAgICBhdmFpbEluQmVmb3JlID0gYXZhaWxJbkFmdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fb3V0QnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuX291dE9mZnNldCA9IG9mZnNldDtcblxuICAgIGlmIChucmVhZCA9PT0gMClcbiAgICAgIGJ1ZmZlcnMgPSBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICBpZiAocmV0Q2h1bmtzKSB7XG4gICAgICBidWZmZXJzLnRvdGFsTGVuID0gbnJlYWQ7XG4gICAgICByZXR1cm4gYnVmZmVycztcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVycy5wdXNoID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gYnVmZmVycztcblxuICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShucmVhZCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHAgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgYnVmID0gYnVmZmVyc1tpXTtcbiAgICAgIG91dHB1dC5zZXQoYnVmLCBwKTtcbiAgICAgIHAgKz0gYnVmLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufVxuXG5jbGFzcyBabGliUGFja2V0V3JpdGVyIHtcbiAgY29uc3RydWN0b3IocHJvdG9jb2wpIHtcbiAgICB0aGlzLmFsbG9jU3RhcnQgPSAwO1xuICAgIHRoaXMuYWxsb2NTdGFydEtFWCA9IDA7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICB0aGlzLl96bGliID0gbmV3IFpsaWIoREVGTEFURSk7XG4gIH1cblxuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLl96bGliKVxuICAgICAgX2Nsb3NlKHRoaXMuX3psaWIpO1xuICB9XG5cbiAgYWxsb2MocGF5bG9hZFNpemUsIGZvcmNlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShwYXlsb2FkU2l6ZSk7XG4gIH1cblxuICBmaW5hbGl6ZShwYXlsb2FkLCBmb3JjZSkge1xuICAgIGlmICh0aGlzLl9wcm90b2NvbC5fa2V4aW5pdCA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSB0aGlzLl96bGliLndyaXRlU3luYyhwYXlsb2FkLCB0cnVlKTtcbiAgICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3Byb3RvY29sLl9jaXBoZXIuYWxsb2NQYWNrZXQob3V0cHV0LnRvdGFsTGVuKTtcbiAgICAgIGlmIChvdXRwdXQucHVzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhY2tldC5zZXQob3V0cHV0LCA1KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwID0gNTsgaSA8IG91dHB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gb3V0cHV0W2ldO1xuICAgICAgICAgIHBhY2tldC5zZXQoY2h1bmssIHApO1xuICAgICAgICAgIHAgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFja2V0O1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfVxufVxuXG5jbGFzcyBQYWNrZXRXcml0ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm90b2NvbCkge1xuICAgIHRoaXMuYWxsb2NTdGFydCA9IDU7XG4gICAgdGhpcy5hbGxvY1N0YXJ0S0VYID0gNTtcbiAgICB0aGlzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICB9XG5cbiAgY2xlYW51cCgpIHt9XG5cbiAgYWxsb2MocGF5bG9hZFNpemUsIGZvcmNlKSB7XG4gICAgaWYgKHRoaXMuX3Byb3RvY29sLl9rZXhpbml0ID09PSB1bmRlZmluZWQgfHwgZm9yY2UpXG4gICAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2wuX2NpcGhlci5hbGxvY1BhY2tldChwYXlsb2FkU2l6ZSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShwYXlsb2FkU2l6ZSk7XG4gIH1cblxuICBmaW5hbGl6ZShwYWNrZXQsIGZvcmNlKSB7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxufVxuXG5jbGFzcyBabGliUGFja2V0UmVhZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5femxpYiA9IG5ldyBabGliKElORkxBVEUpO1xuICB9XG5cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5femxpYilcbiAgICAgIF9jbG9zZSh0aGlzLl96bGliKTtcbiAgfVxuXG4gIHJlYWQoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl96bGliLndyaXRlU3luYyhkYXRhLCBmYWxzZSk7XG4gIH1cbn1cblxuY2xhc3MgUGFja2V0UmVhZGVyIHtcbiAgY2xlYW51cCgpIHt9XG5cbiAgcmVhZChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFBhY2tldFJlYWRlcixcbiAgUGFja2V0V3JpdGVyLFxuICBabGliUGFja2V0UmVhZGVyLFxuICBabGliUGFja2V0V3JpdGVyLFxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgYnVmZmVyU2xpY2UsXG4gIGJ1ZmZlclBhcnNlcixcbiAgZG9GYXRhbEVycm9yLFxuICBzaWdTU0hUb0FTTjEsXG4gIHdyaXRlVUludDMyQkUsXG59ID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuXG5jb25zdCB7XG4gIENIQU5ORUxfT1BFTl9GQUlMVVJFLFxuICBDT01QQVQsXG4gIE1FU1NBR0UsXG4gIFRFUk1JTkFMX01PREUsXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMuanMnKTtcblxuY29uc3Qge1xuICBwYXJzZUtleSxcbn0gPSByZXF1aXJlKCcuL2tleVBhcnNlci5qcycpO1xuXG5jb25zdCBURVJNSU5BTF9NT0RFX0JZX1ZBTFVFID1cbiAgQXJyYXkuZnJvbShPYmplY3QuZW50cmllcyhURVJNSU5BTF9NT0RFKSlcbiAgICAgICAucmVkdWNlKChvYmosIFtrZXksIHZhbHVlXSkgPT4gKHsgLi4ub2JqLCBba2V5XTogdmFsdWUgfSksIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIFRyYW5zcG9ydCBsYXllciBwcm90b2NvbCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBbTUVTU0FHRS5ESVNDT05ORUNUXTogKHNlbGYsIHBheWxvYWQpID0+IHtcbiAgICAvKlxuICAgICAgYnl0ZSAgICAgIFNTSF9NU0dfRElTQ09OTkVDVFxuICAgICAgdWludDMyICAgIHJlYXNvbiBjb2RlXG4gICAgICBzdHJpbmcgICAgZGVzY3JpcHRpb24gaW4gSVNPLTEwNjQ2IFVURi04IGVuY29kaW5nXG4gICAgICBzdHJpbmcgICAgbGFuZ3VhZ2UgdGFnXG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZWFzb24gPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgY29uc3QgZGVzYyA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgIGNvbnN0IGxhbmcgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKGxhbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgc2VsZixcbiAgICAgICAgJ0luYm91bmQ6IE1hbGZvcm1lZCBESVNDT05ORUNUIHBhY2tldCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc2VsZi5fZGVidWcgJiYgc2VsZi5fZGVidWcoXG4gICAgICBgSW5ib3VuZDogUmVjZWl2ZWQgRElTQ09OTkVDVCAoJHtyZWFzb259LCBcIiR7ZGVzY31cIilgXG4gICAgKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5ESVNDT05ORUNUO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlcihzZWxmLCByZWFzb24sIGRlc2MpO1xuICB9LFxuICBbTUVTU0FHRS5JR05PUkVdOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgU1NIX01TR19JR05PUkVcbiAgICAgIHN0cmluZyAgICBkYXRhXG4gICAgKi9cbiAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZygnSW5ib3VuZDogUmVjZWl2ZWQgSUdOT1JFJyk7XG4gIH0sXG4gIFtNRVNTQUdFLlVOSU1QTEVNRU5URURdOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgU1NIX01TR19VTklNUExFTUVOVEVEXG4gICAgICB1aW50MzIgICAgcGFja2V0IHNlcXVlbmNlIG51bWJlciBvZiByZWplY3RlZCBtZXNzYWdlXG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCBzZXFubyA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgIGlmIChzZXFubyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICBzZWxmLFxuICAgICAgICAnSW5ib3VuZDogTWFsZm9ybWVkIFVOSU1QTEVNRU5URUQgcGFja2V0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kZWJ1Z1xuICAgICAgJiYgc2VsZi5fZGVidWcoYEluYm91bmQ6IFJlY2VpdmVkIFVOSU1QTEVNRU5URUQgKHNlcW5vICR7c2Vxbm99KWApO1xuICB9LFxuICBbTUVTU0FHRS5ERUJVR106IChzZWxmLCBwYXlsb2FkKSA9PiB7XG4gICAgLypcbiAgICAgIGJ5dGUgICAgICBTU0hfTVNHX0RFQlVHXG4gICAgICBib29sZWFuICAgYWx3YXlzX2Rpc3BsYXlcbiAgICAgIHN0cmluZyAgICBtZXNzYWdlIGluIElTTy0xMDY0NiBVVEYtOCBlbmNvZGluZyBbUkZDMzYyOV1cbiAgICAgIHN0cmluZyAgICBsYW5ndWFnZSB0YWcgW1JGQzMwNjZdXG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCBkaXNwbGF5ID0gYnVmZmVyUGFyc2VyLnJlYWRCb29sKCk7XG4gICAgY29uc3QgbXNnID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgY29uc3QgbGFuZyA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAobGFuZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICBzZWxmLFxuICAgICAgICAnSW5ib3VuZDogTWFsZm9ybWVkIERFQlVHIHBhY2tldCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc2VsZi5fZGVidWcgJiYgc2VsZi5fZGVidWcoJ0luYm91bmQ6IFJlY2VpdmVkIERFQlVHJyk7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gc2VsZi5faGFuZGxlcnMuREVCVUc7XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyKHNlbGYsIGRpc3BsYXksIG1zZyk7XG4gIH0sXG4gIFtNRVNTQUdFLlNFUlZJQ0VfUkVRVUVTVF06IChzZWxmLCBwYXlsb2FkKSA9PiB7XG4gICAgLypcbiAgICAgIGJ5dGUgICAgICBTU0hfTVNHX1NFUlZJQ0VfUkVRVUVTVFxuICAgICAgc3RyaW5nICAgIHNlcnZpY2UgbmFtZVxuICAgICovXG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgbmFtZSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgc2VsZixcbiAgICAgICAgJ0luYm91bmQ6IE1hbGZvcm1lZCBTRVJWSUNFX1JFUVVFU1QgcGFja2V0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZyhgSW5ib3VuZDogUmVjZWl2ZWQgU0VSVklDRV9SRVFVRVNUICgke25hbWV9KWApO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IHNlbGYuX2hhbmRsZXJzLlNFUlZJQ0VfUkVRVUVTVDtcbiAgICBoYW5kbGVyICYmIGhhbmRsZXIoc2VsZiwgbmFtZSk7XG4gIH0sXG4gIFtNRVNTQUdFLlNFUlZJQ0VfQUNDRVBUXTogKHNlbGYsIHBheWxvYWQpID0+IHtcbiAgICAvLyBTLT5DXG4gICAgLypcbiAgICAgIGJ5dGUgICAgICBTU0hfTVNHX1NFUlZJQ0VfQUNDRVBUXG4gICAgICBzdHJpbmcgICAgc2VydmljZSBuYW1lXG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCBuYW1lID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICBzZWxmLFxuICAgICAgICAnSW5ib3VuZDogTWFsZm9ybWVkIFNFUlZJQ0VfQUNDRVBUIHBhY2tldCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc2VsZi5fZGVidWcgJiYgc2VsZi5fZGVidWcoYEluYm91bmQ6IFJlY2VpdmVkIFNFUlZJQ0VfQUNDRVBUICgke25hbWV9KWApO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IHNlbGYuX2hhbmRsZXJzLlNFUlZJQ0VfQUNDRVBUO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlcihzZWxmLCBuYW1lKTtcbiAgfSxcbiAgW01FU1NBR0UuRVhUX0lORk9dOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgIFNTSF9NU0dfRVhUX0lORk9cbiAgICAgIHVpbnQzMiAgICAgbnItZXh0ZW5zaW9uc1xuICAgICAgcmVwZWF0IHRoZSBmb2xsb3dpbmcgMiBmaWVsZHMgXCJuci1leHRlbnNpb25zXCIgdGltZXM6XG4gICAgICAgIHN0cmluZyAgIGV4dGVuc2lvbi1uYW1lXG4gICAgICAgIHN0cmluZyAgIGV4dGVuc2lvbi12YWx1ZSAoYmluYXJ5KVxuICAgICovXG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgbnVtRXh0cyA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBsZXQgZXh0cztcbiAgICBpZiAobnVtRXh0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBleHRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUV4dHM7ICsraSkge1xuICAgICAgICBjb25zdCBuYW1lID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdzZXJ2ZXItc2lnLWFsZ3MnOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGFsZ3MgPSBkYXRhLmxhdGluMVNsaWNlKDAsIGRhdGEubGVuZ3RoKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICBleHRzLnB1c2goeyBuYW1lLCBhbGdzIH0pO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWxmb3JtZWRcbiAgICAgICAgZXh0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKGV4dHMgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3Ioc2VsZiwgJ0luYm91bmQ6IE1hbGZvcm1lZCBFWFRfSU5GTyBwYWNrZXQnKTtcblxuICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKCdJbmJvdW5kOiBSZWNlaXZlZCBFWFRfSU5GTycpO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IHNlbGYuX2hhbmRsZXJzLkVYVF9JTkZPO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlcihzZWxmLCBleHRzKTtcbiAgfSxcblxuICAvLyBVc2VyIGF1dGggcHJvdG9jb2wgLS0gZ2VuZXJpYyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgW01FU1NBR0UuVVNFUkFVVEhfUkVRVUVTVF06IChzZWxmLCBwYXlsb2FkKSA9PiB7XG4gICAgLypcbiAgICAgIGJ5dGUgICAgICBTU0hfTVNHX1VTRVJBVVRIX1JFUVVFU1RcbiAgICAgIHN0cmluZyAgICB1c2VyIG5hbWUgaW4gSVNPLTEwNjQ2IFVURi04IGVuY29kaW5nIFtSRkMzNjI5XVxuICAgICAgc3RyaW5nICAgIHNlcnZpY2UgbmFtZSBpbiBVUy1BU0NJSVxuICAgICAgc3RyaW5nICAgIG1ldGhvZCBuYW1lIGluIFVTLUFTQ0lJXG4gICAgICAuLi4uICAgICAgbWV0aG9kIHNwZWNpZmljIGZpZWxkc1xuICAgICovXG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgdXNlciA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgIGNvbnN0IHNlcnZpY2UgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICBjb25zdCBtZXRob2QgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICBsZXQgbWV0aG9kRGF0YTtcbiAgICBsZXQgbWV0aG9kRGVzYztcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgIG1ldGhvZERhdGEgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bhc3N3b3JkJzoge1xuICAgICAgICAvKlxuICAgICAgICAgIGJvb2xlYW4gICA8bmV3IHBhc3N3b3JkIGZvbGxvd3MgKG9sZCkgcGxhaW50ZXh0IHBhc3N3b3JkPz5cbiAgICAgICAgICBzdHJpbmcgICAgcGxhaW50ZXh0IHBhc3N3b3JkIGluIElTTy0xMDY0NiBVVEYtOCBlbmNvZGluZyBbUkZDMzYyOV1cbiAgICAgICAgIFtzdHJpbmcgICAgbmV3IHBhc3N3b3JkXVxuICAgICAgICAqL1xuICAgICAgICBjb25zdCBpc0NoYW5nZSA9IGJ1ZmZlclBhcnNlci5yZWFkQm9vbCgpO1xuICAgICAgICBpZiAoaXNDaGFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1ldGhvZERhdGEgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgICBpZiAobWV0aG9kRGF0YSAhPT0gdW5kZWZpbmVkICYmIGlzQ2hhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdQYXNzd29yZCA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgICAgICAgaWYgKG5ld1Bhc3N3b3JkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIG1ldGhvZERhdGEgPSB7IG9sZFBhc3N3b3JkOiBtZXRob2REYXRhLCBuZXdQYXNzd29yZCB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtZXRob2REYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3B1YmxpY2tleSc6IHtcbiAgICAgICAgLypcbiAgICAgICAgICBib29sZWFuICAgPHNpZ25hdHVyZSBmb2xsb3dzIHB1YmxpYyBrZXkgYmxvYj8+XG4gICAgICAgICAgc3RyaW5nICAgIHB1YmxpYyBrZXkgYWxnb3JpdGhtIG5hbWVcbiAgICAgICAgICBzdHJpbmcgICAgcHVibGljIGtleSBibG9iXG4gICAgICAgICBbc3RyaW5nICAgIHNpZ25hdHVyZV1cbiAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaGFzU2lnID0gYnVmZmVyUGFyc2VyLnJlYWRCb29sKCk7XG4gICAgICAgIGlmIChoYXNTaWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IGtleUFsZ28gPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgICBsZXQgcmVhbEtleUFsZ28gPSBrZXlBbGdvO1xuICAgICAgICAgIGNvbnN0IGtleSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG5cbiAgICAgICAgICBsZXQgaGFzaEFsZ287XG4gICAgICAgICAgc3dpdGNoIChrZXlBbGdvKSB7XG4gICAgICAgICAgICBjYXNlICdyc2Etc2hhMi0yNTYnOlxuICAgICAgICAgICAgICByZWFsS2V5QWxnbyA9ICdzc2gtcnNhJztcbiAgICAgICAgICAgICAgaGFzaEFsZ28gPSAnc2hhMjU2JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyc2Etc2hhMi01MTInOlxuICAgICAgICAgICAgICByZWFsS2V5QWxnbyA9ICdzc2gtcnNhJztcbiAgICAgICAgICAgICAgaGFzaEFsZ28gPSAnc2hhNTEyJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc1NpZykge1xuICAgICAgICAgICAgY29uc3QgYmxvYkVuZCA9IGJ1ZmZlclBhcnNlci5wb3MoKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChzaWduYXR1cmUubGVuZ3RoID4gKDQgKyBrZXlBbGdvLmxlbmd0aCArIDQpXG4gICAgICAgICAgICAgICAgICAmJiBzaWduYXR1cmUudXRmOFNsaWNlKDQsIDQgKyBrZXlBbGdvLmxlbmd0aCkgPT09IGtleUFsZ28pIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGFsZ29MZW4gKyBhbGdvICsgc2lnTGVuXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gYnVmZmVyU2xpY2Uoc2lnbmF0dXJlLCA0ICsga2V5QWxnby5sZW5ndGggKyA0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNpZ25hdHVyZSA9IHNpZ1NTSFRvQVNOMShzaWduYXR1cmUsIHJlYWxLZXlBbGdvKTtcbiAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JRCA9IHNlbGYuX2tleC5zZXNzaW9uSUQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgc2Vzc2lvbklELmxlbmd0aCArIGJsb2JFbmQpO1xuICAgICAgICAgICAgICAgIHdyaXRlVUludDMyQkUoYmxvYiwgc2Vzc2lvbklELmxlbmd0aCwgMCk7XG4gICAgICAgICAgICAgICAgYmxvYi5zZXQoc2Vzc2lvbklELCA0KTtcbiAgICAgICAgICAgICAgICBibG9iLnNldChcbiAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHBheWxvYWQuYnVmZmVyLCBwYXlsb2FkLmJ5dGVPZmZzZXQsIGJsb2JFbmQpLFxuICAgICAgICAgICAgICAgICAgNCArIHNlc3Npb25JRC5sZW5ndGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG1ldGhvZERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBrZXlBbGdvOiByZWFsS2V5QWxnbyxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAgIGJsb2IsXG4gICAgICAgICAgICAgICAgICBoYXNoQWxnbyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZERhdGEgPSB7IGtleUFsZ286IHJlYWxLZXlBbGdvLCBrZXksIGhhc2hBbGdvIH07XG4gICAgICAgICAgICBtZXRob2REZXNjID0gJ3B1YmxpY2tleSAtLSBjaGVjayc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnaG9zdGJhc2VkJzoge1xuICAgICAgICAvKlxuICAgICAgICAgIHN0cmluZyAgICBwdWJsaWMga2V5IGFsZ29yaXRobSBmb3IgaG9zdCBrZXlcbiAgICAgICAgICBzdHJpbmcgICAgcHVibGljIGhvc3Qga2V5IGFuZCBjZXJ0aWZpY2F0ZXMgZm9yIGNsaWVudCBob3N0XG4gICAgICAgICAgc3RyaW5nICAgIGNsaWVudCBob3N0IG5hbWUgZXhwcmVzc2VkIGFzIHRoZSBGUUROIGluIFVTLUFTQ0lJXG4gICAgICAgICAgc3RyaW5nICAgIHVzZXIgbmFtZSBvbiB0aGUgY2xpZW50IGhvc3QgaW4gSVNPLTEwNjQ2IFVURi04IGVuY29kaW5nXG4gICAgICAgICAgICAgICAgICAgICBbUkZDMzYyOV1cbiAgICAgICAgICBzdHJpbmcgICAgc2lnbmF0dXJlXG4gICAgICAgICovXG4gICAgICAgIGNvbnN0IGtleUFsZ28gPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgbGV0IHJlYWxLZXlBbGdvID0ga2V5QWxnbztcbiAgICAgICAgY29uc3Qga2V5ID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbG9jYWxIb3N0bmFtZSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgICBjb25zdCBsb2NhbFVzZXJuYW1lID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG5cbiAgICAgICAgbGV0IGhhc2hBbGdvO1xuICAgICAgICBzd2l0Y2ggKGtleUFsZ28pIHtcbiAgICAgICAgICBjYXNlICdyc2Etc2hhMi0yNTYnOlxuICAgICAgICAgICAgcmVhbEtleUFsZ28gPSAnc3NoLXJzYSc7XG4gICAgICAgICAgICBoYXNoQWxnbyA9ICdzaGEyNTYnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncnNhLXNoYTItNTEyJzpcbiAgICAgICAgICAgIHJlYWxLZXlBbGdvID0gJ3NzaC1yc2EnO1xuICAgICAgICAgICAgaGFzaEFsZ28gPSAnc2hhNTEyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmxvYkVuZCA9IGJ1ZmZlclBhcnNlci5wb3MoKTtcbiAgICAgICAgbGV0IHNpZ25hdHVyZSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgICAgIGlmIChzaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChzaWduYXR1cmUubGVuZ3RoID4gKDQgKyBrZXlBbGdvLmxlbmd0aCArIDQpXG4gICAgICAgICAgICAgICYmIHNpZ25hdHVyZS51dGY4U2xpY2UoNCwgNCArIGtleUFsZ28ubGVuZ3RoKSA9PT0ga2V5QWxnbykge1xuICAgICAgICAgICAgLy8gU2tpcCBhbGdvTGVuICsgYWxnbyArIHNpZ0xlblxuICAgICAgICAgICAgc2lnbmF0dXJlID0gYnVmZmVyU2xpY2Uoc2lnbmF0dXJlLCA0ICsga2V5QWxnby5sZW5ndGggKyA0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzaWduYXR1cmUgPSBzaWdTU0hUb0FTTjEoc2lnbmF0dXJlLCByZWFsS2V5QWxnbyk7XG4gICAgICAgICAgaWYgKHNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSUQgPSBzZWxmLl9rZXguc2Vzc2lvbklEO1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgc2Vzc2lvbklELmxlbmd0aCArIGJsb2JFbmQpO1xuICAgICAgICAgICAgd3JpdGVVSW50MzJCRShibG9iLCBzZXNzaW9uSUQubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgIGJsb2Iuc2V0KHNlc3Npb25JRCwgNCk7XG4gICAgICAgICAgICBibG9iLnNldChcbiAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkocGF5bG9hZC5idWZmZXIsIHBheWxvYWQuYnl0ZU9mZnNldCwgYmxvYkVuZCksXG4gICAgICAgICAgICAgIDQgKyBzZXNzaW9uSUQubGVuZ3RoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWV0aG9kRGF0YSA9IHtcbiAgICAgICAgICAgICAga2V5QWxnbzogcmVhbEtleUFsZ28sXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICBibG9iLFxuICAgICAgICAgICAgICBsb2NhbEhvc3RuYW1lLFxuICAgICAgICAgICAgICBsb2NhbFVzZXJuYW1lLFxuICAgICAgICAgICAgICBoYXNoQWxnb1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdrZXlib2FyZC1pbnRlcmFjdGl2ZSc6XG4gICAgICAgIC8qXG4gICAgICAgICAgc3RyaW5nICAgIGxhbmd1YWdlIHRhZyAoYXMgZGVmaW5lZCBpbiBbUkZDLTMwNjZdKVxuICAgICAgICAgIHN0cmluZyAgICBzdWJtZXRob2RzIChJU08tMTA2NDYgVVRGLTgpXG4gICAgICAgICovXG4gICAgICAgIC8vIFNraXAvaWdub3JlIGxhbmd1YWdlIGZpZWxkIC0tIGl0J3MgZGVwcmVjYXRlZCBpbiBSRkMgNDI1NlxuICAgICAgICBidWZmZXJQYXJzZXIuc2tpcFN0cmluZygpO1xuXG4gICAgICAgIG1ldGhvZERhdGEgPSBidWZmZXJQYXJzZXIucmVhZExpc3QoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgbWV0aG9kRGF0YSA9IGJ1ZmZlclBhcnNlci5yZWFkUmF3KCk7XG4gICAgfVxuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKG1ldGhvZERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgc2VsZixcbiAgICAgICAgJ0luYm91bmQ6IE1hbGZvcm1lZCBVU0VSQVVUSF9SRVFVRVNUIHBhY2tldCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZERlc2MgPT09IHVuZGVmaW5lZClcbiAgICAgIG1ldGhvZERlc2MgPSBtZXRob2Q7XG5cbiAgICBzZWxmLl9hdXRoc1F1ZXVlLnB1c2gobWV0aG9kKTtcblxuICAgIHNlbGYuX2RlYnVnXG4gICAgICAmJiBzZWxmLl9kZWJ1ZyhgSW5ib3VuZDogUmVjZWl2ZWQgVVNFUkFVVEhfUkVRVUVTVCAoJHttZXRob2REZXNjfSlgKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5VU0VSQVVUSF9SRVFVRVNUO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlcihzZWxmLCB1c2VyLCBzZXJ2aWNlLCBtZXRob2QsIG1ldGhvZERhdGEpO1xuICB9LFxuICBbTUVTU0FHRS5VU0VSQVVUSF9GQUlMVVJFXTogKHNlbGYsIHBheWxvYWQpID0+IHtcbiAgICAvLyBTLT5DXG4gICAgLypcbiAgICAgIGJ5dGUgICAgICAgICBTU0hfTVNHX1VTRVJBVVRIX0ZBSUxVUkVcbiAgICAgIG5hbWUtbGlzdCAgICBhdXRoZW50aWNhdGlvbnMgdGhhdCBjYW4gY29udGludWVcbiAgICAgIGJvb2xlYW4gICAgICBwYXJ0aWFsIHN1Y2Nlc3NcbiAgICAqL1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IGF1dGhNZXRob2RzID0gYnVmZmVyUGFyc2VyLnJlYWRMaXN0KCk7XG4gICAgY29uc3QgcGFydGlhbFN1Y2Nlc3MgPSBidWZmZXJQYXJzZXIucmVhZEJvb2woKTtcbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgIGlmIChwYXJ0aWFsU3VjY2VzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICBzZWxmLFxuICAgICAgICAnSW5ib3VuZDogTWFsZm9ybWVkIFVTRVJBVVRIX0ZBSUxVUkUgcGFja2V0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kZWJ1Z1xuICAgICAgJiYgc2VsZi5fZGVidWcoYEluYm91bmQ6IFJlY2VpdmVkIFVTRVJBVVRIX0ZBSUxVUkUgKCR7YXV0aE1ldGhvZHN9KWApO1xuXG4gICAgc2VsZi5fYXV0aHNRdWV1ZS5zaGlmdCgpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5VU0VSQVVUSF9GQUlMVVJFO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlcihzZWxmLCBhdXRoTWV0aG9kcywgcGFydGlhbFN1Y2Nlc3MpO1xuICB9LFxuICBbTUVTU0FHRS5VU0VSQVVUSF9TVUNDRVNTXTogKHNlbGYsIHBheWxvYWQpID0+IHtcbiAgICAvLyBTLT5DXG4gICAgLypcbiAgICAgIGJ5dGUgICAgICBTU0hfTVNHX1VTRVJBVVRIX1NVQ0NFU1NcbiAgICAqL1xuICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKCdJbmJvdW5kOiBSZWNlaXZlZCBVU0VSQVVUSF9TVUNDRVNTJyk7XG5cbiAgICBzZWxmLl9hdXRoc1F1ZXVlLnNoaWZ0KCk7XG4gICAgY29uc3QgaGFuZGxlciA9IHNlbGYuX2hhbmRsZXJzLlVTRVJBVVRIX1NVQ0NFU1M7XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyKHNlbGYpO1xuICB9LFxuICBbTUVTU0FHRS5VU0VSQVVUSF9CQU5ORVJdOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8vIFMtPkNcbiAgICAvKlxuICAgICAgYnl0ZSAgICAgIFNTSF9NU0dfVVNFUkFVVEhfQkFOTkVSXG4gICAgICBzdHJpbmcgICAgbWVzc2FnZSBpbiBJU08tMTA2NDYgVVRGLTggZW5jb2RpbmcgW1JGQzM2MjldXG4gICAgICBzdHJpbmcgICAgbGFuZ3VhZ2UgdGFnIFtSRkMzMDY2XVxuICAgICovXG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgbXNnID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgY29uc3QgbGFuZyA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAobGFuZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICBzZWxmLFxuICAgICAgICAnSW5ib3VuZDogTWFsZm9ybWVkIFVTRVJBVVRIX0JBTk5FUiBwYWNrZXQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKCdJbmJvdW5kOiBSZWNlaXZlZCBVU0VSQVVUSF9CQU5ORVInKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5VU0VSQVVUSF9CQU5ORVI7XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyKHNlbGYsIG1zZyk7XG4gIH0sXG5cbiAgLy8gVXNlciBhdXRoIHByb3RvY29sIC0tIG1ldGhvZC1zcGVjaWZpYyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIDYwOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIGlmICghc2VsZi5fYXV0aHNRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHNlbGYuX2RlYnVnXG4gICAgICAgICYmIHNlbGYuX2RlYnVnKCdJbmJvdW5kOiBSZWNlaXZlZCBwYXlsb2FkIHR5cGUgNjAgd2l0aG91dCBhdXRoJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChzZWxmLl9hdXRoc1F1ZXVlWzBdKSB7XG4gICAgICBjYXNlICdwYXNzd29yZCc6IHtcbiAgICAgICAgLy8gUy0+Q1xuICAgICAgICAvKlxuICAgICAgICAgIGJ5dGUgICAgICBTU0hfTVNHX1VTRVJBVVRIX1BBU1NXRF9DSEFOR0VSRVFcbiAgICAgICAgICBzdHJpbmcgICAgcHJvbXB0IGluIElTTy0xMDY0NiBVVEYtOCBlbmNvZGluZyBbUkZDMzYyOV1cbiAgICAgICAgICBzdHJpbmcgICAgbGFuZ3VhZ2UgdGFnIFtSRkMzMDY2XVxuICAgICAgICAqL1xuICAgICAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGxhbmcgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgICAgICBpZiAobGFuZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgICAgIHNlbGYsXG4gICAgICAgICAgICAnSW5ib3VuZDogTWFsZm9ybWVkIFVTRVJBVVRIX1BBU1NXRF9DSEFOR0VSRVEgcGFja2V0J1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9kZWJ1Z1xuICAgICAgICAgICYmIHNlbGYuX2RlYnVnKCdJbmJvdW5kOiBSZWNlaXZlZCBVU0VSQVVUSF9QQVNTV0RfQ0hBTkdFUkVRJyk7XG5cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHNlbGYuX2hhbmRsZXJzLlVTRVJBVVRIX1BBU1NXRF9DSEFOR0VSRVE7XG4gICAgICAgIGhhbmRsZXIgJiYgaGFuZGxlcihzZWxmLCBwcm9tcHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3B1YmxpY2tleSc6IHtcbiAgICAgICAgLy8gUy0+Q1xuICAgICAgICAvKlxuICAgICAgICAgIGJ5dGUgICAgICBTU0hfTVNHX1VTRVJBVVRIX1BLX09LXG4gICAgICAgICAgc3RyaW5nICAgIHB1YmxpYyBrZXkgYWxnb3JpdGhtIG5hbWUgZnJvbSB0aGUgcmVxdWVzdFxuICAgICAgICAgIHN0cmluZyAgICBwdWJsaWMga2V5IGJsb2IgZnJvbSB0aGUgcmVxdWVzdFxuICAgICAgICAqL1xuICAgICAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICAgICAgY29uc3Qga2V5QWxnbyA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgICBjb25zdCBrZXkgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgICAgc2VsZixcbiAgICAgICAgICAgICdJbmJvdW5kOiBNYWxmb3JtZWQgVVNFUkFVVEhfUEtfT0sgcGFja2V0J1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZygnSW5ib3VuZDogUmVjZWl2ZWQgVVNFUkFVVEhfUEtfT0snKTtcblxuICAgICAgICBzZWxmLl9hdXRoc1F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5VU0VSQVVUSF9QS19PSztcbiAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyKHNlbGYsIGtleUFsZ28sIGtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAna2V5Ym9hcmQtaW50ZXJhY3RpdmUnOiB7XG4gICAgICAgIC8vIFMtPkNcbiAgICAgICAgLypcbiAgICAgICAgICBieXRlICAgICAgU1NIX01TR19VU0VSQVVUSF9JTkZPX1JFUVVFU1RcbiAgICAgICAgICBzdHJpbmcgICAgbmFtZSAoSVNPLTEwNjQ2IFVURi04KVxuICAgICAgICAgIHN0cmluZyAgICBpbnN0cnVjdGlvbiAoSVNPLTEwNjQ2IFVURi04KVxuICAgICAgICAgIHN0cmluZyAgICBsYW5ndWFnZSB0YWcgKGFzIGRlZmluZWQgaW4gW1JGQy0zMDY2XSlcbiAgICAgICAgICBpbnQgICAgICAgbnVtLXByb21wdHNcbiAgICAgICAgICBzdHJpbmcgICAgcHJvbXB0WzFdIChJU08tMTA2NDYgVVRGLTgpXG4gICAgICAgICAgYm9vbGVhbiAgIGVjaG9bMV1cbiAgICAgICAgICAuLi5cbiAgICAgICAgICBzdHJpbmcgICAgcHJvbXB0W251bS1wcm9tcHRzXSAoSVNPLTEwNjQ2IFVURi04KVxuICAgICAgICAgIGJvb2xlYW4gICBlY2hvW251bS1wcm9tcHRzXVxuICAgICAgICAqL1xuICAgICAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcoKTsgLy8gc2tpcCBsYW5nXG4gICAgICAgIGNvbnN0IG51bVByb21wdHMgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgICAgIGxldCBwcm9tcHRzO1xuICAgICAgICBpZiAobnVtUHJvbXB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvbXB0cyA9IG5ldyBBcnJheShudW1Qcm9tcHRzKTtcbiAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUHJvbXB0czsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tcHQgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGVjaG8gPSBidWZmZXJQYXJzZXIucmVhZEJvb2woKTtcbiAgICAgICAgICAgIGlmIChlY2hvID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcHJvbXB0c1tpXSA9IHsgcHJvbXB0LCBlY2hvIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpICE9PSBudW1Qcm9tcHRzKVxuICAgICAgICAgICAgcHJvbXB0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgICAgICBpZiAocHJvbXB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgICAgIHNlbGYsXG4gICAgICAgICAgICAnSW5ib3VuZDogTWFsZm9ybWVkIFVTRVJBVVRIX0lORk9fUkVRVUVTVCBwYWNrZXQnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKCdJbmJvdW5kOiBSZWNlaXZlZCBVU0VSQVVUSF9JTkZPX1JFUVVFU1QnKTtcblxuICAgICAgICBjb25zdCBoYW5kbGVyID0gc2VsZi5faGFuZGxlcnMuVVNFUkFVVEhfSU5GT19SRVFVRVNUO1xuICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIoc2VsZiwgbmFtZSwgaW5zdHJ1Y3Rpb25zLCBwcm9tcHRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZWxmLl9kZWJ1Z1xuICAgICAgICAgICYmIHNlbGYuX2RlYnVnKCdJbmJvdW5kOiBSZWNlaXZlZCB1bmV4cGVjdGVkIHBheWxvYWQgdHlwZSA2MCcpO1xuICAgIH1cbiAgfSxcbiAgNjE6IChzZWxmLCBwYXlsb2FkKSA9PiB7XG4gICAgaWYgKCFzZWxmLl9hdXRoc1F1ZXVlLmxlbmd0aCkge1xuICAgICAgc2VsZi5fZGVidWdcbiAgICAgICAgJiYgc2VsZi5fZGVidWcoJ0luYm91bmQ6IFJlY2VpdmVkIHBheWxvYWQgdHlwZSA2MSB3aXRob3V0IGF1dGgnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLypcbiAgICAgIGJ5dGUgICAgICBTU0hfTVNHX1VTRVJBVVRIX0lORk9fUkVTUE9OU0VcbiAgICAgIGludCAgICAgICBudW0tcmVzcG9uc2VzXG4gICAgICBzdHJpbmcgICAgcmVzcG9uc2VbMV0gKElTTy0xMDY0NiBVVEYtOClcbiAgICAgIC4uLlxuICAgICAgc3RyaW5nICAgIHJlc3BvbnNlW251bS1yZXNwb25zZXNdIChJU08tMTA2NDYgVVRGLTgpXG4gICAgKi9cbiAgICBpZiAoc2VsZi5fYXV0aHNRdWV1ZVswXSAhPT0gJ2tleWJvYXJkLWludGVyYWN0aXZlJykge1xuICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgc2VsZixcbiAgICAgICAgJ0luYm91bmQ6IFJlY2VpdmVkIHVuZXhwZWN0ZWQgcGF5bG9hZCB0eXBlIDYxJ1xuICAgICAgKTtcbiAgICB9XG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgbnVtUmVzcG9uc2VzID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGxldCByZXNwb25zZXM7XG4gICAgaWYgKG51bVJlc3BvbnNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXNwb25zZXMgPSBuZXcgQXJyYXkobnVtUmVzcG9uc2VzKTtcbiAgICAgIGxldCBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlc3BvbnNlczsgKytpKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXNwb25zZXNbaV0gPSByZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIGlmIChpICE9PSBudW1SZXNwb25zZXMpXG4gICAgICAgIHJlc3BvbnNlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAocmVzcG9uc2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdJbmJvdW5kOiBNYWxmb3JtZWQgVVNFUkFVVEhfSU5GT19SRVNQT05TRSBwYWNrZXQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKCdJbmJvdW5kOiBSZWNlaXZlZCBVU0VSQVVUSF9JTkZPX1JFU1BPTlNFJyk7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gc2VsZi5faGFuZGxlcnMuVVNFUkFVVEhfSU5GT19SRVNQT05TRTtcbiAgICBoYW5kbGVyICYmIGhhbmRsZXIoc2VsZiwgcmVzcG9uc2VzKTtcbiAgfSxcblxuICAvLyBDb25uZWN0aW9uIHByb3RvY29sIC0tIGdlbmVyaWMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgW01FU1NBR0UuR0xPQkFMX1JFUVVFU1RdOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgU1NIX01TR19HTE9CQUxfUkVRVUVTVFxuICAgICAgc3RyaW5nICAgIHJlcXVlc3QgbmFtZSBpbiBVUy1BU0NJSSBvbmx5XG4gICAgICBib29sZWFuICAgd2FudCByZXBseVxuICAgICAgLi4uLiAgICAgIHJlcXVlc3Qtc3BlY2lmaWMgZGF0YSBmb2xsb3dzXG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCBuYW1lID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgY29uc3Qgd2FudFJlcGx5ID0gYnVmZmVyUGFyc2VyLnJlYWRCb29sKCk7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKHdhbnRSZXBseSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSAndGNwaXAtZm9yd2FyZCc6XG4gICAgICAgIGNhc2UgJ2NhbmNlbC10Y3BpcC1mb3J3YXJkJzoge1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICBzdHJpbmcgICAgYWRkcmVzcyB0byBiaW5kIChlLmcuLCBcIjAuMC4wLjBcIilcbiAgICAgICAgICAgIHVpbnQzMiAgICBwb3J0IG51bWJlciB0byBiaW5kXG4gICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBiaW5kQWRkciA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGJpbmRQb3J0ID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICAgIGlmIChiaW5kUG9ydCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGF0YSA9IHsgYmluZEFkZHIsIGJpbmRQb3J0IH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3RyZWFtbG9jYWwtZm9yd2FyZEBvcGVuc3NoLmNvbSc6XG4gICAgICAgIGNhc2UgJ2NhbmNlbC1zdHJlYW1sb2NhbC1mb3J3YXJkQG9wZW5zc2guY29tJzoge1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICBzdHJpbmcgICAgc29ja2V0IHBhdGhcbiAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IHNvY2tldFBhdGggPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgICBpZiAoc29ja2V0UGF0aCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGF0YSA9IHsgc29ja2V0UGF0aCB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vLW1vcmUtc2Vzc2lvbnNAb3BlbnNzaC5jb20nOlxuICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdob3N0a2V5cy0wMEBvcGVuc3NoLmNvbSc6IHtcbiAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgd2hpbGUgKGJ1ZmZlclBhcnNlci5hdmFpbCgpID4gMCkge1xuICAgICAgICAgICAgY29uc3Qga2V5UmF3ID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChrZXlSYXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhcnNlS2V5KGtleVJhdyk7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW5zdGFuY2VvZiBFcnJvcikpXG4gICAgICAgICAgICAgIGRhdGEucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRhdGEgPSBidWZmZXJQYXJzZXIucmVhZFJhdygpO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdJbmJvdW5kOiBNYWxmb3JtZWQgR0xPQkFMX1JFUVVFU1QgcGFja2V0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZyhgSW5ib3VuZDogR0xPQkFMX1JFUVVFU1QgKCR7bmFtZX0pYCk7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gc2VsZi5faGFuZGxlcnMuR0xPQkFMX1JFUVVFU1Q7XG4gICAgaWYgKGhhbmRsZXIpXG4gICAgICBoYW5kbGVyKHNlbGYsIG5hbWUsIHdhbnRSZXBseSwgZGF0YSk7XG4gICAgZWxzZVxuICAgICAgc2VsZi5yZXF1ZXN0RmFpbHVyZSgpOyAvLyBBdXRvIHJlamVjdFxuICB9LFxuICBbTUVTU0FHRS5SRVFVRVNUX1NVQ0NFU1NdOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgU1NIX01TR19SRVFVRVNUX1NVQ0NFU1NcbiAgICAgIC4uLi4gICAgIHJlc3BvbnNlIHNwZWNpZmljIGRhdGFcbiAgICAqL1xuICAgIGNvbnN0IGRhdGEgPSAocGF5bG9hZC5sZW5ndGggPiAxID8gYnVmZmVyU2xpY2UocGF5bG9hZCwgMSkgOiBudWxsKTtcblxuICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKCdJbmJvdW5kOiBSRVFVRVNUX1NVQ0NFU1MnKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5SRVFVRVNUX1NVQ0NFU1M7XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyKHNlbGYsIGRhdGEpO1xuICB9LFxuICBbTUVTU0FHRS5SRVFVRVNUX0ZBSUxVUkVdOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgU1NIX01TR19SRVFVRVNUX0ZBSUxVUkVcbiAgICAqL1xuICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKCdJbmJvdW5kOiBSZWNlaXZlZCBSRVFVRVNUX0ZBSUxVUkUnKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5SRVFVRVNUX0ZBSUxVUkU7XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyKHNlbGYpO1xuICB9LFxuXG4gIC8vIENvbm5lY3Rpb24gcHJvdG9jb2wgLS0gY2hhbm5lbC1yZWxhdGVkID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBbTUVTU0FHRS5DSEFOTkVMX09QRU5dOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgU1NIX01TR19DSEFOTkVMX09QRU5cbiAgICAgIHN0cmluZyAgICBjaGFubmVsIHR5cGUgaW4gVVMtQVNDSUkgb25seVxuICAgICAgdWludDMyICAgIHNlbmRlciBjaGFubmVsXG4gICAgICB1aW50MzIgICAgaW5pdGlhbCB3aW5kb3cgc2l6ZVxuICAgICAgdWludDMyICAgIG1heGltdW0gcGFja2V0IHNpemVcbiAgICAgIC4uLi4gICAgICBjaGFubmVsIHR5cGUgc3BlY2lmaWMgZGF0YSBmb2xsb3dzXG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCB0eXBlID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgY29uc3Qgc2VuZGVyID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGNvbnN0IHdpbmRvdyA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBjb25zdCBwYWNrZXRTaXplID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGxldCBjaGFubmVsSW5mbztcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZm9yd2FyZGVkLXRjcGlwJzogLy8gUy0+Q1xuICAgICAgY2FzZSAnZGlyZWN0LXRjcGlwJzogeyAvLyBDLT5TXG4gICAgICAgIC8qXG4gICAgICAgICAgc3RyaW5nICAgIGFkZHJlc3MgdGhhdCB3YXMgY29ubmVjdGVkIC8gaG9zdCB0byBjb25uZWN0XG4gICAgICAgICAgdWludDMyICAgIHBvcnQgdGhhdCB3YXMgY29ubmVjdGVkIC8gcG9ydCB0byBjb25uZWN0XG4gICAgICAgICAgc3RyaW5nICAgIG9yaWdpbmF0b3IgSVAgYWRkcmVzc1xuICAgICAgICAgIHVpbnQzMiAgICBvcmlnaW5hdG9yIHBvcnRcbiAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZGVzdElQID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGRlc3RQb3J0ID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICBjb25zdCBzcmNJUCA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgICBjb25zdCBzcmNQb3J0ID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICBpZiAoc3JjUG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2hhbm5lbEluZm8gPSB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgc2VuZGVyLFxuICAgICAgICAgICAgd2luZG93LFxuICAgICAgICAgICAgcGFja2V0U2l6ZSxcbiAgICAgICAgICAgIGRhdGE6IHsgZGVzdElQLCBkZXN0UG9ydCwgc3JjSVAsIHNyY1BvcnQgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdmb3J3YXJkZWQtc3RyZWFtbG9jYWxAb3BlbnNzaC5jb20nOiAvLyBTLT5DXG4gICAgICBjYXNlICdkaXJlY3Qtc3RyZWFtbG9jYWxAb3BlbnNzaC5jb20nOiB7IC8vIEMtPlNcbiAgICAgICAgLypcbiAgICAgICAgICBzdHJpbmcgICAgc29ja2V0IHBhdGhcbiAgICAgICAgICBzdHJpbmcgICAgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2VcblxuICAgICAgICAgIChkaXJlY3Qtc3RyZWFtbG9jYWxAb3BlbnNzaC5jb20gYWRkaXRpb25hbGx5IGhhczopXG4gICAgICAgICAgdWludDMyICAgIHJlc2VydmVkXG4gICAgICAgICovXG4gICAgICAgIGNvbnN0IHNvY2tldFBhdGggPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgaWYgKHNvY2tldFBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNoYW5uZWxJbmZvID0ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHNlbmRlcixcbiAgICAgICAgICAgIHdpbmRvdyxcbiAgICAgICAgICAgIHBhY2tldFNpemUsXG4gICAgICAgICAgICBkYXRhOiB7IHNvY2tldFBhdGggfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICd4MTEnOiB7IC8vIFMtPkNcbiAgICAgICAgLypcbiAgICAgICAgICBzdHJpbmcgICAgb3JpZ2luYXRvciBhZGRyZXNzIChlLmcuLCBcIjE5Mi4xNjguNy4zOFwiKVxuICAgICAgICAgIHVpbnQzMiAgICBvcmlnaW5hdG9yIHBvcnRcbiAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc3JjSVAgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgY29uc3Qgc3JjUG9ydCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAgICAgaWYgKHNyY1BvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNoYW5uZWxJbmZvID0ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHNlbmRlcixcbiAgICAgICAgICAgIHdpbmRvdyxcbiAgICAgICAgICAgIHBhY2tldFNpemUsXG4gICAgICAgICAgICBkYXRhOiB7IHNyY0lQLCBzcmNQb3J0IH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gSW5jbHVkZXM6XG4gICAgICAgIC8vICAgJ3Nlc3Npb24nIChDLT5TKVxuICAgICAgICAvLyAgICdhdXRoLWFnZW50QG9wZW5zc2guY29tJyAoUy0+QylcbiAgICAgICAgY2hhbm5lbEluZm8gPSB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzZW5kZXIsXG4gICAgICAgICAgd2luZG93LFxuICAgICAgICAgIHBhY2tldFNpemUsXG4gICAgICAgICAgZGF0YToge31cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAoY2hhbm5lbEluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgc2VsZixcbiAgICAgICAgJ0luYm91bmQ6IE1hbGZvcm1lZCBDSEFOTkVMX09QRU4gcGFja2V0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZyhgSW5ib3VuZDogQ0hBTk5FTF9PUEVOIChzOiR7c2VuZGVyfSwgJHt0eXBlfSlgKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5DSEFOTkVMX09QRU47XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIoc2VsZiwgY2hhbm5lbEluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmNoYW5uZWxPcGVuRmFpbChcbiAgICAgICAgY2hhbm5lbEluZm8uc2VuZGVyLFxuICAgICAgICBDSEFOTkVMX09QRU5fRkFJTFVSRS5BRE1JTklTVFJBVElWRUxZX1BST0hJQklURUQsXG4gICAgICAgICcnLFxuICAgICAgICAnJ1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIFtNRVNTQUdFLkNIQU5ORUxfT1BFTl9DT05GSVJNQVRJT05dOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgU1NIX01TR19DSEFOTkVMX09QRU5fQ09ORklSTUFUSU9OXG4gICAgICB1aW50MzIgICAgcmVjaXBpZW50IGNoYW5uZWxcbiAgICAgIHVpbnQzMiAgICBzZW5kZXIgY2hhbm5lbFxuICAgICAgdWludDMyICAgIGluaXRpYWwgd2luZG93IHNpemVcbiAgICAgIHVpbnQzMiAgICBtYXhpbXVtIHBhY2tldCBzaXplXG4gICAgICAuLi4uICAgICAgY2hhbm5lbCB0eXBlIHNwZWNpZmljIGRhdGEgZm9sbG93c1xuICAgICovXG4gICAgLy8gXCJUaGUgJ3JlY2lwaWVudCBjaGFubmVsJyBpcyB0aGUgY2hhbm5lbCBudW1iZXIgZ2l2ZW4gaW4gdGhlXG4gICAgLy8gb3JpZ2luYWwgb3BlbiByZXF1ZXN0LCBhbmQgJ3NlbmRlciBjaGFubmVsJyBpcyB0aGUgY2hhbm5lbCBudW1iZXJcbiAgICAvLyBhbGxvY2F0ZWQgYnkgdGhlIG90aGVyIHNpZGUuXCJcbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZWNpcGllbnQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgY29uc3Qgc2VuZGVyID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGNvbnN0IHdpbmRvdyA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBjb25zdCBwYWNrZXRTaXplID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGNvbnN0IGRhdGEgPSAoYnVmZmVyUGFyc2VyLmF2YWlsKCkgPyBidWZmZXJQYXJzZXIucmVhZFJhdygpIDogdW5kZWZpbmVkKTtcbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgIGlmIChwYWNrZXRTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdJbmJvdW5kOiBNYWxmb3JtZWQgQ0hBTk5FTF9PUEVOX0NPTkZJUk1BVElPTiBwYWNrZXQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKFxuICAgICAgYEluYm91bmQ6IENIQU5ORUxfT1BFTl9DT05GSVJNQVRJT04gKHI6JHtyZWNpcGllbnR9LCBzOiR7c2VuZGVyfSlgXG4gICAgKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5DSEFOTkVMX09QRU5fQ09ORklSTUFUSU9OO1xuICAgIGlmIChoYW5kbGVyKVxuICAgICAgaGFuZGxlcihzZWxmLCB7IHJlY2lwaWVudCwgc2VuZGVyLCB3aW5kb3csIHBhY2tldFNpemUsIGRhdGEgfSk7XG4gIH0sXG4gIFtNRVNTQUdFLkNIQU5ORUxfT1BFTl9GQUlMVVJFXTogKHNlbGYsIHBheWxvYWQpID0+IHtcbiAgICAvKlxuICAgICAgYnl0ZSAgICAgIFNTSF9NU0dfQ0hBTk5FTF9PUEVOX0ZBSUxVUkVcbiAgICAgIHVpbnQzMiAgICByZWNpcGllbnQgY2hhbm5lbFxuICAgICAgdWludDMyICAgIHJlYXNvbiBjb2RlXG4gICAgICBzdHJpbmcgICAgZGVzY3JpcHRpb24gaW4gSVNPLTEwNjQ2IFVURi04IGVuY29kaW5nIFtSRkMzNjI5XVxuICAgICAgc3RyaW5nICAgIGxhbmd1YWdlIHRhZyBbUkZDMzA2Nl1cbiAgICAqL1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlY2lwaWVudCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBjb25zdCByZWFzb24gPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICBjb25zdCBsYW5nID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgIGlmIChsYW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdJbmJvdW5kOiBNYWxmb3JtZWQgQ0hBTk5FTF9PUEVOX0ZBSUxVUkUgcGFja2V0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kZWJ1Z1xuICAgICAgJiYgc2VsZi5fZGVidWcoYEluYm91bmQ6IENIQU5ORUxfT1BFTl9GQUlMVVJFIChyOiR7cmVjaXBpZW50fSlgKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5DSEFOTkVMX09QRU5fRkFJTFVSRTtcbiAgICBoYW5kbGVyICYmIGhhbmRsZXIoc2VsZiwgcmVjaXBpZW50LCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgfSxcbiAgW01FU1NBR0UuQ0hBTk5FTF9XSU5ET1dfQURKVVNUXTogKHNlbGYsIHBheWxvYWQpID0+IHtcbiAgICAvKlxuICAgICAgYnl0ZSAgICAgIFNTSF9NU0dfQ0hBTk5FTF9XSU5ET1dfQURKVVNUXG4gICAgICB1aW50MzIgICAgcmVjaXBpZW50IGNoYW5uZWxcbiAgICAgIHVpbnQzMiAgICBieXRlcyB0byBhZGRcbiAgICAqL1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlY2lwaWVudCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBjb25zdCBieXRlc1RvQWRkID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKGJ5dGVzVG9BZGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgc2VsZixcbiAgICAgICAgJ0luYm91bmQ6IE1hbGZvcm1lZCBDSEFOTkVMX1dJTkRPV19BREpVU1QgcGFja2V0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZyhcbiAgICAgIGBJbmJvdW5kOiBDSEFOTkVMX1dJTkRPV19BREpVU1QgKHI6JHtyZWNpcGllbnR9LCAke2J5dGVzVG9BZGR9KWBcbiAgICApO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IHNlbGYuX2hhbmRsZXJzLkNIQU5ORUxfV0lORE9XX0FESlVTVDtcbiAgICBoYW5kbGVyICYmIGhhbmRsZXIoc2VsZiwgcmVjaXBpZW50LCBieXRlc1RvQWRkKTtcbiAgfSxcbiAgW01FU1NBR0UuQ0hBTk5FTF9EQVRBXTogKHNlbGYsIHBheWxvYWQpID0+IHtcbiAgICAvKlxuICAgICAgYnl0ZSAgICAgIFNTSF9NU0dfQ0hBTk5FTF9EQVRBXG4gICAgICB1aW50MzIgICAgcmVjaXBpZW50IGNoYW5uZWxcbiAgICAgIHN0cmluZyAgICBkYXRhXG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZWNpcGllbnQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgY29uc3QgZGF0YSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICBzZWxmLFxuICAgICAgICAnSW5ib3VuZDogTWFsZm9ybWVkIENIQU5ORUxfREFUQSBwYWNrZXQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHNlbGYuX2RlYnVnXG4gICAgICAmJiBzZWxmLl9kZWJ1ZyhgSW5ib3VuZDogQ0hBTk5FTF9EQVRBIChyOiR7cmVjaXBpZW50fSwgJHtkYXRhLmxlbmd0aH0pYCk7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gc2VsZi5faGFuZGxlcnMuQ0hBTk5FTF9EQVRBO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlcihzZWxmLCByZWNpcGllbnQsIGRhdGEpO1xuICB9LFxuICBbTUVTU0FHRS5DSEFOTkVMX0VYVEVOREVEX0RBVEFdOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgU1NIX01TR19DSEFOTkVMX0VYVEVOREVEX0RBVEFcbiAgICAgIHVpbnQzMiAgICByZWNpcGllbnQgY2hhbm5lbFxuICAgICAgdWludDMyICAgIGRhdGFfdHlwZV9jb2RlXG4gICAgICBzdHJpbmcgICAgZGF0YVxuICAgICovXG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgcmVjaXBpZW50ID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGNvbnN0IHR5cGUgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgY29uc3QgZGF0YSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICBzZWxmLFxuICAgICAgICAnSW5ib3VuZDogTWFsZm9ybWVkIENIQU5ORUxfRVhURU5ERURfREFUQSBwYWNrZXQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKFxuICAgICAgYEluYm91bmQ6IENIQU5ORUxfRVhURU5ERURfREFUQSAocjoke3JlY2lwaWVudH0sICR7ZGF0YS5sZW5ndGh9KWBcbiAgICApO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IHNlbGYuX2hhbmRsZXJzLkNIQU5ORUxfRVhURU5ERURfREFUQTtcbiAgICBoYW5kbGVyICYmIGhhbmRsZXIoc2VsZiwgcmVjaXBpZW50LCBkYXRhLCB0eXBlKTtcbiAgfSxcbiAgW01FU1NBR0UuQ0hBTk5FTF9FT0ZdOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgU1NIX01TR19DSEFOTkVMX0VPRlxuICAgICAgdWludDMyICAgIHJlY2lwaWVudCBjaGFubmVsXG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZWNpcGllbnQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAocmVjaXBpZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdJbmJvdW5kOiBNYWxmb3JtZWQgQ0hBTk5FTF9FT0YgcGFja2V0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZyhgSW5ib3VuZDogQ0hBTk5FTF9FT0YgKHI6JHtyZWNpcGllbnR9KWApO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IHNlbGYuX2hhbmRsZXJzLkNIQU5ORUxfRU9GO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlcihzZWxmLCByZWNpcGllbnQpO1xuICB9LFxuICBbTUVTU0FHRS5DSEFOTkVMX0NMT1NFXTogKHNlbGYsIHBheWxvYWQpID0+IHtcbiAgICAvKlxuICAgICAgYnl0ZSAgICAgIFNTSF9NU0dfQ0hBTk5FTF9DTE9TRVxuICAgICAgdWludDMyICAgIHJlY2lwaWVudCBjaGFubmVsXG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZWNpcGllbnQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAocmVjaXBpZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdJbmJvdW5kOiBNYWxmb3JtZWQgQ0hBTk5FTF9DTE9TRSBwYWNrZXQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKGBJbmJvdW5kOiBDSEFOTkVMX0NMT1NFIChyOiR7cmVjaXBpZW50fSlgKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5DSEFOTkVMX0NMT1NFO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlcihzZWxmLCByZWNpcGllbnQpO1xuICB9LFxuICBbTUVTU0FHRS5DSEFOTkVMX1JFUVVFU1RdOiAoc2VsZiwgcGF5bG9hZCkgPT4ge1xuICAgIC8qXG4gICAgICBieXRlICAgICAgU1NIX01TR19DSEFOTkVMX1JFUVVFU1RcbiAgICAgIHVpbnQzMiAgICByZWNpcGllbnQgY2hhbm5lbFxuICAgICAgc3RyaW5nICAgIHJlcXVlc3QgdHlwZSBpbiBVUy1BU0NJSSBjaGFyYWN0ZXJzIG9ubHlcbiAgICAgIGJvb2xlYW4gICB3YW50IHJlcGx5XG4gICAgICAuLi4uICAgICAgdHlwZS1zcGVjaWZpYyBkYXRhIGZvbGxvd3NcbiAgICAqL1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlY2lwaWVudCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBjb25zdCB0eXBlID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgY29uc3Qgd2FudFJlcGx5ID0gYnVmZmVyUGFyc2VyLnJlYWRCb29sKCk7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKHdhbnRSZXBseSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXhpdC1zdGF0dXMnOiAvLyBTLT5DXG4gICAgICAgICAgLypcbiAgICAgICAgICAgIHVpbnQzMiAgICBleGl0X3N0YXR1c1xuICAgICAgICAgICovXG4gICAgICAgICAgZGF0YSA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAgICAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZyhcbiAgICAgICAgICAgIGBJbmJvdW5kOiBDSEFOTkVMX1JFUVVFU1QgKHI6JHtyZWNpcGllbnR9LCAke3R5cGV9OiAke2RhdGF9KWBcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdleGl0LXNpZ25hbCc6IHsgLy8gUy0+Q1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICBzdHJpbmcgICAgc2lnbmFsIG5hbWUgKHdpdGhvdXQgdGhlIFwiU0lHXCIgcHJlZml4KVxuICAgICAgICAgICAgYm9vbGVhbiAgIGNvcmUgZHVtcGVkXG4gICAgICAgICAgICBzdHJpbmcgICAgZXJyb3IgbWVzc2FnZSBpbiBJU08tMTA2NDYgVVRGLTggZW5jb2RpbmdcbiAgICAgICAgICAgIHN0cmluZyAgICBsYW5ndWFnZSB0YWdcbiAgICAgICAgICAqL1xuICAgICAgICAgIGxldCBzaWduYWw7XG4gICAgICAgICAgbGV0IGNvcmVEdW1wZWQ7XG4gICAgICAgICAgaWYgKHNlbGYuX2NvbXBhdEZsYWdzICYgQ09NUEFULk9MRF9FWElUKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBJbnN0ZWFkIG9mIGBzaWduYWwgbmFtZWAgYW5kIGBjb3JlIGR1bXBlZGAsIHdlIGhhdmUganVzdDpcbiAgICAgICAgICAgICAgICB1aW50MzIgIHNpZ25hbCBudW1iZXJcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBudW0gPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG51bSkge1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc2lnbmFsID0gJ0hVUCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBzaWduYWwgPSAnSU5UJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHNpZ25hbCA9ICdRVUlUJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHNpZ25hbCA9ICdBQlJUJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHNpZ25hbCA9ICdLSUxMJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBzaWduYWwgPSAnQUxSTSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgc2lnbmFsID0gJ1RFUk0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChudW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgLy8gVW5rbm93biBvciBPUy1zcGVjaWZpY1xuICAgICAgICAgICAgICAgICAgc2lnbmFsID0gYFVOS05PV04gKCR7bnVtfSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvcmVEdW1wZWQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmFsID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgICAgICBjb3JlRHVtcGVkID0gYnVmZmVyUGFyc2VyLnJlYWRCb29sKCk7XG4gICAgICAgICAgICBpZiAoY29yZUR1bXBlZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICBzaWduYWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgICAgIGlmIChidWZmZXJQYXJzZXIuc2tpcFN0cmluZygpICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBkYXRhID0geyBzaWduYWwsIGNvcmVEdW1wZWQsIGVycm9yTWVzc2FnZSB9O1xuICAgICAgICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKFxuICAgICAgICAgICAgYEluYm91bmQ6IENIQU5ORUxfUkVRVUVTVCAocjoke3JlY2lwaWVudH0sICR7dHlwZX06ICR7c2lnbmFsfSlgXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwdHktcmVxJzogeyAvLyBDLT5TXG4gICAgICAgICAgLypcbiAgICAgICAgICAgIHN0cmluZyAgICBURVJNIGVudmlyb25tZW50IHZhcmlhYmxlIHZhbHVlIChlLmcuLCB2dDEwMClcbiAgICAgICAgICAgIHVpbnQzMiAgICB0ZXJtaW5hbCB3aWR0aCwgY2hhcmFjdGVycyAoZS5nLiwgODApXG4gICAgICAgICAgICB1aW50MzIgICAgdGVybWluYWwgaGVpZ2h0LCByb3dzIChlLmcuLCAyNClcbiAgICAgICAgICAgIHVpbnQzMiAgICB0ZXJtaW5hbCB3aWR0aCwgcGl4ZWxzIChlLmcuLCA2NDApXG4gICAgICAgICAgICB1aW50MzIgICAgdGVybWluYWwgaGVpZ2h0LCBwaXhlbHMgKGUuZy4sIDQ4MClcbiAgICAgICAgICAgIHN0cmluZyAgICBlbmNvZGVkIHRlcm1pbmFsIG1vZGVzXG4gICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCB0ZXJtID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgICAgY29uc3QgY29scyA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAgICAgICBjb25zdCByb3dzID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAgICAgICBjb25zdCBtb2Rlc0JpbmFyeSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKG1vZGVzQmluYXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJ1ZmZlclBhcnNlci5pbml0KG1vZGVzQmluYXJ5LCAxKTtcbiAgICAgICAgICAgIGxldCBtb2RlcyA9IHt9O1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlclBhcnNlci5hdmFpbCgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9wY29kZSA9IGJ1ZmZlclBhcnNlci5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgICBpZiAob3Bjb2RlID09PSBURVJNSU5BTF9NT0RFLlRUWV9PUF9FTkQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBURVJNSU5BTF9NT0RFX0JZX1ZBTFVFW29wY29kZV07XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICAgICAgICBpZiAob3Bjb2RlID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgIHx8IG5hbWUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1vZGVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1vZGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kZXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgZGF0YSA9IHsgdGVybSwgY29scywgcm93cywgd2lkdGgsIGhlaWdodCwgbW9kZXMgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5fZGVidWcgJiYgc2VsZi5fZGVidWcoXG4gICAgICAgICAgICBgSW5ib3VuZDogQ0hBTk5FTF9SRVFVRVNUIChyOiR7cmVjaXBpZW50fSwgJHt0eXBlfSlgXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd3aW5kb3ctY2hhbmdlJzogeyAvLyBDLT5TXG4gICAgICAgICAgLypcbiAgICAgICAgICAgIHVpbnQzMiAgICB0ZXJtaW5hbCB3aWR0aCwgY29sdW1uc1xuICAgICAgICAgICAgdWludDMyICAgIHRlcm1pbmFsIGhlaWdodCwgcm93c1xuICAgICAgICAgICAgdWludDMyICAgIHRlcm1pbmFsIHdpZHRoLCBwaXhlbHNcbiAgICAgICAgICAgIHVpbnQzMiAgICB0ZXJtaW5hbCBoZWlnaHQsIHBpeGVsc1xuICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgY29scyA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAgICAgICBjb25zdCByb3dzID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAgICAgICBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBkYXRhID0geyBjb2xzLCByb3dzLCB3aWR0aCwgaGVpZ2h0IH07XG4gICAgICAgICAgc2VsZi5fZGVidWcgJiYgc2VsZi5fZGVidWcoXG4gICAgICAgICAgICBgSW5ib3VuZDogQ0hBTk5FTF9SRVFVRVNUIChyOiR7cmVjaXBpZW50fSwgJHt0eXBlfSlgXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd4MTEtcmVxJzogeyAvLyBDLT5TXG4gICAgICAgICAgLypcbiAgICAgICAgICAgIGJvb2xlYW4gICBzaW5nbGUgY29ubmVjdGlvblxuICAgICAgICAgICAgc3RyaW5nICAgIHgxMSBhdXRoZW50aWNhdGlvbiBwcm90b2NvbFxuICAgICAgICAgICAgc3RyaW5nICAgIHgxMSBhdXRoZW50aWNhdGlvbiBjb29raWVcbiAgICAgICAgICAgIHVpbnQzMiAgICB4MTEgc2NyZWVuIG51bWJlclxuICAgICAgICAgICovXG4gICAgICAgICAgY29uc3Qgc2luZ2xlID0gYnVmZmVyUGFyc2VyLnJlYWRCb29sKCk7XG4gICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgICBjb25zdCBjb29raWUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgICAgICAgIGNvbnN0IHNjcmVlbiA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAgICAgICBpZiAoc2NyZWVuICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBkYXRhID0geyBzaW5nbGUsIHByb3RvY29sLCBjb29raWUsIHNjcmVlbiB9O1xuICAgICAgICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKFxuICAgICAgICAgICAgYEluYm91bmQ6IENIQU5ORUxfUkVRVUVTVCAocjoke3JlY2lwaWVudH0sICR7dHlwZX0pYFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZW52JzogeyAvLyBDLT5TXG4gICAgICAgICAgLypcbiAgICAgICAgICAgIHN0cmluZyAgICB2YXJpYWJsZSBuYW1lXG4gICAgICAgICAgICBzdHJpbmcgICAgdmFyaWFibGUgdmFsdWVcbiAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGF0YSA9IHsgbmFtZSwgdmFsdWUgfTtcbiAgICAgICAgICBpZiAoc2VsZi5fZGVidWcpIHtcbiAgICAgICAgICAgIHNlbGYuX2RlYnVnKFxuICAgICAgICAgICAgICBgSW5ib3VuZDogQ0hBTk5FTF9SRVFVRVNUIChyOiR7cmVjaXBpZW50fSwgJHt0eXBlfTogYFxuICAgICAgICAgICAgICAgICsgYCR7bmFtZX09JHt2YWx1ZX0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc2hlbGwnOiAvLyBDLT5TXG4gICAgICAgICAgZGF0YSA9IG51bGw7IC8vIE5vIGV4dHJhIGRhdGFcbiAgICAgICAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZyhcbiAgICAgICAgICAgIGBJbmJvdW5kOiBDSEFOTkVMX1JFUVVFU1QgKHI6JHtyZWNpcGllbnR9LCAke3R5cGV9KWBcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdleGVjJzogLy8gQy0+U1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICBzdHJpbmcgICAgY29tbWFuZFxuICAgICAgICAgICovXG4gICAgICAgICAgZGF0YSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKFxuICAgICAgICAgICAgYEluYm91bmQ6IENIQU5ORUxfUkVRVUVTVCAocjoke3JlY2lwaWVudH0sICR7dHlwZX06ICR7ZGF0YX0pYFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N1YnN5c3RlbSc6IC8vIEMtPlNcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgc3RyaW5nICAgIHN1YnN5c3RlbSBuYW1lXG4gICAgICAgICAgKi9cbiAgICAgICAgICBkYXRhID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgICAgc2VsZi5fZGVidWcgJiYgc2VsZi5fZGVidWcoXG4gICAgICAgICAgICBgSW5ib3VuZDogQ0hBTk5FTF9SRVFVRVNUIChyOiR7cmVjaXBpZW50fSwgJHt0eXBlfTogJHtkYXRhfSlgXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2lnbmFsJzogLy8gQy0+U1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICBzdHJpbmcgICAgc2lnbmFsIG5hbWUgKHdpdGhvdXQgdGhlIFwiU0lHXCIgcHJlZml4KVxuICAgICAgICAgICovXG4gICAgICAgICAgZGF0YSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKFxuICAgICAgICAgICAgYEluYm91bmQ6IENIQU5ORUxfUkVRVUVTVCAocjoke3JlY2lwaWVudH0sICR7dHlwZX06ICR7ZGF0YX0pYFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3hvbi14b2ZmJzogLy8gQy0+U1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICBib29sZWFuICAgY2xpZW50IGNhbiBkb1xuICAgICAgICAgICovXG4gICAgICAgICAgZGF0YSA9IGJ1ZmZlclBhcnNlci5yZWFkQm9vbCgpO1xuICAgICAgICAgIHNlbGYuX2RlYnVnICYmIHNlbGYuX2RlYnVnKFxuICAgICAgICAgICAgYEluYm91bmQ6IENIQU5ORUxfUkVRVUVTVCAocjoke3JlY2lwaWVudH0sICR7dHlwZX06ICR7ZGF0YX0pYFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2F1dGgtYWdlbnQtcmVxQG9wZW5zc2guY29tJzogLy8gQy1TXG4gICAgICAgICAgZGF0YSA9IG51bGw7IC8vIE5vIGV4dHJhIGRhdGFcbiAgICAgICAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZyhcbiAgICAgICAgICAgIGBJbmJvdW5kOiBDSEFOTkVMX1JFUVVFU1QgKHI6JHtyZWNpcGllbnR9LCAke3R5cGV9KWBcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRhdGEgPSAoYnVmZmVyUGFyc2VyLmF2YWlsKCkgPyBidWZmZXJQYXJzZXIucmVhZFJhdygpIDogbnVsbCk7XG4gICAgICAgICAgc2VsZi5fZGVidWcgJiYgc2VsZi5fZGVidWcoXG4gICAgICAgICAgICBgSW5ib3VuZDogQ0hBTk5FTF9SRVFVRVNUIChyOiR7cmVjaXBpZW50fSwgJHt0eXBlfSlgXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICBzZWxmLFxuICAgICAgICAnSW5ib3VuZDogTWFsZm9ybWVkIENIQU5ORUxfUkVRVUVTVCBwYWNrZXQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5DSEFOTkVMX1JFUVVFU1Q7XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyKHNlbGYsIHJlY2lwaWVudCwgdHlwZSwgd2FudFJlcGx5LCBkYXRhKTtcbiAgfSxcbiAgW01FU1NBR0UuQ0hBTk5FTF9TVUNDRVNTXTogKHNlbGYsIHBheWxvYWQpID0+IHtcbiAgICAvKlxuICAgICAgYnl0ZSAgICAgIFNTSF9NU0dfQ0hBTk5FTF9TVUNDRVNTXG4gICAgICB1aW50MzIgICAgcmVjaXBpZW50IGNoYW5uZWxcbiAgICAqL1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlY2lwaWVudCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgIGlmIChyZWNpcGllbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgc2VsZixcbiAgICAgICAgJ0luYm91bmQ6IE1hbGZvcm1lZCBDSEFOTkVMX1NVQ0NFU1MgcGFja2V0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZyhgSW5ib3VuZDogQ0hBTk5FTF9TVUNDRVNTIChyOiR7cmVjaXBpZW50fSlgKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBzZWxmLl9oYW5kbGVycy5DSEFOTkVMX1NVQ0NFU1M7XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyKHNlbGYsIHJlY2lwaWVudCk7XG4gIH0sXG4gIFtNRVNTQUdFLkNIQU5ORUxfRkFJTFVSRV06IChzZWxmLCBwYXlsb2FkKSA9PiB7XG4gICAgLypcbiAgICAgIGJ5dGUgICAgICBTU0hfTVNHX0NIQU5ORUxfRkFJTFVSRVxuICAgICAgdWludDMyICAgIHJlY2lwaWVudCBjaGFubmVsXG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZWNpcGllbnQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAocmVjaXBpZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdJbmJvdW5kOiBNYWxmb3JtZWQgQ0hBTk5FTF9GQUlMVVJFIHBhY2tldCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc2VsZi5fZGVidWcgJiYgc2VsZi5fZGVidWcoYEluYm91bmQ6IENIQU5ORUxfRkFJTFVSRSAocjoke3JlY2lwaWVudH0pYCk7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gc2VsZi5faGFuZGxlcnMuQ0hBTk5FTF9GQUlMVVJFO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlcihzZWxmLCByZWNpcGllbnQpO1xuICB9LFxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1FU1NBR0VfSEFORExFUlMgPSBuZXcgQXJyYXkoMjU2KTtcbltcbiAgcmVxdWlyZSgnLi9rZXguanMnKS5IQU5ETEVSUyxcbiAgcmVxdWlyZSgnLi9oYW5kbGVycy5taXNjLmpzJyksXG5dLmZvckVhY2goKGhhbmRsZXJzKSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgZm9yIChsZXQgW3R5cGUsIGhhbmRsZXJdIG9mIE9iamVjdC5lbnRyaWVzKGhhbmRsZXJzKSkge1xuICAgIHR5cGUgPSArdHlwZTtcbiAgICBpZiAoaXNGaW5pdGUodHlwZSkgJiYgdHlwZSA+PSAwICYmIHR5cGUgPCBNRVNTQUdFX0hBTkRMRVJTLmxlbmd0aClcbiAgICAgIE1FU1NBR0VfSEFORExFUlNbdHlwZV0gPSBoYW5kbGVyO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNRVNTQUdFX0hBTkRMRVJTO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuICBjcmVhdGVEaWZmaWVIZWxsbWFuLFxuICBjcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXAsXG4gIGNyZWF0ZUVDREgsXG4gIGNyZWF0ZUhhc2gsXG4gIGNyZWF0ZVB1YmxpY0tleSxcbiAgZGlmZmllSGVsbG1hbixcbiAgZ2VuZXJhdGVLZXlQYWlyU3luYyxcbiAgcmFuZG9tRmlsbFN5bmMsXG59ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IHsgQmVyIH0gPSByZXF1aXJlKCdhc24xJyk7XG5cbmNvbnN0IHtcbiAgQ09NUEFULFxuICBjdXJ2ZTI1NTE5U3VwcG9ydGVkLFxuICBERUZBVUxUX0tFWCxcbiAgREVGQVVMVF9TRVJWRVJfSE9TVF9LRVksXG4gIERFRkFVTFRfQ0lQSEVSLFxuICBERUZBVUxUX01BQyxcbiAgREVGQVVMVF9DT01QUkVTU0lPTixcbiAgRElTQ09OTkVDVF9SRUFTT04sXG4gIE1FU1NBR0UsXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMuanMnKTtcbmNvbnN0IHtcbiAgQ0lQSEVSX0lORk8sXG4gIGNyZWF0ZUNpcGhlcixcbiAgY3JlYXRlRGVjaXBoZXIsXG4gIE1BQ19JTkZPLFxufSA9IHJlcXVpcmUoJy4vY3J5cHRvLmpzJyk7XG5jb25zdCB7IHBhcnNlREVSS2V5IH0gPSByZXF1aXJlKCcuL2tleVBhcnNlci5qcycpO1xuY29uc3Qge1xuICBidWZmZXJGaWxsLFxuICBidWZmZXJQYXJzZXIsXG4gIGNvbnZlcnRTaWduYXR1cmUsXG4gIGRvRmF0YWxFcnJvcixcbiAgRmFzdEJ1ZmZlcixcbiAgc2lnU1NIVG9BU04xLFxuICB3cml0ZVVJbnQzMkJFLFxufSA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcbmNvbnN0IHtcbiAgUGFja2V0UmVhZGVyLFxuICBQYWNrZXRXcml0ZXIsXG4gIFpsaWJQYWNrZXRSZWFkZXIsXG4gIFpsaWJQYWNrZXRXcml0ZXIsXG59ID0gcmVxdWlyZSgnLi96bGliLmpzJyk7XG5cbmxldCBNRVNTQUdFX0hBTkRMRVJTO1xuXG5jb25zdCBHRVhfTUlOX0JJVFMgPSAyMDQ4OyAvLyBSRkMgODI3MFxuY29uc3QgR0VYX01BWF9CSVRTID0gODE5MjsgLy8gUkZDIDgyNzBcblxuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jKDApO1xuXG4vLyBDbGllbnQvU2VydmVyXG5mdW5jdGlvbiBrZXhpbml0KHNlbGYpIHtcbiAgLypcbiAgICBieXRlICAgICAgICAgU1NIX01TR19LRVhJTklUXG4gICAgYnl0ZVsxNl0gICAgIGNvb2tpZSAocmFuZG9tIGJ5dGVzKVxuICAgIG5hbWUtbGlzdCAgICBrZXhfYWxnb3JpdGhtc1xuICAgIG5hbWUtbGlzdCAgICBzZXJ2ZXJfaG9zdF9rZXlfYWxnb3JpdGhtc1xuICAgIG5hbWUtbGlzdCAgICBlbmNyeXB0aW9uX2FsZ29yaXRobXNfY2xpZW50X3RvX3NlcnZlclxuICAgIG5hbWUtbGlzdCAgICBlbmNyeXB0aW9uX2FsZ29yaXRobXNfc2VydmVyX3RvX2NsaWVudFxuICAgIG5hbWUtbGlzdCAgICBtYWNfYWxnb3JpdGhtc19jbGllbnRfdG9fc2VydmVyXG4gICAgbmFtZS1saXN0ICAgIG1hY19hbGdvcml0aG1zX3NlcnZlcl90b19jbGllbnRcbiAgICBuYW1lLWxpc3QgICAgY29tcHJlc3Npb25fYWxnb3JpdGhtc19jbGllbnRfdG9fc2VydmVyXG4gICAgbmFtZS1saXN0ICAgIGNvbXByZXNzaW9uX2FsZ29yaXRobXNfc2VydmVyX3RvX2NsaWVudFxuICAgIG5hbWUtbGlzdCAgICBsYW5ndWFnZXNfY2xpZW50X3RvX3NlcnZlclxuICAgIG5hbWUtbGlzdCAgICBsYW5ndWFnZXNfc2VydmVyX3RvX2NsaWVudFxuICAgIGJvb2xlYW4gICAgICBmaXJzdF9rZXhfcGFja2V0X2ZvbGxvd3NcbiAgICB1aW50MzIgICAgICAgMCAocmVzZXJ2ZWQgZm9yIGZ1dHVyZSBleHRlbnNpb24pXG4gICovXG5cbiAgbGV0IHBheWxvYWQ7XG4gIGlmIChzZWxmLl9jb21wYXRGbGFncyAmIENPTVBBVC5CQURfREhHRVgpIHtcbiAgICBjb25zdCBlbnRyeSA9IHNlbGYuX29mZmVyLmxpc3RzLmtleDtcbiAgICBsZXQga2V4ID0gZW50cnkuYXJyYXk7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXgubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChrZXhbaV0uaW5jbHVkZXMoJ2dyb3VwLWV4Y2hhbmdlJykpIHtcbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAvLyBDb3B5IGFycmF5IGxhemlseVxuICAgICAgICAgIGtleCA9IGtleC5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGtleC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICBsZXQgbGVuID0gMSArIDE2ICsgc2VsZi5fb2ZmZXIudG90YWxTaXplICsgMSArIDQ7XG4gICAgICBjb25zdCBuZXdLZXhCdWYgPSBCdWZmZXIuZnJvbShrZXguam9pbignLCcpKTtcbiAgICAgIGxlbiAtPSAoZW50cnkuYnVmZmVyLmxlbmd0aCAtIG5ld0tleEJ1Zi5sZW5ndGgpO1xuXG4gICAgICBjb25zdCBhbGwgPSBzZWxmLl9vZmZlci5saXN0cy5hbGw7XG4gICAgICBjb25zdCByZXN0ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIGFsbC5idWZmZXIsXG4gICAgICAgIGFsbC5ieXRlT2Zmc2V0ICsgNCArIGVudHJ5LmJ1ZmZlci5sZW5ndGgsXG4gICAgICAgIGFsbC5sZW5ndGggLSAoNCArIGVudHJ5LmJ1ZmZlci5sZW5ndGgpXG4gICAgICApO1xuXG4gICAgICBwYXlsb2FkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbik7XG4gICAgICB3cml0ZVVJbnQzMkJFKHBheWxvYWQsIG5ld0tleEJ1Zi5sZW5ndGgsIDE3KTtcbiAgICAgIHBheWxvYWQuc2V0KG5ld0tleEJ1ZiwgMTcgKyA0KTtcbiAgICAgIHBheWxvYWQuc2V0KHJlc3QsIDE3ICsgNCArIG5ld0tleEJ1Zi5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXlsb2FkID09PSB1bmRlZmluZWQpIHtcbiAgICBwYXlsb2FkID0gQnVmZmVyLmFsbG9jVW5zYWZlKDEgKyAxNiArIHNlbGYuX29mZmVyLnRvdGFsU2l6ZSArIDEgKyA0KTtcbiAgICBzZWxmLl9vZmZlci5jb3B5QWxsVG8ocGF5bG9hZCwgMTcpO1xuICB9XG5cbiAgc2VsZi5fZGVidWcgJiYgc2VsZi5fZGVidWcoJ091dGJvdW5kOiBTZW5kaW5nIEtFWElOSVQnKTtcblxuICBwYXlsb2FkWzBdID0gTUVTU0FHRS5LRVhJTklUO1xuICByYW5kb21GaWxsU3luYyhwYXlsb2FkLCAxLCAxNik7XG5cbiAgLy8gWmVyby1maWxsIGZpcnN0X2tleF9wYWNrZXRfZm9sbG93cyBhbmQgcmVzZXJ2ZWQgYnl0ZXNcbiAgYnVmZmVyRmlsbChwYXlsb2FkLCAwLCBwYXlsb2FkLmxlbmd0aCAtIDUpO1xuXG4gIHNlbGYuX2tleGluaXQgPSBwYXlsb2FkO1xuXG4gIC8vIE5lZWRlZCB0byBjb3JyZWN0IHRoZSBzdGFydGluZyBwb3NpdGlvbiBpbiBhbGxvY2F0ZWQgXCJwYWNrZXRzXCIgd2hlbiBwYWNrZXRzXG4gIC8vIHdpbGwgYmUgYnVmZmVyZWQgZHVlIHRvIGFjdGl2ZSBrZXkgZXhjaGFuZ2VcbiAgc2VsZi5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydCA9IDA7XG5cbiAgLy8gVE9ETzogb25seSBjcmVhdGUgc2luZ2xlIGJ1ZmZlciBhbmQgc2V0IF9rZXhpbml0IGFzIHNsaWNlIG9mIHBhY2tldCBpbnN0ZWFkXG4gIHtcbiAgICBjb25zdCBwID0gc2VsZi5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydEtFWDtcbiAgICBjb25zdCBwYWNrZXQgPSBzZWxmLl9wYWNrZXRSVy53cml0ZS5hbGxvYyhwYXlsb2FkLmxlbmd0aCwgdHJ1ZSk7XG4gICAgcGFja2V0LnNldChwYXlsb2FkLCBwKTtcbiAgICBzZWxmLl9jaXBoZXIuZW5jcnlwdChzZWxmLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQsIHRydWUpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVLZXhJbml0KHNlbGYsIHBheWxvYWQpIHtcbiAgLypcbiAgICBieXRlICAgICAgICAgU1NIX01TR19LRVhJTklUXG4gICAgYnl0ZVsxNl0gICAgIGNvb2tpZSAocmFuZG9tIGJ5dGVzKVxuICAgIG5hbWUtbGlzdCAgICBrZXhfYWxnb3JpdGhtc1xuICAgIG5hbWUtbGlzdCAgICBzZXJ2ZXJfaG9zdF9rZXlfYWxnb3JpdGhtc1xuICAgIG5hbWUtbGlzdCAgICBlbmNyeXB0aW9uX2FsZ29yaXRobXNfY2xpZW50X3RvX3NlcnZlclxuICAgIG5hbWUtbGlzdCAgICBlbmNyeXB0aW9uX2FsZ29yaXRobXNfc2VydmVyX3RvX2NsaWVudFxuICAgIG5hbWUtbGlzdCAgICBtYWNfYWxnb3JpdGhtc19jbGllbnRfdG9fc2VydmVyXG4gICAgbmFtZS1saXN0ICAgIG1hY19hbGdvcml0aG1zX3NlcnZlcl90b19jbGllbnRcbiAgICBuYW1lLWxpc3QgICAgY29tcHJlc3Npb25fYWxnb3JpdGhtc19jbGllbnRfdG9fc2VydmVyXG4gICAgbmFtZS1saXN0ICAgIGNvbXByZXNzaW9uX2FsZ29yaXRobXNfc2VydmVyX3RvX2NsaWVudFxuICAgIG5hbWUtbGlzdCAgICBsYW5ndWFnZXNfY2xpZW50X3RvX3NlcnZlclxuICAgIG5hbWUtbGlzdCAgICBsYW5ndWFnZXNfc2VydmVyX3RvX2NsaWVudFxuICAgIGJvb2xlYW4gICAgICBmaXJzdF9rZXhfcGFja2V0X2ZvbGxvd3NcbiAgICB1aW50MzIgICAgICAgMCAocmVzZXJ2ZWQgZm9yIGZ1dHVyZSBleHRlbnNpb24pXG4gICovXG4gIGNvbnN0IGluaXQgPSB7XG4gICAga2V4OiB1bmRlZmluZWQsXG4gICAgc2VydmVySG9zdEtleTogdW5kZWZpbmVkLFxuICAgIGNzOiB7XG4gICAgICBjaXBoZXI6IHVuZGVmaW5lZCxcbiAgICAgIG1hYzogdW5kZWZpbmVkLFxuICAgICAgY29tcHJlc3M6IHVuZGVmaW5lZCxcbiAgICAgIGxhbmc6IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIHNjOiB7XG4gICAgICBjaXBoZXI6IHVuZGVmaW5lZCxcbiAgICAgIG1hYzogdW5kZWZpbmVkLFxuICAgICAgY29tcHJlc3M6IHVuZGVmaW5lZCxcbiAgICAgIGxhbmc6IHVuZGVmaW5lZCxcbiAgICB9LFxuICB9O1xuXG4gIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDE3KTtcblxuICBpZiAoKGluaXQua2V4ID0gYnVmZmVyUGFyc2VyLnJlYWRMaXN0KCkpID09PSB1bmRlZmluZWRcbiAgICAgIHx8IChpbml0LnNlcnZlckhvc3RLZXkgPSBidWZmZXJQYXJzZXIucmVhZExpc3QoKSkgPT09IHVuZGVmaW5lZFxuICAgICAgfHwgKGluaXQuY3MuY2lwaGVyID0gYnVmZmVyUGFyc2VyLnJlYWRMaXN0KCkpID09PSB1bmRlZmluZWRcbiAgICAgIHx8IChpbml0LnNjLmNpcGhlciA9IGJ1ZmZlclBhcnNlci5yZWFkTGlzdCgpKSA9PT0gdW5kZWZpbmVkXG4gICAgICB8fCAoaW5pdC5jcy5tYWMgPSBidWZmZXJQYXJzZXIucmVhZExpc3QoKSkgPT09IHVuZGVmaW5lZFxuICAgICAgfHwgKGluaXQuc2MubWFjID0gYnVmZmVyUGFyc2VyLnJlYWRMaXN0KCkpID09PSB1bmRlZmluZWRcbiAgICAgIHx8IChpbml0LmNzLmNvbXByZXNzID0gYnVmZmVyUGFyc2VyLnJlYWRMaXN0KCkpID09PSB1bmRlZmluZWRcbiAgICAgIHx8IChpbml0LnNjLmNvbXByZXNzID0gYnVmZmVyUGFyc2VyLnJlYWRMaXN0KCkpID09PSB1bmRlZmluZWRcbiAgICAgIHx8IChpbml0LmNzLmxhbmcgPSBidWZmZXJQYXJzZXIucmVhZExpc3QoKSkgPT09IHVuZGVmaW5lZFxuICAgICAgfHwgKGluaXQuc2MubGFuZyA9IGJ1ZmZlclBhcnNlci5yZWFkTGlzdCgpKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG4gICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgIHNlbGYsXG4gICAgICAnUmVjZWl2ZWQgbWFsZm9ybWVkIEtFWElOSVQnLFxuICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHBvcyA9IGJ1ZmZlclBhcnNlci5wb3MoKTtcbiAgY29uc3QgZmlyc3RGb2xsb3dzID0gKHBvcyA8IHBheWxvYWQubGVuZ3RoICYmIHBheWxvYWRbcG9zXSA9PT0gMSk7XG4gIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gIGNvbnN0IGxvY2FsID0gc2VsZi5fb2ZmZXI7XG4gIGNvbnN0IHJlbW90ZSA9IGluaXQ7XG5cbiAgbGV0IGxvY2FsS2V4ID0gbG9jYWwubGlzdHMua2V4LmFycmF5O1xuICBpZiAoc2VsZi5fY29tcGF0RmxhZ3MgJiBDT01QQVQuQkFEX0RIR0VYKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbEtleC5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGxvY2FsS2V4W2ldLmluZGV4T2YoJ2dyb3VwLWV4Y2hhbmdlJykgIT09IC0xKSB7XG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgLy8gQ29weSBhcnJheSBsYXppbHlcbiAgICAgICAgICBsb2NhbEtleCA9IGxvY2FsS2V4LnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxLZXguc3BsaWNlKGktLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IGNsaWVudExpc3Q7XG4gIGxldCBzZXJ2ZXJMaXN0O1xuICBsZXQgaTtcbiAgY29uc3QgZGVidWcgPSBzZWxmLl9kZWJ1ZztcblxuICBkZWJ1ZyAmJiBkZWJ1ZygnSW5ib3VuZDogSGFuZHNoYWtlIGluIHByb2dyZXNzJyk7XG5cbiAgLy8gS2V5IGV4Y2hhbmdlIG1ldGhvZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGRlYnVnICYmIGRlYnVnKGBIYW5kc2hha2U6IChsb2NhbCkgS0VYIG1ldGhvZDogJHtsb2NhbEtleH1gKTtcbiAgZGVidWcgJiYgZGVidWcoYEhhbmRzaGFrZTogKHJlbW90ZSkgS0VYIG1ldGhvZDogJHtyZW1vdGUua2V4fWApO1xuICBsZXQgcmVtb3RlRXh0SW5mb0VuYWJsZWQ7XG4gIGlmIChzZWxmLl9zZXJ2ZXIpIHtcbiAgICBzZXJ2ZXJMaXN0ID0gbG9jYWxLZXg7XG4gICAgY2xpZW50TGlzdCA9IHJlbW90ZS5rZXg7XG4gICAgcmVtb3RlRXh0SW5mb0VuYWJsZWQgPSAoY2xpZW50TGlzdC5pbmRleE9mKCdleHQtaW5mby1jJykgIT09IC0xKTtcbiAgfSBlbHNlIHtcbiAgICBzZXJ2ZXJMaXN0ID0gcmVtb3RlLmtleDtcbiAgICBjbGllbnRMaXN0ID0gbG9jYWxLZXg7XG4gICAgcmVtb3RlRXh0SW5mb0VuYWJsZWQgPSAoc2VydmVyTGlzdC5pbmRleE9mKCdleHQtaW5mby1zJykgIT09IC0xKTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYWdyZWVhYmxlIGtleSBleGNoYW5nZSBhbGdvcml0aG1cbiAgZm9yIChpID0gMDtcbiAgICAgICBpIDwgY2xpZW50TGlzdC5sZW5ndGggJiYgc2VydmVyTGlzdC5pbmRleE9mKGNsaWVudExpc3RbaV0pID09PSAtMTtcbiAgICAgICArK2kpO1xuICBpZiAoaSA9PT0gY2xpZW50TGlzdC5sZW5ndGgpIHtcbiAgICAvLyBObyBzdWl0YWJsZSBtYXRjaCBmb3VuZCFcbiAgICBkZWJ1ZyAmJiBkZWJ1ZygnSGFuZHNoYWtlOiBObyBtYXRjaGluZyBrZXkgZXhjaGFuZ2UgYWxnb3JpdGhtJyk7XG4gICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgIHNlbGYsXG4gICAgICAnSGFuZHNoYWtlIGZhaWxlZDogbm8gbWF0Y2hpbmcga2V5IGV4Y2hhbmdlIGFsZ29yaXRobScsXG4gICAgICAnaGFuZHNoYWtlJyxcbiAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICApO1xuICB9XG4gIGluaXQua2V4ID0gY2xpZW50TGlzdFtpXTtcbiAgZGVidWcgJiYgZGVidWcoYEhhbmRzaGFrZTogS0VYIGFsZ29yaXRobTogJHtjbGllbnRMaXN0W2ldfWApO1xuICBpZiAoZmlyc3RGb2xsb3dzICYmICghcmVtb3RlLmtleC5sZW5ndGggfHwgY2xpZW50TGlzdFtpXSAhPT0gcmVtb3RlLmtleFswXSkpIHtcbiAgICAvLyBJZ25vcmUgbmV4dCBpbmJvdW5kIHBhY2tldCwgaXQgd2FzIGEgd3JvbmcgZmlyc3QgZ3Vlc3MgYXQgS0VYIGFsZ29yaXRobVxuICAgIHNlbGYuX3NraXBOZXh0SW5ib3VuZFBhY2tldCA9IHRydWU7XG4gIH1cblxuXG4gIC8vIFNlcnZlciBob3N0IGtleSBmb3JtYXQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCBsb2NhbFNydkhvc3RLZXkgPSBsb2NhbC5saXN0cy5zZXJ2ZXJIb3N0S2V5LmFycmF5O1xuICBkZWJ1ZyAmJiBkZWJ1ZyhgSGFuZHNoYWtlOiAobG9jYWwpIEhvc3Qga2V5IGZvcm1hdDogJHtsb2NhbFNydkhvc3RLZXl9YCk7XG4gIGRlYnVnICYmIGRlYnVnKFxuICAgIGBIYW5kc2hha2U6IChyZW1vdGUpIEhvc3Qga2V5IGZvcm1hdDogJHtyZW1vdGUuc2VydmVySG9zdEtleX1gXG4gICk7XG4gIGlmIChzZWxmLl9zZXJ2ZXIpIHtcbiAgICBzZXJ2ZXJMaXN0ID0gbG9jYWxTcnZIb3N0S2V5O1xuICAgIGNsaWVudExpc3QgPSByZW1vdGUuc2VydmVySG9zdEtleTtcbiAgfSBlbHNlIHtcbiAgICBzZXJ2ZXJMaXN0ID0gcmVtb3RlLnNlcnZlckhvc3RLZXk7XG4gICAgY2xpZW50TGlzdCA9IGxvY2FsU3J2SG9zdEtleTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYWdyZWVhYmxlIHNlcnZlciBob3N0IGtleSBmb3JtYXRcbiAgZm9yIChpID0gMDtcbiAgICAgICBpIDwgY2xpZW50TGlzdC5sZW5ndGggJiYgc2VydmVyTGlzdC5pbmRleE9mKGNsaWVudExpc3RbaV0pID09PSAtMTtcbiAgICAgICArK2kpO1xuICBpZiAoaSA9PT0gY2xpZW50TGlzdC5sZW5ndGgpIHtcbiAgICAvLyBObyBzdWl0YWJsZSBtYXRjaCBmb3VuZCFcbiAgICBkZWJ1ZyAmJiBkZWJ1ZygnSGFuZHNoYWtlOiBObyBtYXRjaGluZyBob3N0IGtleSBmb3JtYXQnKTtcbiAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgc2VsZixcbiAgICAgICdIYW5kc2hha2UgZmFpbGVkOiBubyBtYXRjaGluZyBob3N0IGtleSBmb3JtYXQnLFxuICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgKTtcbiAgfVxuICBpbml0LnNlcnZlckhvc3RLZXkgPSBjbGllbnRMaXN0W2ldO1xuICBkZWJ1ZyAmJiBkZWJ1ZyhgSGFuZHNoYWtlOiBIb3N0IGtleSBmb3JtYXQ6ICR7Y2xpZW50TGlzdFtpXX1gKTtcblxuXG4gIC8vIENsaWVudC0+U2VydmVyIGNpcGhlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCBsb2NhbENTQ2lwaGVyID0gbG9jYWwubGlzdHMuY3MuY2lwaGVyLmFycmF5O1xuICBkZWJ1ZyAmJiBkZWJ1ZyhgSGFuZHNoYWtlOiAobG9jYWwpIEMtPlMgY2lwaGVyOiAke2xvY2FsQ1NDaXBoZXJ9YCk7XG4gIGRlYnVnICYmIGRlYnVnKGBIYW5kc2hha2U6IChyZW1vdGUpIEMtPlMgY2lwaGVyOiAke3JlbW90ZS5jcy5jaXBoZXJ9YCk7XG4gIGlmIChzZWxmLl9zZXJ2ZXIpIHtcbiAgICBzZXJ2ZXJMaXN0ID0gbG9jYWxDU0NpcGhlcjtcbiAgICBjbGllbnRMaXN0ID0gcmVtb3RlLmNzLmNpcGhlcjtcbiAgfSBlbHNlIHtcbiAgICBzZXJ2ZXJMaXN0ID0gcmVtb3RlLmNzLmNpcGhlcjtcbiAgICBjbGllbnRMaXN0ID0gbG9jYWxDU0NpcGhlcjtcbiAgfVxuICAvLyBDaGVjayBmb3IgYWdyZWVhYmxlIGNsaWVudC0+c2VydmVyIGNpcGhlclxuICBmb3IgKGkgPSAwO1xuICAgICAgIGkgPCBjbGllbnRMaXN0Lmxlbmd0aCAmJiBzZXJ2ZXJMaXN0LmluZGV4T2YoY2xpZW50TGlzdFtpXSkgPT09IC0xO1xuICAgICAgICsraSk7XG4gIGlmIChpID09PSBjbGllbnRMaXN0Lmxlbmd0aCkge1xuICAgIC8vIE5vIHN1aXRhYmxlIG1hdGNoIGZvdW5kIVxuICAgIGRlYnVnICYmIGRlYnVnKCdIYW5kc2hha2U6IE5vIG1hdGNoaW5nIEMtPlMgY2lwaGVyJyk7XG4gICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgIHNlbGYsXG4gICAgICAnSGFuZHNoYWtlIGZhaWxlZDogbm8gbWF0Y2hpbmcgQy0+UyBjaXBoZXInLFxuICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgKTtcbiAgfVxuICBpbml0LmNzLmNpcGhlciA9IGNsaWVudExpc3RbaV07XG4gIGRlYnVnICYmIGRlYnVnKGBIYW5kc2hha2U6IEMtPlMgQ2lwaGVyOiAke2NsaWVudExpc3RbaV19YCk7XG5cblxuICAvLyBTZXJ2ZXItPkNsaWVudCBjaXBoZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgbG9jYWxTQ0NpcGhlciA9IGxvY2FsLmxpc3RzLnNjLmNpcGhlci5hcnJheTtcbiAgZGVidWcgJiYgZGVidWcoYEhhbmRzaGFrZTogKGxvY2FsKSBTLT5DIGNpcGhlcjogJHtsb2NhbFNDQ2lwaGVyfWApO1xuICBkZWJ1ZyAmJiBkZWJ1ZyhgSGFuZHNoYWtlOiAocmVtb3RlKSBTLT5DIGNpcGhlcjogJHtyZW1vdGUuc2MuY2lwaGVyfWApO1xuICBpZiAoc2VsZi5fc2VydmVyKSB7XG4gICAgc2VydmVyTGlzdCA9IGxvY2FsU0NDaXBoZXI7XG4gICAgY2xpZW50TGlzdCA9IHJlbW90ZS5zYy5jaXBoZXI7XG4gIH0gZWxzZSB7XG4gICAgc2VydmVyTGlzdCA9IHJlbW90ZS5zYy5jaXBoZXI7XG4gICAgY2xpZW50TGlzdCA9IGxvY2FsU0NDaXBoZXI7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGFncmVlYWJsZSBzZXJ2ZXItPmNsaWVudCBjaXBoZXJcbiAgZm9yIChpID0gMDtcbiAgICAgICBpIDwgY2xpZW50TGlzdC5sZW5ndGggJiYgc2VydmVyTGlzdC5pbmRleE9mKGNsaWVudExpc3RbaV0pID09PSAtMTtcbiAgICAgICArK2kpO1xuICBpZiAoaSA9PT0gY2xpZW50TGlzdC5sZW5ndGgpIHtcbiAgICAvLyBObyBzdWl0YWJsZSBtYXRjaCBmb3VuZCFcbiAgICBkZWJ1ZyAmJiBkZWJ1ZygnSGFuZHNoYWtlOiBObyBtYXRjaGluZyBTLT5DIGNpcGhlcicpO1xuICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICBzZWxmLFxuICAgICAgJ0hhbmRzaGFrZSBmYWlsZWQ6IG5vIG1hdGNoaW5nIFMtPkMgY2lwaGVyJyxcbiAgICAgICdoYW5kc2hha2UnLFxuICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICk7XG4gIH1cbiAgaW5pdC5zYy5jaXBoZXIgPSBjbGllbnRMaXN0W2ldO1xuICBkZWJ1ZyAmJiBkZWJ1ZyhgSGFuZHNoYWtlOiBTLT5DIGNpcGhlcjogJHtjbGllbnRMaXN0W2ldfWApO1xuXG5cbiAgLy8gQ2xpZW50LT5TZXJ2ZXIgTUFDID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGxvY2FsQ1NNQUMgPSBsb2NhbC5saXN0cy5jcy5tYWMuYXJyYXk7XG4gIGRlYnVnICYmIGRlYnVnKGBIYW5kc2hha2U6IChsb2NhbCkgQy0+UyBNQUM6ICR7bG9jYWxDU01BQ31gKTtcbiAgZGVidWcgJiYgZGVidWcoYEhhbmRzaGFrZTogKHJlbW90ZSkgQy0+UyBNQUM6ICR7cmVtb3RlLmNzLm1hY31gKTtcbiAgaWYgKENJUEhFUl9JTkZPW2luaXQuY3MuY2lwaGVyXS5hdXRoTGVuID4gMCkge1xuICAgIGluaXQuY3MubWFjID0gJyc7XG4gICAgZGVidWcgJiYgZGVidWcoJ0hhbmRzaGFrZTogQy0+UyBNQUM6IDxpbXBsaWNpdD4nKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VsZi5fc2VydmVyKSB7XG4gICAgICBzZXJ2ZXJMaXN0ID0gbG9jYWxDU01BQztcbiAgICAgIGNsaWVudExpc3QgPSByZW1vdGUuY3MubWFjO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJ2ZXJMaXN0ID0gcmVtb3RlLmNzLm1hYztcbiAgICAgIGNsaWVudExpc3QgPSBsb2NhbENTTUFDO1xuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgYWdyZWVhYmxlIGNsaWVudC0+c2VydmVyIGhtYWMgYWxnb3JpdGhtXG4gICAgZm9yIChpID0gMDtcbiAgICAgICAgIGkgPCBjbGllbnRMaXN0Lmxlbmd0aCAmJiBzZXJ2ZXJMaXN0LmluZGV4T2YoY2xpZW50TGlzdFtpXSkgPT09IC0xO1xuICAgICAgICAgKytpKTtcbiAgICBpZiAoaSA9PT0gY2xpZW50TGlzdC5sZW5ndGgpIHtcbiAgICAgIC8vIE5vIHN1aXRhYmxlIG1hdGNoIGZvdW5kIVxuICAgICAgZGVidWcgJiYgZGVidWcoJ0hhbmRzaGFrZTogTm8gbWF0Y2hpbmcgQy0+UyBNQUMnKTtcbiAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdIYW5kc2hha2UgZmFpbGVkOiBubyBtYXRjaGluZyBDLT5TIE1BQycsXG4gICAgICAgICdoYW5kc2hha2UnLFxuICAgICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgICApO1xuICAgIH1cbiAgICBpbml0LmNzLm1hYyA9IGNsaWVudExpc3RbaV07XG4gICAgZGVidWcgJiYgZGVidWcoYEhhbmRzaGFrZTogQy0+UyBNQUM6ICR7Y2xpZW50TGlzdFtpXX1gKTtcbiAgfVxuXG5cbiAgLy8gU2VydmVyLT5DbGllbnQgTUFDID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGxvY2FsU0NNQUMgPSBsb2NhbC5saXN0cy5zYy5tYWMuYXJyYXk7XG4gIGRlYnVnICYmIGRlYnVnKGBIYW5kc2hha2U6IChsb2NhbCkgUy0+QyBNQUM6ICR7bG9jYWxTQ01BQ31gKTtcbiAgZGVidWcgJiYgZGVidWcoYEhhbmRzaGFrZTogKHJlbW90ZSkgUy0+QyBNQUM6ICR7cmVtb3RlLnNjLm1hY31gKTtcbiAgaWYgKENJUEhFUl9JTkZPW2luaXQuc2MuY2lwaGVyXS5hdXRoTGVuID4gMCkge1xuICAgIGluaXQuc2MubWFjID0gJyc7XG4gICAgZGVidWcgJiYgZGVidWcoJ0hhbmRzaGFrZTogUy0+QyBNQUM6IDxpbXBsaWNpdD4nKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VsZi5fc2VydmVyKSB7XG4gICAgICBzZXJ2ZXJMaXN0ID0gbG9jYWxTQ01BQztcbiAgICAgIGNsaWVudExpc3QgPSByZW1vdGUuc2MubWFjO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJ2ZXJMaXN0ID0gcmVtb3RlLnNjLm1hYztcbiAgICAgIGNsaWVudExpc3QgPSBsb2NhbFNDTUFDO1xuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgYWdyZWVhYmxlIHNlcnZlci0+Y2xpZW50IGhtYWMgYWxnb3JpdGhtXG4gICAgZm9yIChpID0gMDtcbiAgICAgICAgIGkgPCBjbGllbnRMaXN0Lmxlbmd0aCAmJiBzZXJ2ZXJMaXN0LmluZGV4T2YoY2xpZW50TGlzdFtpXSkgPT09IC0xO1xuICAgICAgICAgKytpKTtcbiAgICBpZiAoaSA9PT0gY2xpZW50TGlzdC5sZW5ndGgpIHtcbiAgICAgIC8vIE5vIHN1aXRhYmxlIG1hdGNoIGZvdW5kIVxuICAgICAgZGVidWcgJiYgZGVidWcoJ0hhbmRzaGFrZTogTm8gbWF0Y2hpbmcgUy0+QyBNQUMnKTtcbiAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdIYW5kc2hha2UgZmFpbGVkOiBubyBtYXRjaGluZyBTLT5DIE1BQycsXG4gICAgICAgICdoYW5kc2hha2UnLFxuICAgICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgICApO1xuICAgIH1cbiAgICBpbml0LnNjLm1hYyA9IGNsaWVudExpc3RbaV07XG4gICAgZGVidWcgJiYgZGVidWcoYEhhbmRzaGFrZTogUy0+QyBNQUM6ICR7Y2xpZW50TGlzdFtpXX1gKTtcbiAgfVxuXG5cbiAgLy8gQ2xpZW50LT5TZXJ2ZXIgY29tcHJlc3Npb24gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGxvY2FsQ1NDb21wcmVzcyA9IGxvY2FsLmxpc3RzLmNzLmNvbXByZXNzLmFycmF5O1xuICBkZWJ1ZyAmJiBkZWJ1ZyhgSGFuZHNoYWtlOiAobG9jYWwpIEMtPlMgY29tcHJlc3Npb246ICR7bG9jYWxDU0NvbXByZXNzfWApO1xuICBkZWJ1ZyAmJiBkZWJ1ZyhgSGFuZHNoYWtlOiAocmVtb3RlKSBDLT5TIGNvbXByZXNzaW9uOiAke3JlbW90ZS5jcy5jb21wcmVzc31gKTtcbiAgaWYgKHNlbGYuX3NlcnZlcikge1xuICAgIHNlcnZlckxpc3QgPSBsb2NhbENTQ29tcHJlc3M7XG4gICAgY2xpZW50TGlzdCA9IHJlbW90ZS5jcy5jb21wcmVzcztcbiAgfSBlbHNlIHtcbiAgICBzZXJ2ZXJMaXN0ID0gcmVtb3RlLmNzLmNvbXByZXNzO1xuICAgIGNsaWVudExpc3QgPSBsb2NhbENTQ29tcHJlc3M7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGFncmVlYWJsZSBjbGllbnQtPnNlcnZlciBjb21wcmVzc2lvbiBhbGdvcml0aG1cbiAgZm9yIChpID0gMDtcbiAgICAgICBpIDwgY2xpZW50TGlzdC5sZW5ndGggJiYgc2VydmVyTGlzdC5pbmRleE9mKGNsaWVudExpc3RbaV0pID09PSAtMTtcbiAgICAgICArK2kpO1xuICBpZiAoaSA9PT0gY2xpZW50TGlzdC5sZW5ndGgpIHtcbiAgICAvLyBObyBzdWl0YWJsZSBtYXRjaCBmb3VuZCFcbiAgICBkZWJ1ZyAmJiBkZWJ1ZygnSGFuZHNoYWtlOiBObyBtYXRjaGluZyBDLT5TIGNvbXByZXNzaW9uJyk7XG4gICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgIHNlbGYsXG4gICAgICAnSGFuZHNoYWtlIGZhaWxlZDogbm8gbWF0Y2hpbmcgQy0+UyBjb21wcmVzc2lvbicsXG4gICAgICAnaGFuZHNoYWtlJyxcbiAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICApO1xuICB9XG4gIGluaXQuY3MuY29tcHJlc3MgPSBjbGllbnRMaXN0W2ldO1xuICBkZWJ1ZyAmJiBkZWJ1ZyhgSGFuZHNoYWtlOiBDLT5TIGNvbXByZXNzaW9uOiAke2NsaWVudExpc3RbaV19YCk7XG5cblxuICAvLyBTZXJ2ZXItPkNsaWVudCBjb21wcmVzc2lvbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgbG9jYWxTQ0NvbXByZXNzID0gbG9jYWwubGlzdHMuc2MuY29tcHJlc3MuYXJyYXk7XG4gIGRlYnVnICYmIGRlYnVnKGBIYW5kc2hha2U6IChsb2NhbCkgUy0+QyBjb21wcmVzc2lvbjogJHtsb2NhbFNDQ29tcHJlc3N9YCk7XG4gIGRlYnVnICYmIGRlYnVnKGBIYW5kc2hha2U6IChyZW1vdGUpIFMtPkMgY29tcHJlc3Npb246ICR7cmVtb3RlLnNjLmNvbXByZXNzfWApO1xuICBpZiAoc2VsZi5fc2VydmVyKSB7XG4gICAgc2VydmVyTGlzdCA9IGxvY2FsU0NDb21wcmVzcztcbiAgICBjbGllbnRMaXN0ID0gcmVtb3RlLnNjLmNvbXByZXNzO1xuICB9IGVsc2Uge1xuICAgIHNlcnZlckxpc3QgPSByZW1vdGUuc2MuY29tcHJlc3M7XG4gICAgY2xpZW50TGlzdCA9IGxvY2FsU0NDb21wcmVzcztcbiAgfVxuICAvLyBDaGVjayBmb3IgYWdyZWVhYmxlIHNlcnZlci0+Y2xpZW50IGNvbXByZXNzaW9uIGFsZ29yaXRobVxuICBmb3IgKGkgPSAwO1xuICAgICAgIGkgPCBjbGllbnRMaXN0Lmxlbmd0aCAmJiBzZXJ2ZXJMaXN0LmluZGV4T2YoY2xpZW50TGlzdFtpXSkgPT09IC0xO1xuICAgICAgICsraSk7XG4gIGlmIChpID09PSBjbGllbnRMaXN0Lmxlbmd0aCkge1xuICAgIC8vIE5vIHN1aXRhYmxlIG1hdGNoIGZvdW5kIVxuICAgIGRlYnVnICYmIGRlYnVnKCdIYW5kc2hha2U6IE5vIG1hdGNoaW5nIFMtPkMgY29tcHJlc3Npb24nKTtcbiAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgc2VsZixcbiAgICAgICdIYW5kc2hha2UgZmFpbGVkOiBubyBtYXRjaGluZyBTLT5DIGNvbXByZXNzaW9uJyxcbiAgICAgICdoYW5kc2hha2UnLFxuICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICk7XG4gIH1cbiAgaW5pdC5zYy5jb21wcmVzcyA9IGNsaWVudExpc3RbaV07XG4gIGRlYnVnICYmIGRlYnVnKGBIYW5kc2hha2U6IFMtPkMgY29tcHJlc3Npb246ICR7Y2xpZW50TGlzdFtpXX1gKTtcblxuICBpbml0LmNzLmxhbmcgPSAnJztcbiAgaW5pdC5zYy5sYW5nID0gJyc7XG5cbiAgLy8gWFhYOiBoYWNrIC0tIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXNcbiAgaWYgKHNlbGYuX2tleCkge1xuICAgIGlmICghc2VsZi5fa2V4aW5pdCkge1xuICAgICAgLy8gV2UgcmVjZWl2ZWQgYSByZWtleSByZXF1ZXN0LCBidXQgd2UgaGF2ZW4ndCBzZW50IGEgS0VYSU5JVCBpbiByZXNwb25zZVxuICAgICAgLy8geWV0XG4gICAgICBrZXhpbml0KHNlbGYpO1xuICAgIH1cbiAgICBzZWxmLl9kZWNpcGhlci5fb25QYXlsb2FkID0gb25LRVhQYXlsb2FkLmJpbmQoc2VsZiwgeyBmaXJzdFBhY2tldDogZmFsc2UgfSk7XG4gIH1cblxuICBzZWxmLl9rZXggPSBjcmVhdGVLZXlFeGNoYW5nZShpbml0LCBzZWxmLCBwYXlsb2FkKTtcbiAgc2VsZi5fa2V4LnJlbW90ZUV4dEluZm9FbmFibGVkID0gcmVtb3RlRXh0SW5mb0VuYWJsZWQ7XG4gIHNlbGYuX2tleC5zdGFydCgpO1xufVxuXG5jb25zdCBjcmVhdGVLZXlFeGNoYW5nZSA9ICgoKSA9PiB7XG4gIGZ1bmN0aW9uIGNvbnZlcnRUb01waW50KGJ1Zikge1xuICAgIGxldCBpZHggPSAwO1xuICAgIGxldCBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgIHdoaWxlIChidWZbaWR4XSA9PT0gMHgwMCkge1xuICAgICAgKytpZHg7XG4gICAgICAtLWxlbmd0aDtcbiAgICB9XG4gICAgbGV0IG5ld0J1ZjtcbiAgICBpZiAoYnVmW2lkeF0gJiAweDgwKSB7XG4gICAgICBuZXdCdWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMSArIGxlbmd0aCk7XG4gICAgICBuZXdCdWZbMF0gPSAwO1xuICAgICAgYnVmLmNvcHkobmV3QnVmLCAxLCBpZHgpO1xuICAgICAgYnVmID0gbmV3QnVmO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoICE9PSBidWYubGVuZ3RoKSB7XG4gICAgICBuZXdCdWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgICAgIGJ1Zi5jb3B5KG5ld0J1ZiwgMCwgaWR4KTtcbiAgICAgIGJ1ZiA9IG5ld0J1ZjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIGNsYXNzIEtleUV4Y2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihuZWdvdGlhdGVkLCBwcm90b2NvbCwgcmVtb3RlS2V4aW5pdCkge1xuICAgICAgdGhpcy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcblxuICAgICAgdGhpcy5zZXNzaW9uSUQgPSAocHJvdG9jb2wuX2tleCA/IHByb3RvY29sLl9rZXguc2Vzc2lvbklEIDogdW5kZWZpbmVkKTtcbiAgICAgIHRoaXMubmVnb3RpYXRlZCA9IG5lZ290aWF0ZWQ7XG4gICAgICB0aGlzLnJlbW90ZUV4dEluZm9FbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9zdGVwID0gMTtcbiAgICAgIHRoaXMuX3B1YmxpYyA9IG51bGw7XG4gICAgICB0aGlzLl9kaCA9IG51bGw7XG4gICAgICB0aGlzLl9zZW50TkVXS0VZUyA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVjZWl2ZWRORVdLRVlTID0gZmFsc2U7XG4gICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faG9zdFZlcmlmaWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIERhdGEgbmVlZGVkIGZvciBpbml0aWFsaXppbmcgY2lwaGVyL2RlY2lwaGVyL2V0Yy5cbiAgICAgIHRoaXMuX2tleGluaXQgPSBwcm90b2NvbC5fa2V4aW5pdDtcbiAgICAgIHRoaXMuX3JlbW90ZUtleGluaXQgPSByZW1vdGVLZXhpbml0O1xuICAgICAgdGhpcy5faWRlbnRSYXcgPSBwcm90b2NvbC5faWRlbnRSYXc7XG4gICAgICB0aGlzLl9yZW1vdGVJZGVudFJhdyA9IHByb3RvY29sLl9yZW1vdGVJZGVudFJhdztcbiAgICAgIHRoaXMuX2hvc3RLZXkgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9kaERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9zaWcgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgIGlmICh0aGlzLl9maW5pc2hlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBjb25zdCBpc1NlcnZlciA9IHRoaXMuX3Byb3RvY29sLl9zZXJ2ZXI7XG4gICAgICBjb25zdCBuZWdvdGlhdGVkID0gdGhpcy5uZWdvdGlhdGVkO1xuXG4gICAgICBjb25zdCBwdWJLZXkgPSB0aGlzLmNvbnZlcnRQdWJsaWNLZXkodGhpcy5fZGhEYXRhKTtcbiAgICAgIGxldCBzZWNyZXQgPSB0aGlzLmNvbXB1dGVTZWNyZXQodGhpcy5fZGhEYXRhKTtcbiAgICAgIGlmIChzZWNyZXQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBzZWNyZXQubWVzc2FnZSA9XG4gICAgICAgICAgYEVycm9yIHdoaWxlIGNvbXB1dGluZyBESCBzZWNyZXQgKCR7dGhpcy50eXBlfSk6ICR7c2VjcmV0Lm1lc3NhZ2V9YDtcbiAgICAgICAgc2VjcmV0LmxldmVsID0gJ2hhbmRzaGFrZSc7XG4gICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgc2VjcmV0LFxuICAgICAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFzaCA9IGNyZWF0ZUhhc2godGhpcy5oYXNoTmFtZSk7XG4gICAgICAvLyBWX0NcbiAgICAgIGhhc2hTdHJpbmcoaGFzaCwgKGlzU2VydmVyID8gdGhpcy5fcmVtb3RlSWRlbnRSYXcgOiB0aGlzLl9pZGVudFJhdykpO1xuICAgICAgLy8gXCJWX1NcIlxuICAgICAgaGFzaFN0cmluZyhoYXNoLCAoaXNTZXJ2ZXIgPyB0aGlzLl9pZGVudFJhdyA6IHRoaXMuX3JlbW90ZUlkZW50UmF3KSk7XG4gICAgICAvLyBcIklfQ1wiXG4gICAgICBoYXNoU3RyaW5nKGhhc2gsIChpc1NlcnZlciA/IHRoaXMuX3JlbW90ZUtleGluaXQgOiB0aGlzLl9rZXhpbml0KSk7XG4gICAgICAvLyBcIklfU1wiXG4gICAgICBoYXNoU3RyaW5nKGhhc2gsIChpc1NlcnZlciA/IHRoaXMuX2tleGluaXQgOiB0aGlzLl9yZW1vdGVLZXhpbml0KSk7XG4gICAgICAvLyBcIktfU1wiXG4gICAgICBjb25zdCBzZXJ2ZXJQdWJsaWNIb3N0S2V5ID0gKGlzU2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5faG9zdEtleS5nZXRQdWJsaWNTU0goKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2hvc3RLZXkpO1xuICAgICAgaGFzaFN0cmluZyhoYXNoLCBzZXJ2ZXJQdWJsaWNIb3N0S2V5KTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2dyb3VwZXgnKSB7XG4gICAgICAgIC8vIEdyb3VwIGV4Y2hhbmdlLXNwZWNpZmljXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZ2V0REhQYXJhbXMoKTtcbiAgICAgICAgY29uc3QgbnVtID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpO1xuICAgICAgICAvLyBtaW4gKHVpbnQzMilcbiAgICAgICAgd3JpdGVVSW50MzJCRShudW0sIHRoaXMuX21pbkJpdHMsIDApO1xuICAgICAgICBoYXNoLnVwZGF0ZShudW0pO1xuICAgICAgICAvLyBwcmVmZXJyZWQgKHVpbnQzMilcbiAgICAgICAgd3JpdGVVSW50MzJCRShudW0sIHRoaXMuX3ByZWZCaXRzLCAwKTtcbiAgICAgICAgaGFzaC51cGRhdGUobnVtKTtcbiAgICAgICAgLy8gbWF4ICh1aW50MzIpXG4gICAgICAgIHdyaXRlVUludDMyQkUobnVtLCB0aGlzLl9tYXhCaXRzLCAwKTtcbiAgICAgICAgaGFzaC51cGRhdGUobnVtKTtcbiAgICAgICAgLy8gcHJpbWVcbiAgICAgICAgaGFzaFN0cmluZyhoYXNoLCBwYXJhbXMucHJpbWUpO1xuICAgICAgICAvLyBnZW5lcmF0b3JcbiAgICAgICAgaGFzaFN0cmluZyhoYXNoLCBwYXJhbXMuZ2VuZXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWV0aG9kLXNwZWNpZmljIGRhdGEgc2VudCBieSBjbGllbnRcbiAgICAgIGhhc2hTdHJpbmcoaGFzaCwgKGlzU2VydmVyID8gcHViS2V5IDogdGhpcy5nZXRQdWJsaWNLZXkoKSkpO1xuICAgICAgLy8gbWV0aG9kLXNwZWNpZmljIGRhdGEgc2VudCBieSBzZXJ2ZXJcbiAgICAgIGNvbnN0IHNlcnZlclB1YmxpY0tleSA9IChpc1NlcnZlciA/IHRoaXMuZ2V0UHVibGljS2V5KCkgOiBwdWJLZXkpO1xuICAgICAgaGFzaFN0cmluZyhoYXNoLCBzZXJ2ZXJQdWJsaWNLZXkpO1xuICAgICAgLy8gc2hhcmVkIHNlY3JldCAoXCJLXCIpXG4gICAgICBoYXNoU3RyaW5nKGhhc2gsIHNlY3JldCk7XG5cbiAgICAgIC8vIFwiSFwiXG4gICAgICBjb25zdCBleGNoYW5nZUhhc2ggPSBoYXNoLmRpZ2VzdCgpO1xuXG4gICAgICBpZiAoIWlzU2VydmVyKSB7XG4gICAgICAgIGJ1ZmZlclBhcnNlci5pbml0KHRoaXMuX3NpZywgMCk7XG4gICAgICAgIGNvbnN0IHNpZ1R5cGUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcblxuICAgICAgICBpZiAoIXNpZ1R5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAnTWFsZm9ybWVkIHBhY2tldCB3aGlsZSByZWFkaW5nIHNpZ25hdHVyZScsXG4gICAgICAgICAgICAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZ1R5cGUgIT09IG5lZ290aWF0ZWQuc2VydmVySG9zdEtleSkge1xuICAgICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbCxcbiAgICAgICAgICAgIGBXcm9uZyBzaWduYXR1cmUgdHlwZTogJHtzaWdUeXBlfSwgYFxuICAgICAgICAgICAgICArIGBleHBlY3RlZDogJHtuZWdvdGlhdGVkLnNlcnZlckhvc3RLZXl9YCxcbiAgICAgICAgICAgICdoYW5kc2hha2UnLFxuICAgICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBcInNcIlxuICAgICAgICBsZXQgc2lnVmFsdWUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuXG4gICAgICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgICAgIGlmIChzaWdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLFxuICAgICAgICAgICAgJ01hbGZvcm1lZCBwYWNrZXQgd2hpbGUgcmVhZGluZyBzaWduYXR1cmUnLFxuICAgICAgICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHNpZ1ZhbHVlID0gc2lnU1NIVG9BU04xKHNpZ1ZhbHVlLCBzaWdUeXBlKSkpIHtcbiAgICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAnTWFsZm9ybWVkIHNpZ25hdHVyZScsXG4gICAgICAgICAgICAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhcnNlZEhvc3RLZXk7XG4gICAgICAgIHtcbiAgICAgICAgICBidWZmZXJQYXJzZXIuaW5pdCh0aGlzLl9ob3N0S2V5LCAwKTtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgICAgY29uc3QgaG9zdEtleSA9IHRoaXMuX2hvc3RLZXkuc2xpY2UoYnVmZmVyUGFyc2VyLnBvcygpKTtcbiAgICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcbiAgICAgICAgICBwYXJzZWRIb3N0S2V5ID0gcGFyc2VERVJLZXkoaG9zdEtleSwgbmFtZSk7XG4gICAgICAgICAgaWYgKHBhcnNlZEhvc3RLZXkgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcGFyc2VkSG9zdEtleS5sZXZlbCA9ICdoYW5kc2hha2UnO1xuICAgICAgICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAgIHBhcnNlZEhvc3RLZXksXG4gICAgICAgICAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhhc2hBbGdvO1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGhhc2ggYWxnb3JpdGhtXG4gICAgICAgIHN3aXRjaCAodGhpcy5uZWdvdGlhdGVkLnNlcnZlckhvc3RLZXkpIHtcbiAgICAgICAgICBjYXNlICdyc2Etc2hhMi0yNTYnOiBoYXNoQWxnbyA9ICdzaGEyNTYnOyBicmVhaztcbiAgICAgICAgICBjYXNlICdyc2Etc2hhMi01MTInOiBoYXNoQWxnbyA9ICdzaGE1MTInOyBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Byb3RvY29sLl9kZWJ1Z1xuICAgICAgICAgICYmIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZygnVmVyaWZ5aW5nIHNpZ25hdHVyZSAuLi4nKTtcblxuICAgICAgICBjb25zdCB2ZXJpZmllZCA9IHBhcnNlZEhvc3RLZXkudmVyaWZ5KGV4Y2hhbmdlSGFzaCwgc2lnVmFsdWUsIGhhc2hBbGdvKTtcbiAgICAgICAgaWYgKHZlcmlmaWVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHZlcmlmaWVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyAmJiB0aGlzLl9wcm90b2NvbC5fZGVidWcoXG4gICAgICAgICAgICAgIGBTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZDogJHt2ZXJpZmllZC5zdGFja31gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5fZGVidWcgJiYgdGhpcy5fcHJvdG9jb2wuX2RlYnVnKFxuICAgICAgICAgICAgICAnU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAnSGFuZHNoYWtlIGZhaWxlZDogc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcm90b2NvbC5fZGVidWcgJiYgdGhpcy5fcHJvdG9jb2wuX2RlYnVnKCdWZXJpZmllZCBzaWduYXR1cmUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNlcnZlclxuXG4gICAgICAgIGxldCBoYXNoQWxnbztcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBoYXNoIGFsZ29yaXRobVxuICAgICAgICBzd2l0Y2ggKHRoaXMubmVnb3RpYXRlZC5zZXJ2ZXJIb3N0S2V5KSB7XG4gICAgICAgICAgY2FzZSAncnNhLXNoYTItMjU2JzogaGFzaEFsZ28gPSAnc2hhMjU2JzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncnNhLXNoYTItNTEyJzogaGFzaEFsZ28gPSAnc2hhNTEyJzsgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcm90b2NvbC5fZGVidWcgJiYgdGhpcy5fcHJvdG9jb2wuX2RlYnVnKFxuICAgICAgICAgICdHZW5lcmF0aW5nIHNpZ25hdHVyZSAuLi4nXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuX2hvc3RLZXkuc2lnbihleGNoYW5nZUhhc2gsIGhhc2hBbGdvKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLFxuICAgICAgICAgICAgJ0hhbmRzaGFrZSBmYWlsZWQ6IHNpZ25hdHVyZSBnZW5lcmF0aW9uIGZhaWxlZCBmb3IgJ1xuICAgICAgICAgICAgICArIGAke3RoaXMuX2hvc3RLZXkudHlwZX0gaG9zdCBrZXk6ICR7c2lnbmF0dXJlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICdoYW5kc2hha2UnLFxuICAgICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBzaWduYXR1cmUgPSBjb252ZXJ0U2lnbmF0dXJlKHNpZ25hdHVyZSwgdGhpcy5faG9zdEtleS50eXBlKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAnSGFuZHNoYWtlIGZhaWxlZDogc2lnbmF0dXJlIGNvbnZlcnNpb24gZmFpbGVkIGZvciAnXG4gICAgICAgICAgICAgICsgYCR7dGhpcy5faG9zdEtleS50eXBlfSBob3N0IGtleWAsXG4gICAgICAgICAgICAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VuZCBLRVggcmVwbHlcbiAgICAgICAgLypcbiAgICAgICAgICBieXRlICAgICAgU1NIX01TR19LRVhESF9SRVBMWVxuICAgICAgICAgICAgICAgICAgICAgIC8gU1NIX01TR19LRVhfREhfR0VYX1JFUExZXG4gICAgICAgICAgICAgICAgICAgICAgLyBTU0hfTVNHX0tFWF9FQ0RIX1JFUExZXG4gICAgICAgICAgc3RyaW5nICAgIHNlcnZlciBwdWJsaWMgaG9zdCBrZXkgYW5kIGNlcnRpZmljYXRlcyAoS19TKVxuICAgICAgICAgIHN0cmluZyAgICA8bWV0aG9kLXNwZWNpZmljIGRhdGE+XG4gICAgICAgICAgc3RyaW5nICAgIHNpZ25hdHVyZSBvZiBIXG4gICAgICAgICovXG4gICAgICAgIGNvbnN0IHNpZ1R5cGUgPSB0aGlzLm5lZ290aWF0ZWQuc2VydmVySG9zdEtleTtcbiAgICAgICAgY29uc3Qgc2lnVHlwZUxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHNpZ1R5cGUpO1xuICAgICAgICBjb25zdCBzaWdMZW4gPSA0ICsgc2lnVHlwZUxlbiArIDQgKyBzaWduYXR1cmUubGVuZ3RoO1xuICAgICAgICBsZXQgcCA9IHRoaXMuX3Byb3RvY29sLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0S0VYO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wcm90b2NvbC5fcGFja2V0Ulcud3JpdGUuYWxsb2MoXG4gICAgICAgICAgMVxuICAgICAgICAgICAgKyA0ICsgc2VydmVyUHVibGljSG9zdEtleS5sZW5ndGhcbiAgICAgICAgICAgICsgNCArIHNlcnZlclB1YmxpY0tleS5sZW5ndGhcbiAgICAgICAgICAgICsgNCArIHNpZ0xlbixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG5cbiAgICAgICAgcGFja2V0W3BdID0gTUVTU0FHRS5LRVhESF9SRVBMWTtcblxuICAgICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgc2VydmVyUHVibGljSG9zdEtleS5sZW5ndGgsICsrcCk7XG4gICAgICAgIHBhY2tldC5zZXQoc2VydmVyUHVibGljSG9zdEtleSwgcCArPSA0KTtcblxuICAgICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQdWJsaWNLZXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgIHAgKz0gc2VydmVyUHVibGljSG9zdEtleS5sZW5ndGgpO1xuICAgICAgICBwYWNrZXQuc2V0KHNlcnZlclB1YmxpY0tleSwgcCArPSA0KTtcblxuICAgICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgc2lnTGVuLCBwICs9IHNlcnZlclB1YmxpY0tleS5sZW5ndGgpO1xuXG4gICAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBzaWdUeXBlTGVuLCBwICs9IDQpO1xuICAgICAgICBwYWNrZXQudXRmOFdyaXRlKHNpZ1R5cGUsIHAgKz0gNCwgc2lnVHlwZUxlbik7XG5cbiAgICAgICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHNpZ25hdHVyZS5sZW5ndGgsIHAgKz0gc2lnVHlwZUxlbik7XG4gICAgICAgIHBhY2tldC5zZXQoc2lnbmF0dXJlLCBwICs9IDQpO1xuXG4gICAgICAgIGlmICh0aGlzLl9wcm90b2NvbC5fZGVidWcpIHtcbiAgICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZ3JvdXAnOlxuICAgICAgICAgICAgICB0eXBlID0gJ0tFWERIX1JFUExZJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdncm91cGV4JzpcbiAgICAgICAgICAgICAgdHlwZSA9ICdLRVhESF9HRVhfUkVQTFknO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHR5cGUgPSAnS0VYRUNESF9SRVBMWSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyhgT3V0Ym91bmQ6IFNlbmRpbmcgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb3RvY29sLl9jaXBoZXIuZW5jcnlwdChcbiAgICAgICAgICB0aGlzLl9wcm90b2NvbC5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0LCB0cnVlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdHJ5U2VuZE5FV0tFWVModGhpcyk7XG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlSGFuZHNoYWtlID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbklEKVxuICAgICAgICAgIHRoaXMuc2Vzc2lvbklEID0gZXhjaGFuZ2VIYXNoO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBuZXdTZWNyZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIHNlY3JldC5sZW5ndGgpO1xuICAgICAgICAgIHdyaXRlVUludDMyQkUobmV3U2VjcmV0LCBzZWNyZXQubGVuZ3RoLCAwKTtcbiAgICAgICAgICBuZXdTZWNyZXQuc2V0KHNlY3JldCwgNCk7XG4gICAgICAgICAgc2VjcmV0ID0gbmV3U2VjcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBuZXcgY2lwaGVycywgZGVjaXBoZXJzLCBldGMuXG5cbiAgICAgICAgY29uc3QgY3NDaXBoZXJJbmZvID0gQ0lQSEVSX0lORk9bbmVnb3RpYXRlZC5jcy5jaXBoZXJdO1xuICAgICAgICBjb25zdCBzY0NpcGhlckluZm8gPSBDSVBIRVJfSU5GT1tuZWdvdGlhdGVkLnNjLmNpcGhlcl07XG5cbiAgICAgICAgY29uc3QgY3NJViA9IGdlbmVyYXRlS0VYVmFsKGNzQ2lwaGVySW5mby5pdkxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzaE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNoYW5nZUhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25JRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdBJyk7XG4gICAgICAgIGNvbnN0IHNjSVYgPSBnZW5lcmF0ZUtFWFZhbChzY0NpcGhlckluZm8uaXZMZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc2hOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjaGFuZ2VIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQicpO1xuICAgICAgICBjb25zdCBjc0tleSA9IGdlbmVyYXRlS0VYVmFsKGNzQ2lwaGVySW5mby5rZXlMZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNoTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjaGFuZ2VIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbklELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDJyk7XG4gICAgICAgIGNvbnN0IHNjS2V5ID0gZ2VuZXJhdGVLRVhWYWwoc2NDaXBoZXJJbmZvLmtleUxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc2hOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNoYW5nZUhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0QnKTtcbiAgICAgICAgbGV0IGNzTWFjSW5mbztcbiAgICAgICAgbGV0IGNzTWFjS2V5O1xuICAgICAgICBpZiAoIWNzQ2lwaGVySW5mby5hdXRoTGVuKSB7XG4gICAgICAgICAgY3NNYWNJbmZvID0gTUFDX0lORk9bbmVnb3RpYXRlZC5jcy5tYWNdO1xuICAgICAgICAgIGNzTWFjS2V5ID0gZ2VuZXJhdGVLRVhWYWwoY3NNYWNJbmZvLmxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzaE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNoYW5nZUhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25JRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdFJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjTWFjSW5mbztcbiAgICAgICAgbGV0IHNjTWFjS2V5O1xuICAgICAgICBpZiAoIXNjQ2lwaGVySW5mby5hdXRoTGVuKSB7XG4gICAgICAgICAgc2NNYWNJbmZvID0gTUFDX0lORk9bbmVnb3RpYXRlZC5zYy5tYWNdO1xuICAgICAgICAgIHNjTWFjS2V5ID0gZ2VuZXJhdGVLRVhWYWwoc2NNYWNJbmZvLmxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzaE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNoYW5nZUhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25JRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdGJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgaW5ib3VuZDoge1xuICAgICAgICAgICAgb25QYXlsb2FkOiB0aGlzLl9wcm90b2NvbC5fb25QYXlsb2FkLFxuICAgICAgICAgICAgc2Vxbm86IHRoaXMuX3Byb3RvY29sLl9kZWNpcGhlci5pblNlcW5vLFxuICAgICAgICAgICAgZGVjaXBoZXJJbmZvOiAoIWlzU2VydmVyID8gc2NDaXBoZXJJbmZvIDogY3NDaXBoZXJJbmZvKSxcbiAgICAgICAgICAgIGRlY2lwaGVySVY6ICghaXNTZXJ2ZXIgPyBzY0lWIDogY3NJViksXG4gICAgICAgICAgICBkZWNpcGhlcktleTogKCFpc1NlcnZlciA/IHNjS2V5IDogY3NLZXkpLFxuICAgICAgICAgICAgbWFjSW5mbzogKCFpc1NlcnZlciA/IHNjTWFjSW5mbyA6IGNzTWFjSW5mbyksXG4gICAgICAgICAgICBtYWNLZXk6ICghaXNTZXJ2ZXIgPyBzY01hY0tleSA6IGNzTWFjS2V5KSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG91dGJvdW5kOiB7XG4gICAgICAgICAgICBvbldyaXRlOiB0aGlzLl9wcm90b2NvbC5fb25Xcml0ZSxcbiAgICAgICAgICAgIHNlcW5vOiB0aGlzLl9wcm90b2NvbC5fY2lwaGVyLm91dFNlcW5vLFxuICAgICAgICAgICAgY2lwaGVySW5mbzogKGlzU2VydmVyID8gc2NDaXBoZXJJbmZvIDogY3NDaXBoZXJJbmZvKSxcbiAgICAgICAgICAgIGNpcGhlcklWOiAoaXNTZXJ2ZXIgPyBzY0lWIDogY3NJViksXG4gICAgICAgICAgICBjaXBoZXJLZXk6IChpc1NlcnZlciA/IHNjS2V5IDogY3NLZXkpLFxuICAgICAgICAgICAgbWFjSW5mbzogKGlzU2VydmVyID8gc2NNYWNJbmZvIDogY3NNYWNJbmZvKSxcbiAgICAgICAgICAgIG1hY0tleTogKGlzU2VydmVyID8gc2NNYWNLZXkgOiBjc01hY0tleSksXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2NpcGhlciAmJiB0aGlzLl9wcm90b2NvbC5fY2lwaGVyLmZyZWUoKTtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2RlY2lwaGVyICYmIHRoaXMuX3Byb3RvY29sLl9kZWNpcGhlci5mcmVlKCk7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sLl9jaXBoZXIgPSBjcmVhdGVDaXBoZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2RlY2lwaGVyID0gY3JlYXRlRGVjaXBoZXIoY29uZmlnKTtcblxuICAgICAgICBjb25zdCBydyA9IHtcbiAgICAgICAgICByZWFkOiB1bmRlZmluZWQsXG4gICAgICAgICAgd3JpdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChuZWdvdGlhdGVkLmNzLmNvbXByZXNzKSB7XG4gICAgICAgICAgY2FzZSAnemxpYic6IC8vIHN0YXJ0cyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGlzU2VydmVyKVxuICAgICAgICAgICAgICBydy5yZWFkID0gbmV3IFpsaWJQYWNrZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgcncud3JpdGUgPSBuZXcgWmxpYlBhY2tldFdyaXRlcih0aGlzLl9wcm90b2NvbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd6bGliQG9wZW5zc2guY29tJzpcbiAgICAgICAgICAgIC8vIFN0YXJ0cyBhZnRlciBzdWNjZXNzZnVsIHVzZXIgYXV0aGVudGljYXRpb25cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3RvY29sLl9hdXRoZW50aWNhdGVkKSB7XG4gICAgICAgICAgICAgIC8vIElmIGEgcmVrZXkgaGFwcGVucyBhbmQgdGhpcyBjb21wcmVzc2lvbiBtZXRob2QgaXMgc2VsZWN0ZWQgYW5kXG4gICAgICAgICAgICAgIC8vIHdlIGFscmVhZHkgYXV0aGVudGljYXRlZCBzdWNjZXNzZnVsbHksIHdlIG5lZWQgdG8gc3RhcnRcbiAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgaW5zdGVhZFxuICAgICAgICAgICAgICBpZiAoaXNTZXJ2ZXIpXG4gICAgICAgICAgICAgICAgcncucmVhZCA9IG5ldyBabGliUGFja2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBydy53cml0ZSA9IG5ldyBabGliUGFja2V0V3JpdGVyKHRoaXMuX3Byb3RvY29sKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gRkFMTFRIUk9VR0hcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gbm9uZSAtLSBuZXZlciBhbnkgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvblxuXG4gICAgICAgICAgICBpZiAoaXNTZXJ2ZXIpXG4gICAgICAgICAgICAgIHJ3LnJlYWQgPSBuZXcgUGFja2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJ3LndyaXRlID0gbmV3IFBhY2tldFdyaXRlcih0aGlzLl9wcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChuZWdvdGlhdGVkLnNjLmNvbXByZXNzKSB7XG4gICAgICAgICAgY2FzZSAnemxpYic6IC8vIHN0YXJ0cyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGlzU2VydmVyKVxuICAgICAgICAgICAgICBydy53cml0ZSA9IG5ldyBabGliUGFja2V0V3JpdGVyKHRoaXMuX3Byb3RvY29sKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgcncucmVhZCA9IG5ldyBabGliUGFja2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd6bGliQG9wZW5zc2guY29tJzpcbiAgICAgICAgICAgIC8vIFN0YXJ0cyBhZnRlciBzdWNjZXNzZnVsIHVzZXIgYXV0aGVudGljYXRpb25cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3RvY29sLl9hdXRoZW50aWNhdGVkKSB7XG4gICAgICAgICAgICAgIC8vIElmIGEgcmVrZXkgaGFwcGVucyBhbmQgdGhpcyBjb21wcmVzc2lvbiBtZXRob2QgaXMgc2VsZWN0ZWQgYW5kXG4gICAgICAgICAgICAgIC8vIHdlIGFscmVhZHkgYXV0aGVudGljYXRlZCBzdWNjZXNzZnVsbHksIHdlIG5lZWQgdG8gc3RhcnRcbiAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgaW5zdGVhZFxuICAgICAgICAgICAgICBpZiAoaXNTZXJ2ZXIpXG4gICAgICAgICAgICAgICAgcncud3JpdGUgPSBuZXcgWmxpYlBhY2tldFdyaXRlcih0aGlzLl9wcm90b2NvbCk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBydy5yZWFkID0gbmV3IFpsaWJQYWNrZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gRkFMTFRIUk9VR0hcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gbm9uZSAtLSBuZXZlciBhbnkgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvblxuXG4gICAgICAgICAgICBpZiAoaXNTZXJ2ZXIpXG4gICAgICAgICAgICAgIHJ3LndyaXRlID0gbmV3IFBhY2tldFdyaXRlcih0aGlzLl9wcm90b2NvbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJ3LnJlYWQgPSBuZXcgUGFja2V0UmVhZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuX3BhY2tldFJXLnJlYWQuY2xlYW51cCgpO1xuICAgICAgICB0aGlzLl9wcm90b2NvbC5fcGFja2V0Ulcud3JpdGUuY2xlYW51cCgpO1xuICAgICAgICB0aGlzLl9wcm90b2NvbC5fcGFja2V0UlcgPSBydztcblxuICAgICAgICAvLyBDbGVhbnVwL3Jlc2V0IHZhcmlvdXMgc3RhdGVcbiAgICAgICAgdGhpcy5fcHVibGljID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGggPSBudWxsO1xuICAgICAgICB0aGlzLl9rZXhpbml0ID0gdGhpcy5fcHJvdG9jb2wuX2tleGluaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3JlbW90ZUtleGluaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2lkZW50UmF3ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9yZW1vdGVJZGVudFJhdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faG9zdEtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZGhEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaWcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuX29uSGFuZHNoYWtlQ29tcGxldGUobmVnb3RpYXRlZCk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIGlmICghaXNTZXJ2ZXIpXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUhhbmRzaGFrZSgpO1xuICAgICAgdGhpcy5maW5pc2ggPSBjb21wbGV0ZUhhbmRzaGFrZTtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgIGlmICghdGhpcy5fcHJvdG9jb2wuX3NlcnZlcikge1xuICAgICAgICBpZiAodGhpcy5fcHJvdG9jb2wuX2RlYnVnKSB7XG4gICAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2dyb3VwJzpcbiAgICAgICAgICAgICAgdHlwZSA9ICdLRVhESF9JTklUJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0eXBlID0gJ0tFWEVDREhfSU5JVCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyhgT3V0Ym91bmQ6IFNlbmRpbmcgJHt0eXBlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHViS2V5ID0gdGhpcy5nZXRQdWJsaWNLZXkoKTtcblxuICAgICAgICBsZXQgcCA9IHRoaXMuX3Byb3RvY29sLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0S0VYO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wcm90b2NvbC5fcGFja2V0Ulcud3JpdGUuYWxsb2MoXG4gICAgICAgICAgMSArIDQgKyBwdWJLZXkubGVuZ3RoLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgcGFja2V0W3BdID0gTUVTU0FHRS5LRVhESF9JTklUO1xuICAgICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcHViS2V5Lmxlbmd0aCwgKytwKTtcbiAgICAgICAgcGFja2V0LnNldChwdWJLZXksIHAgKz0gNCk7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sLl9jaXBoZXIuZW5jcnlwdChcbiAgICAgICAgICB0aGlzLl9wcm90b2NvbC5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0LCB0cnVlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRQdWJsaWNLZXkoKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlS2V5cygpO1xuXG4gICAgICBjb25zdCBrZXkgPSB0aGlzLl9wdWJsaWM7XG5cbiAgICAgIGlmIChrZXkpXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRQdWJsaWNLZXkoa2V5KTtcbiAgICB9XG4gICAgY29udmVydFB1YmxpY0tleShrZXkpIHtcbiAgICAgIGxldCBuZXdLZXk7XG4gICAgICBsZXQgaWR4ID0gMDtcbiAgICAgIGxldCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGtleVtpZHhdID09PSAweDAwKSB7XG4gICAgICAgICsraWR4O1xuICAgICAgICAtLWxlbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleVtpZHhdICYgMHg4MCkge1xuICAgICAgICBuZXdLZXkgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMSArIGxlbik7XG4gICAgICAgIG5ld0tleVswXSA9IDA7XG4gICAgICAgIGtleS5jb3B5KG5ld0tleSwgMSwgaWR4KTtcbiAgICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbiAhPT0ga2V5Lmxlbmd0aCkge1xuICAgICAgICBuZXdLZXkgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKTtcbiAgICAgICAga2V5LmNvcHkobmV3S2V5LCAwLCBpZHgpO1xuICAgICAgICBrZXkgPSBuZXdLZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBjb21wdXRlU2VjcmV0KG90aGVyUHVibGljS2V5KSB7XG4gICAgICB0aGlzLmdlbmVyYXRlS2V5cygpO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29udmVydFRvTXBpbnQodGhpcy5fZGguY29tcHV0ZVNlY3JldChvdGhlclB1YmxpY0tleSkpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJzZShwYXlsb2FkKSB7XG4gICAgICBjb25zdCB0eXBlID0gcGF5bG9hZFswXTtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RlcCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKHRoaXMuX3Byb3RvY29sLl9zZXJ2ZXIpIHtcbiAgICAgICAgICAgIC8vIFNlcnZlclxuICAgICAgICAgICAgaWYgKHR5cGUgIT09IE1FU1NBR0UuS0VYREhfSU5JVCkge1xuICAgICAgICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLFxuICAgICAgICAgICAgICAgIGBSZWNlaXZlZCBwYWNrZXQgJHt0eXBlfSBpbnN0ZWFkIG9mICR7TUVTU0FHRS5LRVhESF9JTklUfWAsXG4gICAgICAgICAgICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2RlYnVnICYmIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgJ1JlY2VpdmVkIERIIEluaXQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgYnl0ZSAgICAgU1NIX01TR19LRVhESF9JTklUXG4gICAgICAgICAgICAgICAgICAgICAgICAgLyBTU0hfTVNHX0tFWF9FQ0RIX0lOSVRcbiAgICAgICAgICAgICAgc3RyaW5nICAgPG1ldGhvZC1zcGVjaWZpYyBkYXRhPlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgICAgICAgICAgY29uc3QgZGhEYXRhID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKGRoRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgJ1JlY2VpdmVkIG1hbGZvcm1lZCBLRVgqX0lOSVQnLFxuICAgICAgICAgICAgICAgICdoYW5kc2hha2UnLFxuICAgICAgICAgICAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xpZW50IHB1YmxpYyBrZXlcbiAgICAgICAgICAgIHRoaXMuX2RoRGF0YSA9IGRoRGF0YTtcblxuICAgICAgICAgICAgbGV0IGhvc3RLZXkgPVxuICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5faG9zdEtleXNbdGhpcy5uZWdvdGlhdGVkLnNlcnZlckhvc3RLZXldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaG9zdEtleSkpXG4gICAgICAgICAgICAgIGhvc3RLZXkgPSBob3N0S2V5WzBdO1xuICAgICAgICAgICAgdGhpcy5faG9zdEtleSA9IGhvc3RLZXk7XG5cbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENsaWVudFxuICAgICAgICAgICAgaWYgKHR5cGUgIT09IE1FU1NBR0UuS0VYREhfUkVQTFkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbCxcbiAgICAgICAgICAgICAgICBgUmVjZWl2ZWQgcGFja2V0ICR7dHlwZX0gaW5zdGVhZCBvZiAke01FU1NBR0UuS0VYREhfUkVQTFl9YCxcbiAgICAgICAgICAgICAgICAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5fZGVidWcgJiYgdGhpcy5fcHJvdG9jb2wuX2RlYnVnKFxuICAgICAgICAgICAgICAnUmVjZWl2ZWQgREggUmVwbHknXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgYnl0ZSAgICAgIFNTSF9NU0dfS0VYREhfUkVQTFlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLyBTU0hfTVNHX0tFWF9ESF9HRVhfUkVQTFlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLyBTU0hfTVNHX0tFWF9FQ0RIX1JFUExZXG4gICAgICAgICAgICAgIHN0cmluZyAgICBzZXJ2ZXIgcHVibGljIGhvc3Qga2V5IGFuZCBjZXJ0aWZpY2F0ZXMgKEtfUylcbiAgICAgICAgICAgICAgc3RyaW5nICAgIDxtZXRob2Qtc3BlY2lmaWMgZGF0YT5cbiAgICAgICAgICAgICAgc3RyaW5nICAgIHNpZ25hdHVyZSBvZiBIXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgICAgICAgICBsZXQgaG9zdFB1YktleTtcbiAgICAgICAgICAgIGxldCBkaERhdGE7XG4gICAgICAgICAgICBsZXQgc2lnO1xuICAgICAgICAgICAgaWYgKChob3N0UHViS2V5ID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcoKSkgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHx8IChkaERhdGEgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpKSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfHwgKHNpZyA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG4gICAgICAgICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgJ1JlY2VpdmVkIG1hbGZvcm1lZCBLRVgqX1JFUExZJyxcbiAgICAgICAgICAgICAgICAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgaG9zdCBwdWJsaWMga2V5IHR5cGUgbWF0Y2hlcyB3aGF0IHdhcyBuZWdvdGlhdGVkXG4gICAgICAgICAgICAvLyBkdXJpbmcgS0VYSU5JVCBzd2FwXG4gICAgICAgICAgICBidWZmZXJQYXJzZXIuaW5pdChob3N0UHViS2V5LCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RQdWJLZXlUeXBlID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIGlmIChob3N0UHViS2V5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgJ1JlY2VpdmVkIG1hbGZvcm1lZCBob3N0IHB1YmxpYyBrZXknLFxuICAgICAgICAgICAgICAgICdoYW5kc2hha2UnLFxuICAgICAgICAgICAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChob3N0UHViS2V5VHlwZSAhPT0gdGhpcy5uZWdvdGlhdGVkLnNlcnZlckhvc3RLZXkpIHtcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBtYWtlIGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubmVnb3RpYXRlZC5zZXJ2ZXJIb3N0S2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncnNhLXNoYTItMjU2JzpcbiAgICAgICAgICAgICAgICBjYXNlICdyc2Etc2hhMi01MTInOlxuICAgICAgICAgICAgICAgICAgaWYgKGhvc3RQdWJLZXlUeXBlID09PSAnc3NoLXJzYScpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIEZBTExUSFJPVUdIXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLFxuICAgICAgICAgICAgICAgICAgICAnSG9zdCBrZXkgZG9lcyBub3QgbWF0Y2ggbmVnb3RpYXRlZCB0eXBlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICAgICAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faG9zdEtleSA9IGhvc3RQdWJLZXk7XG4gICAgICAgICAgICB0aGlzLl9kaERhdGEgPSBkaERhdGE7XG4gICAgICAgICAgICB0aGlzLl9zaWcgPSBzaWc7XG5cbiAgICAgICAgICAgIGxldCBjaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcmV0O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3RvY29sLl9ob3N0VmVyaWZpZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5fZGVidWcgJiYgdGhpcy5fcHJvdG9jb2wuX2RlYnVnKFxuICAgICAgICAgICAgICAgICdIb3N0IGFjY2VwdGVkIGJ5IGRlZmF1bHQgKG5vIHZlcmlmaWNhdGlvbiknXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXQgPSB0aGlzLl9wcm90b2NvbC5faG9zdFZlcmlmaWVyKGhvc3RQdWJLZXksIChwZXJtaXR0ZWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZClcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGVybWl0dGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2RlYnVnICYmIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAgJ0hvc3QgZGVuaWVkICh2ZXJpZmljYXRpb24gZmFpbGVkKSdcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbCxcbiAgICAgICAgICAgICAgICAgICAgJ0hvc3QgZGVuaWVkICh2ZXJpZmljYXRpb24gZmFpbGVkKScsXG4gICAgICAgICAgICAgICAgICAgICdoYW5kc2hha2UnLFxuICAgICAgICAgICAgICAgICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5fZGVidWcgJiYgdGhpcy5fcHJvdG9jb2wuX2RlYnVnKFxuICAgICAgICAgICAgICAgICAgJ0hvc3QgYWNjZXB0ZWQgKHZlcmlmaWVkKSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvc3RWZXJpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlY2VpdmVkTkVXS0VZUylcbiAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgdHJ5U2VuZE5FV0tFWVModGhpcyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIEFzeW5jIGhvc3QgdmVyaWZpY2F0aW9uXG4gICAgICAgICAgICAgICsrdGhpcy5fc3RlcDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5fZGVidWcgJiYgdGhpcy5fcHJvdG9jb2wuX2RlYnVnKFxuICAgICAgICAgICAgICAgICdIb3N0IGRlbmllZCAodmVyaWZpY2F0aW9uIGZhaWxlZCknXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgJ0hvc3QgZGVuaWVkICh2ZXJpZmljYXRpb24gZmFpbGVkKScsXG4gICAgICAgICAgICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2RlYnVnICYmIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgJ0hvc3QgYWNjZXB0ZWQgKHZlcmlmaWVkKSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9ob3N0VmVyaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5U2VuZE5FV0tFWVModGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgICsrdGhpcy5fc3RlcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmICh0eXBlICE9PSBNRVNTQUdFLk5FV0tFWVMpIHtcbiAgICAgICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLFxuICAgICAgICAgICAgICBgUmVjZWl2ZWQgcGFja2V0ICR7dHlwZX0gaW5zdGVhZCBvZiAke01FU1NBR0UuTkVXS0VZU31gLFxuICAgICAgICAgICAgICAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2RlYnVnICYmIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyhcbiAgICAgICAgICAgICdJbmJvdW5kOiBORVdLRVlTJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fcmVjZWl2ZWRORVdLRVlTID0gdHJ1ZTtcbiAgICAgICAgICArK3RoaXMuX3N0ZXA7XG4gICAgICAgICAgaWYgKHRoaXMuX3Byb3RvY29sLl9zZXJ2ZXIgfHwgdGhpcy5faG9zdFZlcmlmaWVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG5cbiAgICAgICAgICAvLyBTaWduYWwgdG8gY3VycmVudCBkZWNpcGhlciB0aGF0IHdlIG5lZWQgdG8gY2hhbmdlIHRvIGEgbmV3IGRlY2lwaGVyXG4gICAgICAgICAgLy8gZm9yIHRoZSBuZXh0IHBhY2tldFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICBgUmVjZWl2ZWQgdW5leHBlY3RlZCBwYWNrZXQgJHt0eXBlfSBhZnRlciBORVdLRVlTYCxcbiAgICAgICAgICAgICdoYW5kc2hha2UnLFxuICAgICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgQ3VydmUyNTUxOUV4Y2hhbmdlIGV4dGVuZHMgS2V5RXhjaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hOYW1lLCAuLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcblxuICAgICAgdGhpcy50eXBlID0gJzI1NTE5JztcbiAgICAgIHRoaXMuaGFzaE5hbWUgPSBoYXNoTmFtZTtcbiAgICAgIHRoaXMuX2tleXMgPSBudWxsO1xuICAgIH1cbiAgICBnZW5lcmF0ZUtleXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX2tleXMpXG4gICAgICAgIHRoaXMuX2tleXMgPSBnZW5lcmF0ZUtleVBhaXJTeW5jKCd4MjU1MTknKTtcbiAgICB9XG4gICAgZ2V0UHVibGljS2V5KCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUtleXMoKTtcblxuICAgICAgY29uc3Qga2V5ID0gdGhpcy5fa2V5cy5wdWJsaWNLZXkuZXhwb3J0KHsgdHlwZTogJ3Nwa2knLCBmb3JtYXQ6ICdkZXInIH0pO1xuICAgICAgcmV0dXJuIGtleS5zbGljZSgtMzIpOyAvLyBIQUNLOiBhdm9pZHMgcGFyc2luZyBERVIvQkVSIGhlYWRlclxuICAgIH1cbiAgICBjb252ZXJ0UHVibGljS2V5KGtleSkge1xuICAgICAgbGV0IG5ld0tleTtcbiAgICAgIGxldCBpZHggPSAwO1xuICAgICAgbGV0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgICB3aGlsZSAoa2V5W2lkeF0gPT09IDB4MDApIHtcbiAgICAgICAgKytpZHg7XG4gICAgICAgIC0tbGVuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMzIpXG4gICAgICAgIHJldHVybiBrZXk7XG5cbiAgICAgIGlmIChsZW4gIT09IGtleS5sZW5ndGgpIHtcbiAgICAgICAgbmV3S2V5ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbik7XG4gICAgICAgIGtleS5jb3B5KG5ld0tleSwgMCwgaWR4KTtcbiAgICAgICAga2V5ID0gbmV3S2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgY29tcHV0ZVNlY3JldChvdGhlclB1YmxpY0tleSkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUtleXMoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXNuV3JpdGVyID0gbmV3IEJlci5Xcml0ZXIoKTtcbiAgICAgICAgYXNuV3JpdGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgICBhc25Xcml0ZXIuc3RhcnRTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgYXNuV3JpdGVyLndyaXRlT0lEKCcxLjMuMTAxLjExMCcpOyAvLyBpZC1YMjU1MTlcbiAgICAgICAgICBhc25Xcml0ZXIuZW5kU2VxdWVuY2UoKTtcblxuICAgICAgICAgIC8vIFB1YmxpY0tleVxuICAgICAgICAgIGFzbldyaXRlci5zdGFydFNlcXVlbmNlKEJlci5CaXRTdHJpbmcpO1xuICAgICAgICAgICAgYXNuV3JpdGVyLndyaXRlQnl0ZSgweDAwKTtcbiAgICAgICAgICAgIC8vIFhYWDogaGFjayB0byB3cml0ZSBhIHJhdyBidWZmZXIgd2l0aG91dCBhIHRhZyAtLSB5dWNrXG4gICAgICAgICAgICBhc25Xcml0ZXIuX2Vuc3VyZShvdGhlclB1YmxpY0tleS5sZW5ndGgpO1xuICAgICAgICAgICAgb3RoZXJQdWJsaWNLZXkuY29weShhc25Xcml0ZXIuX2J1ZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNuV3JpdGVyLl9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyUHVibGljS2V5Lmxlbmd0aCk7XG4gICAgICAgICAgICBhc25Xcml0ZXIuX29mZnNldCArPSBvdGhlclB1YmxpY0tleS5sZW5ndGg7XG4gICAgICAgICAgYXNuV3JpdGVyLmVuZFNlcXVlbmNlKCk7XG4gICAgICAgIGFzbldyaXRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9NcGludChkaWZmaWVIZWxsbWFuKHtcbiAgICAgICAgICBwcml2YXRlS2V5OiB0aGlzLl9rZXlzLnByaXZhdGVLZXksXG4gICAgICAgICAgcHVibGljS2V5OiBjcmVhdGVQdWJsaWNLZXkoe1xuICAgICAgICAgICAga2V5OiBhc25Xcml0ZXIuYnVmZmVyLFxuICAgICAgICAgICAgdHlwZTogJ3Nwa2knLFxuICAgICAgICAgICAgZm9ybWF0OiAnZGVyJyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEVDREhFeGNoYW5nZSBleHRlbmRzIEtleUV4Y2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihjdXJ2ZU5hbWUsIGhhc2hOYW1lLCAuLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcblxuICAgICAgdGhpcy50eXBlID0gJ2VjZGgnO1xuICAgICAgdGhpcy5jdXJ2ZU5hbWUgPSBjdXJ2ZU5hbWU7XG4gICAgICB0aGlzLmhhc2hOYW1lID0gaGFzaE5hbWU7XG4gICAgfVxuICAgIGdlbmVyYXRlS2V5cygpIHtcbiAgICAgIGlmICghdGhpcy5fZGgpIHtcbiAgICAgICAgdGhpcy5fZGggPSBjcmVhdGVFQ0RIKHRoaXMuY3VydmVOYW1lKTtcbiAgICAgICAgdGhpcy5fcHVibGljID0gdGhpcy5fZGguZ2VuZXJhdGVLZXlzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgREhHcm91cEV4Y2hhbmdlIGV4dGVuZHMgS2V5RXhjaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hOYW1lLCAuLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcblxuICAgICAgdGhpcy50eXBlID0gJ2dyb3VwZXgnO1xuICAgICAgdGhpcy5oYXNoTmFtZSA9IGhhc2hOYW1lO1xuICAgICAgdGhpcy5fcHJpbWUgPSBudWxsO1xuICAgICAgdGhpcy5fZ2VuZXJhdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX21pbkJpdHMgPSBHRVhfTUlOX0JJVFM7XG4gICAgICB0aGlzLl9wcmVmQml0cyA9IGRoRXN0aW1hdGUodGhpcy5uZWdvdGlhdGVkKTtcbiAgICAgIGlmICh0aGlzLl9wcm90b2NvbC5fY29tcGF0RmxhZ3MgJiBDT01QQVQuQlVHX0RIR0VYX0xBUkdFKVxuICAgICAgICB0aGlzLl9wcmVmQml0cyA9IE1hdGgubWluKHRoaXMuX3ByZWZCaXRzLCA0MDk2KTtcbiAgICAgIHRoaXMuX21heEJpdHMgPSBHRVhfTUFYX0JJVFM7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgaWYgKHRoaXMuX3Byb3RvY29sLl9zZXJ2ZXIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyAmJiB0aGlzLl9wcm90b2NvbC5fZGVidWcoXG4gICAgICAgICdPdXRib3VuZDogU2VuZGluZyBLRVhESF9HRVhfUkVRVUVTVCdcbiAgICAgICk7XG4gICAgICBsZXQgcCA9IHRoaXMuX3Byb3RvY29sLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0S0VYO1xuICAgICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcHJvdG9jb2wuX3BhY2tldFJXLndyaXRlLmFsbG9jKFxuICAgICAgICAxICsgNCArIDQgKyA0LFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgcGFja2V0W3BdID0gTUVTU0FHRS5LRVhESF9HRVhfUkVRVUVTVDtcbiAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCB0aGlzLl9taW5CaXRzLCArK3ApO1xuICAgICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHRoaXMuX3ByZWZCaXRzLCBwICs9IDQpO1xuICAgICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHRoaXMuX21heEJpdHMsIHAgKz0gNCk7XG4gICAgICB0aGlzLl9wcm90b2NvbC5fY2lwaGVyLmVuY3J5cHQoXG4gICAgICAgIHRoaXMuX3Byb3RvY29sLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQsIHRydWUpXG4gICAgICApO1xuICAgIH1cbiAgICBnZW5lcmF0ZUtleXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX2RoICYmIHRoaXMuX3ByaW1lICYmIHRoaXMuX2dlbmVyYXRvcikge1xuICAgICAgICB0aGlzLl9kaCA9IGNyZWF0ZURpZmZpZUhlbGxtYW4odGhpcy5fcHJpbWUsIHRoaXMuX2dlbmVyYXRvcik7XG4gICAgICAgIHRoaXMuX3B1YmxpYyA9IHRoaXMuX2RoLmdlbmVyYXRlS2V5cygpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRESFBhcmFtcyhwcmltZSwgZ2VuZXJhdG9yKSB7XG4gICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcmltZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmltZSB2YWx1ZScpO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZ2VuZXJhdG9yKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGdlbmVyYXRvciB2YWx1ZScpO1xuICAgICAgdGhpcy5fcHJpbWUgPSBwcmltZTtcbiAgICAgIHRoaXMuX2dlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICB9XG4gICAgZ2V0REhQYXJhbXMoKSB7XG4gICAgICBpZiAodGhpcy5fZGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcmltZTogY29udmVydFRvTXBpbnQodGhpcy5fZGguZ2V0UHJpbWUoKSksXG4gICAgICAgICAgZ2VuZXJhdG9yOiBjb252ZXJ0VG9NcGludCh0aGlzLl9kaC5nZXRHZW5lcmF0b3IoKSksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnNlKHBheWxvYWQpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBwYXlsb2FkWzBdO1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGVwKSB7XG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgIGlmICh0aGlzLl9wcm90b2NvbC5fc2VydmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gTUVTU0FHRS5LRVhESF9HRVhfUkVRVUVTVCkge1xuICAgICAgICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLFxuICAgICAgICAgICAgICAgIGBSZWNlaXZlZCBwYWNrZXQgJHt0eXBlfSBpbnN0ZWFkIG9mIGBcbiAgICAgICAgICAgICAgICAgICsgTUVTU0FHRS5LRVhESF9HRVhfUkVRVUVTVCxcbiAgICAgICAgICAgICAgICAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBhbGxvdyB1c2VyIGltcGxlbWVudGF0aW9uIHRvIHByb3ZpZGUgc2FmZSBwcmltZSBhbmRcbiAgICAgICAgICAgIC8vIGdlbmVyYXRvciBvbiBkZW1hbmQgdG8gc3VwcG9ydCBncm91cCBleGNoYW5nZSBvbiBzZXJ2ZXIgc2lkZVxuICAgICAgICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAgICdHcm91cCBleGNoYW5nZSBub3QgaW1wbGVtZW50ZWQgZm9yIHNlcnZlcicsXG4gICAgICAgICAgICAgICdoYW5kc2hha2UnLFxuICAgICAgICAgICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlICE9PSBNRVNTQUdFLktFWERIX0dFWF9HUk9VUCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvRmF0YWxFcnJvcihcbiAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAgIGBSZWNlaXZlZCBwYWNrZXQgJHt0eXBlfSBpbnN0ZWFkIG9mICR7TUVTU0FHRS5LRVhESF9HRVhfR1JPVVB9YCxcbiAgICAgICAgICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICAgIERJU0NPTk5FQ1RfUkVBU09OLktFWV9FWENIQU5HRV9GQUlMRURcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2RlYnVnICYmIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyhcbiAgICAgICAgICAgICdSZWNlaXZlZCBESCBHRVggR3JvdXAnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8qXG4gICAgICAgICAgICBieXRlICAgIFNTSF9NU0dfS0VYX0RIX0dFWF9HUk9VUFxuICAgICAgICAgICAgbXBpbnQgICBwLCBzYWZlIHByaW1lXG4gICAgICAgICAgICBtcGludCAgIGcsIGdlbmVyYXRvciBmb3Igc3ViZ3JvdXAgaW4gR0YocClcbiAgICAgICAgICAqL1xuICAgICAgICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgICAgICAgIGxldCBwcmltZTtcbiAgICAgICAgICBsZXQgZ2VuO1xuICAgICAgICAgIGlmICgocHJpbWUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpKSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgIHx8IChnZW4gPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLFxuICAgICAgICAgICAgICAnUmVjZWl2ZWQgbWFsZm9ybWVkIEtFWERIX0dFWF9HUk9VUCcsXG4gICAgICAgICAgICAgICdoYW5kc2hha2UnLFxuICAgICAgICAgICAgICBESVNDT05ORUNUX1JFQVNPTi5LRVlfRVhDSEFOR0VfRkFJTEVEXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgICAgICAgIC8vIFRPRE86IHZhbGlkYXRlIHByaW1lXG4gICAgICAgICAgdGhpcy5zZXRESFBhcmFtcyhwcmltZSwgZ2VuKTtcbiAgICAgICAgICB0aGlzLmdlbmVyYXRlS2V5cygpO1xuICAgICAgICAgIGNvbnN0IHB1YmtleSA9IHRoaXMuZ2V0UHVibGljS2V5KCk7XG5cbiAgICAgICAgICB0aGlzLl9wcm90b2NvbC5fZGVidWcgJiYgdGhpcy5fcHJvdG9jb2wuX2RlYnVnKFxuICAgICAgICAgICAgJ091dGJvdW5kOiBTZW5kaW5nIEtFWERIX0dFWF9JTklUJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBsZXQgcCA9IHRoaXMuX3Byb3RvY29sLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0S0VYO1xuICAgICAgICAgIGNvbnN0IHBhY2tldCA9XG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5fcGFja2V0Ulcud3JpdGUuYWxsb2MoMSArIDQgKyBwdWJrZXkubGVuZ3RoLCB0cnVlKTtcbiAgICAgICAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLktFWERIX0dFWF9JTklUO1xuICAgICAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBwdWJrZXkubGVuZ3RoLCArK3ApO1xuICAgICAgICAgIHBhY2tldC5zZXQocHVia2V5LCBwICs9IDQpO1xuICAgICAgICAgIHRoaXMuX3Byb3RvY29sLl9jaXBoZXIuZW5jcnlwdChcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQsIHRydWUpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICsrdGhpcy5fc3RlcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaWYgKHRoaXMuX3Byb3RvY29sLl9zZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBNRVNTQUdFLktFWERIX0dFWF9JTklUKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgYFJlY2VpdmVkIHBhY2tldCAke3R5cGV9IGluc3RlYWQgb2YgJHtNRVNTQUdFLktFWERIX0dFWF9JTklUfWAsXG4gICAgICAgICAgICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2RlYnVnICYmIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgJ1JlY2VpdmVkIERIIEdFWCBJbml0J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkb0ZhdGFsRXJyb3IoXG4gICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLFxuICAgICAgICAgICAgICAnR3JvdXAgZXhjaGFuZ2Ugbm90IGltcGxlbWVudGVkIGZvciBzZXJ2ZXInLFxuICAgICAgICAgICAgICAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IE1FU1NBR0UuS0VYREhfR0VYX1JFUExZKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbCxcbiAgICAgICAgICAgICAgYFJlY2VpdmVkIHBhY2tldCAke3R5cGV9IGluc3RlYWQgb2YgJHtNRVNTQUdFLktFWERIX0dFWF9SRVBMWX1gLFxuICAgICAgICAgICAgICAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2RlYnVnICYmIHRoaXMuX3Byb3RvY29sLl9kZWJ1ZyhcbiAgICAgICAgICAgICdSZWNlaXZlZCBESCBHRVggUmVwbHknXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLl9zdGVwID0gMTtcbiAgICAgICAgICBwYXlsb2FkWzBdID0gTUVTU0FHRS5LRVhESF9SRVBMWTtcbiAgICAgICAgICB0aGlzLnBhcnNlID0gS2V5RXhjaGFuZ2UucHJvdG90eXBlLnBhcnNlO1xuICAgICAgICAgIHRoaXMucGFyc2UocGF5bG9hZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgREhFeGNoYW5nZSBleHRlbmRzIEtleUV4Y2hhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihncm91cE5hbWUsIGhhc2hOYW1lLCAuLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcblxuICAgICAgdGhpcy50eXBlID0gJ2dyb3VwJztcbiAgICAgIHRoaXMuZ3JvdXBOYW1lID0gZ3JvdXBOYW1lO1xuICAgICAgdGhpcy5oYXNoTmFtZSA9IGhhc2hOYW1lO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgIGlmICghdGhpcy5fcHJvdG9jb2wuX3NlcnZlcikge1xuICAgICAgICB0aGlzLl9wcm90b2NvbC5fZGVidWcgJiYgdGhpcy5fcHJvdG9jb2wuX2RlYnVnKFxuICAgICAgICAgICdPdXRib3VuZDogU2VuZGluZyBLRVhESF9JTklUJ1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBwdWJLZXkgPSB0aGlzLmdldFB1YmxpY0tleSgpO1xuICAgICAgICBsZXQgcCA9IHRoaXMuX3Byb3RvY29sLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0S0VYO1xuICAgICAgICBjb25zdCBwYWNrZXQgPVxuICAgICAgICAgIHRoaXMuX3Byb3RvY29sLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIHB1YktleS5sZW5ndGgsIHRydWUpO1xuICAgICAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLktFWERIX0lOSVQ7XG4gICAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBwdWJLZXkubGVuZ3RoLCArK3ApO1xuICAgICAgICBwYWNrZXQuc2V0KHB1YktleSwgcCArPSA0KTtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuX2NpcGhlci5lbmNyeXB0KFxuICAgICAgICAgIHRoaXMuX3Byb3RvY29sLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQsIHRydWUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbmVyYXRlS2V5cygpIHtcbiAgICAgIGlmICghdGhpcy5fZGgpIHtcbiAgICAgICAgdGhpcy5fZGggPSBjcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXAodGhpcy5ncm91cE5hbWUpO1xuICAgICAgICB0aGlzLl9wdWJsaWMgPSB0aGlzLl9kaC5nZW5lcmF0ZUtleXMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0REhQYXJhbXMoKSB7XG4gICAgICBpZiAodGhpcy5fZGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcmltZTogY29udmVydFRvTXBpbnQodGhpcy5fZGguZ2V0UHJpbWUoKSksXG4gICAgICAgICAgZ2VuZXJhdG9yOiBjb252ZXJ0VG9NcGludCh0aGlzLl9kaC5nZXRHZW5lcmF0b3IoKSksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChuZWdvdGlhdGVkLCAuLi5hcmdzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuZWdvdGlhdGVkICE9PSAnb2JqZWN0JyB8fCBuZWdvdGlhdGVkID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5lZ290aWF0ZWQgYXJndW1lbnQnKTtcbiAgICBjb25zdCBrZXhUeXBlID0gbmVnb3RpYXRlZC5rZXg7XG4gICAgaWYgKHR5cGVvZiBrZXhUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgYXJncyA9IFtuZWdvdGlhdGVkLCAuLi5hcmdzXTtcbiAgICAgIHN3aXRjaCAoa2V4VHlwZSkge1xuICAgICAgICBjYXNlICdjdXJ2ZTI1NTE5LXNoYTI1Nic6XG4gICAgICAgIGNhc2UgJ2N1cnZlMjU1MTktc2hhMjU2QGxpYnNzaC5vcmcnOlxuICAgICAgICAgIGlmICghY3VydmUyNTUxOVN1cHBvcnRlZClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHJldHVybiBuZXcgQ3VydmUyNTUxOUV4Y2hhbmdlKCdzaGEyNTYnLCAuLi5hcmdzKTtcblxuICAgICAgICBjYXNlICdlY2RoLXNoYTItbmlzdHAyNTYnOlxuICAgICAgICAgIHJldHVybiBuZXcgRUNESEV4Y2hhbmdlKCdwcmltZTI1NnYxJywgJ3NoYTI1NicsIC4uLmFyZ3MpO1xuICAgICAgICBjYXNlICdlY2RoLXNoYTItbmlzdHAzODQnOlxuICAgICAgICAgIHJldHVybiBuZXcgRUNESEV4Y2hhbmdlKCdzZWNwMzg0cjEnLCAnc2hhMzg0JywgLi4uYXJncyk7XG4gICAgICAgIGNhc2UgJ2VjZGgtc2hhMi1uaXN0cDUyMSc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBFQ0RIRXhjaGFuZ2UoJ3NlY3A1MjFyMScsICdzaGE1MTInLCAuLi5hcmdzKTtcblxuICAgICAgICBjYXNlICdkaWZmaWUtaGVsbG1hbi1ncm91cDEtc2hhMSc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBESEV4Y2hhbmdlKCdtb2RwMicsICdzaGExJywgLi4uYXJncyk7XG4gICAgICAgIGNhc2UgJ2RpZmZpZS1oZWxsbWFuLWdyb3VwMTQtc2hhMSc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBESEV4Y2hhbmdlKCdtb2RwMTQnLCAnc2hhMScsIC4uLmFyZ3MpO1xuICAgICAgICBjYXNlICdkaWZmaWUtaGVsbG1hbi1ncm91cDE0LXNoYTI1Nic6XG4gICAgICAgICAgcmV0dXJuIG5ldyBESEV4Y2hhbmdlKCdtb2RwMTQnLCAnc2hhMjU2JywgLi4uYXJncyk7XG4gICAgICAgIGNhc2UgJ2RpZmZpZS1oZWxsbWFuLWdyb3VwMTUtc2hhNTEyJzpcbiAgICAgICAgICByZXR1cm4gbmV3IERIRXhjaGFuZ2UoJ21vZHAxNScsICdzaGE1MTInLCAuLi5hcmdzKTtcbiAgICAgICAgY2FzZSAnZGlmZmllLWhlbGxtYW4tZ3JvdXAxNi1zaGE1MTInOlxuICAgICAgICAgIHJldHVybiBuZXcgREhFeGNoYW5nZSgnbW9kcDE2JywgJ3NoYTUxMicsIC4uLmFyZ3MpO1xuICAgICAgICBjYXNlICdkaWZmaWUtaGVsbG1hbi1ncm91cDE3LXNoYTUxMic6XG4gICAgICAgICAgcmV0dXJuIG5ldyBESEV4Y2hhbmdlKCdtb2RwMTcnLCAnc2hhNTEyJywgLi4uYXJncyk7XG4gICAgICAgIGNhc2UgJ2RpZmZpZS1oZWxsbWFuLWdyb3VwMTgtc2hhNTEyJzpcbiAgICAgICAgICByZXR1cm4gbmV3IERIRXhjaGFuZ2UoJ21vZHAxOCcsICdzaGE1MTInLCAuLi5hcmdzKTtcblxuICAgICAgICBjYXNlICdkaWZmaWUtaGVsbG1hbi1ncm91cC1leGNoYW5nZS1zaGExJzpcbiAgICAgICAgICByZXR1cm4gbmV3IERIR3JvdXBFeGNoYW5nZSgnc2hhMScsIC4uLmFyZ3MpO1xuICAgICAgICBjYXNlICdkaWZmaWUtaGVsbG1hbi1ncm91cC1leGNoYW5nZS1zaGEyNTYnOlxuICAgICAgICAgIHJldHVybiBuZXcgREhHcm91cEV4Y2hhbmdlKCdzaGEyNTYnLCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQga2V5IGV4Y2hhbmdlIGFsZ29yaXRobTogJHtrZXhUeXBlfWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQga2V5IGV4Y2hhbmdlIHR5cGU6ICR7a2V4VHlwZX1gKTtcbiAgfTtcbn0pKCk7XG5cbmNvbnN0IEtleEluaXQgPSAoKCkgPT4ge1xuICBjb25zdCBLRVhfUFJPUEVSVFlfTkFNRVMgPSBbXG4gICAgJ2tleCcsXG4gICAgJ3NlcnZlckhvc3RLZXknLFxuICAgIFsnY3MnLCAnY2lwaGVyJyBdLFxuICAgIFsnc2MnLCAnY2lwaGVyJyBdLFxuICAgIFsnY3MnLCAnbWFjJyBdLFxuICAgIFsnc2MnLCAnbWFjJyBdLFxuICAgIFsnY3MnLCAnY29tcHJlc3MnIF0sXG4gICAgWydzYycsICdjb21wcmVzcycgXSxcbiAgICBbJ2NzJywgJ2xhbmcnIF0sXG4gICAgWydzYycsICdsYW5nJyBdLFxuICBdO1xuICByZXR1cm4gY2xhc3MgS2V4SW5pdCB7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXG4gICAgICBjb25zdCBsaXN0cyA9IHtcbiAgICAgICAga2V4OiB1bmRlZmluZWQsXG4gICAgICAgIHNlcnZlckhvc3RLZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgY3M6IHtcbiAgICAgICAgICBjaXBoZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICBtYWM6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjb21wcmVzczogdW5kZWZpbmVkLFxuICAgICAgICAgIGxhbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcbiAgICAgICAgc2M6IHtcbiAgICAgICAgICBjaXBoZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICBtYWM6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjb21wcmVzczogdW5kZWZpbmVkLFxuICAgICAgICAgIGxhbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcblxuICAgICAgICBhbGw6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBsZXQgdG90YWxTaXplID0gMDtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBLRVhfUFJPUEVSVFlfTkFNRVMpIHtcbiAgICAgICAgbGV0IGJhc2U7XG4gICAgICAgIGxldCB2YWw7XG4gICAgICAgIGxldCBkZXNjO1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYmFzZSA9IGxpc3RzO1xuICAgICAgICAgIHZhbCA9IG9ialtwcm9wXTtcbiAgICAgICAgICBkZXNjID0ga2V5ID0gcHJvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBwcm9wWzBdO1xuICAgICAgICAgIGJhc2UgPSBsaXN0c1twYXJlbnRdO1xuICAgICAgICAgIGtleSA9IHByb3BbMV07XG4gICAgICAgICAgdmFsID0gb2JqW3BhcmVudF1ba2V5XTtcbiAgICAgICAgICBkZXNjID0gYCR7cGFyZW50fS4ke2tleX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0geyBhcnJheTogdW5kZWZpbmVkLCBidWZmZXI6IHVuZGVmaW5lZCB9O1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAgICAgICBlbnRyeS5hcnJheSA9ICgnJyArIHZhbCkuc3BsaXQoJywnKTtcbiAgICAgICAgICBlbnRyeS5idWZmZXIgPSB2YWw7XG4gICAgICAgICAgdG90YWxTaXplICs9IDQgKyB2YWwubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zcGxpdCgnLCcpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGVudHJ5LmFycmF5ID0gdmFsO1xuICAgICAgICAgICAgZW50cnkuYnVmZmVyID0gQnVmZmVyLmZyb20odmFsLmpvaW4oJywnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgXFxgJHtkZXNjfVxcYCB0eXBlOiAke3R5cGVvZiB2YWx9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsU2l6ZSArPSA0ICsgZW50cnkuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBiYXNlW2tleV0gPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWxsID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsU2l6ZSk7XG4gICAgICBsaXN0cy5hbGwgPSBhbGw7XG5cbiAgICAgIGxldCBhbGxQb3MgPSAwO1xuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIEtFWF9QUk9QRVJUWV9OQU1FUykge1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJylcbiAgICAgICAgICBkYXRhID0gbGlzdHNbcHJvcF0uYnVmZmVyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZGF0YSA9IGxpc3RzW3Byb3BbMF1dW3Byb3BbMV1dLmJ1ZmZlcjtcbiAgICAgICAgYWxsUG9zID0gd3JpdGVVSW50MzJCRShhbGwsIGRhdGEubGVuZ3RoLCBhbGxQb3MpO1xuICAgICAgICBhbGwuc2V0KGRhdGEsIGFsbFBvcyk7XG4gICAgICAgIGFsbFBvcyArPSBkYXRhLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b3RhbFNpemUgPSB0b3RhbFNpemU7XG4gICAgICB0aGlzLmxpc3RzID0gbGlzdHM7XG4gICAgfVxuICAgIGNvcHlBbGxUbyhidWYsIG9mZnNldCkge1xuICAgICAgY29uc3Qgc3JjID0gdGhpcy5saXN0cy5hbGw7XG4gICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgb2Zmc2V0IHZhbHVlOiAke3R5cGVvZiBvZmZzZXR9YCk7XG4gICAgICBpZiAoYnVmLmxlbmd0aCAtIG9mZnNldCA8IHNyYy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdWZmaWNpZW50IHNwYWNlIHRvIGNvcHkgbGlzdCcpO1xuICAgICAgYnVmLnNldChzcmMsIG9mZnNldCk7XG4gICAgICByZXR1cm4gc3JjLmxlbmd0aDtcbiAgICB9XG4gIH07XG59KSgpO1xuXG5jb25zdCBoYXNoU3RyaW5nID0gKCgpID0+IHtcbiAgY29uc3QgTEVOID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpO1xuICByZXR1cm4gKGhhc2gsIGJ1ZikgPT4ge1xuICAgIHdyaXRlVUludDMyQkUoTEVOLCBidWYubGVuZ3RoLCAwKTtcbiAgICBoYXNoLnVwZGF0ZShMRU4pO1xuICAgIGhhc2gudXBkYXRlKGJ1Zik7XG4gIH07XG59KSgpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUtFWFZhbChsZW4sIGhhc2hOYW1lLCBzZWNyZXQsIGV4Y2hhbmdlSGFzaCwgc2Vzc2lvbklELCBjaGFyKSB7XG4gIGxldCByZXQ7XG4gIGlmIChsZW4pIHtcbiAgICBsZXQgZGlnZXN0ID0gY3JlYXRlSGFzaChoYXNoTmFtZSlcbiAgICAgICAgICAgICAgICAgICAudXBkYXRlKHNlY3JldClcbiAgICAgICAgICAgICAgICAgICAudXBkYXRlKGV4Y2hhbmdlSGFzaClcbiAgICAgICAgICAgICAgICAgICAudXBkYXRlKGNoYXIpXG4gICAgICAgICAgICAgICAgICAgLnVwZGF0ZShzZXNzaW9uSUQpXG4gICAgICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICAgIHdoaWxlIChkaWdlc3QubGVuZ3RoIDwgbGVuKSB7XG4gICAgICBjb25zdCBjaHVuayA9IGNyZWF0ZUhhc2goaGFzaE5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZShzZWNyZXQpXG4gICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZShleGNoYW5nZUhhc2gpXG4gICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZShkaWdlc3QpXG4gICAgICAgICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICAgICAgY29uc3QgZXh0ZW5kZWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZGlnZXN0Lmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICBleHRlbmRlZC5zZXQoZGlnZXN0LCAwKTtcbiAgICAgIGV4dGVuZGVkLnNldChjaHVuaywgZGlnZXN0Lmxlbmd0aCk7XG4gICAgICBkaWdlc3QgPSBleHRlbmRlZDtcbiAgICB9XG4gICAgaWYgKGRpZ2VzdC5sZW5ndGggPT09IGxlbilcbiAgICAgIHJldCA9IGRpZ2VzdDtcbiAgICBlbHNlXG4gICAgICByZXQgPSBuZXcgRmFzdEJ1ZmZlcihkaWdlc3QuYnVmZmVyLCBkaWdlc3QuYnl0ZU9mZnNldCwgbGVuKTtcbiAgfSBlbHNlIHtcbiAgICByZXQgPSBFTVBUWV9CVUZGRVI7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25LRVhQYXlsb2FkKHN0YXRlLCBwYXlsb2FkKSB7XG4gIC8vIFhYWDogbW92ZSB0aGlzIHRvIHRoZSBEZWNpcGhlciBpbXBsZW1lbnRhdGlvbnM/XG4gIGlmIChwYXlsb2FkLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKCdJbmJvdW5kOiBTa2lwcGluZyBlbXB0eSBwYWNrZXQgcGF5bG9hZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9za2lwTmV4dEluYm91bmRQYWNrZXQpIHtcbiAgICB0aGlzLl9za2lwTmV4dEluYm91bmRQYWNrZXQgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBwYXlsb2FkID0gdGhpcy5fcGFja2V0UlcucmVhZC5yZWFkKHBheWxvYWQpO1xuXG4gIGNvbnN0IHR5cGUgPSBwYXlsb2FkWzBdO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIE1FU1NBR0UuRElTQ09OTkVDVDpcbiAgICBjYXNlIE1FU1NBR0UuSUdOT1JFOlxuICAgIGNhc2UgTUVTU0FHRS5VTklNUExFTUVOVEVEOlxuICAgIGNhc2UgTUVTU0FHRS5ERUJVRzpcbiAgICAgIGlmICghTUVTU0FHRV9IQU5ETEVSUylcbiAgICAgICAgTUVTU0FHRV9IQU5ETEVSUyA9IHJlcXVpcmUoJy4vaGFuZGxlcnMuanMnKTtcbiAgICAgIHJldHVybiBNRVNTQUdFX0hBTkRMRVJTW3R5cGVdKHRoaXMsIHBheWxvYWQpO1xuICAgIGNhc2UgTUVTU0FHRS5LRVhJTklUOlxuICAgICAgaWYgKCFzdGF0ZS5maXJzdFBhY2tldCkge1xuICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgJ1JlY2VpdmVkIGV4dHJhIEtFWElOSVQgZHVyaW5nIGhhbmRzaGFrZScsXG4gICAgICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc3RhdGUuZmlyc3RQYWNrZXQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBoYW5kbGVLZXhJbml0KHRoaXMsIHBheWxvYWQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZSA8IDIwIHx8IHR5cGUgPiA0OSkge1xuICAgICAgICByZXR1cm4gZG9GYXRhbEVycm9yKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYFJlY2VpdmVkIHVuZXhwZWN0ZWQgcGFja2V0IHR5cGUgJHt0eXBlfWAsXG4gICAgICAgICAgJ2hhbmRzaGFrZScsXG4gICAgICAgICAgRElTQ09OTkVDVF9SRUFTT04uS0VZX0VYQ0hBTkdFX0ZBSUxFRFxuICAgICAgICApO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2tleC5wYXJzZShwYXlsb2FkKTtcbn1cblxuZnVuY3Rpb24gZGhFc3RpbWF0ZShuZWcpIHtcbiAgY29uc3QgY3NDaXBoZXIgPSBDSVBIRVJfSU5GT1tuZWcuY3MuY2lwaGVyXTtcbiAgY29uc3Qgc2NDaXBoZXIgPSBDSVBIRVJfSU5GT1tuZWcuc2MuY2lwaGVyXTtcbiAgLy8gWFhYOiBpZiBPcGVuU1NIJ3MgYHVtYWMtKmAgTUFDcyBhcmUgZXZlciBzdXBwb3J0ZWQsIHRoZWlyIGtleSBsZW5ndGhzIHdpbGxcbiAgLy8gYWxzbyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQgd2hlbiBjYWxjdWxhdGluZyBgYml0c2BcbiAgY29uc3QgYml0cyA9IE1hdGgubWF4KFxuICAgIDAsXG4gICAgKGNzQ2lwaGVyLnNzbE5hbWUgPT09ICdkZXMtZWRlMy1jYmMnID8gMTQgOiBjc0NpcGhlci5rZXlMZW4pLFxuICAgIGNzQ2lwaGVyLmJsb2NrTGVuLFxuICAgIGNzQ2lwaGVyLml2TGVuLFxuICAgIChzY0NpcGhlci5zc2xOYW1lID09PSAnZGVzLWVkZTMtY2JjJyA/IDE0IDogc2NDaXBoZXIua2V5TGVuKSxcbiAgICBzY0NpcGhlci5ibG9ja0xlbixcbiAgICBzY0NpcGhlci5pdkxlblxuICApICogODtcbiAgaWYgKGJpdHMgPD0gMTEyKVxuICAgIHJldHVybiAyMDQ4O1xuICBpZiAoYml0cyA8PSAxMjgpXG4gICAgcmV0dXJuIDMwNzI7XG4gIGlmIChiaXRzIDw9IDE5MilcbiAgICByZXR1cm4gNzY4MDtcbiAgcmV0dXJuIDgxOTI7XG59XG5cbmZ1bmN0aW9uIHRyeVNlbmRORVdLRVlTKGtleCkge1xuICBpZiAoIWtleC5fc2VudE5FV0tFWVMpIHtcbiAgICBrZXguX3Byb3RvY29sLl9kZWJ1ZyAmJiBrZXguX3Byb3RvY29sLl9kZWJ1ZyhcbiAgICAgICdPdXRib3VuZDogU2VuZGluZyBORVdLRVlTJ1xuICAgICk7XG4gICAgY29uc3QgcCA9IGtleC5fcHJvdG9jb2wuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnRLRVg7XG4gICAgY29uc3QgcGFja2V0ID0ga2V4Ll9wcm90b2NvbC5fcGFja2V0Ulcud3JpdGUuYWxsb2MoMSwgdHJ1ZSk7XG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5ORVdLRVlTO1xuICAgIGtleC5fcHJvdG9jb2wuX2NpcGhlci5lbmNyeXB0KFxuICAgICAga2V4Ll9wcm90b2NvbC5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0LCB0cnVlKVxuICAgICk7XG4gICAga2V4Ll9zZW50TkVXS0VZUyA9IHRydWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtleEluaXQsXG4gIGtleGluaXQsXG4gIG9uS0VYUGF5bG9hZCxcbiAgREVGQVVMVF9LRVhJTklUX0NMSUVOVDogbmV3IEtleEluaXQoe1xuICAgIGtleDogREVGQVVMVF9LRVguY29uY2F0KFsnZXh0LWluZm8tYyddKSxcbiAgICBzZXJ2ZXJIb3N0S2V5OiBERUZBVUxUX1NFUlZFUl9IT1NUX0tFWSxcbiAgICBjczoge1xuICAgICAgY2lwaGVyOiBERUZBVUxUX0NJUEhFUixcbiAgICAgIG1hYzogREVGQVVMVF9NQUMsXG4gICAgICBjb21wcmVzczogREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICAgIGxhbmc6IFtdLFxuICAgIH0sXG4gICAgc2M6IHtcbiAgICAgIGNpcGhlcjogREVGQVVMVF9DSVBIRVIsXG4gICAgICBtYWM6IERFRkFVTFRfTUFDLFxuICAgICAgY29tcHJlc3M6IERFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgICBsYW5nOiBbXSxcbiAgICB9LFxuICB9KSxcbiAgREVGQVVMVF9LRVhJTklUX1NFUlZFUjogbmV3IEtleEluaXQoe1xuICAgIGtleDogREVGQVVMVF9LRVgsXG4gICAgc2VydmVySG9zdEtleTogREVGQVVMVF9TRVJWRVJfSE9TVF9LRVksXG4gICAgY3M6IHtcbiAgICAgIGNpcGhlcjogREVGQVVMVF9DSVBIRVIsXG4gICAgICBtYWM6IERFRkFVTFRfTUFDLFxuICAgICAgY29tcHJlc3M6IERFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgICBsYW5nOiBbXSxcbiAgICB9LFxuICAgIHNjOiB7XG4gICAgICBjaXBoZXI6IERFRkFVTFRfQ0lQSEVSLFxuICAgICAgbWFjOiBERUZBVUxUX01BQyxcbiAgICAgIGNvbXByZXNzOiBERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgICAgbGFuZzogW10sXG4gICAgfSxcbiAgfSksXG4gIEhBTkRMRVJTOiB7XG4gICAgW01FU1NBR0UuS0VYSU5JVF06IGhhbmRsZUtleEluaXQsXG4gIH0sXG59O1xuIiwgIntcbiAgXCJuYW1lXCI6IFwic3NoMlwiLFxuICBcInZlcnNpb25cIjogXCIxLjEzLjBcIixcbiAgXCJhdXRob3JcIjogXCJCcmlhbiBXaGl0ZSA8bXNjZGV4QG1zY2RleC5uZXQ+XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJTU0gyIGNsaWVudCBhbmQgc2VydmVyIG1vZHVsZXMgd3JpdHRlbiBpbiBwdXJlIEphdmFTY3JpcHQgZm9yIG5vZGUuanNcIixcbiAgXCJtYWluXCI6IFwiLi9saWIvaW5kZXguanNcIixcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCI+PTEwLjE2LjBcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJhc24xXCI6IFwiXjAuMi42XCIsXG4gICAgXCJiY3J5cHQtcGJrZGZcIjogXCJeMS4wLjJcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAbXNjZGV4L2VzbGludC1jb25maWdcIjogXCJeMS4xLjBcIixcbiAgICBcImVzbGludFwiOiBcIl43LjMyLjBcIlxuICB9LFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImNwdS1mZWF0dXJlc1wiOiBcIn4wLjAuN1wiLFxuICAgIFwibmFuXCI6IFwiXjIuMTcuMFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJpbnN0YWxsXCI6IFwibm9kZSBpbnN0YWxsLmpzXCIsXG4gICAgXCJyZWJ1aWxkXCI6IFwibm9kZSBpbnN0YWxsLmpzXCIsXG4gICAgXCJ0ZXN0XCI6IFwibm9kZSB0ZXN0L3Rlc3QuanNcIixcbiAgICBcImxpbnRcIjogXCJlc2xpbnQgLS1jYWNoZSAtLXJlcG9ydC11bnVzZWQtZGlzYWJsZS1kaXJlY3RpdmVzIC0tZXh0PS5qcyAuZXNsaW50cmMuanMgZXhhbXBsZXMgbGliIHRlc3RcIixcbiAgICBcImxpbnQ6Zml4XCI6IFwibnBtIHJ1biBsaW50IC0tIC0tZml4XCJcbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJzc2hcIixcbiAgICBcInNzaDJcIixcbiAgICBcInNmdHBcIixcbiAgICBcInNlY3VyZVwiLFxuICAgIFwic2hlbGxcIixcbiAgICBcImV4ZWNcIixcbiAgICBcInJlbW90ZVwiLFxuICAgIFwiY2xpZW50XCJcbiAgXSxcbiAgXCJsaWNlbnNlc1wiOiBbXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiTUlUXCIsXG4gICAgICBcInVybFwiOiBcImh0dHA6Ly9naXRodWIuY29tL21zY2RleC9zc2gyL3Jhdy9tYXN0ZXIvTElDRU5TRVwiXG4gICAgfVxuICBdLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vbXNjZGV4L3NzaDIuZ2l0XCJcbiAgfVxufVxuIiwgIi8qXG4gIFRPRE86XG4gICAgKiBSZXBsYWNlIGBidWZmZXIuX3Bvc2AgdXNhZ2UgaW4ga2V5UGFyc2VyLmpzIGFuZCBlbHNld2hlcmVcbiAgICAqIFV0aWxpemUgb3B0aW9uYWwgXCJ3cml0ZXZcIiBzdXBwb3J0IHdoZW4gd3JpdGluZyBwYWNrZXRzIGZyb21cbiAgICAgIGNpcGhlci5lbmNyeXB0KClcbiAgICAqIEJ1aWx0LWluIHN1cHBvcnQgZm9yIGF1dG9tYXRpYyByZS1rZXlpbmcsIG9uIGJ5IGRlZmF1bHRcbiAgICAqIFJldmlzaXQgcmVjZWl2aW5nIHVuZXhwZWN0ZWQvdW5rbm93biBwYWNrZXRzXG4gICAgICAqIEVycm9yIChmYXRhbCBvciBvdGhlcndpc2UpIG9yIGlnbm9yZSBvciBwYXNzIG9uIHRvIHVzZXIgKGluIHNvbWUgb3IgYWxsXG4gICAgICAgIGNhc2VzKT9cbiAgICAgICogSW5jbHVkaW5nIHNlcnZlci9jbGllbnQgY2hlY2sgZm9yIHNpbmdsZSBkaXJlY3Rpb25hbCBwYWNrZXQgdHlwZXM/XG4gICAgICAqIENoZWNrIHBhY2tldHMgZm9yIHZhbGlkaXR5IG9yIGJhaWwgYXMgZWFybHkgYXMgcG9zc2libGU/XG4gICAgKiBBdXRvbWF0aWMgcmUta2V5IGV2ZXJ5IDIqKjMxIHBhY2tldHMgYWZ0ZXIgdGhlIGxhc3Qga2V5IGV4Y2hhbmdlIChzZW50IG9yXG4gICAgICByZWNlaXZlZCksIGFzIHN1Z2dlc3RlZCBieSBSRkM0MzQ0LiBPcGVuU1NIIGN1cnJlbnRseSBkb2VzIHRoaXMuXG4gICAgKiBBdXRvbWF0aWMgcmUta2V5IGV2ZXJ5IHNvIG1hbnkgYmxvY2tzIGRlcGVuZGluZyBvbiBjaXBoZXIuIFJGQzQzNDQ6XG4gICAgICAgICBCZWNhdXNlIG9mIGEgYmlydGhkYXkgcHJvcGVydHkgb2YgYmxvY2sgY2lwaGVycyBhbmQgc29tZSBtb2RlcyBvZlxuICAgICAgICAgb3BlcmF0aW9uLCBpbXBsZW1lbnRhdGlvbnMgbXVzdCBiZSBjYXJlZnVsIG5vdCB0byBlbmNyeXB0IHRvbyBtYW55XG4gICAgICAgICBibG9ja3Mgd2l0aCB0aGUgc2FtZSBlbmNyeXB0aW9uIGtleS5cblxuICAgICAgICAgTGV0IEwgYmUgdGhlIGJsb2NrIGxlbmd0aCAoaW4gYml0cykgb2YgYW4gU1NIIGVuY3J5cHRpb24gbWV0aG9kJ3NcbiAgICAgICAgIGJsb2NrIGNpcGhlciAoZS5nLiwgMTI4IGZvciBBRVMpLiAgSWYgTCBpcyBhdCBsZWFzdCAxMjgsIHRoZW4sIGFmdGVyXG4gICAgICAgICByZWtleWluZywgYW4gU1NIIGltcGxlbWVudGF0aW9uIFNIT1VMRCBOT1QgZW5jcnlwdCBtb3JlIHRoYW4gMioqKEwvNClcbiAgICAgICAgIGJsb2NrcyBiZWZvcmUgcmVrZXlpbmcgYWdhaW4uICBJZiBMIGlzIGF0IGxlYXN0IDEyOCwgdGhlbiBTU0hcbiAgICAgICAgIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBhdHRlbXB0IHRvIGZvcmNlIGEgcmVrZXkgYmVmb3JlIHJlY2VpdmluZ1xuICAgICAgICAgbW9yZSB0aGFuIDIqKihMLzQpIGJsb2Nrcy4gIElmIEwgaXMgbGVzcyB0aGFuIDEyOCAod2hpY2ggaXMgdGhlIGNhc2VcbiAgICAgICAgIGZvciBvbGRlciBjaXBoZXJzIHN1Y2ggYXMgM0RFUywgQmxvd2Zpc2gsIENBU1QtMTI4LCBhbmQgSURFQSksIHRoZW4sXG4gICAgICAgICBhbHRob3VnaCBpdCBtYXkgYmUgdG9vIGV4cGVuc2l2ZSB0byByZWtleSBldmVyeSAyKiooTC80KSBibG9ja3MsIGl0XG4gICAgICAgICBpcyBzdGlsbCBhZHZpc2FibGUgZm9yIFNTSCBpbXBsZW1lbnRhdGlvbnMgdG8gZm9sbG93IHRoZSBvcmlnaW5hbFxuICAgICAgICAgcmVjb21tZW5kYXRpb24gaW4gW1JGQzQyNTNdOiByZWtleSBhdCBsZWFzdCBvbmNlIGZvciBldmVyeSBnaWdhYnl0ZVxuICAgICAgICAgb2YgdHJhbnNtaXR0ZWQgZGF0YS5cblxuICAgICAgICAgTm90ZSB0aGF0IGlmIEwgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDEyOCwgdGhlbiB0aGUgcmVjb21tZW5kYXRpb25cbiAgICAgICAgIGluIHRoaXMgc3Vic2VjdGlvbiBzdXBlcnNlZGVzIHRoZSByZWNvbW1lbmRhdGlvbiBpbiBTZWN0aW9uIDMuMS4gIElmXG4gICAgICAgICBhbiBTU0ggaW1wbGVtZW50YXRpb24gdXNlcyBhIGJsb2NrIGNpcGhlciB3aXRoIGEgbGFyZ2VyIGJsb2NrIHNpemVcbiAgICAgICAgIChlLmcuLCBSaWpuZGFlbCB3aXRoIDI1Ni1iaXQgYmxvY2tzKSwgdGhlbiB0aGUgcmVjb21tZW5kYXRpb25zIGluXG4gICAgICAgICBTZWN0aW9uIDMuMSBtYXkgc3VwZXJzZWRlIHRoZSByZWNvbW1lbmRhdGlvbnMgaW4gdGhpcyBzdWJzZWN0aW9uXG4gICAgICAgICAoZGVwZW5kaW5nIG9uIHRoZSBsZW5ndGhzIG9mIHRoZSBwYWNrZXRzKS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBpbnNwZWN0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IHsgYmluZGluZ0F2YWlsYWJsZSwgTnVsbENpcGhlciwgTnVsbERlY2lwaGVyIH0gPSByZXF1aXJlKCcuL2NyeXB0by5qcycpO1xuY29uc3Qge1xuICBDT01QQVRfQ0hFQ0tTLFxuICBESVNDT05ORUNUX1JFQVNPTixcbiAgZWRkc2FTdXBwb3J0ZWQsXG4gIE1FU1NBR0UsXG4gIFNJR05BTFMsXG4gIFRFUk1JTkFMX01PREUsXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMuanMnKTtcbmNvbnN0IHtcbiAgREVGQVVMVF9LRVhJTklUX0NMSUVOVCxcbiAgREVGQVVMVF9LRVhJTklUX1NFUlZFUixcbiAgS2V4SW5pdCxcbiAga2V4aW5pdCxcbiAgb25LRVhQYXlsb2FkLFxufSA9IHJlcXVpcmUoJy4va2V4LmpzJyk7XG5jb25zdCB7XG4gIHBhcnNlS2V5LFxufSA9IHJlcXVpcmUoJy4va2V5UGFyc2VyLmpzJyk7XG5jb25zdCBNRVNTQUdFX0hBTkRMRVJTID0gcmVxdWlyZSgnLi9oYW5kbGVycy5qcycpO1xuY29uc3Qge1xuICBidWZmZXJDb3B5LFxuICBidWZmZXJGaWxsLFxuICBidWZmZXJTbGljZSxcbiAgY29udmVydFNpZ25hdHVyZSxcbiAgc2VuZFBhY2tldCxcbiAgd3JpdGVVSW50MzJCRSxcbn0gPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG5jb25zdCB7XG4gIFBhY2tldFJlYWRlcixcbiAgUGFja2V0V3JpdGVyLFxuICBabGliUGFja2V0UmVhZGVyLFxuICBabGliUGFja2V0V3JpdGVyLFxufSA9IHJlcXVpcmUoJy4vemxpYi5qcycpO1xuXG5jb25zdCBNT0RVTEVfVkVSID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcblxuY29uc3QgVkFMSURfRElTQ09OTkVDVF9SRUFTT05TID0gbmV3IE1hcChcbiAgT2JqZWN0LnZhbHVlcyhESVNDT05ORUNUX1JFQVNPTikubWFwKChuKSA9PiBbbiwgMV0pXG4pO1xuY29uc3QgSURFTlRfUkFXID0gQnVmZmVyLmZyb20oYFNTSC0yLjAtc3NoMmpzJHtNT0RVTEVfVkVSfWApO1xuY29uc3QgSURFTlQgPSBCdWZmZXIuZnJvbShgJHtJREVOVF9SQVd9XFxyXFxuYCk7XG5jb25zdCBNQVhfTElORV9MRU4gPSA4MTkyO1xuY29uc3QgTUFYX0xJTkVTID0gMTAyNDtcbmNvbnN0IFBJTkdfUEFZTE9BRCA9IEJ1ZmZlci5mcm9tKFtcbiAgTUVTU0FHRS5HTE9CQUxfUkVRVUVTVCxcbiAgLy8gXCJrZWVwYWxpdmVAb3BlbnNzaC5jb21cIlxuICAwLCAwLCAwLCAyMSxcbiAgICAxMDcsIDEwMSwgMTAxLCAxMTIsIDk3LCAxMDgsIDEwNSwgMTE4LCAxMDEsIDY0LCAxMTEsIDExMiwgMTAxLCAxMTAsIDExNSxcbiAgICAxMTUsIDEwNCwgNDYsIDk5LCAxMTEsIDEwOSxcbiAgLy8gUmVxdWVzdCBhIHJlcGx5XG4gIDEsXG5dKTtcbmNvbnN0IE5PX1RFUk1JTkFMX01PREVTX0JVRkZFUiA9IEJ1ZmZlci5mcm9tKFsgVEVSTUlOQUxfTU9ERS5UVFlfT1BfRU5EIF0pO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLypcbiAgSW5ib3VuZDpcbiAgICAqIGtleGluaXQgcGF5bG9hZCAobmVlZGVkIG9ubHkgdW50aWwgZXhjaGFuZ2UgaGFzaCBpcyBnZW5lcmF0ZWQpXG4gICAgKiByYXcgaWRlbnRcbiAgICAqIHJla2V5IHBhY2tldCBxdWV1ZVxuICAgICogZXhwZWN0ZWQgcGFja2V0IChpbXBsZW1lbnRlZCBhcyBzZXBhcmF0ZSBfcGFyc2UoKSBmdW5jdGlvbj8pXG4gIE91dGJvdW5kOlxuICAgICoga2V4aW5pdCBwYXlsb2FkIChuZWVkZWQgb25seSB1bnRpbCBleGNoYW5nZSBoYXNoIGlzIGdlbmVyYXRlZClcbiAgICAqIHJla2V5IHBhY2tldCBxdWV1ZVxuICAgICoga2V4IHNlY3JldCAobmVlZGVkIG9ubHkgdW50aWwgTkVXS0VZUylcbiAgICAqIGV4Y2hhbmdlIGhhc2ggKG5lZWRlZCBvbmx5IHVudGlsIE5FV0tFWVMpXG4gICAgKiBzZXNzaW9uIElEIChzZXQgdG8gZXhjaGFuZ2UgaGFzaCBmcm9tIGluaXRpYWwgaGFuZHNoYWtlKVxuKi9cbmNsYXNzIFByb3RvY29sIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3Qgb25Xcml0ZSA9IGNvbmZpZy5vbldyaXRlO1xuICAgIGlmICh0eXBlb2Ygb25Xcml0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBvbldyaXRlIGZ1bmN0aW9uJyk7XG4gICAgdGhpcy5fb25Xcml0ZSA9IChkYXRhKSA9PiB7IG9uV3JpdGUoZGF0YSk7IH07XG5cbiAgICBjb25zdCBvbkVycm9yID0gY29uZmlnLm9uRXJyb3I7XG4gICAgaWYgKHR5cGVvZiBvbkVycm9yICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIG9uRXJyb3IgZnVuY3Rpb24nKTtcbiAgICB0aGlzLl9vbkVycm9yID0gKGVycikgPT4geyBvbkVycm9yKGVycik7IH07XG5cbiAgICBjb25zdCBkZWJ1ZyA9IGNvbmZpZy5kZWJ1ZztcbiAgICB0aGlzLl9kZWJ1ZyA9ICh0eXBlb2YgZGVidWcgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICA/IChtc2cpID0+IHsgZGVidWcobXNnKTsgfVxuICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IG9uSGVhZGVyID0gY29uZmlnLm9uSGVhZGVyO1xuICAgIHRoaXMuX29uSGVhZGVyID0gKHR5cGVvZiBvbkhlYWRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgID8gKC4uLmFyZ3MpID0+IHsgb25IZWFkZXIoLi4uYXJncyk7IH1cbiAgICAgICAgICAgICAgICAgICAgICA6IG5vb3ApO1xuXG4gICAgY29uc3Qgb25QYWNrZXQgPSBjb25maWcub25QYWNrZXQ7XG4gICAgdGhpcy5fb25QYWNrZXQgPSAodHlwZW9mIG9uUGFja2V0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKSA9PiB7IG9uUGFja2V0KCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICA6IG5vb3ApO1xuXG4gICAgbGV0IG9uSGFuZHNoYWtlQ29tcGxldGUgPSBjb25maWcub25IYW5kc2hha2VDb21wbGV0ZTtcbiAgICBpZiAodHlwZW9mIG9uSGFuZHNoYWtlQ29tcGxldGUgIT09ICdmdW5jdGlvbicpXG4gICAgICBvbkhhbmRzaGFrZUNvbXBsZXRlID0gbm9vcDtcbiAgICBsZXQgZmlyc3RIYW5kc2hha2U7XG4gICAgdGhpcy5fb25IYW5kc2hha2VDb21wbGV0ZSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZygnSGFuZHNoYWtlIGNvbXBsZXRlZCcpO1xuICAgICAgaWYgKGZpcnN0SGFuZHNoYWtlID09PSB1bmRlZmluZWQpXG4gICAgICAgIGZpcnN0SGFuZHNoYWtlID0gdHJ1ZTtcbiAgICAgIGVsc2VcbiAgICAgICAgZmlyc3RIYW5kc2hha2UgPSBmYWxzZTtcblxuICAgICAgLy8gUHJvY2VzcyBwYWNrZXRzIHF1ZXVlZCBkdXJpbmcgYSByZWtleSB3aGVyZSBuZWNlc3NhcnlcbiAgICAgIGNvbnN0IG9sZFF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgICBpZiAob2xkUXVldWUpIHtcbiAgICAgICAgdGhpcy5fcXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgICAgIGBEcmFpbmluZyBvdXRib3VuZCBxdWV1ZSAoJHtvbGRRdWV1ZS5sZW5ndGh9KSAuLi5gXG4gICAgICAgICk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2xkUXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gb2xkUXVldWVbaV07XG4gICAgICAgICAgLy8gZGF0YSA9PT0gcGF5bG9hZCBvbmx5XG5cbiAgICAgICAgICAvLyBYWFg6IGhhY2t5XG4gICAgICAgICAgbGV0IGZpbmFsaXplZCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKGRhdGEpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZWQgPT09IGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX2NpcGhlci5hbGxvY1BhY2tldChkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBwYWNrZXQuc2V0KGRhdGEsIDUpO1xuICAgICAgICAgICAgZmluYWxpemVkID0gcGFja2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbmRQYWNrZXQodGhpcywgZmluYWxpemVkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZygnLi4uIGZpbmlzaGVkIGRyYWluaW5nIG91dGJvdW5kIHF1ZXVlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdEhhbmRzaGFrZSAmJiB0aGlzLl9zZXJ2ZXIgJiYgdGhpcy5fa2V4LnJlbW90ZUV4dEluZm9FbmFibGVkKVxuICAgICAgICBzZW5kRXh0SW5mbyh0aGlzKTtcblxuICAgICAgb25IYW5kc2hha2VDb21wbGV0ZSguLi5hcmdzKTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlID0gdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgbWVzc2FnZUhhbmRsZXJzID0gY29uZmlnLm1lc3NhZ2VIYW5kbGVycztcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2VIYW5kbGVycyA9PT0gJ29iamVjdCcgJiYgbWVzc2FnZUhhbmRsZXJzICE9PSBudWxsKVxuICAgICAgdGhpcy5faGFuZGxlcnMgPSBtZXNzYWdlSGFuZGxlcnM7XG4gICAgZWxzZVxuICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcblxuICAgIHRoaXMuX29uUGF5bG9hZCA9IG9uUGF5bG9hZC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2VydmVyID0gISFjb25maWcuc2VydmVyO1xuICAgIHRoaXMuX2Jhbm5lciA9IHVuZGVmaW5lZDtcbiAgICBsZXQgZ3JlZXRpbmc7XG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcuaG9zdEtleXMgIT09ICdvYmplY3QnIHx8IGNvbmZpZy5ob3N0S2V5cyA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNlcnZlciBob3N0IGtleShzKScpO1xuICAgICAgdGhpcy5faG9zdEtleXMgPSBjb25maWcuaG9zdEtleXM7XG5cbiAgICAgIC8vIEdyZWV0aW5nIGRpc3BsYXllZCBiZWZvcmUgdGhlIHNzaCBpZGVudGlmaWNhdGlvbiBzdHJpbmcgaXMgc2VudCwgdGhpc1xuICAgICAgLy8gaXMgdXN1YWxseSBpZ25vcmVkIGJ5IG1vc3QgY2xpZW50c1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcuZ3JlZXRpbmcgPT09ICdzdHJpbmcnICYmIGNvbmZpZy5ncmVldGluZy5sZW5ndGgpIHtcbiAgICAgICAgZ3JlZXRpbmcgPSAoY29uZmlnLmdyZWV0aW5nLnNsaWNlKC0yKSA9PT0gJ1xcclxcbidcbiAgICAgICAgICAgICAgICAgICAgPyBjb25maWcuZ3JlZXRpbmdcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtjb25maWcuZ3JlZXRpbmd9XFxyXFxuYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJhbm5lciBzaG93biBhZnRlciB0aGUgaGFuZHNoYWtlIGNvbXBsZXRlcywgYnV0IGJlZm9yZSB1c2VyXG4gICAgICAvLyBhdXRoZW50aWNhdGlvbiBiZWdpbnNcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmJhbm5lciA9PT0gJ3N0cmluZycgJiYgY29uZmlnLmJhbm5lci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fYmFubmVyID0gKGNvbmZpZy5iYW5uZXIuc2xpY2UoLTIpID09PSAnXFxyXFxuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25maWcuYmFubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGAke2NvbmZpZy5iYW5uZXJ9XFxyXFxuYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hvc3RLZXlzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGxldCBvZmZlciA9IGNvbmZpZy5vZmZlcjtcbiAgICBpZiAodHlwZW9mIG9mZmVyICE9PSAnb2JqZWN0JyB8fCBvZmZlciA9PT0gbnVsbCkge1xuICAgICAgb2ZmZXIgPSAodGhpcy5fc2VydmVyID8gREVGQVVMVF9LRVhJTklUX1NFUlZFUiA6IERFRkFVTFRfS0VYSU5JVF9DTElFTlQpO1xuICAgIH0gZWxzZSBpZiAob2ZmZXIuY29uc3RydWN0b3IgIT09IEtleEluaXQpIHtcbiAgICAgIGlmICghdGhpcy5fc2VydmVyKVxuICAgICAgICBvZmZlci5rZXggPSBvZmZlci5rZXguY29uY2F0KFsnZXh0LWluZm8tYyddKTtcbiAgICAgIG9mZmVyID0gbmV3IEtleEluaXQob2ZmZXIpO1xuICAgIH1cbiAgICB0aGlzLl9rZXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fa2V4aW5pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vZmZlciA9IG9mZmVyO1xuICAgIHRoaXMuX2NpcGhlciA9IG5ldyBOdWxsQ2lwaGVyKDAsIHRoaXMuX29uV3JpdGUpO1xuICAgIHRoaXMuX2RlY2lwaGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NraXBOZXh0SW5ib3VuZFBhY2tldCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhY2tldFJXID0ge1xuICAgICAgcmVhZDogbmV3IFBhY2tldFJlYWRlcigpLFxuICAgICAgd3JpdGU6IG5ldyBQYWNrZXRXcml0ZXIodGhpcyksXG4gICAgfTtcbiAgICB0aGlzLl9ob3N0VmVyaWZpZXIgPSAoIXRoaXMuX3NlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdHlwZW9mIGNvbmZpZy5ob3N0VmVyaWZpZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25maWcuaG9zdFZlcmlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcblxuICAgIHRoaXMuX3BhcnNlID0gcGFyc2VIZWFkZXI7XG4gICAgdGhpcy5fYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2F1dGhzUXVldWUgPSBbXTtcbiAgICB0aGlzLl9hdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVtb3RlSWRlbnRSYXcgPSB1bmRlZmluZWQ7XG4gICAgbGV0IHNlbnRJZGVudDtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5pZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2lkZW50UmF3ID0gQnVmZmVyLmZyb20oYFNTSC0yLjAtJHtjb25maWcuaWRlbnR9YCk7XG5cbiAgICAgIHNlbnRJZGVudCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLl9pZGVudFJhdy5sZW5ndGggKyAyKTtcbiAgICAgIHNlbnRJZGVudC5zZXQodGhpcy5faWRlbnRSYXcsIDApO1xuICAgICAgc2VudElkZW50W3NlbnRJZGVudC5sZW5ndGggLSAyXSA9IDEzOyAvLyAnXFxyJ1xuICAgICAgc2VudElkZW50W3NlbnRJZGVudC5sZW5ndGggLSAxXSA9IDEwOyAvLyAnXFxuJ1xuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGNvbmZpZy5pZGVudCkpIHtcbiAgICAgIGNvbnN0IGZ1bGxJZGVudCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg4ICsgY29uZmlnLmlkZW50Lmxlbmd0aCk7XG4gICAgICBmdWxsSWRlbnQubGF0aW4xV3JpdGUoJ1NTSC0yLjAtJywgMCwgOCk7XG4gICAgICBmdWxsSWRlbnQuc2V0KGNvbmZpZy5pZGVudCwgOCk7XG4gICAgICB0aGlzLl9pZGVudFJhdyA9IGZ1bGxJZGVudDtcblxuICAgICAgc2VudElkZW50ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGZ1bGxJZGVudC5sZW5ndGggKyAyKTtcbiAgICAgIHNlbnRJZGVudC5zZXQoZnVsbElkZW50LCAwKTtcbiAgICAgIHNlbnRJZGVudFtzZW50SWRlbnQubGVuZ3RoIC0gMl0gPSAxMzsgLy8gJ1xccidcbiAgICAgIHNlbnRJZGVudFtzZW50SWRlbnQubGVuZ3RoIC0gMV0gPSAxMDsgLy8gJ1xcbidcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faWRlbnRSYXcgPSBJREVOVF9SQVc7XG4gICAgICBzZW50SWRlbnQgPSBJREVOVDtcbiAgICB9XG4gICAgdGhpcy5fY29tcGF0RmxhZ3MgPSAwO1xuXG4gICAgaWYgKHRoaXMuX2RlYnVnKSB7XG4gICAgICBpZiAoYmluZGluZ0F2YWlsYWJsZSlcbiAgICAgICAgdGhpcy5fZGVidWcoJ0N1c3RvbSBjcnlwdG8gYmluZGluZyBhdmFpbGFibGUnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5fZGVidWcoJ0N1c3RvbSBjcnlwdG8gYmluZGluZyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgTG9jYWwgaWRlbnQ6ICR7aW5zcGVjdCh0aGlzLl9pZGVudFJhdy50b1N0cmluZygpKX1gXG4gICAgKTtcbiAgICB0aGlzLnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChncmVldGluZylcbiAgICAgICAgdGhpcy5fb25Xcml0ZShncmVldGluZyk7XG4gICAgICB0aGlzLl9vbldyaXRlKHNlbnRJZGVudCk7XG4gICAgfTtcbiAgfVxuICBfZGVzdHJ1Y3QocmVhc29uKSB7XG4gICAgdGhpcy5fcGFja2V0UlcucmVhZC5jbGVhbnVwKCk7XG4gICAgdGhpcy5fcGFja2V0Ulcud3JpdGUuY2xlYW51cCgpO1xuICAgIHRoaXMuX2NpcGhlciAmJiB0aGlzLl9jaXBoZXIuZnJlZSgpO1xuICAgIHRoaXMuX2RlY2lwaGVyICYmIHRoaXMuX2RlY2lwaGVyLmZyZWUoKTtcbiAgICBpZiAodHlwZW9mIHJlYXNvbiAhPT0gJ3N0cmluZycgfHwgcmVhc29uLmxlbmd0aCA9PT0gMClcbiAgICAgIHJlYXNvbiA9ICdmYXRhbCBlcnJvcic7XG4gICAgdGhpcy5wYXJzZSA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2UgdW51c2FibGUgYWZ0ZXIgJHtyZWFzb259YCk7XG4gICAgfTtcbiAgICB0aGlzLl9vbldyaXRlID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB1bnVzYWJsZSBhZnRlciAke3JlYXNvbn1gKTtcbiAgICB9O1xuICAgIHRoaXMuX2Rlc3RydWN0ID0gdW5kZWZpbmVkO1xuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgdGhpcy5fZGVzdHJ1Y3QgJiYgdGhpcy5fZGVzdHJ1Y3QoKTtcbiAgfVxuICBwYXJzZShjaHVuaywgaSwgbGVuKSB7XG4gICAgd2hpbGUgKGkgPCBsZW4pXG4gICAgICBpID0gdGhpcy5fcGFyc2UoY2h1bmssIGksIGxlbik7XG4gIH1cblxuICAvLyBQcm90b2NvbCBtZXNzYWdlIEFQSVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBDb21tb24vU2hhcmVkID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLy8gR2xvYmFsXG4gIC8vIC0tLS0tLVxuICBkaXNjb25uZWN0KHJlYXNvbikge1xuICAgIGNvbnN0IHBrdExlbiA9IDEgKyA0ICsgNCArIDQ7XG4gICAgLy8gV2UgZG9uJ3QgdXNlIF9wYWNrZXRSVy53cml0ZS4qIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgLy8gd2UgYWx3YXlzIGdldCBhIGZ1bGwgcGFja2V0IGFsbG9jYXRlZCBiZWNhdXNlIHRoaXMgbWVzc2FnZSBjYW4gYmUgc2VudFxuICAgIC8vIGF0IGFueSB0aW1lIC0tIGV2ZW4gZHVyaW5nIGEga2V5IGV4Y2hhbmdlXG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0S0VYO1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKHBrdExlbiwgdHJ1ZSk7XG4gICAgY29uc3QgZW5kID0gcCArIHBrdExlbjtcblxuICAgIGlmICghVkFMSURfRElTQ09OTkVDVF9SRUFTT05TLmhhcyhyZWFzb24pKVxuICAgICAgcmVhc29uID0gRElTQ09OTkVDVF9SRUFTT04uUFJPVE9DT0xfRVJST1I7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkRJU0NPTk5FQ1Q7XG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHJlYXNvbiwgKytwKTtcbiAgICBwYWNrZXQuZmlsbCgwLCBwICs9IDQsIGVuZCk7XG5cbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhgT3V0Ym91bmQ6IFNlbmRpbmcgRElTQ09OTkVDVCAoJHtyZWFzb259KWApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0LCB0cnVlKSwgdHJ1ZSk7XG4gIH1cbiAgcGluZygpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYyhQSU5HX1BBWUxPQUQubGVuZ3RoKTtcblxuICAgIHBhY2tldC5zZXQoUElOR19QQVlMT0FELCBwKTtcblxuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgJ091dGJvdW5kOiBTZW5kaW5nIHBpbmcgKEdMT0JBTF9SRVFVRVNUOiBrZWVwYWxpdmVAb3BlbnNzaC5jb20pJ1xuICAgICk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICByZWtleSgpIHtcbiAgICBpZiAodGhpcy5fa2V4aW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZygnT3V0Ym91bmQ6IEluaXRpYXRlZCBleHBsaWNpdCByZWtleScpO1xuICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgIGtleGluaXQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKCdPdXRib3VuZDogSWdub3JpbmcgcmVrZXkgZHVyaW5nIGhhbmRzaGFrZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vICdzc2gtY29ubmVjdGlvbicgc2VydmljZS1zcGVjaWZpY1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVxdWVzdFN1Y2Nlc3MoZGF0YSkge1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBsZXQgcGFja2V0O1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyBkYXRhLmxlbmd0aCk7XG5cbiAgICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuUkVRVUVTVF9TVUNDRVNTO1xuXG4gICAgICBwYWNrZXQuc2V0KGRhdGEsICsrcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEpO1xuXG4gICAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLlJFUVVFU1RfU1VDQ0VTUztcbiAgICB9XG5cbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZygnT3V0Ym91bmQ6IFNlbmRpbmcgUkVRVUVTVF9TVUNDRVNTJyk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICByZXF1ZXN0RmFpbHVyZSgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxKTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuUkVRVUVTVF9GQUlMVVJFO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoJ091dGJvdW5kOiBTZW5kaW5nIFJFUVVFU1RfRkFJTFVSRScpO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgY2hhbm5lbFN1Y2Nlc3MoY2hhbikge1xuICAgIC8vIERvZXMgbm90IGNvbnN1bWUgd2luZG93IHNwYWNlXG5cbiAgICBsZXQgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2MoMSArIDQpO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5DSEFOTkVMX1NVQ0NFU1M7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY2hhbiwgKytwKTtcblxuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKGBPdXRib3VuZDogU2VuZGluZyBDSEFOTkVMX1NVQ0NFU1MgKHI6JHtjaGFufSlgKTtcbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG4gIGNoYW5uZWxGYWlsdXJlKGNoYW4pIHtcbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuXG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0KTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuQ0hBTk5FTF9GQUlMVVJFO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGNoYW4sICsrcCk7XG5cbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhgT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9GQUlMVVJFIChyOiR7Y2hhbn0pYCk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBjaGFubmVsRU9GKGNoYW4pIHtcbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuXG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0KTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuQ0hBTk5FTF9FT0Y7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY2hhbiwgKytwKTtcblxuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKGBPdXRib3VuZDogU2VuZGluZyBDSEFOTkVMX0VPRiAocjoke2NoYW59KWApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgY2hhbm5lbENsb3NlKGNoYW4pIHtcbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuXG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0KTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuQ0hBTk5FTF9DTE9TRTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjaGFuLCArK3ApO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoYE91dGJvdW5kOiBTZW5kaW5nIENIQU5ORUxfQ0xPU0UgKHI6JHtjaGFufSlgKTtcbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG4gIGNoYW5uZWxXaW5kb3dBZGp1c3QoY2hhbiwgYW1vdW50KSB7XG4gICAgLy8gRG9lcyBub3QgY29uc3VtZSB3aW5kb3cgc3BhY2VcblxuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIDQpO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5DSEFOTkVMX1dJTkRPV19BREpVU1Q7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY2hhbiwgKytwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBhbW91bnQsIHAgKz0gNCk7XG5cbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhcbiAgICAgIGBPdXRib3VuZDogU2VuZGluZyBDSEFOTkVMX1dJTkRPV19BREpVU1QgKHI6JHtjaGFufSwgJHthbW91bnR9KWBcbiAgICApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgY2hhbm5lbERhdGEoY2hhbiwgZGF0YSkge1xuICAgIGNvbnN0IGlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyKGRhdGEpO1xuICAgIGNvbnN0IGRhdGFMZW4gPSAoaXNCdWZmZXIgPyBkYXRhLmxlbmd0aCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpKTtcbiAgICBsZXQgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2MoMSArIDQgKyA0ICsgZGF0YUxlbik7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfREFUQTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjaGFuLCArK3ApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGRhdGFMZW4sIHAgKz0gNCk7XG5cbiAgICBpZiAoaXNCdWZmZXIpXG4gICAgICBwYWNrZXQuc2V0KGRhdGEsIHAgKz0gNCk7XG4gICAgZWxzZVxuICAgICAgcGFja2V0LnV0ZjhXcml0ZShkYXRhLCBwICs9IDQsIGRhdGFMZW4pO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9EQVRBIChyOiR7Y2hhbn0sICR7ZGF0YUxlbn0pYFxuICAgICk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBjaGFubmVsRXh0RGF0YShjaGFuLCBkYXRhLCB0eXBlKSB7XG4gICAgY29uc3QgaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXIoZGF0YSk7XG4gICAgY29uc3QgZGF0YUxlbiA9IChpc0J1ZmZlciA/IGRhdGEubGVuZ3RoIDogQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkpO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIDQgKyA0ICsgZGF0YUxlbik7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfRVhURU5ERURfREFUQTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjaGFuLCArK3ApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHR5cGUsIHAgKz0gNCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgZGF0YUxlbiwgcCArPSA0KTtcblxuICAgIGlmIChpc0J1ZmZlcilcbiAgICAgIHBhY2tldC5zZXQoZGF0YSwgcCArPSA0KTtcbiAgICBlbHNlXG4gICAgICBwYWNrZXQudXRmOFdyaXRlKGRhdGEsIHAgKz0gNCwgZGF0YUxlbik7XG5cbiAgICB0aGlzLl9kZWJ1Z1xuICAgICAgJiYgdGhpcy5fZGVidWcoYE91dGJvdW5kOiBTZW5kaW5nIENIQU5ORUxfRVhURU5ERURfREFUQSAocjoke2NoYW59KWApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgY2hhbm5lbE9wZW5Db25maXJtKHJlbW90ZSwgbG9jYWwsIGluaXRXaW5kb3csIG1heFBhY2tldCkge1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIDQgKyA0ICsgNCk7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfT1BFTl9DT05GSVJNQVRJT047XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcmVtb3RlLCArK3ApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGxvY2FsLCBwICs9IDQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGluaXRXaW5kb3csIHAgKz0gNCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgbWF4UGFja2V0LCBwICs9IDQpO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9PUEVOX0NPTkZJUk1BVElPTiAocjoke3JlbW90ZX0sIGw6JHtsb2NhbH0pYFxuICAgICk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBjaGFubmVsT3BlbkZhaWwocmVtb3RlLCByZWFzb24sIGRlc2MpIHtcbiAgICBpZiAodHlwZW9mIGRlc2MgIT09ICdzdHJpbmcnKVxuICAgICAgZGVzYyA9ICcnO1xuXG4gICAgY29uc3QgZGVzY0xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRlc2MpO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIDQgKyA0ICsgZGVzY0xlbiArIDQpO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5DSEFOTkVMX09QRU5fRkFJTFVSRTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCByZW1vdGUsICsrcCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcmVhc29uLCBwICs9IDQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGRlc2NMZW4sIHAgKz0gNCk7XG5cbiAgICBwICs9IDQ7XG4gICAgaWYgKGRlc2NMZW4pIHtcbiAgICAgIHBhY2tldC51dGY4V3JpdGUoZGVzYywgcCwgZGVzY0xlbik7XG4gICAgICBwICs9IGRlc2NMZW47XG4gICAgfVxuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDAsIHApOyAvLyBFbXB0eSBsYW5ndWFnZSB0YWdcblxuICAgIHRoaXMuX2RlYnVnXG4gICAgICAmJiB0aGlzLl9kZWJ1ZyhgT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9PUEVOX0ZBSUxVUkUgKHI6JHtyZW1vdGV9KWApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ2xpZW50LXNwZWNpZmljID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8vIEdsb2JhbFxuICAvLyAtLS0tLS1cbiAgc2VydmljZShuYW1lKSB7XG4gICAgaWYgKHRoaXMuX3NlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgY29uc3QgbmFtZUxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG5hbWUpO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIG5hbWVMZW4pO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5TRVJWSUNFX1JFUVVFU1Q7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgbmFtZUxlbiwgKytwKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKG5hbWUsIHAgKz0gNCwgbmFtZUxlbik7XG5cbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhgT3V0Ym91bmQ6IFNlbmRpbmcgU0VSVklDRV9SRVFVRVNUICgke25hbWV9KWApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cblxuICAvLyAnc3NoLXVzZXJhdXRoJyBzZXJ2aWNlLXNwZWNpZmljXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYXV0aFBhc3N3b3JkKHVzZXJuYW1lLCBwYXNzd29yZCwgbmV3UGFzc3dvcmQpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBjb25zdCB1c2VyTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodXNlcm5hbWUpO1xuICAgIGNvbnN0IHBhc3NMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXNzd29yZCk7XG4gICAgY29uc3QgbmV3UGFzc0xlbiA9IChuZXdQYXNzd29yZCA/IEJ1ZmZlci5ieXRlTGVuZ3RoKG5ld1Bhc3N3b3JkKSA6IDApO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYyhcbiAgICAgIDEgKyA0ICsgdXNlckxlbiArIDQgKyAxNCArIDQgKyA4ICsgMSArIDQgKyBwYXNzTGVuXG4gICAgICAgICsgKG5ld1Bhc3N3b3JkID8gNCArIG5ld1Bhc3NMZW4gOiAwKVxuICAgICk7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLlVTRVJBVVRIX1JFUVVFU1Q7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgdXNlckxlbiwgKytwKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKHVzZXJuYW1lLCBwICs9IDQsIHVzZXJMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDE0LCBwICs9IHVzZXJMZW4pO1xuICAgIHBhY2tldC51dGY4V3JpdGUoJ3NzaC1jb25uZWN0aW9uJywgcCArPSA0LCAxNCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgOCwgcCArPSAxNCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgncGFzc3dvcmQnLCBwICs9IDQsIDgpO1xuXG4gICAgcGFja2V0W3AgKz0gOF0gPSAobmV3UGFzc3dvcmQgPyAxIDogMCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcGFzc0xlbiwgKytwKTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSlcbiAgICAgIGJ1ZmZlckNvcHkocGFzc3dvcmQsIHBhY2tldCwgMCwgcGFzc0xlbiwgcCArPSA0KTtcbiAgICBlbHNlXG4gICAgICBwYWNrZXQudXRmOFdyaXRlKHBhc3N3b3JkLCBwICs9IDQsIHBhc3NMZW4pO1xuXG4gICAgaWYgKG5ld1Bhc3N3b3JkKSB7XG4gICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgbmV3UGFzc0xlbiwgcCArPSBwYXNzTGVuKTtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIobmV3UGFzc3dvcmQpKVxuICAgICAgICBidWZmZXJDb3B5KG5ld1Bhc3N3b3JkLCBwYWNrZXQsIDAsIG5ld1Bhc3NMZW4sIHAgKz0gNCk7XG4gICAgICBlbHNlXG4gICAgICAgIHBhY2tldC51dGY4V3JpdGUobmV3UGFzc3dvcmQsIHAgKz0gNCwgbmV3UGFzc0xlbik7XG4gICAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgJ091dGJvdW5kOiBTZW5kaW5nIFVTRVJBVVRIX1JFUVVFU1QgKGNoYW5nZWQgcGFzc3dvcmQpJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICAgICdPdXRib3VuZDogU2VuZGluZyBVU0VSQVVUSF9SRVFVRVNUIChwYXNzd29yZCknXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX2F1dGhzUXVldWUucHVzaCgncGFzc3dvcmQnKTtcblxuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgYXV0aFBLKHVzZXJuYW1lLCBwdWJLZXksIGtleUFsZ28sIGNiU2lnbikge1xuICAgIGlmICh0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIHB1YktleSA9IHBhcnNlS2V5KHB1YktleSk7XG4gICAgaWYgKHB1YktleSBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuXG4gICAgY29uc3Qga2V5VHlwZSA9IHB1YktleS50eXBlO1xuICAgIHB1YktleSA9IHB1YktleS5nZXRQdWJsaWNTU0goKTtcblxuICAgIGlmICh0eXBlb2Yga2V5QWxnbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2JTaWduID0ga2V5QWxnbztcbiAgICAgIGtleUFsZ28gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICgha2V5QWxnbylcbiAgICAgIGtleUFsZ28gPSBrZXlUeXBlO1xuXG4gICAgY29uc3QgdXNlckxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHVzZXJuYW1lKTtcbiAgICBjb25zdCBhbGdvTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoa2V5QWxnbyk7XG4gICAgY29uc3QgcHViS2V5TGVuID0gcHViS2V5Lmxlbmd0aDtcbiAgICBjb25zdCBzZXNzaW9uSUQgPSB0aGlzLl9rZXguc2Vzc2lvbklEO1xuICAgIGNvbnN0IHNlc0xlbiA9IHNlc3Npb25JRC5sZW5ndGg7XG4gICAgY29uc3QgcGF5bG9hZExlbiA9XG4gICAgICAoY2JTaWduID8gNCArIHNlc0xlbiA6IDApXG4gICAgICAgICsgMSArIDQgKyB1c2VyTGVuICsgNCArIDE0ICsgNCArIDkgKyAxICsgNCArIGFsZ29MZW4gKyA0ICsgcHViS2V5TGVuO1xuICAgIGxldCBwYWNrZXQ7XG4gICAgbGV0IHA7XG4gICAgaWYgKGNiU2lnbikge1xuICAgICAgcGFja2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBheWxvYWRMZW4pO1xuICAgICAgcCA9IDA7XG4gICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgc2VzTGVuLCBwKTtcbiAgICAgIHBhY2tldC5zZXQoc2Vzc2lvbklELCBwICs9IDQpO1xuICAgICAgcCArPSBzZXNMZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKHBheWxvYWRMZW4pO1xuICAgICAgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgfVxuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5VU0VSQVVUSF9SRVFVRVNUO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHVzZXJMZW4sICsrcCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSh1c2VybmFtZSwgcCArPSA0LCB1c2VyTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCAxNCwgcCArPSB1c2VyTGVuKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKCdzc2gtY29ubmVjdGlvbicsIHAgKz0gNCwgMTQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDksIHAgKz0gMTQpO1xuICAgIHBhY2tldC51dGY4V3JpdGUoJ3B1YmxpY2tleScsIHAgKz0gNCwgOSk7XG5cbiAgICBwYWNrZXRbcCArPSA5XSA9IChjYlNpZ24gPyAxIDogMCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgYWxnb0xlbiwgKytwKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKGtleUFsZ28sIHAgKz0gNCwgYWxnb0xlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcHViS2V5TGVuLCBwICs9IGFsZ29MZW4pO1xuICAgIHBhY2tldC5zZXQocHViS2V5LCBwICs9IDQpO1xuXG4gICAgaWYgKCFjYlNpZ24pIHtcbiAgICAgIHRoaXMuX2F1dGhzUXVldWUucHVzaCgncHVibGlja2V5Jyk7XG5cbiAgICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgICAnT3V0Ym91bmQ6IFNlbmRpbmcgVVNFUkFVVEhfUkVRVUVTVCAocHVibGlja2V5IC0tIGNoZWNrKSdcbiAgICAgICk7XG4gICAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNiU2lnbihwYWNrZXQsIChzaWduYXR1cmUpID0+IHtcbiAgICAgIHNpZ25hdHVyZSA9IGNvbnZlcnRTaWduYXR1cmUoc2lnbmF0dXJlLCBrZXlUeXBlKTtcbiAgICAgIGlmIChzaWduYXR1cmUgPT09IGZhbHNlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHdoaWxlIGNvbnZlcnRpbmcgaGFuZHNoYWtlIHNpZ25hdHVyZScpO1xuXG4gICAgICBjb25zdCBzaWdMZW4gPSBzaWduYXR1cmUubGVuZ3RoO1xuICAgICAgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgICBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYyhcbiAgICAgICAgMSArIDQgKyB1c2VyTGVuICsgNCArIDE0ICsgNCArIDkgKyAxICsgNCArIGFsZ29MZW4gKyA0ICsgcHViS2V5TGVuICsgNFxuICAgICAgICAgICsgNCArIGFsZ29MZW4gKyA0ICsgc2lnTGVuXG4gICAgICApO1xuXG4gICAgICAvLyBUT0RPOiBzaW1wbHkgY29weSBmcm9tIG9yaWdpbmFsIFwicGFja2V0XCIgdG8gbmV3IGBwYWNrZXRgIHRvIGF2b2lkXG4gICAgICAvLyBoYXZpbmcgdG8gd3JpdGUgZWFjaCBpbmRpdmlkdWFsIGZpZWxkIGEgc2Vjb25kIHRpbWU/XG4gICAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLlVTRVJBVVRIX1JFUVVFU1Q7XG5cbiAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCB1c2VyTGVuLCArK3ApO1xuICAgICAgcGFja2V0LnV0ZjhXcml0ZSh1c2VybmFtZSwgcCArPSA0LCB1c2VyTGVuKTtcblxuICAgICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDE0LCBwICs9IHVzZXJMZW4pO1xuICAgICAgcGFja2V0LnV0ZjhXcml0ZSgnc3NoLWNvbm5lY3Rpb24nLCBwICs9IDQsIDE0KTtcblxuICAgICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDksIHAgKz0gMTQpO1xuICAgICAgcGFja2V0LnV0ZjhXcml0ZSgncHVibGlja2V5JywgcCArPSA0LCA5KTtcblxuICAgICAgcGFja2V0W3AgKz0gOV0gPSAxO1xuXG4gICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgYWxnb0xlbiwgKytwKTtcbiAgICAgIHBhY2tldC51dGY4V3JpdGUoa2V5QWxnbywgcCArPSA0LCBhbGdvTGVuKTtcblxuICAgICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHB1YktleUxlbiwgcCArPSBhbGdvTGVuKTtcbiAgICAgIHBhY2tldC5zZXQocHViS2V5LCBwICs9IDQpO1xuXG4gICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgNCArIGFsZ29MZW4gKyA0ICsgc2lnTGVuLCBwICs9IHB1YktleUxlbik7XG5cbiAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBhbGdvTGVuLCBwICs9IDQpO1xuICAgICAgcGFja2V0LnV0ZjhXcml0ZShrZXlBbGdvLCBwICs9IDQsIGFsZ29MZW4pO1xuXG4gICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgc2lnTGVuLCBwICs9IGFsZ29MZW4pO1xuICAgICAgcGFja2V0LnNldChzaWduYXR1cmUsIHAgKz0gNCk7XG5cbiAgICAgIC8vIFNlcnZlcnMgc2hvdWxkbid0IHNlbmQgcGFja2V0IHR5cGUgNjAgaW4gcmVzcG9uc2UgdG8gc2lnbmVkIHB1YmxpY2tleVxuICAgICAgLy8gYXR0ZW1wdHMsIGJ1dCBpZiB0aGV5IGRvLCBpbnRlcnByZXQgYXMgdHlwZSA2MC5cbiAgICAgIHRoaXMuX2F1dGhzUXVldWUucHVzaCgncHVibGlja2V5Jyk7XG5cbiAgICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgICAnT3V0Ym91bmQ6IFNlbmRpbmcgVVNFUkFVVEhfUkVRVUVTVCAocHVibGlja2V5KSdcbiAgICAgICk7XG4gICAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICAgIH0pO1xuICB9XG4gIGF1dGhIb3N0YmFzZWQodXNlcm5hbWUsIHB1YktleSwgaG9zdG5hbWUsIHVzZXJsb2NhbCwga2V5QWxnbywgY2JTaWduKSB7XG4gICAgLy8gVE9ETzogTWFrZSBEUlkgYnkgc2hhcmluZyBzaW1pbGFyIGNvZGUgd2l0aCBhdXRoUEsoKVxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIHB1YktleSA9IHBhcnNlS2V5KHB1YktleSk7XG4gICAgaWYgKHB1YktleSBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuXG4gICAgY29uc3Qga2V5VHlwZSA9IHB1YktleS50eXBlO1xuICAgIHB1YktleSA9IHB1YktleS5nZXRQdWJsaWNTU0goKTtcblxuICAgIGlmICh0eXBlb2Yga2V5QWxnbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2JTaWduID0ga2V5QWxnbztcbiAgICAgIGtleUFsZ28gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICgha2V5QWxnbylcbiAgICAgIGtleUFsZ28gPSBrZXlUeXBlO1xuXG4gICAgY29uc3QgdXNlckxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHVzZXJuYW1lKTtcbiAgICBjb25zdCBhbGdvTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoa2V5QWxnbyk7XG4gICAgY29uc3QgcHViS2V5TGVuID0gcHViS2V5Lmxlbmd0aDtcbiAgICBjb25zdCBzZXNzaW9uSUQgPSB0aGlzLl9rZXguc2Vzc2lvbklEO1xuICAgIGNvbnN0IHNlc0xlbiA9IHNlc3Npb25JRC5sZW5ndGg7XG4gICAgY29uc3QgaG9zdG5hbWVMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChob3N0bmFtZSk7XG4gICAgY29uc3QgdXNlcmxvY2FsTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodXNlcmxvY2FsKTtcbiAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgICAgNCArIHNlc0xlbiArIDEgKyA0ICsgdXNlckxlbiArIDQgKyAxNCArIDQgKyA5ICsgNCArIGFsZ29MZW5cbiAgICAgICAgKyA0ICsgcHViS2V5TGVuICsgNCArIGhvc3RuYW1lTGVuICsgNCArIHVzZXJsb2NhbExlblxuICAgICk7XG4gICAgbGV0IHAgPSAwO1xuXG4gICAgd3JpdGVVSW50MzJCRShkYXRhLCBzZXNMZW4sIHApO1xuICAgIGRhdGEuc2V0KHNlc3Npb25JRCwgcCArPSA0KTtcblxuICAgIGRhdGFbcCArPSBzZXNMZW5dID0gTUVTU0FHRS5VU0VSQVVUSF9SRVFVRVNUO1xuXG4gICAgd3JpdGVVSW50MzJCRShkYXRhLCB1c2VyTGVuLCArK3ApO1xuICAgIGRhdGEudXRmOFdyaXRlKHVzZXJuYW1lLCBwICs9IDQsIHVzZXJMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShkYXRhLCAxNCwgcCArPSB1c2VyTGVuKTtcbiAgICBkYXRhLnV0ZjhXcml0ZSgnc3NoLWNvbm5lY3Rpb24nLCBwICs9IDQsIDE0KTtcblxuICAgIHdyaXRlVUludDMyQkUoZGF0YSwgOSwgcCArPSAxNCk7XG4gICAgZGF0YS51dGY4V3JpdGUoJ2hvc3RiYXNlZCcsIHAgKz0gNCwgOSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGRhdGEsIGFsZ29MZW4sIHAgKz0gOSk7XG4gICAgZGF0YS51dGY4V3JpdGUoa2V5QWxnbywgcCArPSA0LCBhbGdvTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoZGF0YSwgcHViS2V5TGVuLCBwICs9IGFsZ29MZW4pO1xuICAgIGRhdGEuc2V0KHB1YktleSwgcCArPSA0KTtcblxuICAgIHdyaXRlVUludDMyQkUoZGF0YSwgaG9zdG5hbWVMZW4sIHAgKz0gcHViS2V5TGVuKTtcbiAgICBkYXRhLnV0ZjhXcml0ZShob3N0bmFtZSwgcCArPSA0LCBob3N0bmFtZUxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGRhdGEsIHVzZXJsb2NhbExlbiwgcCArPSBob3N0bmFtZUxlbik7XG4gICAgZGF0YS51dGY4V3JpdGUodXNlcmxvY2FsLCBwICs9IDQsIHVzZXJsb2NhbExlbik7XG5cbiAgICBjYlNpZ24oZGF0YSwgKHNpZ25hdHVyZSkgPT4ge1xuICAgICAgc2lnbmF0dXJlID0gY29udmVydFNpZ25hdHVyZShzaWduYXR1cmUsIGtleVR5cGUpO1xuICAgICAgaWYgKCFzaWduYXR1cmUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3Igd2hpbGUgY29udmVydGluZyBoYW5kc2hha2Ugc2lnbmF0dXJlJyk7XG5cbiAgICAgIGNvbnN0IHNpZ0xlbiA9IHNpZ25hdHVyZS5sZW5ndGg7XG4gICAgICBjb25zdCByZXFEYXRhTGVuID0gKGRhdGEubGVuZ3RoIC0gc2VzTGVuIC0gNCk7XG4gICAgICBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKFxuICAgICAgICByZXFEYXRhTGVuICsgNCArIDQgKyBhbGdvTGVuICsgNCArIHNpZ0xlblxuICAgICAgKTtcblxuICAgICAgYnVmZmVyQ29weShkYXRhLCBwYWNrZXQsIDQgKyBzZXNMZW4sIGRhdGEubGVuZ3RoLCBwKTtcblxuICAgICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDQgKyBhbGdvTGVuICsgNCArIHNpZ0xlbiwgcCArPSByZXFEYXRhTGVuKTtcbiAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBhbGdvTGVuLCBwICs9IDQpO1xuICAgICAgcGFja2V0LnV0ZjhXcml0ZShrZXlBbGdvLCBwICs9IDQsIGFsZ29MZW4pO1xuICAgICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHNpZ0xlbiwgcCArPSBhbGdvTGVuKTtcbiAgICAgIHBhY2tldC5zZXQoc2lnbmF0dXJlLCBwICs9IDQpO1xuXG4gICAgICB0aGlzLl9hdXRoc1F1ZXVlLnB1c2goJ2hvc3RiYXNlZCcpO1xuXG4gICAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgJ091dGJvdW5kOiBTZW5kaW5nIFVTRVJBVVRIX1JFUVVFU1QgKGhvc3RiYXNlZCknXG4gICAgICApO1xuICAgICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgICB9KTtcbiAgfVxuICBhdXRoS2V5Ym9hcmQodXNlcm5hbWUpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBjb25zdCB1c2VyTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodXNlcm5hbWUpO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYyhcbiAgICAgIDEgKyA0ICsgdXNlckxlbiArIDQgKyAxNCArIDQgKyAyMCArIDQgKyA0XG4gICAgKTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuVVNFUkFVVEhfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCB1c2VyTGVuLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUodXNlcm5hbWUsIHAgKz0gNCwgdXNlckxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMTQsIHAgKz0gdXNlckxlbik7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgnc3NoLWNvbm5lY3Rpb24nLCBwICs9IDQsIDE0KTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCAyMCwgcCArPSAxNCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgna2V5Ym9hcmQtaW50ZXJhY3RpdmUnLCBwICs9IDQsIDIwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCAwLCBwICs9IDIwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCAwLCBwICs9IDQpO1xuXG4gICAgdGhpcy5fYXV0aHNRdWV1ZS5wdXNoKCdrZXlib2FyZC1pbnRlcmFjdGl2ZScpO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICAnT3V0Ym91bmQ6IFNlbmRpbmcgVVNFUkFVVEhfUkVRVUVTVCAoa2V5Ym9hcmQtaW50ZXJhY3RpdmUpJ1xuICAgICk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBhdXRoTm9uZSh1c2VybmFtZSkge1xuICAgIGlmICh0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGNvbnN0IHVzZXJMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh1c2VybmFtZSk7XG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0ICsgdXNlckxlbiArIDQgKyAxNCArIDQgKyA0KTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuVVNFUkFVVEhfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCB1c2VyTGVuLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUodXNlcm5hbWUsIHAgKz0gNCwgdXNlckxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMTQsIHAgKz0gdXNlckxlbik7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgnc3NoLWNvbm5lY3Rpb24nLCBwICs9IDQsIDE0KTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCA0LCBwICs9IDE0KTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKCdub25lJywgcCArPSA0LCA0KTtcblxuICAgIHRoaXMuX2F1dGhzUXVldWUucHVzaCgnbm9uZScpO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoJ091dGJvdW5kOiBTZW5kaW5nIFVTRVJBVVRIX1JFUVVFU1QgKG5vbmUpJyk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBhdXRoSW5mb1JlcyhyZXNwb25zZXMpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBsZXQgcmVzcG9uc2VzVG90YWxMZW4gPSAwO1xuICAgIGxldCByZXNwb25zZUxlbnM7XG5cbiAgICBpZiAocmVzcG9uc2VzKSB7XG4gICAgICByZXNwb25zZUxlbnMgPSBuZXcgQXJyYXkocmVzcG9uc2VzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3BvbnNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChyZXNwb25zZXNbaV0pO1xuICAgICAgICByZXNwb25zZUxlbnNbaV0gPSBsZW47XG4gICAgICAgIHJlc3BvbnNlc1RvdGFsTGVuICs9IDQgKyBsZW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0ICsgcmVzcG9uc2VzVG90YWxMZW4pO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5VU0VSQVVUSF9JTkZPX1JFU1BPTlNFO1xuXG4gICAgaWYgKHJlc3BvbnNlcykge1xuICAgICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHJlc3BvbnNlcy5sZW5ndGgsICsrcCk7XG4gICAgICBwICs9IDQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3BvbnNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBsZW4gPSByZXNwb25zZUxlbnNbaV07XG4gICAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBsZW4sIHApO1xuICAgICAgICBwICs9IDQ7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICBwYWNrZXQudXRmOFdyaXRlKHJlc3BvbnNlc1tpXSwgcCwgbGVuKTtcbiAgICAgICAgICBwICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMCwgKytwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZygnT3V0Ym91bmQ6IFNlbmRpbmcgVVNFUkFVVEhfSU5GT19SRVNQT05TRScpO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cblxuICAvLyAnc3NoLWNvbm5lY3Rpb24nIHNlcnZpY2Utc3BlY2lmaWNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHRjcGlwRm9yd2FyZChiaW5kQWRkciwgYmluZFBvcnQsIHdhbnRSZXBseSkge1xuICAgIGlmICh0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGNvbnN0IGFkZHJMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChiaW5kQWRkcik7XG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0ICsgMTMgKyAxICsgNCArIGFkZHJMZW4gKyA0KTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuR0xPQkFMX1JFUVVFU1Q7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMTMsICsrcCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgndGNwaXAtZm9yd2FyZCcsIHAgKz0gNCwgMTMpO1xuXG4gICAgcGFja2V0W3AgKz0gMTNdID0gKHdhbnRSZXBseSA9PT0gdW5kZWZpbmVkIHx8IHdhbnRSZXBseSA9PT0gdHJ1ZSA/IDEgOiAwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBhZGRyTGVuLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUoYmluZEFkZHIsIHAgKz0gNCwgYWRkckxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgYmluZFBvcnQsIHAgKz0gYWRkckxlbik7XG5cbiAgICB0aGlzLl9kZWJ1Z1xuICAgICAgJiYgdGhpcy5fZGVidWcoJ091dGJvdW5kOiBTZW5kaW5nIEdMT0JBTF9SRVFVRVNUICh0Y3BpcC1mb3J3YXJkKScpO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgY2FuY2VsVGNwaXBGb3J3YXJkKGJpbmRBZGRyLCBiaW5kUG9ydCwgd2FudFJlcGx5KSB7XG4gICAgaWYgKHRoaXMuX3NlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgY29uc3QgYWRkckxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGJpbmRBZGRyKTtcbiAgICBsZXQgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2MoMSArIDQgKyAyMCArIDEgKyA0ICsgYWRkckxlbiArIDQpO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5HTE9CQUxfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCAyMCwgKytwKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKCdjYW5jZWwtdGNwaXAtZm9yd2FyZCcsIHAgKz0gNCwgMjApO1xuXG4gICAgcGFja2V0W3AgKz0gMjBdID0gKHdhbnRSZXBseSA9PT0gdW5kZWZpbmVkIHx8IHdhbnRSZXBseSA9PT0gdHJ1ZSA/IDEgOiAwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBhZGRyTGVuLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUoYmluZEFkZHIsIHAgKz0gNCwgYWRkckxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgYmluZFBvcnQsIHAgKz0gYWRkckxlbik7XG5cbiAgICB0aGlzLl9kZWJ1Z1xuICAgICAgJiYgdGhpcy5fZGVidWcoJ091dGJvdW5kOiBTZW5kaW5nIEdMT0JBTF9SRVFVRVNUIChjYW5jZWwtdGNwaXAtZm9yd2FyZCknKTtcbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG4gIG9wZW5zc2hfc3RyZWFtTG9jYWxGb3J3YXJkKHNvY2tldFBhdGgsIHdhbnRSZXBseSkge1xuICAgIGlmICh0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGNvbnN0IHNvY2tldFBhdGhMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChzb2NrZXRQYXRoKTtcbiAgICBsZXQgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2MoXG4gICAgICAxICsgNCArIDMxICsgMSArIDQgKyBzb2NrZXRQYXRoTGVuXG4gICAgKTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuR0xPQkFMX1JFUVVFU1Q7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMzEsICsrcCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgnc3RyZWFtbG9jYWwtZm9yd2FyZEBvcGVuc3NoLmNvbScsIHAgKz0gNCwgMzEpO1xuXG4gICAgcGFja2V0W3AgKz0gMzFdID0gKHdhbnRSZXBseSA9PT0gdW5kZWZpbmVkIHx8IHdhbnRSZXBseSA9PT0gdHJ1ZSA/IDEgOiAwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBzb2NrZXRQYXRoTGVuLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUoc29ja2V0UGF0aCwgcCArPSA0LCBzb2NrZXRQYXRoTGVuKTtcblxuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgJ091dGJvdW5kOiBTZW5kaW5nIEdMT0JBTF9SRVFVRVNUIChzdHJlYW1sb2NhbC1mb3J3YXJkQG9wZW5zc2guY29tKSdcbiAgICApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgb3BlbnNzaF9jYW5jZWxTdHJlYW1Mb2NhbEZvcndhcmQoc29ja2V0UGF0aCwgd2FudFJlcGx5KSB7XG4gICAgaWYgKHRoaXMuX3NlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgY29uc3Qgc29ja2V0UGF0aExlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHNvY2tldFBhdGgpO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYyhcbiAgICAgIDEgKyA0ICsgMzggKyAxICsgNCArIHNvY2tldFBhdGhMZW5cbiAgICApO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5HTE9CQUxfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCAzOCwgKytwKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKCdjYW5jZWwtc3RyZWFtbG9jYWwtZm9yd2FyZEBvcGVuc3NoLmNvbScsIHAgKz0gNCwgMzgpO1xuXG4gICAgcGFja2V0W3AgKz0gMzhdID0gKHdhbnRSZXBseSA9PT0gdW5kZWZpbmVkIHx8IHdhbnRSZXBseSA9PT0gdHJ1ZSA/IDEgOiAwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBzb2NrZXRQYXRoTGVuLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUoc29ja2V0UGF0aCwgcCArPSA0LCBzb2NrZXRQYXRoTGVuKTtcblxuICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICdPdXRib3VuZDogU2VuZGluZyBHTE9CQUxfUkVRVUVTVCAnXG4gICAgICAgICAgKyAnKGNhbmNlbC1zdHJlYW1sb2NhbC1mb3J3YXJkQG9wZW5zc2guY29tKSdcbiAgICAgICk7XG4gICAgfVxuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgZGlyZWN0VGNwaXAoY2hhbiwgaW5pdFdpbmRvdywgbWF4UGFja2V0LCBjZmcpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBjb25zdCBzcmNMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChjZmcuc3JjSVApO1xuICAgIGNvbnN0IGRzdExlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNmZy5kc3RJUCk7XG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKFxuICAgICAgMSArIDQgKyAxMiArIDQgKyA0ICsgNCArIDQgKyBzcmNMZW4gKyA0ICsgNCArIGRzdExlbiArIDRcbiAgICApO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5DSEFOTkVMX09QRU47XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMTIsICsrcCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgnZGlyZWN0LXRjcGlwJywgcCArPSA0LCAxMik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY2hhbiwgcCArPSAxMik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgaW5pdFdpbmRvdywgcCArPSA0KTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBtYXhQYWNrZXQsIHAgKz0gNCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgZHN0TGVuLCBwICs9IDQpO1xuICAgIHBhY2tldC51dGY4V3JpdGUoY2ZnLmRzdElQLCBwICs9IDQsIGRzdExlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY2ZnLmRzdFBvcnQsIHAgKz0gZHN0TGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBzcmNMZW4sIHAgKz0gNCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZShjZmcuc3JjSVAsIHAgKz0gNCwgc3JjTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjZmcuc3JjUG9ydCwgcCArPSBzcmNMZW4pO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9PUEVOIChyOiR7Y2hhbn0sIGRpcmVjdC10Y3BpcClgXG4gICAgKTtcbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG4gIG9wZW5zc2hfZGlyZWN0U3RyZWFtTG9jYWwoY2hhbiwgaW5pdFdpbmRvdywgbWF4UGFja2V0LCBjZmcpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBjb25zdCBwYXRoTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2ZnLnNvY2tldFBhdGgpO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYyhcbiAgICAgIDEgKyA0ICsgMzAgKyA0ICsgNCArIDQgKyA0ICsgcGF0aExlbiArIDQgKyA0XG4gICAgKTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuQ0hBTk5FTF9PUEVOO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDMwLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUoJ2RpcmVjdC1zdHJlYW1sb2NhbEBvcGVuc3NoLmNvbScsIHAgKz0gNCwgMzApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGNoYW4sIHAgKz0gMzApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGluaXRXaW5kb3csIHAgKz0gNCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgbWF4UGFja2V0LCBwICs9IDQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHBhdGhMZW4sIHAgKz0gNCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZShjZmcuc29ja2V0UGF0aCwgcCArPSA0LCBwYXRoTGVuKTtcblxuICAgIC8vIHplcm8tZmlsbCByZXNlcnZlZCBmaWVsZHMgKHN0cmluZyBhbmQgdWludDMyKVxuICAgIGJ1ZmZlckZpbGwocGFja2V0LCAwLCBwICs9IHBhdGhMZW4sIHAgKyA4KTtcblxuICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICdPdXRib3VuZDogU2VuZGluZyBDSEFOTkVMX09QRU4gJ1xuICAgICAgICAgICsgYChyOiR7Y2hhbn0sIGRpcmVjdC1zdHJlYW1sb2NhbEBvcGVuc3NoLmNvbSlgXG4gICAgICApO1xuICAgIH1cbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG4gIG9wZW5zc2hfbm9Nb3JlU2Vzc2lvbnMod2FudFJlcGx5KSB7XG4gICAgaWYgKHRoaXMuX3NlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0ICsgMjggKyAxKTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuR0xPQkFMX1JFUVVFU1Q7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMjgsICsrcCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgnbm8tbW9yZS1zZXNzaW9uc0BvcGVuc3NoLmNvbScsIHAgKz0gNCwgMjgpO1xuXG4gICAgcGFja2V0W3AgKz0gMjhdID0gKHdhbnRSZXBseSA9PT0gdW5kZWZpbmVkIHx8IHdhbnRSZXBseSA9PT0gdHJ1ZSA/IDEgOiAwKTtcblxuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgJ091dGJvdW5kOiBTZW5kaW5nIEdMT0JBTF9SRVFVRVNUIChuby1tb3JlLXNlc3Npb25zQG9wZW5zc2guY29tKSdcbiAgICApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgc2Vzc2lvbihjaGFuLCBpbml0V2luZG93LCBtYXhQYWNrZXQpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuXG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0ICsgNyArIDQgKyA0ICsgNCk7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfT1BFTjtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCA3LCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUoJ3Nlc3Npb24nLCBwICs9IDQsIDcpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGNoYW4sIHAgKz0gNyk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgaW5pdFdpbmRvdywgcCArPSA0KTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBtYXhQYWNrZXQsIHAgKz0gNCk7XG5cbiAgICB0aGlzLl9kZWJ1Z1xuICAgICAgJiYgdGhpcy5fZGVidWcoYE91dGJvdW5kOiBTZW5kaW5nIENIQU5ORUxfT1BFTiAocjoke2NoYW59LCBzZXNzaW9uKWApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgd2luZG93Q2hhbmdlKGNoYW4sIHJvd3MsIGNvbHMsIGhlaWdodCwgd2lkdGgpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuXG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKFxuICAgICAgMSArIDQgKyA0ICsgMTMgKyAxICsgNCArIDQgKyA0ICsgNFxuICAgICk7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjaGFuLCArK3ApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDEzLCBwICs9IDQpO1xuICAgIHBhY2tldC51dGY4V3JpdGUoJ3dpbmRvdy1jaGFuZ2UnLCBwICs9IDQsIDEzKTtcblxuICAgIHBhY2tldFtwICs9IDEzXSA9IDA7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY29scywgKytwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCByb3dzLCBwICs9IDQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHdpZHRoLCBwICs9IDQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGhlaWdodCwgcCArPSA0KTtcblxuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYE91dGJvdW5kOiBTZW5kaW5nIENIQU5ORUxfUkVRVUVTVCAocjoke2NoYW59LCB3aW5kb3ctY2hhbmdlKWBcbiAgICApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgcHR5KGNoYW4sIHJvd3MsIGNvbHMsIGhlaWdodCwgd2lkdGgsIHRlcm0sIG1vZGVzLCB3YW50UmVwbHkpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuXG4gICAgaWYgKCF0ZXJtIHx8ICF0ZXJtLmxlbmd0aClcbiAgICAgIHRlcm0gPSAndnQxMDAnO1xuICAgIGlmIChtb2Rlc1xuICAgICAgICAmJiAhQnVmZmVyLmlzQnVmZmVyKG1vZGVzKVxuICAgICAgICAmJiAhQXJyYXkuaXNBcnJheShtb2RlcylcbiAgICAgICAgJiYgdHlwZW9mIG1vZGVzID09PSAnb2JqZWN0J1xuICAgICAgICAmJiBtb2RlcyAhPT0gbnVsbCkge1xuICAgICAgbW9kZXMgPSBtb2Rlc1RvQnl0ZXMobW9kZXMpO1xuICAgIH1cbiAgICBpZiAoIW1vZGVzIHx8ICFtb2Rlcy5sZW5ndGgpXG4gICAgICBtb2RlcyA9IE5PX1RFUk1JTkFMX01PREVTX0JVRkZFUjtcblxuICAgIGNvbnN0IHRlcm1MZW4gPSB0ZXJtLmxlbmd0aDtcbiAgICBjb25zdCBtb2Rlc0xlbiA9IG1vZGVzLmxlbmd0aDtcbiAgICBsZXQgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2MoXG4gICAgICAxICsgNCArIDQgKyA3ICsgMSArIDQgKyB0ZXJtTGVuICsgNCArIDQgKyA0ICsgNCArIDQgKyBtb2Rlc0xlblxuICAgICk7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjaGFuLCArK3ApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDcsIHAgKz0gNCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgncHR5LXJlcScsIHAgKz0gNCwgNyk7XG5cbiAgICBwYWNrZXRbcCArPSA3XSA9ICh3YW50UmVwbHkgPT09IHVuZGVmaW5lZCB8fCB3YW50UmVwbHkgPT09IHRydWUgPyAxIDogMCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgdGVybUxlbiwgKytwKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKHRlcm0sIHAgKz0gNCwgdGVybUxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY29scywgcCArPSB0ZXJtTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCByb3dzLCBwICs9IDQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHdpZHRoLCBwICs9IDQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGhlaWdodCwgcCArPSA0KTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBtb2Rlc0xlbiwgcCArPSA0KTtcbiAgICBwICs9IDQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobW9kZXMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVzTGVuOyArK2kpXG4gICAgICAgIHBhY2tldFtwKytdID0gbW9kZXNbaV07XG4gICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIobW9kZXMpKSB7XG4gICAgICBwYWNrZXQuc2V0KG1vZGVzLCBwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWJ1Z1xuICAgICAgJiYgdGhpcy5fZGVidWcoYE91dGJvdW5kOiBTZW5kaW5nIENIQU5ORUxfUkVRVUVTVCAocjoke2NoYW59LCBwdHktcmVxKWApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgc2hlbGwoY2hhbiwgd2FudFJlcGx5KSB7XG4gICAgaWYgKHRoaXMuX3NlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgLy8gRG9lcyBub3QgY29uc3VtZSB3aW5kb3cgc3BhY2VcblxuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIDQgKyA1ICsgMSk7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjaGFuLCArK3ApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDUsIHAgKz0gNCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgnc2hlbGwnLCBwICs9IDQsIDUpO1xuXG4gICAgcGFja2V0W3AgKz0gNV0gPSAod2FudFJlcGx5ID09PSB1bmRlZmluZWQgfHwgd2FudFJlcGx5ID09PSB0cnVlID8gMSA6IDApO1xuXG4gICAgdGhpcy5fZGVidWdcbiAgICAgICYmIHRoaXMuX2RlYnVnKGBPdXRib3VuZDogU2VuZGluZyBDSEFOTkVMX1JFUVVFU1QgKHI6JHtjaGFufSwgc2hlbGwpYCk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBleGVjKGNoYW4sIGNtZCwgd2FudFJlcGx5KSB7XG4gICAgaWYgKHRoaXMuX3NlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgLy8gRG9lcyBub3QgY29uc3VtZSB3aW5kb3cgc3BhY2VcblxuICAgIGNvbnN0IGlzQnVmID0gQnVmZmVyLmlzQnVmZmVyKGNtZCk7XG4gICAgY29uc3QgY21kTGVuID0gKGlzQnVmID8gY21kLmxlbmd0aCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKGNtZCkpO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIDQgKyA0ICsgMSArIDQgKyBjbWRMZW4pO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5DSEFOTkVMX1JFUVVFU1Q7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY2hhbiwgKytwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCA0LCBwICs9IDQpO1xuICAgIHBhY2tldC51dGY4V3JpdGUoJ2V4ZWMnLCBwICs9IDQsIDQpO1xuXG4gICAgcGFja2V0W3AgKz0gNF0gPSAod2FudFJlcGx5ID09PSB1bmRlZmluZWQgfHwgd2FudFJlcGx5ID09PSB0cnVlID8gMSA6IDApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGNtZExlbiwgKytwKTtcbiAgICBpZiAoaXNCdWYpXG4gICAgICBwYWNrZXQuc2V0KGNtZCwgcCArPSA0KTtcbiAgICBlbHNlXG4gICAgICBwYWNrZXQudXRmOFdyaXRlKGNtZCwgcCArPSA0LCBjbWRMZW4pO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9SRVFVRVNUIChyOiR7Y2hhbn0sIGV4ZWM6ICR7Y21kfSlgXG4gICAgKTtcbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG4gIHNpZ25hbChjaGFuLCBzaWduYWwpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuXG4gICAgY29uc3Qgb3JpZ1NpZ25hbCA9IHNpZ25hbDtcblxuICAgIHNpZ25hbCA9IHNpZ25hbC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChzaWduYWwuc2xpY2UoMCwgMykgPT09ICdTSUcnKVxuICAgICAgc2lnbmFsID0gc2lnbmFsLnNsaWNlKDMpO1xuXG4gICAgaWYgKFNJR05BTFNbc2lnbmFsXSAhPT0gMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYWw6ICR7b3JpZ1NpZ25hbH1gKTtcblxuICAgIGNvbnN0IHNpZ25hbExlbiA9IHNpZ25hbC5sZW5ndGg7XG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKFxuICAgICAgMSArIDQgKyA0ICsgNiArIDEgKyA0ICsgc2lnbmFsTGVuXG4gICAgKTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuQ0hBTk5FTF9SRVFVRVNUO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGNoYW4sICsrcCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgNiwgcCArPSA0KTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKCdzaWduYWwnLCBwICs9IDQsIDYpO1xuXG4gICAgcGFja2V0W3AgKz0gNl0gPSAwO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHNpZ25hbExlbiwgKytwKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKHNpZ25hbCwgcCArPSA0LCBzaWduYWxMZW4pO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9SRVFVRVNUIChyOiR7Y2hhbn0sIHNpZ25hbDogJHtzaWduYWx9KWBcbiAgICApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgZW52KGNoYW4sIGtleSwgdmFsLCB3YW50UmVwbHkpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuXG4gICAgY29uc3Qga2V5TGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoa2V5KTtcbiAgICBjb25zdCBpc0J1ZiA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpO1xuICAgIGNvbnN0IHZhbExlbiA9IChpc0J1ZiA/IHZhbC5sZW5ndGggOiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpKTtcbiAgICBsZXQgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2MoXG4gICAgICAxICsgNCArIDQgKyAzICsgMSArIDQgKyBrZXlMZW4gKyA0ICsgdmFsTGVuXG4gICAgKTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuQ0hBTk5FTF9SRVFVRVNUO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGNoYW4sICsrcCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMywgcCArPSA0KTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKCdlbnYnLCBwICs9IDQsIDMpO1xuXG4gICAgcGFja2V0W3AgKz0gM10gPSAod2FudFJlcGx5ID09PSB1bmRlZmluZWQgfHwgd2FudFJlcGx5ID09PSB0cnVlID8gMSA6IDApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGtleUxlbiwgKytwKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKGtleSwgcCArPSA0LCBrZXlMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHZhbExlbiwgcCArPSBrZXlMZW4pO1xuICAgIGlmIChpc0J1ZilcbiAgICAgIHBhY2tldC5zZXQodmFsLCBwICs9IDQpO1xuICAgIGVsc2VcbiAgICAgIHBhY2tldC51dGY4V3JpdGUodmFsLCBwICs9IDQsIHZhbExlbik7XG5cbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhcbiAgICAgIGBPdXRib3VuZDogU2VuZGluZyBDSEFOTkVMX1JFUVVFU1QgKHI6JHtjaGFufSwgZW52OiAke2tleX09JHt2YWx9KWBcbiAgICApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgeDExRm9yd2FyZChjaGFuLCBjZmcsIHdhbnRSZXBseSkge1xuICAgIGlmICh0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIC8vIERvZXMgbm90IGNvbnN1bWUgd2luZG93IHNwYWNlXG5cbiAgICBjb25zdCBwcm90b2NvbCA9IGNmZy5wcm90b2NvbDtcbiAgICBjb25zdCBjb29raWUgPSBjZmcuY29va2llO1xuICAgIGNvbnN0IGlzQnVmUHJvdG8gPSBCdWZmZXIuaXNCdWZmZXIocHJvdG9jb2wpO1xuICAgIGNvbnN0IHByb3RvTGVuID0gKGlzQnVmUHJvdG9cbiAgICAgICAgICAgICAgICAgICAgICA/IHByb3RvY29sLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgIDogQnVmZmVyLmJ5dGVMZW5ndGgocHJvdG9jb2wpKTtcbiAgICBjb25zdCBpc0J1ZkNvb2tpZSA9IEJ1ZmZlci5pc0J1ZmZlcihjb29raWUpO1xuICAgIGNvbnN0IGNvb2tpZUxlbiA9IChpc0J1ZkNvb2tpZVxuICAgICAgICAgICAgICAgICAgICAgICA/IGNvb2tpZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgOiBCdWZmZXIuYnl0ZUxlbmd0aChjb29raWUpKTtcbiAgICBsZXQgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2MoXG4gICAgICAxICsgNCArIDQgKyA3ICsgMSArIDEgKyA0ICsgcHJvdG9MZW4gKyA0ICsgY29va2llTGVuICsgNFxuICAgICk7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjaGFuLCArK3ApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDcsIHAgKz0gNCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgneDExLXJlcScsIHAgKz0gNCwgNyk7XG5cbiAgICBwYWNrZXRbcCArPSA3XSA9ICh3YW50UmVwbHkgPT09IHVuZGVmaW5lZCB8fCB3YW50UmVwbHkgPT09IHRydWUgPyAxIDogMCk7XG5cbiAgICBwYWNrZXRbKytwXSA9IChjZmcuc2luZ2xlID8gMSA6IDApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHByb3RvTGVuLCArK3ApO1xuICAgIGlmIChpc0J1ZlByb3RvKVxuICAgICAgcGFja2V0LnNldChwcm90b2NvbCwgcCArPSA0KTtcbiAgICBlbHNlXG4gICAgICBwYWNrZXQudXRmOFdyaXRlKHByb3RvY29sLCBwICs9IDQsIHByb3RvTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjb29raWVMZW4sIHAgKz0gcHJvdG9MZW4pO1xuICAgIGlmIChpc0J1ZkNvb2tpZSlcbiAgICAgIHBhY2tldC5zZXQoY29va2llLCBwICs9IDQpO1xuICAgIGVsc2VcbiAgICAgIHBhY2tldC5sYXRpbjFXcml0ZShjb29raWUsIHAgKz0gNCwgY29va2llTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCAoY2ZnLnNjcmVlbiB8fCAwKSwgcCArPSBjb29raWVMZW4pO1xuXG4gICAgdGhpcy5fZGVidWdcbiAgICAgICYmIHRoaXMuX2RlYnVnKGBPdXRib3VuZDogU2VuZGluZyBDSEFOTkVMX1JFUVVFU1QgKHI6JHtjaGFufSwgeDExLXJlcSlgKTtcbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG4gIHN1YnN5c3RlbShjaGFuLCBuYW1lLCB3YW50UmVwbHkpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuICAgIGNvbnN0IG5hbWVMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChuYW1lKTtcbiAgICBsZXQgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2MoMSArIDQgKyA0ICsgOSArIDEgKyA0ICsgbmFtZUxlbik7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjaGFuLCArK3ApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDksIHAgKz0gNCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgnc3Vic3lzdGVtJywgcCArPSA0LCA5KTtcblxuICAgIHBhY2tldFtwICs9IDldID0gKHdhbnRSZXBseSA9PT0gdW5kZWZpbmVkIHx8IHdhbnRSZXBseSA9PT0gdHJ1ZSA/IDEgOiAwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBuYW1lTGVuLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUobmFtZSwgcCArPSA0LCBuYW1lTGVuKTtcblxuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYE91dGJvdW5kOiBTZW5kaW5nIENIQU5ORUxfUkVRVUVTVCAocjoke2NoYW59LCBzdWJzeXN0ZW06ICR7bmFtZX0pYFxuICAgICk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBvcGVuc3NoX2FnZW50Rm9yd2FyZChjaGFuLCB3YW50UmVwbHkpIHtcbiAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuXG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0ICsgNCArIDI2ICsgMSk7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjaGFuLCArK3ApO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDI2LCBwICs9IDQpO1xuICAgIHBhY2tldC51dGY4V3JpdGUoJ2F1dGgtYWdlbnQtcmVxQG9wZW5zc2guY29tJywgcCArPSA0LCAyNik7XG5cbiAgICBwYWNrZXRbcCArPSAyNl0gPSAod2FudFJlcGx5ID09PSB1bmRlZmluZWQgfHwgd2FudFJlcGx5ID09PSB0cnVlID8gMSA6IDApO1xuXG4gICAgaWYgKHRoaXMuX2RlYnVnKSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgJ091dGJvdW5kOiBTZW5kaW5nIENIQU5ORUxfUkVRVUVTVCAnXG4gICAgICAgICAgKyBgKHI6JHtjaGFufSwgYXV0aC1hZ2VudC1yZXFAb3BlbnNzaC5jb20pYFxuICAgICAgKTtcbiAgICB9XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBvcGVuc3NoX2hvc3RLZXlzUHJvdmUoa2V5cykge1xuICAgIGlmICh0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGxldCBrZXlzVG90YWwgPSAwO1xuICAgIGNvbnN0IHB1YmxpY0tleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBrZXkuZ2V0UHVibGljU1NIKCk7XG4gICAgICBrZXlzVG90YWwgKz0gNCArIHB1YmxpY0tleS5sZW5ndGg7XG4gICAgICBwdWJsaWNLZXlzLnB1c2gocHVibGljS2V5KTtcbiAgICB9XG5cbiAgICBsZXQgcCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2MoMSArIDQgKyAyOSArIDEgKyBrZXlzVG90YWwpO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5HTE9CQUxfUkVRVUVTVDtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCAyOSwgKytwKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKCdob3N0a2V5cy1wcm92ZS0wMEBvcGVuc3NoLmNvbScsIHAgKz0gNCwgMjkpO1xuXG4gICAgcGFja2V0W3AgKz0gMjldID0gMTsgLy8gd2FudCByZXBseVxuXG4gICAgKytwO1xuICAgIGZvciAoY29uc3QgYnVmIG9mIHB1YmxpY0tleXMpIHtcbiAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBidWYubGVuZ3RoLCBwKTtcbiAgICAgIGJ1ZmZlckNvcHkoYnVmLCBwYWNrZXQsIDAsIGJ1Zi5sZW5ndGgsIHAgKz0gNCk7XG4gICAgICBwICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlYnVnKSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgJ091dGJvdW5kOiBTZW5kaW5nIEdMT0JBTF9SRVFVRVNUIChob3N0a2V5cy1wcm92ZS0wMEBvcGVuc3NoLmNvbSknXG4gICAgICApO1xuICAgIH1cbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNlcnZlci1zcGVjaWZpYyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvLyBHbG9iYWxcbiAgLy8gLS0tLS0tXG4gIHNlcnZpY2VBY2NlcHQoc3ZjTmFtZSkge1xuICAgIGlmICghdGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXItb25seSBtZXRob2QgY2FsbGVkIGluIGNsaWVudCBtb2RlJyk7XG5cbiAgICBjb25zdCBzdmNOYW1lTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ZjTmFtZSk7XG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0ICsgc3ZjTmFtZUxlbik7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLlNFUlZJQ0VfQUNDRVBUO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIHN2Y05hbWVMZW4sICsrcCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZShzdmNOYW1lLCBwICs9IDQsIHN2Y05hbWVMZW4pO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoYE91dGJvdW5kOiBTZW5kaW5nIFNFUlZJQ0VfQUNDRVBUICgke3N2Y05hbWV9KWApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG5cbiAgICBpZiAodGhpcy5fc2VydmVyICYmIHRoaXMuX2Jhbm5lciAmJiBzdmNOYW1lID09PSAnc3NoLXVzZXJhdXRoJykge1xuICAgICAgY29uc3QgYmFubmVyID0gdGhpcy5fYmFubmVyO1xuICAgICAgdGhpcy5fYmFubmVyID0gdW5kZWZpbmVkOyAvLyBQcmV2ZW50IGJhbm5lciBmcm9tIGJlaW5nIGRpc3BsYXllZCBhZ2FpblxuICAgICAgY29uc3QgYmFubmVyTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoYmFubmVyKTtcbiAgICAgIHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2MoMSArIDQgKyBiYW5uZXJMZW4gKyA0KTtcblxuICAgICAgcGFja2V0W3BdID0gTUVTU0FHRS5VU0VSQVVUSF9CQU5ORVI7XG5cbiAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBiYW5uZXJMZW4sICsrcCk7XG4gICAgICBwYWNrZXQudXRmOFdyaXRlKGJhbm5lciwgcCArPSA0LCBiYW5uZXJMZW4pO1xuXG4gICAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMCwgcCArPSBiYW5uZXJMZW4pOyAvLyBFbXB0eSBsYW5ndWFnZSB0YWdcblxuICAgICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoJ091dGJvdW5kOiBTZW5kaW5nIFVTRVJBVVRIX0JBTk5FUicpO1xuICAgICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgICB9XG4gIH1cbiAgLy8gJ3NzaC1jb25uZWN0aW9uJyBzZXJ2aWNlLXNwZWNpZmljXG4gIGZvcndhcmRlZFRjcGlwKGNoYW4sIGluaXRXaW5kb3csIG1heFBhY2tldCwgY2ZnKSB7XG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gY2xpZW50IG1vZGUnKTtcblxuICAgIGNvbnN0IGJvdW5kQWRkckxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNmZy5ib3VuZEFkZHIpO1xuICAgIGNvbnN0IHJlbW90ZUFkZHJMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChjZmcucmVtb3RlQWRkcik7XG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKFxuICAgICAgMSArIDQgKyAxNSArIDQgKyA0ICsgNCArIDQgKyBib3VuZEFkZHJMZW4gKyA0ICsgNCArIHJlbW90ZUFkZHJMZW4gKyA0XG4gICAgKTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuQ0hBTk5FTF9PUEVOO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDE1LCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUoJ2ZvcndhcmRlZC10Y3BpcCcsIHAgKz0gNCwgMTUpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGNoYW4sIHAgKz0gMTUpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGluaXRXaW5kb3csIHAgKz0gNCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgbWF4UGFja2V0LCBwICs9IDQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGJvdW5kQWRkckxlbiwgcCArPSA0KTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKGNmZy5ib3VuZEFkZHIsIHAgKz0gNCwgYm91bmRBZGRyTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjZmcuYm91bmRQb3J0LCBwICs9IGJvdW5kQWRkckxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcmVtb3RlQWRkckxlbiwgcCArPSA0KTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKGNmZy5yZW1vdGVBZGRyLCBwICs9IDQsIHJlbW90ZUFkZHJMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGNmZy5yZW1vdGVQb3J0LCBwICs9IHJlbW90ZUFkZHJMZW4pO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9PUEVOIChyOiR7Y2hhbn0sIGZvcndhcmRlZC10Y3BpcClgXG4gICAgKTtcbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG4gIHgxMShjaGFuLCBpbml0V2luZG93LCBtYXhQYWNrZXQsIGNmZykge1xuICAgIGlmICghdGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXItb25seSBtZXRob2QgY2FsbGVkIGluIGNsaWVudCBtb2RlJyk7XG5cbiAgICBjb25zdCBhZGRyTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2ZnLm9yaWdpbkFkZHIpO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYyhcbiAgICAgIDEgKyA0ICsgMyArIDQgKyA0ICsgNCArIDQgKyBhZGRyTGVuICsgNFxuICAgICk7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLkNIQU5ORUxfT1BFTjtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCAzLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUoJ3gxMScsIHAgKz0gNCwgMyk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY2hhbiwgcCArPSAzKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBpbml0V2luZG93LCBwICs9IDQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIG1heFBhY2tldCwgcCArPSA0KTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBhZGRyTGVuLCBwICs9IDQpO1xuICAgIHBhY2tldC51dGY4V3JpdGUoY2ZnLm9yaWdpbkFkZHIsIHAgKz0gNCwgYWRkckxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY2ZnLm9yaWdpblBvcnQsIHAgKz0gYWRkckxlbik7XG5cbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhcbiAgICAgIGBPdXRib3VuZDogU2VuZGluZyBDSEFOTkVMX09QRU4gKHI6JHtjaGFufSwgeDExKWBcbiAgICApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgb3BlbnNzaF9hdXRoQWdlbnQoY2hhbiwgaW5pdFdpbmRvdywgbWF4UGFja2V0KSB7XG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gY2xpZW50IG1vZGUnKTtcblxuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIDIyICsgNCArIDQgKyA0KTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuQ0hBTk5FTF9PUEVOO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDIyLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUoJ2F1dGgtYWdlbnRAb3BlbnNzaC5jb20nLCBwICs9IDQsIDIyKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBjaGFuLCBwICs9IDIyKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBpbml0V2luZG93LCBwICs9IDQpO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIG1heFBhY2tldCwgcCArPSA0KTtcblxuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYE91dGJvdW5kOiBTZW5kaW5nIENIQU5ORUxfT1BFTiAocjoke2NoYW59LCBhdXRoLWFnZW50QG9wZW5zc2guY29tKWBcbiAgICApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgb3BlbnNzaF9mb3J3YXJkZWRTdHJlYW1Mb2NhbChjaGFuLCBpbml0V2luZG93LCBtYXhQYWNrZXQsIGNmZykge1xuICAgIGlmICghdGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXItb25seSBtZXRob2QgY2FsbGVkIGluIGNsaWVudCBtb2RlJyk7XG5cbiAgICBjb25zdCBwYXRoTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2ZnLnNvY2tldFBhdGgpO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYyhcbiAgICAgIDEgKyA0ICsgMzMgKyA0ICsgNCArIDQgKyA0ICsgcGF0aExlbiArIDRcbiAgICApO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5DSEFOTkVMX09QRU47XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMzMsICsrcCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgnZm9yd2FyZGVkLXN0cmVhbWxvY2FsQG9wZW5zc2guY29tJywgcCArPSA0LCAzMyk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgY2hhbiwgcCArPSAzMyk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgaW5pdFdpbmRvdywgcCArPSA0KTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBtYXhQYWNrZXQsIHAgKz0gNCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcGF0aExlbiwgcCArPSA0KTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKGNmZy5zb2NrZXRQYXRoLCBwICs9IDQsIHBhdGhMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDAsIHAgKz0gcGF0aExlbik7XG5cbiAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAnT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9PUEVOICdcbiAgICAgICAgICArIGAocjoke2NoYW59LCBmb3J3YXJkZWQtc3RyZWFtbG9jYWxAb3BlbnNzaC5jb20pYFxuICAgICAgKTtcbiAgICB9XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBleGl0U3RhdHVzKGNoYW4sIHN0YXR1cykge1xuICAgIGlmICghdGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXItb25seSBtZXRob2QgY2FsbGVkIGluIGNsaWVudCBtb2RlJyk7XG5cbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIDQgKyAxMSArIDEgKyA0KTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuQ0hBTk5FTF9SRVFVRVNUO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGNoYW4sICsrcCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMTEsIHAgKz0gNCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgnZXhpdC1zdGF0dXMnLCBwICs9IDQsIDExKTtcblxuICAgIHBhY2tldFtwICs9IDExXSA9IDA7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgc3RhdHVzLCArK3ApO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9SRVFVRVNUIChyOiR7Y2hhbn0sIGV4aXQtc3RhdHVzOiAke3N0YXR1c30pYFxuICAgICk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBleGl0U2lnbmFsKGNoYW4sIG5hbWUsIGNvcmVEdW1wZWQsIG1zZykge1xuICAgIGlmICghdGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXItb25seSBtZXRob2QgY2FsbGVkIGluIGNsaWVudCBtb2RlJyk7XG5cbiAgICAvLyBEb2VzIG5vdCBjb25zdW1lIHdpbmRvdyBzcGFjZVxuXG4gICAgY29uc3Qgb3JpZ1NpZ25hbCA9IG5hbWU7XG5cbiAgICBpZiAodHlwZW9mIG9yaWdTaWduYWwgIT09ICdzdHJpbmcnIHx8ICFvcmlnU2lnbmFsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hbDogJHtvcmlnU2lnbmFsfWApO1xuXG4gICAgbGV0IHNpZ25hbCA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoc2lnbmFsLnNsaWNlKDAsIDMpID09PSAnU0lHJylcbiAgICAgIHNpZ25hbCA9IHNpZ25hbC5zbGljZSgzKTtcblxuICAgIGlmIChTSUdOQUxTW3NpZ25hbF0gIT09IDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmFsOiAke29yaWdTaWduYWx9YCk7XG5cbiAgICBjb25zdCBuYW1lTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoc2lnbmFsKTtcbiAgICBjb25zdCBtc2dMZW4gPSAobXNnID8gQnVmZmVyLmJ5dGVMZW5ndGgobXNnKSA6IDApO1xuICAgIGxldCBwID0gdGhpcy5fcGFja2V0Ulcud3JpdGUuYWxsb2NTdGFydDtcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvYyhcbiAgICAgIDEgKyA0ICsgNCArIDExICsgMSArIDQgKyBuYW1lTGVuICsgMSArIDQgKyBtc2dMZW4gKyA0XG4gICAgKTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuQ0hBTk5FTF9SRVFVRVNUO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGNoYW4sICsrcCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMTEsIHAgKz0gNCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZSgnZXhpdC1zaWduYWwnLCBwICs9IDQsIDExKTtcblxuICAgIHBhY2tldFtwICs9IDExXSA9IDA7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgbmFtZUxlbiwgKytwKTtcbiAgICBwYWNrZXQudXRmOFdyaXRlKHNpZ25hbCwgcCArPSA0LCBuYW1lTGVuKTtcblxuICAgIHBhY2tldFtwICs9IG5hbWVMZW5dID0gKGNvcmVEdW1wZWQgPyAxIDogMCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgbXNnTGVuLCArK3ApO1xuXG4gICAgcCArPSA0O1xuICAgIGlmIChtc2dMZW4pIHtcbiAgICAgIHBhY2tldC51dGY4V3JpdGUobXNnLCBwLCBtc2dMZW4pO1xuICAgICAgcCArPSBtc2dMZW47XG4gICAgfVxuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIDAsIHApO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgT3V0Ym91bmQ6IFNlbmRpbmcgQ0hBTk5FTF9SRVFVRVNUIChyOiR7Y2hhbn0sIGV4aXQtc2lnbmFsOiAke25hbWV9KWBcbiAgICApO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbiAgLy8gJ3NzaC11c2VyYXV0aCcgc2VydmljZS1zcGVjaWZpY1xuICBhdXRoRmFpbHVyZShhdXRoTWV0aG9kcywgaXNQYXJ0aWFsKSB7XG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gY2xpZW50IG1vZGUnKTtcblxuICAgIGlmICh0aGlzLl9hdXRoc1F1ZXVlLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYXV0aCBpbiBwcm9ncmVzcycpO1xuXG4gICAgbGV0IG1ldGhvZHM7XG5cbiAgICBpZiAodHlwZW9mIGF1dGhNZXRob2RzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGlzUGFydGlhbCA9IGF1dGhNZXRob2RzO1xuICAgICAgYXV0aE1ldGhvZHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGF1dGhNZXRob2RzKSB7XG4gICAgICBtZXRob2RzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF1dGhNZXRob2RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChhdXRoTWV0aG9kc1tpXS50b0xvd2VyQ2FzZSgpID09PSAnbm9uZScpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIG1ldGhvZHMucHVzaChhdXRoTWV0aG9kc1tpXSk7XG4gICAgICB9XG4gICAgICBtZXRob2RzID0gbWV0aG9kcy5qb2luKCcsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1ldGhvZHMgPSAnJztcbiAgICB9XG5cbiAgICBjb25zdCBtZXRob2RzTGVuID0gbWV0aG9kcy5sZW5ndGg7XG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0ICsgbWV0aG9kc0xlbiArIDEpO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5VU0VSQVVUSF9GQUlMVVJFO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIG1ldGhvZHNMZW4sICsrcCk7XG4gICAgcGFja2V0LnV0ZjhXcml0ZShtZXRob2RzLCBwICs9IDQsIG1ldGhvZHNMZW4pO1xuXG4gICAgcGFja2V0W3AgKz0gbWV0aG9kc0xlbl0gPSAoaXNQYXJ0aWFsID09PSB0cnVlID8gMSA6IDApO1xuXG4gICAgdGhpcy5fYXV0aHNRdWV1ZS5zaGlmdCgpO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoJ091dGJvdW5kOiBTZW5kaW5nIFVTRVJBVVRIX0ZBSUxVUkUnKTtcbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG4gIGF1dGhTdWNjZXNzKCkge1xuICAgIGlmICghdGhpcy5fc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXItb25seSBtZXRob2QgY2FsbGVkIGluIGNsaWVudCBtb2RlJyk7XG5cbiAgICBpZiAodGhpcy5fYXV0aHNRdWV1ZS5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGF1dGggaW4gcHJvZ3Jlc3MnKTtcblxuICAgIGNvbnN0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEpO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5VU0VSQVVUSF9TVUNDRVNTO1xuXG4gICAgdGhpcy5fYXV0aHNRdWV1ZS5zaGlmdCgpO1xuICAgIHRoaXMuX2F1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoJ091dGJvdW5kOiBTZW5kaW5nIFVTRVJBVVRIX1NVQ0NFU1MnKTtcbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuXG4gICAgaWYgKHRoaXMuX2tleC5uZWdvdGlhdGVkLmNzLmNvbXByZXNzID09PSAnemxpYkBvcGVuc3NoLmNvbScpXG4gICAgICB0aGlzLl9wYWNrZXRSVy5yZWFkID0gbmV3IFpsaWJQYWNrZXRSZWFkZXIoKTtcbiAgICBpZiAodGhpcy5fa2V4Lm5lZ290aWF0ZWQuc2MuY29tcHJlc3MgPT09ICd6bGliQG9wZW5zc2guY29tJylcbiAgICAgIHRoaXMuX3BhY2tldFJXLndyaXRlID0gbmV3IFpsaWJQYWNrZXRXcml0ZXIodGhpcyk7XG4gIH1cbiAgYXV0aFBLT0soa2V5QWxnbywga2V5KSB7XG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gY2xpZW50IG1vZGUnKTtcblxuICAgIGlmICh0aGlzLl9hdXRoc1F1ZXVlLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9hdXRoc1F1ZXVlWzBdICE9PSAncHVibGlja2V5JylcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJwdWJsaWNrZXlcIiBhdXRoIG5vdCBpbiBwcm9ncmVzcycpO1xuXG4gICAgLy8gVE9ETzogc3VwcG9ydCBwYXJzZWQga2V5IGZvciBga2V5YFxuXG4gICAgY29uc3Qga2V5QWxnb0xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGtleUFsZ28pO1xuICAgIGNvbnN0IGtleUxlbiA9IGtleS5sZW5ndGg7XG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0ICsga2V5QWxnb0xlbiArIDQgKyBrZXlMZW4pO1xuXG4gICAgcGFja2V0W3BdID0gTUVTU0FHRS5VU0VSQVVUSF9QS19PSztcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBrZXlBbGdvTGVuLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUoa2V5QWxnbywgcCArPSA0LCBrZXlBbGdvTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBrZXlMZW4sIHAgKz0ga2V5QWxnb0xlbik7XG4gICAgcGFja2V0LnNldChrZXksIHAgKz0gNCk7XG5cbiAgICB0aGlzLl9hdXRoc1F1ZXVlLnNoaWZ0KCk7XG5cbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZygnT3V0Ym91bmQ6IFNlbmRpbmcgVVNFUkFVVEhfUEtfT0snKTtcbiAgICBzZW5kUGFja2V0KHRoaXMsIHRoaXMuX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xuICB9XG4gIGF1dGhQYXNzd2RDaGcocHJvbXB0KSB7XG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gY2xpZW50IG1vZGUnKTtcblxuICAgIGNvbnN0IHByb21wdExlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHByb21wdCk7XG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKDEgKyA0ICsgcHJvbXB0TGVuICsgNCk7XG5cbiAgICBwYWNrZXRbcF0gPSBNRVNTQUdFLlVTRVJBVVRIX1BBU1NXRF9DSEFOR0VSRVE7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgcHJvbXB0TGVuLCArK3ApO1xuICAgIHBhY2tldC51dGY4V3JpdGUocHJvbXB0LCBwICs9IDQsIHByb21wdExlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKHBhY2tldCwgMCwgcCArPSBwcm9tcHRMZW4pOyAvLyBFbXB0eSBsYW5ndWFnZSB0YWdcblxuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKCdPdXRib3VuZDogU2VuZGluZyBVU0VSQVVUSF9QQVNTV0RfQ0hBTkdFUkVRJyk7XG4gICAgc2VuZFBhY2tldCh0aGlzLCB0aGlzLl9wYWNrZXRSVy53cml0ZS5maW5hbGl6ZShwYWNrZXQpKTtcbiAgfVxuICBhdXRoSW5mb1JlcShuYW1lLCBpbnN0cnVjdGlvbnMsIHByb21wdHMpIHtcbiAgICBpZiAoIXRoaXMuX3NlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyLW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBjbGllbnQgbW9kZScpO1xuXG4gICAgbGV0IHByb21wdHNMZW4gPSAwO1xuICAgIGNvbnN0IG5hbWVMZW4gPSBuYW1lID8gQnVmZmVyLmJ5dGVMZW5ndGgobmFtZSkgOiAwO1xuICAgIGNvbnN0IGluc3RyTGVuID0gaW5zdHJ1Y3Rpb25zID8gQnVmZmVyLmJ5dGVMZW5ndGgoaW5zdHJ1Y3Rpb25zKSA6IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21wdHMubGVuZ3RoOyArK2kpXG4gICAgICBwcm9tcHRzTGVuICs9IDQgKyBCdWZmZXIuYnl0ZUxlbmd0aChwcm9tcHRzW2ldLnByb21wdCkgKyAxO1xuXG4gICAgbGV0IHAgPSB0aGlzLl9wYWNrZXRSVy53cml0ZS5hbGxvY1N0YXJ0O1xuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMuX3BhY2tldFJXLndyaXRlLmFsbG9jKFxuICAgICAgMSArIDQgKyBuYW1lTGVuICsgNCArIGluc3RyTGVuICsgNCArIDQgKyBwcm9tcHRzTGVuXG4gICAgKTtcblxuICAgIHBhY2tldFtwXSA9IE1FU1NBR0UuVVNFUkFVVEhfSU5GT19SRVFVRVNUO1xuXG4gICAgd3JpdGVVSW50MzJCRShwYWNrZXQsIG5hbWVMZW4sICsrcCk7XG4gICAgcCArPSA0O1xuICAgIGlmIChuYW1lKSB7XG4gICAgICBwYWNrZXQudXRmOFdyaXRlKG5hbWUsIHAsIG5hbWVMZW4pO1xuICAgICAgcCArPSBuYW1lTGVuO1xuICAgIH1cblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBpbnN0ckxlbiwgcCk7XG4gICAgcCArPSA0O1xuICAgIGlmIChpbnN0cnVjdGlvbnMpIHtcbiAgICAgIHBhY2tldC51dGY4V3JpdGUoaW5zdHJ1Y3Rpb25zLCBwLCBpbnN0ckxlbik7XG4gICAgICBwICs9IGluc3RyTGVuO1xuICAgIH1cblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCAwLCBwKTtcblxuICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBwcm9tcHRzLmxlbmd0aCwgcCArPSA0KTtcbiAgICBwICs9IDQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9tcHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwcm9tcHQgPSBwcm9tcHRzW2ldO1xuICAgICAgY29uc3QgcHJvbXB0TGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgocHJvbXB0LnByb21wdCk7XG5cbiAgICAgIHdyaXRlVUludDMyQkUocGFja2V0LCBwcm9tcHRMZW4sIHApO1xuICAgICAgcCArPSA0O1xuICAgICAgaWYgKHByb21wdExlbikge1xuICAgICAgICBwYWNrZXQudXRmOFdyaXRlKHByb21wdC5wcm9tcHQsIHAsIHByb21wdExlbik7XG4gICAgICAgIHAgKz0gcHJvbXB0TGVuO1xuICAgICAgfVxuICAgICAgcGFja2V0W3ArK10gPSAocHJvbXB0LmVjaG8gPyAxIDogMCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoJ091dGJvdW5kOiBTZW5kaW5nIFVTRVJBVVRIX0lORk9fUkVRVUVTVCcpO1xuICAgIHNlbmRQYWNrZXQodGhpcywgdGhpcy5fcGFja2V0Ulcud3JpdGUuZmluYWxpemUocGFja2V0KSk7XG4gIH1cbn1cblxuLy8gU1NILXByb3RvdmVyc2lvbi1zb2Z0d2FyZXZlcnNpb24gKFNQIGNvbW1lbnRzKSBDUiBMRlxuY29uc3QgUkVfSURFTlQgPSAvXlNTSC0oMlxcLjB8MVxcLjk5KS0oW14gXSspKD86ICguKikpPyQvO1xuXG4vLyBUT0RPOiBvcHRpbWl6ZSB0aGlzIGJ5IHN0YXJ0aW5nIG4gYnl0ZXMgZnJvbSB0aGUgZW5kIG9mIHRoaXMuX2J1ZmZlciBpbnN0ZWFkXG4vLyBvZiB0aGUgYmVnaW5uaW5nXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihjaHVuaywgcCwgbGVuKSB7XG4gIGxldCBkYXRhO1xuICBsZXQgY2h1bmtPZmZzZXQ7XG4gIGlmICh0aGlzLl9idWZmZXIpIHtcbiAgICBkYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRoaXMuX2J1ZmZlci5sZW5ndGggKyAobGVuIC0gcCkpO1xuICAgIGRhdGEuc2V0KHRoaXMuX2J1ZmZlciwgMCk7XG4gICAgaWYgKHAgPT09IDApIHtcbiAgICAgIGRhdGEuc2V0KGNodW5rLCB0aGlzLl9idWZmZXIubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuYnl0ZU9mZnNldCArIHAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobGVuIC0gcCkpLFxuICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLmxlbmd0aCk7XG4gICAgfVxuICAgIGNodW5rT2Zmc2V0ID0gdGhpcy5fYnVmZmVyLmxlbmd0aDtcbiAgICBwID0gMDtcbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gY2h1bms7XG4gICAgY2h1bmtPZmZzZXQgPSAwO1xuICB9XG4gIGNvbnN0IG9wID0gcDtcbiAgbGV0IHN0YXJ0ID0gcDtcbiAgbGV0IGVuZCA9IHA7XG4gIGxldCBuZWVkTkwgPSBmYWxzZTtcbiAgbGV0IGxpbmVMZW4gPSAwO1xuICBsZXQgbGluZXMgPSAwO1xuICBmb3IgKDsgcCA8IGRhdGEubGVuZ3RoOyArK3ApIHtcbiAgICBjb25zdCBjaCA9IGRhdGFbcF07XG5cbiAgICBpZiAoY2ggPT09IDEzIC8qICdcXHInICovKSB7XG4gICAgICBuZWVkTkwgPSB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAxMCAvKiAnXFxuJyAqLykge1xuICAgICAgaWYgKGVuZCA+IHN0YXJ0XG4gICAgICAgICAgJiYgZW5kIC0gc3RhcnQgPiA0XG4gICAgICAgICAgJiYgZGF0YVtzdGFydF0gPT09IDgzIC8qICdTJyAqL1xuICAgICAgICAgICYmIGRhdGFbc3RhcnQgKyAxXSA9PT0gODMgLyogJ1MnICovXG4gICAgICAgICAgJiYgZGF0YVtzdGFydCArIDJdID09PSA3MiAvKiAnSCcgKi9cbiAgICAgICAgICAmJiBkYXRhW3N0YXJ0ICsgM10gPT09IDQ1IC8qICctJyAqLykge1xuXG4gICAgICAgIGNvbnN0IGZ1bGwgPSBkYXRhLmxhdGluMVNsaWNlKG9wLCBlbmQgKyAxKTtcbiAgICAgICAgY29uc3QgaWRlbnRSYXcgPSAoc3RhcnQgPT09IG9wID8gZnVsbCA6IGZ1bGwuc2xpY2Uoc3RhcnQgLSBvcCkpO1xuICAgICAgICBjb25zdCBtID0gUkVfSURFTlQuZXhlYyhpZGVudFJhdyk7XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaWRlbnRpZmljYXRpb24gc3RyaW5nJyk7XG5cbiAgICAgICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgICAgIGdyZWV0aW5nOiAoc3RhcnQgPT09IG9wID8gJycgOiBmdWxsLnNsaWNlKDAsIHN0YXJ0IC0gb3ApKSxcbiAgICAgICAgICBpZGVudFJhdyxcbiAgICAgICAgICB2ZXJzaW9uczoge1xuICAgICAgICAgICAgcHJvdG9jb2w6IG1bMV0sXG4gICAgICAgICAgICBzb2Z0d2FyZTogbVsyXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbW1lbnRzOiBtWzNdXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTmVlZGVkIGR1cmluZyBoYW5kc2hha2VcbiAgICAgICAgdGhpcy5fcmVtb3RlSWRlbnRSYXcgPSBCdWZmZXIuZnJvbShpZGVudFJhdyk7XG5cbiAgICAgICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoYFJlbW90ZSBpZGVudDogJHtpbnNwZWN0KGlkZW50UmF3KX1gKTtcbiAgICAgICAgdGhpcy5fY29tcGF0RmxhZ3MgPSBnZXRDb21wYXRGbGFncyhoZWFkZXIpO1xuXG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZGVjaXBoZXIgPVxuICAgICAgICAgIG5ldyBOdWxsRGVjaXBoZXIoMCwgb25LRVhQYXlsb2FkLmJpbmQodGhpcywgeyBmaXJzdFBhY2tldDogdHJ1ZSB9KSk7XG4gICAgICAgIHRoaXMuX3BhcnNlID0gcGFyc2VQYWNrZXQ7XG5cbiAgICAgICAgdGhpcy5fb25IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXN0cnVjdCkge1xuICAgICAgICAgIC8vIFdlIGRpc2Nvbm5lY3RlZCBpbnNpZGUgX29uSGVhZGVyXG4gICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleGluaXQodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHAgKyAxIC0gY2h1bmtPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgYWxsb3cgcHJlLWlkZW50IGdyZWV0aW5ncyB3aGVuIHdlJ3JlIGEgY2xpZW50XG4gICAgICBpZiAodGhpcy5fc2VydmVyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dyZWV0aW5ncyBmcm9tIGNsaWVudHMgbm90IHBlcm1pdHRlZCcpO1xuXG4gICAgICBpZiAoKytsaW5lcyA+IE1BWF9MSU5FUylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXggZ3JlZXRpbmcgbGluZXMgZXhjZWVkZWQnKTtcblxuICAgICAgbmVlZE5MID0gZmFsc2U7XG4gICAgICBzdGFydCA9IHAgKyAxO1xuICAgICAgbGluZUxlbiA9IDA7XG4gICAgfSBlbHNlIGlmIChuZWVkTkwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZWFkZXI6IGV4cGVjdGVkIG5ld2xpbmUnKTtcbiAgICB9IGVsc2UgaWYgKCsrbGluZUxlbiA+PSBNQVhfTElORV9MRU4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSGVhZGVyIGxpbmUgdG9vIGxvbmcnKTtcbiAgICB9XG5cbiAgICBlbmQgPSBwO1xuICB9XG4gIGlmICghdGhpcy5fYnVmZmVyKVxuICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlclNsaWNlKGRhdGEsIG9wKTtcblxuICByZXR1cm4gcCAtIGNodW5rT2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhY2tldChjaHVuaywgcCwgbGVuKSB7XG4gIHJldHVybiB0aGlzLl9kZWNpcGhlci5kZWNyeXB0KGNodW5rLCBwLCBsZW4pO1xufVxuXG5mdW5jdGlvbiBvblBheWxvYWQocGF5bG9hZCkge1xuICAvLyBYWFg6IG1vdmUgdGhpcyB0byB0aGUgRGVjaXBoZXIgaW1wbGVtZW50YXRpb25zP1xuXG4gIHRoaXMuX29uUGFja2V0KCk7XG5cbiAgaWYgKHBheWxvYWQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoJ0luYm91bmQ6IFNraXBwaW5nIGVtcHR5IHBhY2tldCBwYXlsb2FkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcGF5bG9hZCA9IHRoaXMuX3BhY2tldFJXLnJlYWQucmVhZChwYXlsb2FkKTtcblxuICBjb25zdCB0eXBlID0gcGF5bG9hZFswXTtcbiAgaWYgKHR5cGUgPT09IE1FU1NBR0UuVVNFUkFVVEhfU1VDQ0VTU1xuICAgICAgJiYgIXRoaXMuX3NlcnZlclxuICAgICAgJiYgIXRoaXMuX2F1dGhlbnRpY2F0ZWQpIHtcbiAgICB0aGlzLl9hdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fa2V4Lm5lZ290aWF0ZWQuY3MuY29tcHJlc3MgPT09ICd6bGliQG9wZW5zc2guY29tJylcbiAgICAgIHRoaXMuX3BhY2tldFJXLndyaXRlID0gbmV3IFpsaWJQYWNrZXRXcml0ZXIodGhpcyk7XG4gICAgaWYgKHRoaXMuX2tleC5uZWdvdGlhdGVkLnNjLmNvbXByZXNzID09PSAnemxpYkBvcGVuc3NoLmNvbScpXG4gICAgICB0aGlzLl9wYWNrZXRSVy5yZWFkID0gbmV3IFpsaWJQYWNrZXRSZWFkZXIoKTtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gTUVTU0FHRV9IQU5ETEVSU1t0eXBlXTtcbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKGBJbmJvdW5kOiBVbnN1cHBvcnRlZCBtZXNzYWdlIHR5cGU6ICR7dHlwZX1gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gaGFuZGxlcih0aGlzLCBwYXlsb2FkKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcGF0RmxhZ3MoaGVhZGVyKSB7XG4gIGNvbnN0IHNvZnR3YXJlID0gaGVhZGVyLnZlcnNpb25zLnNvZnR3YXJlO1xuXG4gIGxldCBmbGFncyA9IDA7XG5cbiAgZm9yIChjb25zdCBydWxlIG9mIENPTVBBVF9DSEVDS1MpIHtcbiAgICBpZiAodHlwZW9mIHJ1bGVbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoc29mdHdhcmUgPT09IHJ1bGVbMF0pXG4gICAgICAgIGZsYWdzIHw9IHJ1bGVbMV07XG4gICAgfSBlbHNlIGlmIChydWxlWzBdLnRlc3Qoc29mdHdhcmUpKSB7XG4gICAgICBmbGFncyB8PSBydWxlWzFdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmbGFncztcbn1cblxuZnVuY3Rpb24gbW9kZXNUb0J5dGVzKG1vZGVzKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtb2Rlcyk7XG4gIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmFsbG9jVW5zYWZlKCg1ICoga2V5cy5sZW5ndGgpICsgMSk7XG4gIGxldCBiID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChrZXkgPT09ICdUVFlfT1BfRU5EJylcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgY29uc3Qgb3Bjb2RlID0gVEVSTUlOQUxfTU9ERVtrZXldO1xuICAgIGlmIChvcGNvZGUgPT09IHVuZGVmaW5lZClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgdmFsID0gbW9kZXNba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgICAgYnl0ZXNbYisrXSA9IG9wY29kZTtcbiAgICAgIGJ5dGVzW2IrK10gPSB2YWwgPj4+IDI0O1xuICAgICAgYnl0ZXNbYisrXSA9IHZhbCA+Pj4gMTY7XG4gICAgICBieXRlc1tiKytdID0gdmFsID4+PiA4O1xuICAgICAgYnl0ZXNbYisrXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBieXRlc1tiKytdID0gVEVSTUlOQUxfTU9ERS5UVFlfT1BfRU5EO1xuXG4gIGlmIChiIDwgYnl0ZXMubGVuZ3RoKVxuICAgIHJldHVybiBidWZmZXJTbGljZShieXRlcywgMCwgYik7XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5mdW5jdGlvbiBzZW5kRXh0SW5mbyhwcm90bykge1xuICBsZXQgc2VydmVyU2lnQWxncyA9XG4gICAgJ2VjZHNhLXNoYTItbmlzdHAyNTYsZWNkc2Etc2hhMi1uaXN0cDM4NCxlY2RzYS1zaGEyLW5pc3RwNTIxJ1xuICAgICAgKyAncnNhLXNoYTItNTEyLHJzYS1zaGEyLTI1Nixzc2gtcnNhLHNzaC1kc3MnO1xuICBpZiAoZWRkc2FTdXBwb3J0ZWQpXG4gICAgc2VydmVyU2lnQWxncyA9IGBzc2gtZWQyNTUxOSwke3NlcnZlclNpZ0FsZ3N9YDtcbiAgY29uc3QgYWxnc0xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHNlcnZlclNpZ0FsZ3MpO1xuXG4gIGxldCBwID0gcHJvdG8uX3BhY2tldFJXLndyaXRlLmFsbG9jU3RhcnQ7XG4gIGNvbnN0IHBhY2tldCA9IHByb3RvLl9wYWNrZXRSVy53cml0ZS5hbGxvYygxICsgNCArIDQgKyAxNSArIDQgKyBhbGdzTGVuKTtcblxuICBwYWNrZXRbcF0gPSBNRVNTQUdFLkVYVF9JTkZPO1xuXG4gIHdyaXRlVUludDMyQkUocGFja2V0LCAxLCArK3ApO1xuXG4gIHdyaXRlVUludDMyQkUocGFja2V0LCAxNSwgcCArPSA0KTtcbiAgcGFja2V0LnV0ZjhXcml0ZSgnc2VydmVyLXNpZy1hbGdzJywgcCArPSA0LCAxNSk7XG5cbiAgd3JpdGVVSW50MzJCRShwYWNrZXQsIGFsZ3NMZW4sIHAgKz0gMTUpO1xuICBwYWNrZXQudXRmOFdyaXRlKHNlcnZlclNpZ0FsZ3MsIHAgKz0gNCwgYWxnc0xlbik7XG5cbiAgcHJvdG8uX2RlYnVnICYmIHByb3RvLl9kZWJ1ZygnT3V0Ym91bmQ6IFNlbmRpbmcgRVhUX0lORk8nKTtcbiAgc2VuZFBhY2tldChwcm90bywgcHJvdG8uX3BhY2tldFJXLndyaXRlLmZpbmFsaXplKHBhY2tldCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3RvY29sO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCB7IGluc3BlY3QgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLy8gT25seSB1c2UgdGhpcyBmb3IgaW50ZWdlcnMhIERlY2ltYWwgbnVtYmVycyBkbyBub3Qgd29yayB3aXRoIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IodmFsKSB7XG4gIGxldCByZXMgPSAnJztcbiAgbGV0IGkgPSB2YWwubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDA7XG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKVxuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWA7XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YDtcbn1cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGFzc2VydCh0eXBlb2YgdGhpbmcgPT09ICdzdHJpbmcnLCAnYHRoaW5nYCBoYXMgdG8gYmUgb2YgdHlwZSBzdHJpbmcnKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgY29uc3QgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGFzc2VydChsZW4gPiAwLCAnQXQgbGVhc3Qgb25lIGV4cGVjdGVkIHZhbHVlIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKChpKSA9PiBTdHJpbmcoaSkpO1xuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gYG9uZSBvZiAke3RoaW5nfSAke2V4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyl9LCBvciBgXG4gICAgICAgICAgICAgICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBgb25lIG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWRbMF19IG9yICR7ZXhwZWN0ZWRbMV19YDtcbiAgICB9XG4gICAgcmV0dXJuIGBvZiAke3RoaW5nfSAke2V4cGVjdGVkWzBdfWA7XG4gIH1cbiAgcmV0dXJuIGBvZiAke3RoaW5nfSAke1N0cmluZyhleHBlY3RlZCl9YDtcbn1cblxuXG5leHBvcnRzLkVSUl9JTlRFUk5BTF9BU1NFUlRJT04gPSBjbGFzcyBFUlJfSU5URVJOQUxfQVNTRVJUSU9OIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFUlJfSU5URVJOQUxfQVNTRVJUSU9OKTtcblxuICAgIGNvbnN0IHN1ZmZpeCA9ICdUaGlzIGlzIGNhdXNlZCBieSBlaXRoZXIgYSBidWcgaW4gc3NoMiAnXG4gICAgICAgICAgICAgICAgICAgKyAnb3IgaW5jb3JyZWN0IHVzYWdlIG9mIHNzaDIgaW50ZXJuYWxzLlxcbidcbiAgICAgICAgICAgICAgICAgICArICdQbGVhc2Ugb3BlbiBhbiBpc3N1ZSB3aXRoIHRoaXMgc3RhY2sgdHJhY2UgYXQgJ1xuICAgICAgICAgICAgICAgICAgICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9tc2NkZXgvc3NoMi9pc3N1ZXNcXG4nO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/IHN1ZmZpeCA6IGAke21lc3NhZ2V9XFxuJHtzdWZmaXh9YCk7XG4gIH1cbn07XG5cbmNvbnN0IE1BWF8zMkJJVF9JTlQgPSAyICoqIDMyO1xuY29uc3QgTUFYXzMyQklUX0JJR0lOVCA9ICgoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbigncmV0dXJuIDJuICoqIDMybicpKCk7XG4gIH0gY2F0Y2gge31cbn0pKCk7XG5leHBvcnRzLkVSUl9PVVRfT0ZfUkFOR0UgPSBjbGFzcyBFUlJfT1VUX09GX1JBTkdFIGV4dGVuZHMgUmFuZ2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHN0ciwgcmFuZ2UsIGlucHV0LCByZXBsYWNlRGVmYXVsdEJvb2xlYW4pIHtcbiAgICBzdXBlcigpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVSUl9PVVRfT0ZfUkFOR0UpO1xuXG4gICAgYXNzZXJ0KHJhbmdlLCAnTWlzc2luZyBcInJhbmdlXCIgYXJndW1lbnQnKTtcbiAgICBsZXQgbXNnID0gKHJlcGxhY2VEZWZhdWx0Qm9vbGVhblxuICAgICAgICAgICAgICAgPyBzdHJcbiAgICAgICAgICAgICAgIDogYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gKTtcbiAgICBsZXQgcmVjZWl2ZWQ7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IE1BWF8zMkJJVF9JTlQpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpO1xuICAgICAgaWYgKGlucHV0ID4gTUFYXzMyQklUX0JJR0lOVCB8fCBpbnB1dCA8IC1NQVhfMzJCSVRfQklHSU5UKVxuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZCk7XG4gICAgICByZWNlaXZlZCArPSAnbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY2VpdmVkID0gaW5zcGVjdChpbnB1dCk7XG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YDtcblxuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgfVxufTtcblxuY2xhc3MgRVJSX0lOVkFMSURfQVJHX1RZUEUgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gICAgc3VwZXIoKTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG5cbiAgICBhc3NlcnQodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCBgJ25hbWUnIG11c3QgYmUgYSBzdHJpbmdgKTtcblxuICAgIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gICAgbGV0IGRldGVybWluZXI7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgZXhwZWN0ZWQuc3RhcnRzV2l0aCgnbm90ICcpKSB7XG4gICAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gICAgfVxuXG4gICAgbGV0IG1zZztcbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnIGFyZ3VtZW50JykpIHtcbiAgICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICAgIG1zZyA9IGBUaGUgJHtuYW1lfSAke2RldGVybWluZXJ9ICR7b25lT2YoZXhwZWN0ZWQsICd0eXBlJyl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IChuYW1lLmluY2x1ZGVzKCcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50Jyk7XG4gICAgICBtc2cgPSBgVGhlIFwiJHtuYW1lfVwiICR7dHlwZX0gJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCAndHlwZScpfWA7XG4gICAgfVxuXG4gICAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7XG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gIH1cbn1cbmV4cG9ydHMuRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBFUlJfSU5WQUxJRF9BUkdfVFlQRTtcblxuZXhwb3J0cy52YWxpZGF0ZU51bWJlciA9IGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBjb25zdGFudHMgfSA9IGZzO1xuY29uc3Qge1xuICBSZWFkYWJsZTogUmVhZGFibGVTdHJlYW0sXG4gIFdyaXRhYmxlOiBXcml0YWJsZVN0cmVhbVxufSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBpbmhlcml0cywgaXNEYXRlIH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXG5jb25zdCB7XG4gIGJ1ZmZlckNvcHksXG4gIGJ1ZmZlclNsaWNlLFxuICBtYWtlQnVmZmVyUGFyc2VyLFxuICB3cml0ZVVJbnQzMkJFLFxufSA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcblxuY29uc3QgQVRUUiA9IHtcbiAgU0laRTogMHgwMDAwMDAwMSxcbiAgVUlER0lEOiAweDAwMDAwMDAyLFxuICBQRVJNSVNTSU9OUzogMHgwMDAwMDAwNCxcbiAgQUNNT0RUSU1FOiAweDAwMDAwMDA4LFxuICBFWFRFTkRFRDogMHg4MDAwMDAwMCxcbn07XG5cbi8vIExhcmdlIGVub3VnaCB0byBzdG9yZSBhbGwgcG9zc2libGUgYXR0cmlidXRlc1xuY29uc3QgQVRUUlNfQlVGID0gQnVmZmVyLmFsbG9jKDI4KTtcblxuY29uc3QgU1RBVFVTX0NPREUgPSB7XG4gIE9LOiAwLFxuICBFT0Y6IDEsXG4gIE5PX1NVQ0hfRklMRTogMixcbiAgUEVSTUlTU0lPTl9ERU5JRUQ6IDMsXG4gIEZBSUxVUkU6IDQsXG4gIEJBRF9NRVNTQUdFOiA1LFxuICBOT19DT05ORUNUSU9OOiA2LFxuICBDT05ORUNUSU9OX0xPU1Q6IDcsXG4gIE9QX1VOU1VQUE9SVEVEOiA4XG59O1xuXG5jb25zdCBWQUxJRF9TVEFUVVNfQ09ERVMgPSBuZXcgTWFwKFxuICBPYmplY3QudmFsdWVzKFNUQVRVU19DT0RFKS5tYXAoKG4pID0+IFtuLCAxXSlcbik7XG5cbmNvbnN0IFNUQVRVU19DT0RFX1NUUiA9IHtcbiAgW1NUQVRVU19DT0RFLk9LXTogJ05vIGVycm9yJyxcbiAgW1NUQVRVU19DT0RFLkVPRl06ICdFbmQgb2YgZmlsZScsXG4gIFtTVEFUVVNfQ09ERS5OT19TVUNIX0ZJTEVdOiAnTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScsXG4gIFtTVEFUVVNfQ09ERS5QRVJNSVNTSU9OX0RFTklFRF06ICdQZXJtaXNzaW9uIGRlbmllZCcsXG4gIFtTVEFUVVNfQ09ERS5GQUlMVVJFXTogJ0ZhaWx1cmUnLFxuICBbU1RBVFVTX0NPREUuQkFEX01FU1NBR0VdOiAnQmFkIG1lc3NhZ2UnLFxuICBbU1RBVFVTX0NPREUuTk9fQ09OTkVDVElPTl06ICdObyBjb25uZWN0aW9uJyxcbiAgW1NUQVRVU19DT0RFLkNPTk5FQ1RJT05fTE9TVF06ICdDb25uZWN0aW9uIGxvc3QnLFxuICBbU1RBVFVTX0NPREUuT1BfVU5TVVBQT1JURURdOiAnT3BlcmF0aW9uIHVuc3VwcG9ydGVkJyxcbn07XG5cbmNvbnN0IFJFUVVFU1QgPSB7XG4gIElOSVQ6IDEsXG4gIE9QRU46IDMsXG4gIENMT1NFOiA0LFxuICBSRUFEOiA1LFxuICBXUklURTogNixcbiAgTFNUQVQ6IDcsXG4gIEZTVEFUOiA4LFxuICBTRVRTVEFUOiA5LFxuICBGU0VUU1RBVDogMTAsXG4gIE9QRU5ESVI6IDExLFxuICBSRUFERElSOiAxMixcbiAgUkVNT1ZFOiAxMyxcbiAgTUtESVI6IDE0LFxuICBSTURJUjogMTUsXG4gIFJFQUxQQVRIOiAxNixcbiAgU1RBVDogMTcsXG4gIFJFTkFNRTogMTgsXG4gIFJFQURMSU5LOiAxOSxcbiAgU1lNTElOSzogMjAsXG4gIEVYVEVOREVEOiAyMDBcbn07XG5cbmNvbnN0IFJFU1BPTlNFID0ge1xuICBWRVJTSU9OOiAyLFxuICBTVEFUVVM6IDEwMSxcbiAgSEFORExFOiAxMDIsXG4gIERBVEE6IDEwMyxcbiAgTkFNRTogMTA0LFxuICBBVFRSUzogMTA1LFxuICBFWFRFTkRFRDogMjAxXG59O1xuXG5jb25zdCBPUEVOX01PREUgPSB7XG4gIFJFQUQ6IDB4MDAwMDAwMDEsXG4gIFdSSVRFOiAweDAwMDAwMDAyLFxuICBBUFBFTkQ6IDB4MDAwMDAwMDQsXG4gIENSRUFUOiAweDAwMDAwMDA4LFxuICBUUlVOQzogMHgwMDAwMDAxMCxcbiAgRVhDTDogMHgwMDAwMDAyMFxufTtcblxuY29uc3QgUEtUX1JXX09WRVJIRUFEID0gMiAqIDEwMjQ7XG5jb25zdCBNQVhfUkVRSUQgPSAyICoqIDMyIC0gMTtcbmNvbnN0IENMSUVOVF9WRVJTSU9OX0JVRkZFUiA9IEJ1ZmZlci5mcm9tKFtcbiAgMCwgMCwgMCwgNSAvKiBsZW5ndGggKi8sXG4gICAgUkVRVUVTVC5JTklULFxuICAgIDAsIDAsIDAsIDMgLyogdmVyc2lvbiAqL1xuXSk7XG5jb25zdCBTRVJWRVJfVkVSU0lPTl9CVUZGRVIgPSBCdWZmZXIuZnJvbShbXG4gIDAsIDAsIDAsIDUgLyogbGVuZ3RoICovLFxuICAgIFJFU1BPTlNFLlZFUlNJT04sXG4gICAgMCwgMCwgMCwgMyAvKiB2ZXJzaW9uICovXG5dKTtcblxuY29uc3QgUkVfT1BFTlNTSCA9IC9eU1NILTIuMC0oPzpPcGVuU1NIfGRyb3BiZWFyKS87XG5jb25zdCBPUEVOU1NIX01BWF9QS1RfTEVOID0gMjU2ICogMTAyNDtcblxuY29uc3QgYnVmZmVyUGFyc2VyID0gbWFrZUJ1ZmZlclBhcnNlcigpO1xuXG5jb25zdCBmYWtlU3RkZXJyID0ge1xuICByZWFkYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgcHVzaDogKGRhdGEpID0+IHt9LFxuICBvbmNlOiAoKSA9PiB7fSxcbiAgb246ICgpID0+IHt9LFxuICBlbWl0OiAoKSA9PiB7fSxcbiAgZW5kOiAoKSA9PiB7fSxcbn07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vLyBFbXVsYXRlcyBlbm91Z2ggb2YgYENoYW5uZWxgIHRvIGJlIGFibGUgdG8gYmUgdXNlZCBhcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnRcbi8vIGluIG9yZGVyIHRvIHByb2Nlc3MgaW5jb21pbmcgZGF0YSB3aXRoIGFzIGxpdHRsZSBvdmVyaGVhZCBhcyBwb3NzaWJsZVxuY2xhc3MgU0ZUUCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgY2hhbkluZm8sIGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAodHlwZW9mIGNmZyAhPT0gJ29iamVjdCcgfHwgIWNmZylcbiAgICAgIGNmZyA9IHt9O1xuXG4gICAgY29uc3QgcmVtb3RlSWRlbnRSYXcgPSBjbGllbnQuX3Byb3RvY29sLl9yZW1vdGVJZGVudFJhdztcblxuICAgIHRoaXMuc2VydmVyID0gISFjZmcuc2VydmVyO1xuICAgIHRoaXMuX2RlYnVnID0gKHR5cGVvZiBjZmcuZGVidWcgPT09ICdmdW5jdGlvbicgPyBjZmcuZGVidWcgOiB1bmRlZmluZWQpO1xuICAgIHRoaXMuX2lzT3BlblNTSCA9IChyZW1vdGVJZGVudFJhdyAmJiBSRV9PUEVOU1NILnRlc3QocmVtb3RlSWRlbnRSYXcpKTtcblxuICAgIHRoaXMuX3ZlcnNpb24gPSAtMTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fYmlPcHQgPSBjZmcuYmlPcHQ7XG4gICAgdGhpcy5fcGt0TGVuQnl0ZXMgPSAwO1xuICAgIHRoaXMuX3BrdExlbiA9IDA7XG4gICAgdGhpcy5fcGt0UG9zID0gMDtcbiAgICB0aGlzLl9wa3RUeXBlID0gMDtcbiAgICB0aGlzLl9wa3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3dyaXRlUmVxaWQgPSAtMTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IHt9O1xuICAgIHRoaXMuX21heEluUGt0TGVuID0gT1BFTlNTSF9NQVhfUEtUX0xFTjtcbiAgICB0aGlzLl9tYXhPdXRQa3RMZW4gPSAzNDAwMDtcbiAgICB0aGlzLl9tYXhSZWFkTGVuID1cbiAgICAgICh0aGlzLl9pc09wZW5TU0ggPyBPUEVOU1NIX01BWF9QS1RfTEVOIDogMzQwMDApIC0gUEtUX1JXX09WRVJIRUFEO1xuICAgIHRoaXMuX21heFdyaXRlTGVuID1cbiAgICAgICh0aGlzLl9pc09wZW5TU0ggPyBPUEVOU1NIX01BWF9QS1RfTEVOIDogMzQwMDApIC0gUEtUX1JXX09WRVJIRUFEO1xuXG4gICAgdGhpcy5tYXhPcGVuSGFuZGxlcyA9IHVuZGVmaW5lZDtcblxuICAgIC8vIENoYW5uZWwgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLl9wcm90b2NvbCA9IGNsaWVudC5fcHJvdG9jb2w7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5faGFzWDExID0gZmFsc2U7XG4gICAgdGhpcy5fZXhpdCA9IHtcbiAgICAgIGNvZGU6IHVuZGVmaW5lZCxcbiAgICAgIHNpZ25hbDogdW5kZWZpbmVkLFxuICAgICAgZHVtcDogdW5kZWZpbmVkLFxuICAgICAgZGVzYzogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgdGhpcy5fd2FpdFdpbmRvdyA9IGZhbHNlOyAvLyBTU0gtbGV2ZWwgYmFja3ByZXNzdXJlXG4gICAgdGhpcy5fY2h1bmtjYiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9idWZmZXIgPSBbXTtcbiAgICB0aGlzLnR5cGUgPSBjaGFuSW5mby50eXBlO1xuICAgIHRoaXMuc3VidHlwZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluY29taW5nID0gY2hhbkluZm8uaW5jb21pbmc7XG4gICAgdGhpcy5vdXRnb2luZyA9IGNoYW5JbmZvLm91dGdvaW5nO1xuICAgIHRoaXMuc3RkZXJyID0gZmFrZVN0ZGVycjtcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBpbmNvbWluZyBkYXRhIHRvIHBhcnNlXG4gIHB1c2goZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICBjbGVhbnVwUmVxdWVzdHModGhpcyk7XG4gICAgICBpZiAoIXRoaXMucmVhZGFibGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIC8vIE5vIG1vcmUgaW5jb21pbmcgZGF0YSBmcm9tIHRoZSByZW1vdGUgc2lkZVxuICAgICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLypcbiAgICAgICAgdWludDMyICAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICBieXRlICAgICAgICAgICAgICAgdHlwZVxuICAgICAgICBieXRlW2xlbmd0aCAtIDFdICAgZGF0YSBwYXlsb2FkXG4gICAgKi9cbiAgICBsZXQgcCA9IDA7XG5cbiAgICB3aGlsZSAocCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fcGt0TGVuQnl0ZXMgPCA0KSB7XG4gICAgICAgIGxldCBuYiA9IE1hdGgubWluKDQgLSB0aGlzLl9wa3RMZW5CeXRlcywgZGF0YS5sZW5ndGggLSBwKTtcbiAgICAgICAgdGhpcy5fcGt0TGVuQnl0ZXMgKz0gbmI7XG5cbiAgICAgICAgd2hpbGUgKG5iLS0pXG4gICAgICAgICAgdGhpcy5fcGt0TGVuID0gKHRoaXMuX3BrdExlbiA8PCA4KSArIGRhdGFbcCsrXTtcblxuICAgICAgICBpZiAodGhpcy5fcGt0TGVuQnl0ZXMgPCA0KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX3BrdExlbiA9PT0gMClcbiAgICAgICAgICByZXR1cm4gZG9GYXRhbFNGVFBFcnJvcih0aGlzLCAnSW52YWxpZCBwYWNrZXQgbGVuZ3RoJyk7XG4gICAgICAgIGlmICh0aGlzLl9wa3RMZW4gPiB0aGlzLl9tYXhJblBrdExlbikge1xuICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMuX21heEluUGt0TGVuO1xuICAgICAgICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGBQYWNrZXQgbGVuZ3RoICR7dGhpcy5fcGt0TGVufSBleGNlZWRzIG1heCBsZW5ndGggb2YgJHttYXh9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgPj0gZGF0YS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BrdFBvcyA8IHRoaXMuX3BrdExlbikge1xuICAgICAgICBjb25zdCBuYiA9IE1hdGgubWluKHRoaXMuX3BrdExlbiAtIHRoaXMuX3BrdFBvcywgZGF0YS5sZW5ndGggLSBwKTtcbiAgICAgICAgaWYgKHAgIT09IDAgfHwgbmIgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG5iID09PSB0aGlzLl9wa3RMZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3BrdCA9IG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQgKyBwLCBuYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGt0KVxuICAgICAgICAgICAgICB0aGlzLl9wa3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fcGt0TGVuKTtcbiAgICAgICAgICAgIHRoaXMuX3BrdC5zZXQoXG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQgKyBwLCBuYiksXG4gICAgICAgICAgICAgIHRoaXMuX3BrdFBvc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmIgPT09IHRoaXMuX3BrdExlbikge1xuICAgICAgICAgIHRoaXMuX3BrdCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9wa3QpXG4gICAgICAgICAgICB0aGlzLl9wa3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fcGt0TGVuKTtcbiAgICAgICAgICB0aGlzLl9wa3Quc2V0KGRhdGEsIHRoaXMuX3BrdFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcCArPSBuYjtcbiAgICAgICAgdGhpcy5fcGt0UG9zICs9IG5iO1xuICAgICAgICBpZiAodGhpcy5fcGt0UG9zIDwgdGhpcy5fcGt0TGVuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHlwZSA9IHRoaXMuX3BrdFswXTtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLl9wa3Q7XG5cbiAgICAgIC8vIFByZXBhcmUgZm9yIG5leHQgcGFja2V0XG4gICAgICB0aGlzLl9wa3RMZW4gPSAwO1xuICAgICAgdGhpcy5fcGt0TGVuQnl0ZXMgPSAwO1xuICAgICAgdGhpcy5fcGt0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fcGt0UG9zID0gMDtcblxuICAgICAgY29uc3QgaGFuZGxlciA9ICh0aGlzLnNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICA/IFNFUlZFUl9IQU5ETEVSU1t0eXBlXVxuICAgICAgICAgICAgICAgICAgICAgICA6IENMSUVOVF9IQU5ETEVSU1t0eXBlXSk7XG4gICAgICBpZiAoIWhhbmRsZXIpXG4gICAgICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKHRoaXMsIGBVbmtub3duIHBhY2tldCB0eXBlICR7dHlwZX1gKTtcblxuICAgICAgaWYgKHRoaXMuX3ZlcnNpb24gPT09IC0xKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlcikge1xuICAgICAgICAgIGlmICh0eXBlICE9PSBSRVFVRVNULklOSVQpXG4gICAgICAgICAgICByZXR1cm4gZG9GYXRhbFNGVFBFcnJvcih0aGlzLCBgRXhwZWN0ZWQgSU5JVCBwYWNrZXQsIGdvdCAke3R5cGV9YCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gUkVTUE9OU0UuVkVSU0lPTikge1xuICAgICAgICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKHRoaXMsIGBFeHBlY3RlZCBWRVJTSU9OIHBhY2tldCwgZ290ICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFuZGxlcih0aGlzLCBwYXlsb2FkKSA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBlbmQoKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5vdXRnb2luZy5zdGF0ZSA9PT0gJ29wZW4nIHx8IHRoaXMub3V0Z29pbmcuc3RhdGUgPT09ICdlb2YnKSB7XG4gICAgICB0aGlzLm91dGdvaW5nLnN0YXRlID0gJ2Nsb3NpbmcnO1xuICAgICAgdGhpcy5fcHJvdG9jb2wuY2hhbm5lbENsb3NlKHRoaXMub3V0Z29pbmcuaWQpO1xuICAgIH1cbiAgfVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9pbml0ID0gbm9vcDtcbiAgICBpZiAoIXRoaXMuc2VydmVyKVxuICAgICAgc2VuZE9yQnVmZmVyKHRoaXMsIENMSUVOVF9WRVJTSU9OX0JVRkZFUik7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ2xpZW50LXNwZWNpZmljID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjcmVhdGVSZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIHJldHVybiBuZXcgUmVhZFN0cmVhbSh0aGlzLCBwYXRoLCBvcHRpb25zKTtcbiAgfVxuICBjcmVhdGVXcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHRoaXMsIHBhdGgsIG9wdGlvbnMpO1xuICB9XG4gIG9wZW4ocGF0aCwgZmxhZ3NfLCBhdHRycywgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXR0cnM7XG4gICAgICBhdHRycyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBmbGFncyA9ICh0eXBlb2YgZmxhZ3NfID09PSAnbnVtYmVyJyA/IGZsYWdzXyA6IHN0cmluZ1RvRmxhZ3MoZmxhZ3NfKSk7XG4gICAgaWYgKGZsYWdzID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZsYWdzIHN0cmluZzogJHtmbGFnc199YCk7XG5cbiAgICBsZXQgYXR0cnNGbGFncyA9IDA7XG4gICAgbGV0IGF0dHJzTGVuID0gMDtcbiAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXR0cnMgPT09ICdudW1iZXInKVxuICAgICAgYXR0cnMgPSB7IG1vZGU6IGF0dHJzIH07XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ29iamVjdCcgJiYgYXR0cnMgIT09IG51bGwpIHtcbiAgICAgIGF0dHJzID0gYXR0cnNUb0J5dGVzKGF0dHJzKTtcbiAgICAgIGF0dHJzRmxhZ3MgPSBhdHRycy5mbGFncztcbiAgICAgIGF0dHJzTGVuID0gYXR0cnMubmI7XG4gICAgfVxuXG4gICAgLypcbiAgICAgIHVpbnQzMiAgICAgICAgaWRcbiAgICAgIHN0cmluZyAgICAgICAgZmlsZW5hbWVcbiAgICAgIHVpbnQzMiAgICAgICAgcGZsYWdzXG4gICAgICBBVFRSUyAgICAgICAgIGF0dHJzXG4gICAgKi9cbiAgICBjb25zdCBwYXRoTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgocGF0aCk7XG4gICAgbGV0IHAgPSA5O1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgMSArIDQgKyA0ICsgcGF0aExlbiArIDQgKyA0ICsgYXR0cnNMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCAwKTtcbiAgICBidWZbNF0gPSBSRVFVRVNULk9QRU47XG4gICAgY29uc3QgcmVxaWQgPSB0aGlzLl93cml0ZVJlcWlkID0gKHRoaXMuX3dyaXRlUmVxaWQgKyAxKSAmIE1BWF9SRVFJRDtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcmVxaWQsIDUpO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIHBhdGhMZW4sIHApO1xuICAgIGJ1Zi51dGY4V3JpdGUocGF0aCwgcCArPSA0LCBwYXRoTGVuKTtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgZmxhZ3MsIHAgKz0gcGF0aExlbik7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIGF0dHJzRmxhZ3MsIHAgKz0gNCk7XG4gICAgaWYgKGF0dHJzTGVuKSB7XG4gICAgICBwICs9IDQ7XG5cbiAgICAgIGlmIChhdHRyc0xlbiA9PT0gQVRUUlNfQlVGLmxlbmd0aClcbiAgICAgICAgYnVmLnNldChBVFRSU19CVUYsIHApO1xuICAgICAgZWxzZVxuICAgICAgICBidWZmZXJDb3B5KEFUVFJTX0JVRiwgYnVmLCAwLCBhdHRyc0xlbiwgcCk7XG5cbiAgICAgIHAgKz0gYXR0cnNMZW47XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzW3JlcWlkXSA9IHsgY2IgfTtcblxuICAgIGNvbnN0IGlzQnVmZmVyZWQgPSBzZW5kT3JCdWZmZXIodGhpcywgYnVmKTtcbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhcbiAgICAgIGBTRlRQOiBPdXRib3VuZDogJHtpc0J1ZmZlcmVkID8gJ0J1ZmZlcmVkJyA6ICdTZW5kaW5nJ30gT1BFTmBcbiAgICApO1xuICB9XG4gIGNsb3NlKGhhbmRsZSwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGhhbmRsZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhbmRsZSBpcyBub3QgYSBCdWZmZXInKTtcblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIGhhbmRsZVxuICAgICovXG4gICAgY29uc3QgaGFuZGxlTGVuID0gaGFuZGxlLmxlbmd0aDtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBoYW5kbGVMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCAwKTtcbiAgICBidWZbNF0gPSBSRVFVRVNULkNMT1NFO1xuICAgIGNvbnN0IHJlcWlkID0gdGhpcy5fd3JpdGVSZXFpZCA9ICh0aGlzLl93cml0ZVJlcWlkICsgMSkgJiBNQVhfUkVRSUQ7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIHJlcWlkLCA1KTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBoYW5kbGVMZW4sIHApO1xuICAgIGJ1Zi5zZXQoaGFuZGxlLCBwICs9IDQpO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0geyBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYFNGVFA6IE91dGJvdW5kOiAke2lzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnfSBDTE9TRWBcbiAgICApO1xuICB9XG4gIHJlYWQoaGFuZGxlLCBidWYsIG9mZiwgbGVuLCBwb3NpdGlvbiwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihoYW5kbGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGUgaXMgbm90IGEgQnVmZmVyJyk7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignYnVmZmVyIGlzIG5vdCBhIEJ1ZmZlcicpO1xuICAgIGlmIChvZmYgPj0gYnVmLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcignb2Zmc2V0IGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICBpZiAob2ZmICsgbGVuID4gYnVmLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIGV4dGVuZHMgYmV5b25kIGJ1ZmZlcicpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcignbnVsbCBwb3NpdGlvbiBjdXJyZW50bHkgdW5zdXBwb3J0ZWQnKTtcblxuICAgIHJlYWRfKHRoaXMsIGhhbmRsZSwgYnVmLCBvZmYsIGxlbiwgcG9zaXRpb24sIGNiKTtcbiAgfVxuICByZWFkRGF0YShoYW5kbGUsIGJ1Ziwgb2ZmLCBsZW4sIHBvc2l0aW9uLCBjYikge1xuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5yZWFkKGhhbmRsZSwgYnVmLCBvZmYsIGxlbiwgcG9zaXRpb24sIGNiKTtcbiAgfVxuICB3cml0ZShoYW5kbGUsIGJ1Ziwgb2ZmLCBsZW4sIHBvc2l0aW9uLCBjYikge1xuICAgIGlmICh0aGlzLnNlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaGFuZGxlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlIGlzIG5vdCBhIEJ1ZmZlcicpO1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2J1ZmZlciBpcyBub3QgYSBCdWZmZXInKTtcbiAgICBpZiAob2ZmID4gYnVmLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcignb2Zmc2V0IGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICBpZiAob2ZmICsgbGVuID4gYnVmLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIGV4dGVuZHMgYmV5b25kIGJ1ZmZlcicpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcignbnVsbCBwb3NpdGlvbiBjdXJyZW50bHkgdW5zdXBwb3J0ZWQnKTtcblxuICAgIGlmICghbGVuKSB7XG4gICAgICBjYiAmJiBwcm9jZXNzLm5leHRUaWNrKGNiLCB1bmRlZmluZWQsIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1heERhdGFMZW4gPSB0aGlzLl9tYXhXcml0ZUxlbjtcbiAgICBjb25zdCBvdmVyZmxvdyA9IE1hdGgubWF4KGxlbiAtIG1heERhdGFMZW4sIDApO1xuICAgIGNvbnN0IG9yaWdQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXG4gICAgaWYgKG92ZXJmbG93KVxuICAgICAgbGVuID0gbWF4RGF0YUxlbjtcblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIGhhbmRsZVxuICAgICAgdWludDY0ICAgICBvZmZzZXRcbiAgICAgIHN0cmluZyAgICAgZGF0YVxuICAgICovXG4gICAgY29uc3QgaGFuZGxlTGVuID0gaGFuZGxlLmxlbmd0aDtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3Qgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBoYW5kbGVMZW4gKyA4ICsgNCArIGxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKG91dCwgb3V0Lmxlbmd0aCAtIDQsIDApO1xuICAgIG91dFs0XSA9IFJFUVVFU1QuV1JJVEU7XG4gICAgY29uc3QgcmVxaWQgPSB0aGlzLl93cml0ZVJlcWlkID0gKHRoaXMuX3dyaXRlUmVxaWQgKyAxKSAmIE1BWF9SRVFJRDtcbiAgICB3cml0ZVVJbnQzMkJFKG91dCwgcmVxaWQsIDUpO1xuXG4gICAgd3JpdGVVSW50MzJCRShvdXQsIGhhbmRsZUxlbiwgcCk7XG4gICAgb3V0LnNldChoYW5kbGUsIHAgKz0gNCk7XG4gICAgcCArPSBoYW5kbGVMZW47XG4gICAgZm9yIChsZXQgaSA9IDc7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBvdXRbcCArIGldID0gcG9zaXRpb24gJiAweEZGO1xuICAgICAgcG9zaXRpb24gLz0gMjU2O1xuICAgIH1cbiAgICB3cml0ZVVJbnQzMkJFKG91dCwgbGVuLCBwICs9IDgpO1xuICAgIGJ1ZmZlckNvcHkoYnVmLCBvdXQsIG9mZiwgb2ZmICsgbGVuLCBwICs9IDQpO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0ge1xuICAgICAgY2I6IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJmbG93KSB7XG4gICAgICAgICAgdGhpcy53cml0ZShoYW5kbGUsXG4gICAgICAgICAgICAgICAgICAgICBidWYsXG4gICAgICAgICAgICAgICAgICAgICBvZmYgKyBsZW4sXG4gICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgIG9yaWdQb3NpdGlvbiArIGxlbixcbiAgICAgICAgICAgICAgICAgICAgIGNiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYih1bmRlZmluZWQsIG9mZiArIGxlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaXNTZW50ID0gc2VuZE9yQnVmZmVyKHRoaXMsIG91dCk7XG4gICAgaWYgKHRoaXMuX2RlYnVnKSB7XG4gICAgICBjb25zdCBob3cgPSAoaXNTZW50ID8gJ1NlbnQnIDogJ0J1ZmZlcmVkJyk7XG4gICAgICB0aGlzLl9kZWJ1ZyhgU0ZUUDogT3V0Ym91bmQ6ICR7aG93fSBXUklURSAoaWQ6JHtyZXFpZH0pYCk7XG4gICAgfVxuICB9XG4gIHdyaXRlRGF0YShoYW5kbGUsIGJ1Ziwgb2ZmLCBsZW4sIHBvc2l0aW9uLCBjYikge1xuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy53cml0ZShoYW5kbGUsIGJ1Ziwgb2ZmLCBsZW4sIHBvc2l0aW9uLCBjYik7XG4gIH1cbiAgZmFzdEdldChyZW1vdGVQYXRoLCBsb2NhbFBhdGgsIG9wdHMsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBmYXN0WGZlcih0aGlzLCBmcywgcmVtb3RlUGF0aCwgbG9jYWxQYXRoLCBvcHRzLCBjYik7XG4gIH1cbiAgZmFzdFB1dChsb2NhbFBhdGgsIHJlbW90ZVBhdGgsIG9wdHMsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBmYXN0WGZlcihmcywgdGhpcywgbG9jYWxQYXRoLCByZW1vdGVQYXRoLCBvcHRzLCBjYik7XG4gIH1cbiAgcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgY2FsbGJhY2tfKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBsZXQgY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFja18gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2tfO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJylcbiAgICAgIG9wdGlvbnMgPSB7IGVuY29kaW5nOiBvcHRpb25zLCBmbGFnOiAncicgfTtcbiAgICBlbHNlIGlmICghb3B0aW9ucylcbiAgICAgIG9wdGlvbnMgPSB7IGVuY29kaW5nOiBudWxsLCBmbGFnOiAncicgfTtcbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgYXJndW1lbnRzJyk7XG5cbiAgICBjb25zdCBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZW5jb2Rpbmc6ICR7ZW5jb2Rpbmd9YCk7XG5cbiAgICAvLyBGaXJzdCBzdGF0IHRoZSBmaWxlLCBzbyB3ZSBrbm93IHRoZSBzaXplLlxuICAgIGxldCBzaXplO1xuICAgIGxldCBidWZmZXI7IC8vIFNpbmdsZSBidWZmZXIgd2l0aCBmaWxlIGRhdGFcbiAgICBsZXQgYnVmZmVyczsgLy8gTGlzdCBmb3Igd2hlbiBzaXplIGlzIHVua25vd25cbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgaGFuZGxlO1xuXG4gICAgLy8gU0ZUUHYzIGRvZXMgbm90IHN1cHBvcnQgdXNpbmcgLTEgZm9yIHJlYWQgcG9zaXRpb24sIHNvIHdlIGhhdmUgdG8gdHJhY2tcbiAgICAvLyByZWFkIHBvc2l0aW9uIG1hbnVhbGx5XG4gICAgbGV0IGJ5dGVzUmVhZCA9IDA7XG5cbiAgICBjb25zdCBmbGFnID0gb3B0aW9ucy5mbGFnIHx8ICdyJztcblxuICAgIGNvbnN0IHJlYWQgPSAoKSA9PiB7XG4gICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoODE5Mik7XG4gICAgICAgIHRoaXMucmVhZChoYW5kbGUsIGJ1ZmZlciwgMCwgODE5MiwgYnl0ZXNSZWFkLCBhZnRlclJlYWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkKGhhbmRsZSwgYnVmZmVyLCBwb3MsIHNpemUgLSBwb3MsIGJ5dGVzUmVhZCwgYWZ0ZXJSZWFkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYWZ0ZXJSZWFkID0gKGVyLCBuYnl0ZXMpID0+IHtcbiAgICAgIGxldCBlb2Y7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgZW9mID0gKGVyLmNvZGUgPT09IFNUQVRVU19DT0RFLkVPRik7XG4gICAgICAgIGlmICghZW9mKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoaGFuZGxlLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlb2YgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVvZiB8fCAoc2l6ZSA9PT0gMCAmJiBuYnl0ZXMgPT09IDApKVxuICAgICAgICByZXR1cm4gY2xvc2UoKTtcblxuICAgICAgYnl0ZXNSZWFkICs9IG5ieXRlcztcbiAgICAgIHBvcyArPSBuYnl0ZXM7XG4gICAgICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgICAgICBpZiAocG9zID09PSBzaXplKVxuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZWFkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVbmtub3duIHNpemUsIGp1c3QgcmVhZCB1bnRpbCB3ZSBkb24ndCBnZXQgYnl0ZXMuXG4gICAgICAgIGJ1ZmZlcnMucHVzaChidWZmZXJTbGljZShidWZmZXIsIDAsIG5ieXRlcykpO1xuICAgICAgICByZWFkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBhZnRlclJlYWQuX3dhbnRFT0ZFcnJvciA9IHRydWU7XG5cbiAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2UoaGFuZGxlLCAoZXIpID0+IHtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICAvLyBDb2xsZWN0IHRoZSBkYXRhIGludG8gdGhlIGJ1ZmZlcnMgbGlzdC5cbiAgICAgICAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIHBvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zIDwgc2l6ZSkge1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlclNsaWNlKGJ1ZmZlciwgMCwgcG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmNvZGluZylcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soZXIsIGJ1ZmZlcik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5vcGVuKHBhdGgsIGZsYWcsIDBvNjY2LCAoZXIsIGhhbmRsZV8pID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVyKTtcbiAgICAgIGhhbmRsZSA9IGhhbmRsZV87XG5cbiAgICAgIGNvbnN0IHRyeVN0YXQgPSAoZXIsIHN0KSA9PiB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgIC8vIFRyeSBzdGF0KCkgZm9yIHNmdHAgc2VydmVycyB0aGF0IG1heSBub3Qgc3VwcG9ydCBmc3RhdCgpIGZvclxuICAgICAgICAgIC8vIHdoYXRldmVyIHJlYXNvblxuICAgICAgICAgIHRoaXMuc3RhdChwYXRoLCAoZXJfLCBzdF8pID0+IHtcbiAgICAgICAgICAgIGlmIChlcl8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoaGFuZGxlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZXIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeVN0YXQobnVsbCwgc3RfKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzaXplID0gc3Quc2l6ZSB8fCAwO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIFRoZSBrZXJuZWwgbGllcyBhYm91dCBtYW55IGZpbGVzLlxuICAgICAgICAgIC8vIEdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIGJ5dGVzLlxuICAgICAgICAgIGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICByZXR1cm4gcmVhZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpO1xuICAgICAgICByZWFkKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5mc3RhdChoYW5kbGUsIHRyeVN0YXQpO1xuICAgIH0pO1xuICB9XG4gIHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFja18pIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGxldCBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja187XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKVxuICAgICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMsIG1vZGU6IDBvNjY2LCBmbGFnOiAndycgfTtcbiAgICBlbHNlIGlmICghb3B0aW9ucylcbiAgICAgIG9wdGlvbnMgPSB7IGVuY29kaW5nOiAndXRmOCcsIG1vZGU6IDBvNjY2LCBmbGFnOiAndycgfTtcbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgYXJndW1lbnRzJyk7XG5cbiAgICBpZiAob3B0aW9ucy5lbmNvZGluZyAmJiAhQnVmZmVyLmlzRW5jb2Rpbmcob3B0aW9ucy5lbmNvZGluZykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZW5jb2Rpbmc6ICR7b3B0aW9ucy5lbmNvZGluZ31gKTtcblxuICAgIGNvbnN0IGZsYWcgPSBvcHRpb25zLmZsYWcgfHwgJ3cnO1xuICAgIHRoaXMub3BlbihwYXRoLCBmbGFnLCBvcHRpb25zLm1vZGUsIChvcGVuRXJyLCBoYW5kbGUpID0+IHtcbiAgICAgIGlmIChvcGVuRXJyKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG9wZW5FcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEJ1ZmZlci5mcm9tKCcnICsgZGF0YSwgb3B0aW9ucy5lbmNvZGluZyB8fCAndXRmOCcpKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSAoL2EvLnRlc3QoZmxhZykgPyBudWxsIDogMCk7XG5cbiAgICAgICAgLy8gU0ZUUHYzIGRvZXMgbm90IHN1cHBvcnQgdGhlIG5vdGlvbiBvZiAnY3VycmVudCBwb3NpdGlvbidcbiAgICAgICAgLy8gKG51bGwgcG9zaXRpb24pLCBzbyB3ZSBqdXN0IGF0dGVtcHQgdG8gYXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGZpbGVcbiAgICAgICAgLy8gaW5zdGVhZFxuICAgICAgICBpZiAocG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB0cnlTdGF0ID0gKGVyLCBzdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgIC8vIFRyeSBzdGF0KCkgZm9yIHNmdHAgc2VydmVycyB0aGF0IG1heSBub3Qgc3VwcG9ydCBmc3RhdCgpIGZvclxuICAgICAgICAgICAgICAvLyB3aGF0ZXZlciByZWFzb25cbiAgICAgICAgICAgICAgdGhpcy5zdGF0KHBhdGgsIChlcl8sIHN0XykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcl8pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKGhhbmRsZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlcik7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5U3RhdChudWxsLCBzdF8pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVBbGwodGhpcywgaGFuZGxlLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIHN0LnNpemUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuZnN0YXQoaGFuZGxlLCB0cnlTdGF0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVBbGwodGhpcywgaGFuZGxlLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFja18pIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGxldCBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja187XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKVxuICAgICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMsIG1vZGU6IDBvNjY2LCBmbGFnOiAnYScgfTtcbiAgICBlbHNlIGlmICghb3B0aW9ucylcbiAgICAgIG9wdGlvbnMgPSB7IGVuY29kaW5nOiAndXRmOCcsIG1vZGU6IDBvNjY2LCBmbGFnOiAnYScgfTtcbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgYXJndW1lbnRzJyk7XG5cbiAgICBpZiAoIW9wdGlvbnMuZmxhZylcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZmxhZzogJ2EnIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMud3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICBleGlzdHMocGF0aCwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIHRoaXMuc3RhdChwYXRoLCAoZXJyKSA9PiB7XG4gICAgICBjYiAmJiBjYihlcnIgPyBmYWxzZSA6IHRydWUpO1xuICAgIH0pO1xuICB9XG4gIHVubGluayhmaWxlbmFtZSwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIGZpbGVuYW1lXG4gICAgKi9cbiAgICBjb25zdCBmbmFtZUxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGZpbGVuYW1lKTtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBmbmFtZUxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgYnVmLmxlbmd0aCAtIDQsIDApO1xuICAgIGJ1Zls0XSA9IFJFUVVFU1QuUkVNT1ZFO1xuICAgIGNvbnN0IHJlcWlkID0gdGhpcy5fd3JpdGVSZXFpZCA9ICh0aGlzLl93cml0ZVJlcWlkICsgMSkgJiBNQVhfUkVRSUQ7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIHJlcWlkLCA1KTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBmbmFtZUxlbiwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZShmaWxlbmFtZSwgcCArPSA0LCBmbmFtZUxlbik7XG5cbiAgICB0aGlzLl9yZXF1ZXN0c1tyZXFpZF0gPSB7IGNiIH07XG5cbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gc2VuZE9yQnVmZmVyKHRoaXMsIGJ1Zik7XG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgU0ZUUDogT3V0Ym91bmQ6ICR7aXNCdWZmZXJlZCA/ICdCdWZmZXJlZCcgOiAnU2VuZGluZyd9IFJFTU9WRWBcbiAgICApO1xuICB9XG4gIHJlbmFtZShvbGRQYXRoLCBuZXdQYXRoLCBjYikge1xuICAgIGlmICh0aGlzLnNlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgLypcbiAgICAgIHVpbnQzMiAgICAgaWRcbiAgICAgIHN0cmluZyAgICAgb2xkcGF0aFxuICAgICAgc3RyaW5nICAgICBuZXdwYXRoXG4gICAgKi9cbiAgICBjb25zdCBvbGRMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChvbGRQYXRoKTtcbiAgICBjb25zdCBuZXdMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChuZXdQYXRoKTtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBvbGRMZW4gKyA0ICsgbmV3TGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVRVUVTVC5SRU5BTUU7XG4gICAgY29uc3QgcmVxaWQgPSB0aGlzLl93cml0ZVJlcWlkID0gKHRoaXMuX3dyaXRlUmVxaWQgKyAxKSAmIE1BWF9SRVFJRDtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcmVxaWQsIDUpO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIG9sZExlbiwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZShvbGRQYXRoLCBwICs9IDQsIG9sZExlbik7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIG5ld0xlbiwgcCArPSBvbGRMZW4pO1xuICAgIGJ1Zi51dGY4V3JpdGUobmV3UGF0aCwgcCArPSA0LCBuZXdMZW4pO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0geyBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYFNGVFA6IE91dGJvdW5kOiAke2lzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnfSBSRU5BTUVgXG4gICAgKTtcbiAgfVxuICBta2RpcihwYXRoLCBhdHRycywgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGxldCBmbGFncyA9IDA7XG4gICAgbGV0IGF0dHJzTGVuID0gMDtcblxuICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXR0cnM7XG4gICAgICBhdHRycyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ29iamVjdCcgJiYgYXR0cnMgIT09IG51bGwpIHtcbiAgICAgIGF0dHJzID0gYXR0cnNUb0J5dGVzKGF0dHJzKTtcbiAgICAgIGZsYWdzID0gYXR0cnMuZmxhZ3M7XG4gICAgICBhdHRyc0xlbiA9IGF0dHJzLm5iO1xuICAgIH1cblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIHBhdGhcbiAgICAgIEFUVFJTICAgICAgYXR0cnNcbiAgICAqL1xuICAgIGNvbnN0IHBhdGhMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXRoKTtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBwYXRoTGVuICsgNCArIGF0dHJzTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVRVUVTVC5NS0RJUjtcbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcGF0aExlbiwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZShwYXRoLCBwICs9IDQsIHBhdGhMZW4pO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCBmbGFncywgcCArPSBwYXRoTGVuKTtcbiAgICBpZiAoYXR0cnNMZW4pIHtcbiAgICAgIHAgKz0gNDtcblxuICAgICAgaWYgKGF0dHJzTGVuID09PSBBVFRSU19CVUYubGVuZ3RoKVxuICAgICAgICBidWYuc2V0KEFUVFJTX0JVRiwgcCk7XG4gICAgICBlbHNlXG4gICAgICAgIGJ1ZmZlckNvcHkoQVRUUlNfQlVGLCBidWYsIDAsIGF0dHJzTGVuLCBwKTtcblxuICAgICAgcCArPSBhdHRyc0xlbjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0c1tyZXFpZF0gPSB7IGNiIH07XG5cbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gc2VuZE9yQnVmZmVyKHRoaXMsIGJ1Zik7XG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgU0ZUUDogT3V0Ym91bmQ6ICR7aXNCdWZmZXJlZCA/ICdCdWZmZXJlZCcgOiAnU2VuZGluZyd9IE1LRElSYFxuICAgICk7XG4gIH1cbiAgcm1kaXIocGF0aCwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIHBhdGhcbiAgICAqL1xuICAgIGNvbnN0IHBhdGhMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXRoKTtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBwYXRoTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVRVUVTVC5STURJUjtcbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcGF0aExlbiwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZShwYXRoLCBwICs9IDQsIHBhdGhMZW4pO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0geyBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYFNGVFA6IE91dGJvdW5kOiAke2lzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnfSBSTURJUmBcbiAgICApO1xuICB9XG4gIHJlYWRkaXIod2hlcmUsIG9wdHMsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCBvcHRzID09PSBudWxsKVxuICAgICAgb3B0cyA9IHt9O1xuXG4gICAgY29uc3QgZG9GaWx0ZXIgPSAob3B0cyAmJiBvcHRzLmZ1bGwgPyBmYWxzZSA6IHRydWUpO1xuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIod2hlcmUpICYmIHR5cGVvZiB3aGVyZSAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgZGlyZWN0b3J5IGhhbmRsZSBvciBwYXRoJyk7XG5cbiAgICBpZiAodHlwZW9mIHdoZXJlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgbGV0IGUgPSAwO1xuXG4gICAgICBjb25zdCByZXJlYWQgPSAoZXJyLCBoYW5kbGUpID0+IHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgICB0aGlzLnJlYWRkaXIoaGFuZGxlLCBvcHRzLCAoZXJyLCBsaXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgZW9mID0gKGVyciAmJiBlcnIuY29kZSA9PT0gU1RBVFVTX0NPREUuRU9GKTtcblxuICAgICAgICAgIGlmIChlcnIgJiYgIWVvZilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKGhhbmRsZSwgKCkgPT4gY2IoZXJyKSk7XG5cbiAgICAgICAgICBpZiAoZW9mKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZShoYW5kbGUsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgY2IodW5kZWZpbmVkLCBlbnRyaWVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSwgKytlKVxuICAgICAgICAgICAgZW50cmllc1tlXSA9IGxpc3RbaV07XG5cbiAgICAgICAgICByZXJlYWQodW5kZWZpbmVkLCBoYW5kbGUpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5vcGVuZGlyKHdoZXJlLCByZXJlYWQpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIGhhbmRsZVxuICAgICovXG4gICAgY29uc3QgaGFuZGxlTGVuID0gd2hlcmUubGVuZ3RoO1xuICAgIGxldCBwID0gOTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyA0ICsgNCArIGhhbmRsZUxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgYnVmLmxlbmd0aCAtIDQsIDApO1xuICAgIGJ1Zls0XSA9IFJFUVVFU1QuUkVBRERJUjtcbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgaGFuZGxlTGVuLCBwKTtcbiAgICBidWYuc2V0KHdoZXJlLCBwICs9IDQpO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0ge1xuICAgICAgY2I6IChkb0ZpbHRlclxuICAgICAgICAgICA/IChlcnIsIGxpc3QpID0+IHtcbiAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuXG4gICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICBpZiAobGlzdFtpXS5maWxlbmFtZSA9PT0gJy4nIHx8IGxpc3RbaV0uZmlsZW5hbWUgPT09ICcuLicpXG4gICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIGNiKHVuZGVmaW5lZCwgbGlzdCk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICA6IGNiKVxuICAgIH07XG5cbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gc2VuZE9yQnVmZmVyKHRoaXMsIGJ1Zik7XG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgU0ZUUDogT3V0Ym91bmQ6ICR7aXNCdWZmZXJlZCA/ICdCdWZmZXJlZCcgOiAnU2VuZGluZyd9IFJFQURESVJgXG4gICAgKTtcbiAgfVxuICBmc3RhdChoYW5kbGUsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihoYW5kbGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGUgaXMgbm90IGEgQnVmZmVyJyk7XG5cbiAgICAvKlxuICAgICAgdWludDMyICAgICBpZFxuICAgICAgc3RyaW5nICAgICBoYW5kbGVcbiAgICAqL1xuICAgIGNvbnN0IGhhbmRsZUxlbiA9IGhhbmRsZS5sZW5ndGg7XG4gICAgbGV0IHAgPSA5O1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgMSArIDQgKyA0ICsgaGFuZGxlTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVRVUVTVC5GU1RBVDtcbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgaGFuZGxlTGVuLCBwKTtcbiAgICBidWYuc2V0KGhhbmRsZSwgcCArPSA0KTtcblxuICAgIHRoaXMuX3JlcXVlc3RzW3JlcWlkXSA9IHsgY2IgfTtcblxuICAgIGNvbnN0IGlzQnVmZmVyZWQgPSBzZW5kT3JCdWZmZXIodGhpcywgYnVmKTtcbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhcbiAgICAgIGBTRlRQOiBPdXRib3VuZDogJHtpc0J1ZmZlcmVkID8gJ0J1ZmZlcmVkJyA6ICdTZW5kaW5nJ30gRlNUQVRgXG4gICAgKTtcbiAgfVxuICBzdGF0KHBhdGgsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICAvKlxuICAgICAgdWludDMyICAgICBpZFxuICAgICAgc3RyaW5nICAgICBwYXRoXG4gICAgKi9cbiAgICBjb25zdCBwYXRoTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgocGF0aCk7XG4gICAgbGV0IHAgPSA5O1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgMSArIDQgKyA0ICsgcGF0aExlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgYnVmLmxlbmd0aCAtIDQsIDApO1xuICAgIGJ1Zls0XSA9IFJFUVVFU1QuU1RBVDtcbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcGF0aExlbiwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZShwYXRoLCBwICs9IDQsIHBhdGhMZW4pO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0geyBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYFNGVFA6IE91dGJvdW5kOiAke2lzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnfSBTVEFUYFxuICAgICk7XG4gIH1cbiAgbHN0YXQocGF0aCwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIHBhdGhcbiAgICAqL1xuICAgIGNvbnN0IHBhdGhMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXRoKTtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBwYXRoTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVRVUVTVC5MU1RBVDtcbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcGF0aExlbiwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZShwYXRoLCBwICs9IDQsIHBhdGhMZW4pO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0geyBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYFNGVFA6IE91dGJvdW5kOiAke2lzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnfSBMU1RBVGBcbiAgICApO1xuICB9XG4gIG9wZW5kaXIocGF0aCwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIHBhdGhcbiAgICAqL1xuICAgIGNvbnN0IHBhdGhMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXRoKTtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBwYXRoTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVRVUVTVC5PUEVORElSO1xuICAgIGNvbnN0IHJlcWlkID0gdGhpcy5fd3JpdGVSZXFpZCA9ICh0aGlzLl93cml0ZVJlcWlkICsgMSkgJiBNQVhfUkVRSUQ7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIHJlcWlkLCA1KTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBwYXRoTGVuLCBwKTtcbiAgICBidWYudXRmOFdyaXRlKHBhdGgsIHAgKz0gNCwgcGF0aExlbik7XG5cbiAgICB0aGlzLl9yZXF1ZXN0c1tyZXFpZF0gPSB7IGNiIH07XG5cbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gc2VuZE9yQnVmZmVyKHRoaXMsIGJ1Zik7XG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgU0ZUUDogT3V0Ym91bmQ6ICR7aXNCdWZmZXJlZCA/ICdCdWZmZXJlZCcgOiAnU2VuZGluZyd9IE9QRU5ESVJgXG4gICAgKTtcbiAgfVxuICBzZXRzdGF0KHBhdGgsIGF0dHJzLCBjYikge1xuICAgIGlmICh0aGlzLnNlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgbGV0IGZsYWdzID0gMDtcbiAgICBsZXQgYXR0cnNMZW4gPSAwO1xuXG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ29iamVjdCcgJiYgYXR0cnMgIT09IG51bGwpIHtcbiAgICAgIGF0dHJzID0gYXR0cnNUb0J5dGVzKGF0dHJzKTtcbiAgICAgIGZsYWdzID0gYXR0cnMuZmxhZ3M7XG4gICAgICBhdHRyc0xlbiA9IGF0dHJzLm5iO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGF0dHJzO1xuICAgIH1cblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIHBhdGhcbiAgICAgIEFUVFJTICAgICAgYXR0cnNcbiAgICAqL1xuICAgIGNvbnN0IHBhdGhMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXRoKTtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBwYXRoTGVuICsgNCArIGF0dHJzTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVRVUVTVC5TRVRTVEFUO1xuICAgIGNvbnN0IHJlcWlkID0gdGhpcy5fd3JpdGVSZXFpZCA9ICh0aGlzLl93cml0ZVJlcWlkICsgMSkgJiBNQVhfUkVRSUQ7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIHJlcWlkLCA1KTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBwYXRoTGVuLCBwKTtcbiAgICBidWYudXRmOFdyaXRlKHBhdGgsIHAgKz0gNCwgcGF0aExlbik7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIGZsYWdzLCBwICs9IHBhdGhMZW4pO1xuICAgIGlmIChhdHRyc0xlbikge1xuICAgICAgcCArPSA0O1xuXG4gICAgICBpZiAoYXR0cnNMZW4gPT09IEFUVFJTX0JVRi5sZW5ndGgpXG4gICAgICAgIGJ1Zi5zZXQoQVRUUlNfQlVGLCBwKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmZmVyQ29weShBVFRSU19CVUYsIGJ1ZiwgMCwgYXR0cnNMZW4sIHApO1xuXG4gICAgICBwICs9IGF0dHJzTGVuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RzW3JlcWlkXSA9IHsgY2IgfTtcblxuICAgIGNvbnN0IGlzQnVmZmVyZWQgPSBzZW5kT3JCdWZmZXIodGhpcywgYnVmKTtcbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhcbiAgICAgIGBTRlRQOiBPdXRib3VuZDogJHtpc0J1ZmZlcmVkID8gJ0J1ZmZlcmVkJyA6ICdTZW5kaW5nJ30gU0VUU1RBVGBcbiAgICApO1xuICB9XG4gIGZzZXRzdGF0KGhhbmRsZSwgYXR0cnMsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihoYW5kbGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGUgaXMgbm90IGEgQnVmZmVyJyk7XG5cbiAgICBsZXQgZmxhZ3MgPSAwO1xuICAgIGxldCBhdHRyc0xlbiA9IDA7XG5cbiAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnb2JqZWN0JyAmJiBhdHRycyAhPT0gbnVsbCkge1xuICAgICAgYXR0cnMgPSBhdHRyc1RvQnl0ZXMoYXR0cnMpO1xuICAgICAgZmxhZ3MgPSBhdHRycy5mbGFncztcbiAgICAgIGF0dHJzTGVuID0gYXR0cnMubmI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXR0cnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXR0cnM7XG4gICAgfVxuXG4gICAgLypcbiAgICAgIHVpbnQzMiAgICAgaWRcbiAgICAgIHN0cmluZyAgICAgaGFuZGxlXG4gICAgICBBVFRSUyAgICAgIGF0dHJzXG4gICAgKi9cbiAgICBjb25zdCBoYW5kbGVMZW4gPSBoYW5kbGUubGVuZ3RoO1xuICAgIGxldCBwID0gOTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyA0ICsgNCArIGhhbmRsZUxlbiArIDQgKyBhdHRyc0xlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgYnVmLmxlbmd0aCAtIDQsIDApO1xuICAgIGJ1Zls0XSA9IFJFUVVFU1QuRlNFVFNUQVQ7XG4gICAgY29uc3QgcmVxaWQgPSB0aGlzLl93cml0ZVJlcWlkID0gKHRoaXMuX3dyaXRlUmVxaWQgKyAxKSAmIE1BWF9SRVFJRDtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcmVxaWQsIDUpO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGhhbmRsZUxlbiwgcCk7XG4gICAgYnVmLnNldChoYW5kbGUsIHAgKz0gNCk7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIGZsYWdzLCBwICs9IGhhbmRsZUxlbik7XG4gICAgaWYgKGF0dHJzTGVuKSB7XG4gICAgICBwICs9IDQ7XG5cbiAgICAgIGlmIChhdHRyc0xlbiA9PT0gQVRUUlNfQlVGLmxlbmd0aClcbiAgICAgICAgYnVmLnNldChBVFRSU19CVUYsIHApO1xuICAgICAgZWxzZVxuICAgICAgICBidWZmZXJDb3B5KEFUVFJTX0JVRiwgYnVmLCAwLCBhdHRyc0xlbiwgcCk7XG5cbiAgICAgIHAgKz0gYXR0cnNMZW47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0geyBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYFNGVFA6IE91dGJvdW5kOiAke2lzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnfSBGU0VUU1RBVGBcbiAgICApO1xuICB9XG4gIGZ1dGltZXMoaGFuZGxlLCBhdGltZSwgbXRpbWUsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZnNldHN0YXQoaGFuZGxlLCB7XG4gICAgICBhdGltZTogdG9Vbml4VGltZXN0YW1wKGF0aW1lKSxcbiAgICAgIG10aW1lOiB0b1VuaXhUaW1lc3RhbXAobXRpbWUpXG4gICAgfSwgY2IpO1xuICB9XG4gIHV0aW1lcyhwYXRoLCBhdGltZSwgbXRpbWUsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0c3RhdChwYXRoLCB7XG4gICAgICBhdGltZTogdG9Vbml4VGltZXN0YW1wKGF0aW1lKSxcbiAgICAgIG10aW1lOiB0b1VuaXhUaW1lc3RhbXAobXRpbWUpXG4gICAgfSwgY2IpO1xuICB9XG4gIGZjaG93bihoYW5kbGUsIHVpZCwgZ2lkLCBjYikge1xuICAgIHJldHVybiB0aGlzLmZzZXRzdGF0KGhhbmRsZSwge1xuICAgICAgdWlkOiB1aWQsXG4gICAgICBnaWQ6IGdpZFxuICAgIH0sIGNiKTtcbiAgfVxuICBjaG93bihwYXRoLCB1aWQsIGdpZCwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRzdGF0KHBhdGgsIHtcbiAgICAgIHVpZDogdWlkLFxuICAgICAgZ2lkOiBnaWRcbiAgICB9LCBjYik7XG4gIH1cbiAgZmNobW9kKGhhbmRsZSwgbW9kZSwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5mc2V0c3RhdChoYW5kbGUsIHtcbiAgICAgIG1vZGU6IG1vZGVcbiAgICB9LCBjYik7XG4gIH1cbiAgY2htb2QocGF0aCwgbW9kZSwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRzdGF0KHBhdGgsIHtcbiAgICAgIG1vZGU6IG1vZGVcbiAgICB9LCBjYik7XG4gIH1cbiAgcmVhZGxpbmsocGF0aCwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIHBhdGhcbiAgICAqL1xuICAgIGNvbnN0IHBhdGhMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXRoKTtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBwYXRoTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVRVUVTVC5SRUFETElOSztcbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcGF0aExlbiwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZShwYXRoLCBwICs9IDQsIHBhdGhMZW4pO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0ge1xuICAgICAgY2I6IChlcnIsIG5hbWVzKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICBpZiAoIW5hbWVzIHx8ICFuYW1lcy5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignUmVzcG9uc2UgbWlzc2luZyBsaW5rIGluZm8nKSk7XG4gICAgICAgIGNiKHVuZGVmaW5lZCwgbmFtZXNbMF0uZmlsZW5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gc2VuZE9yQnVmZmVyKHRoaXMsIGJ1Zik7XG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgU0ZUUDogT3V0Ym91bmQ6ICR7aXNCdWZmZXJlZCA/ICdCdWZmZXJlZCcgOiAnU2VuZGluZyd9IFJFQURMSU5LYFxuICAgICk7XG4gIH1cbiAgc3ltbGluayh0YXJnZXRQYXRoLCBsaW5rUGF0aCwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIGxpbmtwYXRoXG4gICAgICBzdHJpbmcgICAgIHRhcmdldHBhdGhcbiAgICAqL1xuICAgIGNvbnN0IGxpbmtMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChsaW5rUGF0aCk7XG4gICAgY29uc3QgdGFyZ2V0TGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodGFyZ2V0UGF0aCk7XG4gICAgbGV0IHAgPSA5O1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgMSArIDQgKyA0ICsgbGlua0xlbiArIDQgKyB0YXJnZXRMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCAwKTtcbiAgICBidWZbNF0gPSBSRVFVRVNULlNZTUxJTks7XG4gICAgY29uc3QgcmVxaWQgPSB0aGlzLl93cml0ZVJlcWlkID0gKHRoaXMuX3dyaXRlUmVxaWQgKyAxKSAmIE1BWF9SRVFJRDtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcmVxaWQsIDUpO1xuXG4gICAgaWYgKHRoaXMuX2lzT3BlblNTSCkge1xuICAgICAgLy8gT3BlblNTSCBoYXMgbGlua3BhdGggYW5kIHRhcmdldHBhdGggcG9zaXRpb25zIHN3aXRjaGVkXG4gICAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgdGFyZ2V0TGVuLCBwKTtcbiAgICAgIGJ1Zi51dGY4V3JpdGUodGFyZ2V0UGF0aCwgcCArPSA0LCB0YXJnZXRMZW4pO1xuICAgICAgd3JpdGVVSW50MzJCRShidWYsIGxpbmtMZW4sIHAgKz0gdGFyZ2V0TGVuKTtcbiAgICAgIGJ1Zi51dGY4V3JpdGUobGlua1BhdGgsIHAgKz0gNCwgbGlua0xlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBsaW5rTGVuLCBwKTtcbiAgICAgIGJ1Zi51dGY4V3JpdGUobGlua1BhdGgsIHAgKz0gNCwgbGlua0xlbik7XG4gICAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgdGFyZ2V0TGVuLCBwICs9IGxpbmtMZW4pO1xuICAgICAgYnVmLnV0ZjhXcml0ZSh0YXJnZXRQYXRoLCBwICs9IDQsIHRhcmdldExlbik7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0geyBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYFNGVFA6IE91dGJvdW5kOiAke2lzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnfSBTWU1MSU5LYFxuICAgICk7XG4gIH1cbiAgcmVhbHBhdGgocGF0aCwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGlkXG4gICAgICBzdHJpbmcgICAgIHBhdGhcbiAgICAqL1xuICAgIGNvbnN0IHBhdGhMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXRoKTtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyBwYXRoTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVRVUVTVC5SRUFMUEFUSDtcbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcGF0aExlbiwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZShwYXRoLCBwICs9IDQsIHBhdGhMZW4pO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0ge1xuICAgICAgY2I6IChlcnIsIG5hbWVzKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICBpZiAoIW5hbWVzIHx8ICFuYW1lcy5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignUmVzcG9uc2UgbWlzc2luZyBwYXRoIGluZm8nKSk7XG4gICAgICAgIGNiKHVuZGVmaW5lZCwgbmFtZXNbMF0uZmlsZW5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gc2VuZE9yQnVmZmVyKHRoaXMsIGJ1Zik7XG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgU0ZUUDogT3V0Ym91bmQ6ICR7aXNCdWZmZXJlZCA/ICdCdWZmZXJlZCcgOiAnU2VuZGluZyd9IFJFQUxQQVRIYFxuICAgICk7XG4gIH1cbiAgLy8gZXh0ZW5kZWQgcmVxdWVzdHNcbiAgZXh0X29wZW5zc2hfcmVuYW1lKG9sZFBhdGgsIG5ld1BhdGgsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBjb25zdCBleHQgPSB0aGlzLl9leHRlbnNpb25zWydwb3NpeC1yZW5hbWVAb3BlbnNzaC5jb20nXTtcbiAgICBpZiAoIWV4dCB8fCBleHQgIT09ICcxJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBleHRlbmRlZCByZXF1ZXN0Jyk7XG5cbiAgICAvKlxuICAgICAgdWludDMyICAgIGlkXG4gICAgICBzdHJpbmcgICAgXCJwb3NpeC1yZW5hbWVAb3BlbnNzaC5jb21cIlxuICAgICAgc3RyaW5nICAgIG9sZHBhdGhcbiAgICAgIHN0cmluZyAgICBuZXdwYXRoXG4gICAgKi9cbiAgICBjb25zdCBvbGRMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChvbGRQYXRoKTtcbiAgICBjb25zdCBuZXdMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChuZXdQYXRoKTtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID1cbiAgICAgIEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgMSArIDQgKyA0ICsgMjQgKyA0ICsgb2xkTGVuICsgNCArIG5ld0xlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgYnVmLmxlbmd0aCAtIDQsIDApO1xuICAgIGJ1Zls0XSA9IFJFUVVFU1QuRVhURU5ERUQ7XG4gICAgY29uc3QgcmVxaWQgPSB0aGlzLl93cml0ZVJlcWlkID0gKHRoaXMuX3dyaXRlUmVxaWQgKyAxKSAmIE1BWF9SRVFJRDtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcmVxaWQsIDUpO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIDI0LCBwKTtcbiAgICBidWYudXRmOFdyaXRlKCdwb3NpeC1yZW5hbWVAb3BlbnNzaC5jb20nLCBwICs9IDQsIDI0KTtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1Ziwgb2xkTGVuLCBwICs9IDI0KTtcbiAgICBidWYudXRmOFdyaXRlKG9sZFBhdGgsIHAgKz0gNCwgb2xkTGVuKTtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgbmV3TGVuLCBwICs9IG9sZExlbik7XG4gICAgYnVmLnV0ZjhXcml0ZShuZXdQYXRoLCBwICs9IDQsIG5ld0xlbik7XG5cbiAgICB0aGlzLl9yZXF1ZXN0c1tyZXFpZF0gPSB7IGNiIH07XG5cbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gc2VuZE9yQnVmZmVyKHRoaXMsIGJ1Zik7XG4gICAgaWYgKHRoaXMuX2RlYnVnKSB7XG4gICAgICBjb25zdCB3aGljaCA9IChpc0J1ZmZlcmVkID8gJ0J1ZmZlcmVkJyA6ICdTZW5kaW5nJyk7XG4gICAgICB0aGlzLl9kZWJ1ZyhgU0ZUUDogT3V0Ym91bmQ6ICR7d2hpY2h9IHBvc2l4LXJlbmFtZUBvcGVuc3NoLmNvbWApO1xuICAgIH1cbiAgfVxuICBleHRfb3BlbnNzaF9zdGF0dmZzKHBhdGgsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBjb25zdCBleHQgPSB0aGlzLl9leHRlbnNpb25zWydzdGF0dmZzQG9wZW5zc2guY29tJ107XG4gICAgaWYgKCFleHQgfHwgZXh0ICE9PSAnMicpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHRoaXMgZXh0ZW5kZWQgcmVxdWVzdCcpO1xuXG4gICAgLypcbiAgICAgIHVpbnQzMiAgICBpZFxuICAgICAgc3RyaW5nICAgIFwic3RhdHZmc0BvcGVuc3NoLmNvbVwiXG4gICAgICBzdHJpbmcgICAgcGF0aFxuICAgICovXG4gICAgY29uc3QgcGF0aExlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHBhdGgpO1xuICAgIGxldCBwID0gOTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyA0ICsgNCArIDE5ICsgNCArIHBhdGhMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCAwKTtcbiAgICBidWZbNF0gPSBSRVFVRVNULkVYVEVOREVEO1xuICAgIGNvbnN0IHJlcWlkID0gdGhpcy5fd3JpdGVSZXFpZCA9ICh0aGlzLl93cml0ZVJlcWlkICsgMSkgJiBNQVhfUkVRSUQ7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIHJlcWlkLCA1KTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCAxOSwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZSgnc3RhdHZmc0BvcGVuc3NoLmNvbScsIHAgKz0gNCwgMTkpO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCBwYXRoTGVuLCBwICs9IDE5KTtcbiAgICBidWYudXRmOFdyaXRlKHBhdGgsIHAgKz0gNCwgcGF0aExlbik7XG5cbiAgICB0aGlzLl9yZXF1ZXN0c1tyZXFpZF0gPSB7IGV4dGVuZGVkOiAnc3RhdHZmc0BvcGVuc3NoLmNvbScsIGNiIH07XG5cbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gc2VuZE9yQnVmZmVyKHRoaXMsIGJ1Zik7XG4gICAgaWYgKHRoaXMuX2RlYnVnKSB7XG4gICAgICBjb25zdCB3aGljaCA9IChpc0J1ZmZlcmVkID8gJ0J1ZmZlcmVkJyA6ICdTZW5kaW5nJyk7XG4gICAgICB0aGlzLl9kZWJ1ZyhgU0ZUUDogT3V0Ym91bmQ6ICR7d2hpY2h9IHN0YXR2ZnNAb3BlbnNzaC5jb21gKTtcbiAgICB9XG4gIH1cbiAgZXh0X29wZW5zc2hfZnN0YXR2ZnMoaGFuZGxlLCBjYikge1xuICAgIGlmICh0aGlzLnNlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgY29uc3QgZXh0ID0gdGhpcy5fZXh0ZW5zaW9uc1snZnN0YXR2ZnNAb3BlbnNzaC5jb20nXTtcbiAgICBpZiAoIWV4dCB8fCBleHQgIT09ICcyJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBleHRlbmRlZCByZXF1ZXN0Jyk7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaGFuZGxlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlIGlzIG5vdCBhIEJ1ZmZlcicpO1xuXG4gICAgLypcbiAgICAgIHVpbnQzMiAgICBpZFxuICAgICAgc3RyaW5nICAgIFwiZnN0YXR2ZnNAb3BlbnNzaC5jb21cIlxuICAgICAgc3RyaW5nICAgIGhhbmRsZVxuICAgICovXG4gICAgY29uc3QgaGFuZGxlTGVuID0gaGFuZGxlLmxlbmd0aDtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyAyMCArIDQgKyBoYW5kbGVMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCAwKTtcbiAgICBidWZbNF0gPSBSRVFVRVNULkVYVEVOREVEO1xuICAgIGNvbnN0IHJlcWlkID0gdGhpcy5fd3JpdGVSZXFpZCA9ICh0aGlzLl93cml0ZVJlcWlkICsgMSkgJiBNQVhfUkVRSUQ7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIHJlcWlkLCA1KTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCAyMCwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZSgnZnN0YXR2ZnNAb3BlbnNzaC5jb20nLCBwICs9IDQsIDIwKTtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgaGFuZGxlTGVuLCBwICs9IDIwKTtcbiAgICBidWYuc2V0KGhhbmRsZSwgcCArPSA0KTtcblxuICAgIHRoaXMuX3JlcXVlc3RzW3JlcWlkXSA9IHsgZXh0ZW5kZWQ6ICdmc3RhdHZmc0BvcGVuc3NoLmNvbScsIGNiIH07XG5cbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gc2VuZE9yQnVmZmVyKHRoaXMsIGJ1Zik7XG4gICAgaWYgKHRoaXMuX2RlYnVnKSB7XG4gICAgICBjb25zdCB3aGljaCA9IChpc0J1ZmZlcmVkID8gJ0J1ZmZlcmVkJyA6ICdTZW5kaW5nJyk7XG4gICAgICB0aGlzLl9kZWJ1ZyhgU0ZUUDogT3V0Ym91bmQ6ICR7d2hpY2h9IGZzdGF0dmZzQG9wZW5zc2guY29tYCk7XG4gICAgfVxuICB9XG4gIGV4dF9vcGVuc3NoX2hhcmRsaW5rKG9sZFBhdGgsIG5ld1BhdGgsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBjb25zdCBleHQgPSB0aGlzLl9leHRlbnNpb25zWydoYXJkbGlua0BvcGVuc3NoLmNvbSddO1xuICAgIGlmIChleHQgIT09ICcxJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBleHRlbmRlZCByZXF1ZXN0Jyk7XG5cbiAgICAvKlxuICAgICAgdWludDMyICAgIGlkXG4gICAgICBzdHJpbmcgICAgXCJoYXJkbGlua0BvcGVuc3NoLmNvbVwiXG4gICAgICBzdHJpbmcgICAgb2xkcGF0aFxuICAgICAgc3RyaW5nICAgIG5ld3BhdGhcbiAgICAqL1xuICAgIGNvbnN0IG9sZExlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG9sZFBhdGgpO1xuICAgIGNvbnN0IG5ld0xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG5ld1BhdGgpO1xuICAgIGxldCBwID0gOTtcbiAgICBjb25zdCBidWYgPVxuICAgICAgQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyAyMCArIDQgKyBvbGRMZW4gKyA0ICsgbmV3TGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVRVUVTVC5FWFRFTkRFRDtcbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgMjAsIHApO1xuICAgIGJ1Zi51dGY4V3JpdGUoJ2hhcmRsaW5rQG9wZW5zc2guY29tJywgcCArPSA0LCAyMCk7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIG9sZExlbiwgcCArPSAyMCk7XG4gICAgYnVmLnV0ZjhXcml0ZShvbGRQYXRoLCBwICs9IDQsIG9sZExlbik7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIG5ld0xlbiwgcCArPSBvbGRMZW4pO1xuICAgIGJ1Zi51dGY4V3JpdGUobmV3UGF0aCwgcCArPSA0LCBuZXdMZW4pO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0geyBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgY29uc3Qgd2hpY2ggPSAoaXNCdWZmZXJlZCA/ICdCdWZmZXJlZCcgOiAnU2VuZGluZycpO1xuICAgICAgdGhpcy5fZGVidWcoYFNGVFA6IE91dGJvdW5kOiAke3doaWNofSBoYXJkbGlua0BvcGVuc3NoLmNvbWApO1xuICAgIH1cbiAgfVxuICBleHRfb3BlbnNzaF9mc3luYyhoYW5kbGUsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBjb25zdCBleHQgPSB0aGlzLl9leHRlbnNpb25zWydmc3luY0BvcGVuc3NoLmNvbSddO1xuICAgIGlmIChleHQgIT09ICcxJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBleHRlbmRlZCByZXF1ZXN0Jyk7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaGFuZGxlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlIGlzIG5vdCBhIEJ1ZmZlcicpO1xuXG4gICAgLypcbiAgICAgIHVpbnQzMiAgICBpZFxuICAgICAgc3RyaW5nICAgIFwiZnN5bmNAb3BlbnNzaC5jb21cIlxuICAgICAgc3RyaW5nICAgIGhhbmRsZVxuICAgICovXG4gICAgY29uc3QgaGFuZGxlTGVuID0gaGFuZGxlLmxlbmd0aDtcbiAgICBsZXQgcCA9IDk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKyAxICsgNCArIDQgKyAxNyArIDQgKyBoYW5kbGVMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCAwKTtcbiAgICBidWZbNF0gPSBSRVFVRVNULkVYVEVOREVEO1xuICAgIGNvbnN0IHJlcWlkID0gdGhpcy5fd3JpdGVSZXFpZCA9ICh0aGlzLl93cml0ZVJlcWlkICsgMSkgJiBNQVhfUkVRSUQ7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIHJlcWlkLCA1KTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCAxNywgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZSgnZnN5bmNAb3BlbnNzaC5jb20nLCBwICs9IDQsIDE3KTtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgaGFuZGxlTGVuLCBwICs9IDE3KTtcbiAgICBidWYuc2V0KGhhbmRsZSwgcCArPSA0KTtcblxuICAgIHRoaXMuX3JlcXVlc3RzW3JlcWlkXSA9IHsgY2IgfTtcblxuICAgIGNvbnN0IGlzQnVmZmVyZWQgPSBzZW5kT3JCdWZmZXIodGhpcywgYnVmKTtcbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhcbiAgICAgIGBTRlRQOiBPdXRib3VuZDogJHtpc0J1ZmZlcmVkID8gJ0J1ZmZlcmVkJyA6ICdTZW5kaW5nJ30gZnN5bmNAb3BlbnNzaC5jb21gXG4gICAgKTtcbiAgfVxuICBleHRfb3BlbnNzaF9sc2V0c3RhdChwYXRoLCBhdHRycywgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGNvbnN0IGV4dCA9IHRoaXMuX2V4dGVuc2lvbnNbJ2xzZXRzdGF0QG9wZW5zc2guY29tJ107XG4gICAgaWYgKGV4dCAhPT0gJzEnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIGV4dGVuZGVkIHJlcXVlc3QnKTtcblxuICAgIGxldCBmbGFncyA9IDA7XG4gICAgbGV0IGF0dHJzTGVuID0gMDtcblxuICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdvYmplY3QnICYmIGF0dHJzICE9PSBudWxsKSB7XG4gICAgICBhdHRycyA9IGF0dHJzVG9CeXRlcyhhdHRycyk7XG4gICAgICBmbGFncyA9IGF0dHJzLmZsYWdzO1xuICAgICAgYXR0cnNMZW4gPSBhdHRycy5uYjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhdHRycztcbiAgICB9XG5cbiAgICAvKlxuICAgICAgdWludDMyICAgIGlkXG4gICAgICBzdHJpbmcgICAgXCJsc2V0c3RhdEBvcGVuc3NoLmNvbVwiXG4gICAgICBzdHJpbmcgICAgcGF0aFxuICAgICAgQVRUUlMgICAgIGF0dHJzXG4gICAgKi9cbiAgICBjb25zdCBwYXRoTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgocGF0aCk7XG4gICAgbGV0IHAgPSA5O1xuICAgIGNvbnN0IGJ1ZiA9XG4gICAgICBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyA0ICsgNCArIDIwICsgNCArIHBhdGhMZW4gKyA0ICsgYXR0cnNMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCAwKTtcbiAgICBidWZbNF0gPSBSRVFVRVNULkVYVEVOREVEO1xuICAgIGNvbnN0IHJlcWlkID0gdGhpcy5fd3JpdGVSZXFpZCA9ICh0aGlzLl93cml0ZVJlcWlkICsgMSkgJiBNQVhfUkVRSUQ7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIHJlcWlkLCA1KTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCAyMCwgcCk7XG4gICAgYnVmLnV0ZjhXcml0ZSgnbHNldHN0YXRAb3BlbnNzaC5jb20nLCBwICs9IDQsIDIwKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBwYXRoTGVuLCBwICs9IDIwKTtcbiAgICBidWYudXRmOFdyaXRlKHBhdGgsIHAgKz0gNCwgcGF0aExlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgZmxhZ3MsIHAgKz0gcGF0aExlbik7XG4gICAgaWYgKGF0dHJzTGVuKSB7XG4gICAgICBwICs9IDQ7XG5cbiAgICAgIGlmIChhdHRyc0xlbiA9PT0gQVRUUlNfQlVGLmxlbmd0aClcbiAgICAgICAgYnVmLnNldChBVFRSU19CVUYsIHApO1xuICAgICAgZWxzZVxuICAgICAgICBidWZmZXJDb3B5KEFUVFJTX0JVRiwgYnVmLCAwLCBhdHRyc0xlbiwgcCk7XG5cbiAgICAgIHAgKz0gYXR0cnNMZW47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0geyBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgY29uc3Qgc3RhdHVzID0gKGlzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnKTtcbiAgICAgIHRoaXMuX2RlYnVnKGBTRlRQOiBPdXRib3VuZDogJHtzdGF0dXN9IGxzZXRzdGF0QG9wZW5zc2guY29tYCk7XG4gICAgfVxuICB9XG4gIGV4dF9vcGVuc3NoX2V4cGFuZFBhdGgocGF0aCwgY2IpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudC1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gc2VydmVyIG1vZGUnKTtcblxuICAgIGNvbnN0IGV4dCA9IHRoaXMuX2V4dGVuc2lvbnNbJ2V4cGFuZC1wYXRoQG9wZW5zc2guY29tJ107XG4gICAgaWYgKGV4dCAhPT0gJzEnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIGV4dGVuZGVkIHJlcXVlc3QnKTtcblxuICAgIC8qXG4gICAgICB1aW50MzIgICAgaWRcbiAgICAgIHN0cmluZyAgICBcImV4cGFuZC1wYXRoQG9wZW5zc2guY29tXCJcbiAgICAgIHN0cmluZyAgICBwYXRoXG4gICAgKi9cbiAgICBjb25zdCBwYXRoTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgocGF0aCk7XG4gICAgbGV0IHAgPSA5O1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgMSArIDQgKyA0ICsgMjMgKyA0ICsgcGF0aExlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgYnVmLmxlbmd0aCAtIDQsIDApO1xuICAgIGJ1Zls0XSA9IFJFUVVFU1QuRVhURU5ERUQ7XG4gICAgY29uc3QgcmVxaWQgPSB0aGlzLl93cml0ZVJlcWlkID0gKHRoaXMuX3dyaXRlUmVxaWQgKyAxKSAmIE1BWF9SRVFJRDtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcmVxaWQsIDUpO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIDIzLCBwKTtcbiAgICBidWYudXRmOFdyaXRlKCdleHBhbmQtcGF0aEBvcGVuc3NoLmNvbScsIHAgKz0gNCwgMjMpO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIHBhdGhMZW4sIHAgKz0gMjApO1xuICAgIGJ1Zi51dGY4V3JpdGUocGF0aCwgcCArPSA0LCBwYXRoTGVuKTtcblxuICAgIHRoaXMuX3JlcXVlc3RzW3JlcWlkXSA9IHtcbiAgICAgIGNiOiAoZXJyLCBuYW1lcykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgaWYgKCFuYW1lcyB8fCAhbmFtZXMubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1Jlc3BvbnNlIG1pc3NpbmcgZXhwYW5kZWQgcGF0aCcpKTtcbiAgICAgICAgY2IodW5kZWZpbmVkLCBuYW1lc1swXS5maWxlbmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzQnVmZmVyZWQgPSBzZW5kT3JCdWZmZXIodGhpcywgYnVmKTtcbiAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IChpc0J1ZmZlcmVkID8gJ0J1ZmZlcmVkJyA6ICdTZW5kaW5nJyk7XG4gICAgICB0aGlzLl9kZWJ1ZyhgU0ZUUDogT3V0Ym91bmQ6ICR7c3RhdHVzfSBleHBhbmQtcGF0aEBvcGVuc3NoLmNvbWApO1xuICAgIH1cbiAgfVxuICBleHRfY29weV9kYXRhKHNyY0hhbmRsZSwgc3JjT2Zmc2V0LCBsZW4sIGRzdEhhbmRsZSwgZHN0T2Zmc2V0LCBjYikge1xuICAgIGlmICh0aGlzLnNlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgY29uc3QgZXh0ID0gdGhpcy5fZXh0ZW5zaW9uc1snY29weS1kYXRhJ107XG4gICAgaWYgKGV4dCAhPT0gJzEnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIGV4dGVuZGVkIHJlcXVlc3QnKTtcblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHNyY0hhbmRsZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBoYW5kbGUgaXMgbm90IGEgQnVmZmVyJyk7XG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkc3RIYW5kbGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXN0aW5hdGlvbiBoYW5kbGUgaXMgbm90IGEgQnVmZmVyJyk7XG5cbiAgICAvKlxuICAgICAgdWludDMyICAgIGlkXG4gICAgICBzdHJpbmcgICAgXCJjb3B5LWRhdGFcIlxuICAgICAgc3RyaW5nICAgIHJlYWQtZnJvbS1oYW5kbGVcbiAgICAgIHVpbnQ2NCAgICByZWFkLWZyb20tb2Zmc2V0XG4gICAgICB1aW50NjQgICAgcmVhZC1kYXRhLWxlbmd0aFxuICAgICAgc3RyaW5nICAgIHdyaXRlLXRvLWhhbmRsZVxuICAgICAgdWludDY0ICAgIHdyaXRlLXRvLW9mZnNldFxuICAgICovXG4gICAgbGV0IHAgPSAwO1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShcbiAgICAgIDQgKyAxXG4gICAgICArIDRcbiAgICAgICsgNCArIDlcbiAgICAgICsgNCArIHNyY0hhbmRsZS5sZW5ndGhcbiAgICAgICsgOFxuICAgICAgKyA4XG4gICAgICArIDQgKyBkc3RIYW5kbGUubGVuZ3RoXG4gICAgICArIDhcbiAgICApO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCBwKTtcbiAgICBwICs9IDQ7XG5cbiAgICBidWZbcF0gPSBSRVFVRVNULkVYVEVOREVEO1xuICAgICsrcDtcblxuICAgIGNvbnN0IHJlcWlkID0gdGhpcy5fd3JpdGVSZXFpZCA9ICh0aGlzLl93cml0ZVJlcWlkICsgMSkgJiBNQVhfUkVRSUQ7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIHJlcWlkLCBwKTtcbiAgICBwICs9IDQ7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgOSwgcCk7XG4gICAgcCArPSA0O1xuICAgIGJ1Zi51dGY4V3JpdGUoJ2NvcHktZGF0YScsIHAsIDkpO1xuICAgIHAgKz0gOTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBzcmNIYW5kbGUubGVuZ3RoLCBwKTtcbiAgICBwICs9IDQ7XG4gICAgYnVmLnNldChzcmNIYW5kbGUsIHApO1xuICAgIHAgKz0gc3JjSGFuZGxlLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSA3OyBpID49IDA7IC0taSkge1xuICAgICAgYnVmW3AgKyBpXSA9IHNyY09mZnNldCAmIDB4RkY7XG4gICAgICBzcmNPZmZzZXQgLz0gMjU2O1xuICAgIH1cbiAgICBwICs9IDg7XG5cbiAgICBmb3IgKGxldCBpID0gNzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGJ1ZltwICsgaV0gPSBsZW4gJiAweEZGO1xuICAgICAgbGVuIC89IDI1NjtcbiAgICB9XG4gICAgcCArPSA4O1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGRzdEhhbmRsZS5sZW5ndGgsIHApO1xuICAgIHAgKz0gNDtcbiAgICBidWYuc2V0KGRzdEhhbmRsZSwgcCk7XG4gICAgcCArPSBkc3RIYW5kbGUubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDc7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBidWZbcCArIGldID0gZHN0T2Zmc2V0ICYgMHhGRjtcbiAgICAgIGRzdE9mZnNldCAvPSAyNTY7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0geyBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgY29uc3Qgc3RhdHVzID0gKGlzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnKTtcbiAgICAgIHRoaXMuX2RlYnVnKGBTRlRQOiBPdXRib3VuZDogJHtzdGF0dXN9IGNvcHktZGF0YWApO1xuICAgIH1cbiAgfVxuICBleHRfaG9tZV9kaXIodXNlcm5hbWUsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBjb25zdCBleHQgPSB0aGlzLl9leHRlbnNpb25zWydob21lLWRpcmVjdG9yeSddO1xuICAgIGlmIChleHQgIT09ICcxJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBleHRlbmRlZCByZXF1ZXN0Jyk7XG5cbiAgICBpZiAodHlwZW9mIHVzZXJuYW1lICE9PSAnc3RyaW5nJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZXJuYW1lIGlzIG5vdCBhIHN0cmluZycpO1xuXG4gICAgLypcbiAgICAgIHVpbnQzMiAgICBpZFxuICAgICAgc3RyaW5nICAgIFwiaG9tZS1kaXJlY3RvcnlcIlxuICAgICAgc3RyaW5nICAgIHVzZXJuYW1lXG4gICAgKi9cbiAgICBsZXQgcCA9IDA7XG4gICAgY29uc3QgdXNlcm5hbWVMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh1c2VybmFtZSk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgICAgNCArIDFcbiAgICAgICsgNFxuICAgICAgKyA0ICsgMTRcbiAgICAgICsgNCArIHVzZXJuYW1lTGVuXG4gICAgKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgcCk7XG4gICAgcCArPSA0O1xuXG4gICAgYnVmW3BdID0gUkVRVUVTVC5FWFRFTkRFRDtcbiAgICArK3A7XG5cbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgcCk7XG4gICAgcCArPSA0O1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIDE0LCBwKTtcbiAgICBwICs9IDQ7XG4gICAgYnVmLnV0ZjhXcml0ZSgnaG9tZS1kaXJlY3RvcnknLCBwLCAxNCk7XG4gICAgcCArPSAxNDtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCB1c2VybmFtZUxlbiwgcCk7XG4gICAgcCArPSA0O1xuICAgIGJ1Zi51dGY4V3JpdGUodXNlcm5hbWUsIHAsIHVzZXJuYW1lTGVuKTtcbiAgICBwICs9IHVzZXJuYW1lTGVuO1xuXG4gICAgdGhpcy5fcmVxdWVzdHNbcmVxaWRdID0ge1xuICAgICAgY2I6IChlcnIsIG5hbWVzKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICBpZiAoIW5hbWVzIHx8ICFuYW1lcy5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignUmVzcG9uc2UgbWlzc2luZyBob21lIGRpcmVjdG9yeScpKTtcbiAgICAgICAgY2IodW5kZWZpbmVkLCBuYW1lc1swXS5maWxlbmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzQnVmZmVyZWQgPSBzZW5kT3JCdWZmZXIodGhpcywgYnVmKTtcbiAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IChpc0J1ZmZlcmVkID8gJ0J1ZmZlcmVkJyA6ICdTZW5kaW5nJyk7XG4gICAgICB0aGlzLl9kZWJ1ZyhgU0ZUUDogT3V0Ym91bmQ6ICR7c3RhdHVzfSBob21lLWRpcmVjdG9yeWApO1xuICAgIH1cbiAgfVxuICBleHRfdXNlcnNfZ3JvdXBzKHVpZHMsIGdpZHMsIGNiKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBjb25zdCBleHQgPSB0aGlzLl9leHRlbnNpb25zWyd1c2Vycy1ncm91cHMtYnktaWRAb3BlbnNzaC5jb20nXTtcbiAgICBpZiAoZXh0ICE9PSAnMScpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHRoaXMgZXh0ZW5kZWQgcmVxdWVzdCcpO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVpZHMpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndWlkcyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB1aWRzKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsKSB8fCB2YWwgPCAwIHx8IHZhbCA+ICgyICoqIDMyIC0gMSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndWlkIHZhbHVlcyBtdXN0IGFsbCBiZSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlcnMnKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGdpZHMpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2lkcyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBnaWRzKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsKSB8fCB2YWwgPCAwIHx8IHZhbCA+ICgyICoqIDMyIC0gMSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2lkIHZhbHVlcyBtdXN0IGFsbCBiZSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlcnMnKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAgdWludDMyICAgIGlkXG4gICAgICBzdHJpbmcgICAgXCJ1c2Vycy1ncm91cHMtYnktaWRAb3BlbnNzaC5jb21cIlxuICAgICAgc3RyaW5nICAgIHVpZHNcbiAgICAgICAgdWludDMyICAgIHVpZDFcbiAgICAgICAgLi4uXG4gICAgICBzdHJpbmcgICAgZ2lkc1xuICAgICAgICB1aW50MzIgICAgZ2lkMVxuICAgICAgICAuLi5cbiAgICAqL1xuICAgIGxldCBwID0gMDtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoXG4gICAgICA0ICsgMVxuICAgICAgKyA0XG4gICAgICArIDQgKyAzMFxuICAgICAgKyA0ICsgKDQgKiB1aWRzLmxlbmd0aClcbiAgICAgICsgNCArICg0ICogZ2lkcy5sZW5ndGgpXG4gICAgKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgcCk7XG4gICAgcCArPSA0O1xuXG4gICAgYnVmW3BdID0gUkVRVUVTVC5FWFRFTkRFRDtcbiAgICArK3A7XG5cbiAgICBjb25zdCByZXFpZCA9IHRoaXMuX3dyaXRlUmVxaWQgPSAodGhpcy5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgcCk7XG4gICAgcCArPSA0O1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIDMwLCBwKTtcbiAgICBwICs9IDQ7XG4gICAgYnVmLnV0ZjhXcml0ZSgndXNlcnMtZ3JvdXBzLWJ5LWlkQG9wZW5zc2guY29tJywgcCwgMzApO1xuICAgIHAgKz0gMzA7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgNCAqIHVpZHMubGVuZ3RoLCBwKTtcbiAgICBwICs9IDQ7XG4gICAgZm9yIChjb25zdCB2YWwgb2YgdWlkcykge1xuICAgICAgd3JpdGVVSW50MzJCRShidWYsIHZhbCwgcCk7XG4gICAgICBwICs9IDQ7XG4gICAgfVxuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIDQgKiBnaWRzLmxlbmd0aCwgcCk7XG4gICAgcCArPSA0O1xuICAgIGZvciAoY29uc3QgdmFsIG9mIGdpZHMpIHtcbiAgICAgIHdyaXRlVUludDMyQkUoYnVmLCB2YWwsIHApO1xuICAgICAgcCArPSA0O1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RzW3JlcWlkXSA9IHsgZXh0ZW5kZWQ6ICd1c2Vycy1ncm91cHMtYnktaWRAb3BlbnNzaC5jb20nLCBjYiB9O1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgY29uc3Qgc3RhdHVzID0gKGlzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnKTtcbiAgICAgIHRoaXMuX2RlYnVnKGBTRlRQOiBPdXRib3VuZDogJHtzdGF0dXN9IHVzZXJzLWdyb3Vwcy1ieS1pZEBvcGVuc3NoLmNvbWApO1xuICAgIH1cbiAgfVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2VydmVyLXNwZWNpZmljID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBoYW5kbGUocmVxaWQsIGhhbmRsZSkge1xuICAgIGlmICghdGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gY2xpZW50IG1vZGUnKTtcblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGhhbmRsZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhbmRsZSBpcyBub3QgYSBCdWZmZXInKTtcblxuICAgIGNvbnN0IGhhbmRsZUxlbiA9IGhhbmRsZS5sZW5ndGg7XG5cbiAgICBpZiAoaGFuZGxlTGVuID4gMjU2KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGUgdG9vIGxhcmdlICg+IDI1NiBieXRlcyknKTtcblxuICAgIGxldCBwID0gOTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyA0ICsgNCArIGhhbmRsZUxlbik7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgYnVmLmxlbmd0aCAtIDQsIDApO1xuICAgIGJ1Zls0XSA9IFJFU1BPTlNFLkhBTkRMRTtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcmVxaWQsIDUpO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGhhbmRsZUxlbiwgcCk7XG4gICAgaWYgKGhhbmRsZUxlbilcbiAgICAgIGJ1Zi5zZXQoaGFuZGxlLCBwICs9IDQpO1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYFNGVFA6IE91dGJvdW5kOiAke2lzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnfSBIQU5ETEVgXG4gICAgKTtcbiAgfVxuICBzdGF0dXMocmVxaWQsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIXRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXItb25seSBtZXRob2QgY2FsbGVkIGluIGNsaWVudCBtb2RlJyk7XG5cbiAgICBpZiAoIVZBTElEX1NUQVRVU19DT0RFUy5oYXMoY29kZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBzdGF0dXMgY29kZTogJHtjb2RlfWApO1xuXG4gICAgbWVzc2FnZSB8fCAobWVzc2FnZSA9ICcnKTtcblxuICAgIGNvbnN0IG1zZ0xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpO1xuICAgIGxldCBwID0gOTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyA0ICsgNCArIDQgKyBtc2dMZW4gKyA0KTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVTUE9OU0UuU1RBVFVTO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgY29kZSwgcCk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgbXNnTGVuLCBwICs9IDQpO1xuICAgIHAgKz0gNDtcbiAgICBpZiAobXNnTGVuKSB7XG4gICAgICBidWYudXRmOFdyaXRlKG1lc3NhZ2UsIHAsIG1zZ0xlbik7XG4gICAgICBwICs9IG1zZ0xlbjtcbiAgICB9XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgMCwgcCk7IC8vIEVtcHR5IGxhbmd1YWdlIHRhZ1xuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYFNGVFA6IE91dGJvdW5kOiAke2lzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnfSBTVEFUVVNgXG4gICAgKTtcbiAgfVxuICBkYXRhKHJlcWlkLCBkYXRhLCBlbmNvZGluZykge1xuICAgIGlmICghdGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gY2xpZW50IG1vZGUnKTtcblxuICAgIGNvbnN0IGlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyKGRhdGEpO1xuXG4gICAgaWYgKCFpc0J1ZmZlciAmJiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgaXMgbm90IGEgQnVmZmVyIG9yIHN0cmluZycpO1xuXG4gICAgbGV0IGlzVVRGODtcbiAgICBpZiAoIWlzQnVmZmVyICYmICFlbmNvZGluZykge1xuICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICBpc1VURjggPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGFMZW4gPSAoXG4gICAgICBpc0J1ZmZlclxuICAgICAgPyBkYXRhLmxlbmd0aFxuICAgICAgOiBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhLCBlbmNvZGluZylcbiAgICApO1xuICAgIGxldCBwID0gOTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyA0ICsgNCArIGRhdGFMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCAwKTtcbiAgICBidWZbNF0gPSBSRVNQT05TRS5EQVRBO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgZGF0YUxlbiwgcCk7XG4gICAgaWYgKGRhdGFMZW4pIHtcbiAgICAgIGlmIChpc0J1ZmZlcilcbiAgICAgICAgYnVmLnNldChkYXRhLCBwICs9IDQpO1xuICAgICAgZWxzZSBpZiAoaXNVVEY4KVxuICAgICAgICBidWYudXRmOFdyaXRlKGRhdGEsIHAgKz0gNCwgZGF0YUxlbik7XG4gICAgICBlbHNlXG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCBwICs9IDQsIGRhdGFMZW4sIGVuY29kaW5nKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gc2VuZE9yQnVmZmVyKHRoaXMsIGJ1Zik7XG4gICAgdGhpcy5fZGVidWcgJiYgdGhpcy5fZGVidWcoXG4gICAgICBgU0ZUUDogT3V0Ym91bmQ6ICR7aXNCdWZmZXJlZCA/ICdCdWZmZXJlZCcgOiAnU2VuZGluZyd9IERBVEFgXG4gICAgKTtcbiAgfVxuICBuYW1lKHJlcWlkLCBuYW1lcykge1xuICAgIGlmICghdGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gY2xpZW50IG1vZGUnKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShuYW1lcykpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZXMgIT09ICdvYmplY3QnIHx8IG5hbWVzID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWVzIGlzIG5vdCBhbiBvYmplY3Qgb3IgYXJyYXknKTtcbiAgICAgIG5hbWVzID0gWyBuYW1lcyBdO1xuICAgIH1cblxuICAgIGNvbnN0IGNvdW50ID0gbmFtZXMubGVuZ3RoO1xuICAgIGxldCBuYW1lc0xlbiA9IDA7XG4gICAgbGV0IG5hbWVBdHRycztcbiAgICBjb25zdCBhdHRycyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IChcbiAgICAgICAgIW5hbWUgfHwgIW5hbWUuZmlsZW5hbWUgfHwgdHlwZW9mIG5hbWUuZmlsZW5hbWUgIT09ICdzdHJpbmcnXG4gICAgICAgID8gJydcbiAgICAgICAgOiBuYW1lLmZpbGVuYW1lXG4gICAgICApO1xuICAgICAgbmFtZXNMZW4gKz0gNCArIEJ1ZmZlci5ieXRlTGVuZ3RoKGZpbGVuYW1lKTtcbiAgICAgIGNvbnN0IGxvbmduYW1lID0gKFxuICAgICAgICAhbmFtZSB8fCAhbmFtZS5sb25nbmFtZSB8fCB0eXBlb2YgbmFtZS5sb25nbmFtZSAhPT0gJ3N0cmluZydcbiAgICAgICAgPyAnJ1xuICAgICAgICA6IG5hbWUubG9uZ25hbWVcbiAgICAgICk7XG4gICAgICBuYW1lc0xlbiArPSA0ICsgQnVmZmVyLmJ5dGVMZW5ndGgobG9uZ25hbWUpO1xuXG4gICAgICBpZiAodHlwZW9mIG5hbWUuYXR0cnMgPT09ICdvYmplY3QnICYmIG5hbWUuYXR0cnMgIT09IG51bGwpIHtcbiAgICAgICAgbmFtZUF0dHJzID0gYXR0cnNUb0J5dGVzKG5hbWUuYXR0cnMpO1xuICAgICAgICBuYW1lc0xlbiArPSA0ICsgbmFtZUF0dHJzLm5iO1xuXG4gICAgICAgIGlmIChuYW1lQXR0cnMubmIpIHtcbiAgICAgICAgICBsZXQgYnl0ZXM7XG5cbiAgICAgICAgICBpZiAobmFtZUF0dHJzLm5iID09PSBBVFRSU19CVUYubGVuZ3RoKSB7XG4gICAgICAgICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KEFUVFJTX0JVRik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobmFtZUF0dHJzLm5iKTtcbiAgICAgICAgICAgIGJ1ZmZlckNvcHkoQVRUUlNfQlVGLCBieXRlcywgMCwgbmFtZUF0dHJzLm5iLCAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYW1lQXR0cnMuYnl0ZXMgPSBieXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJzLnB1c2gobmFtZUF0dHJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWVzTGVuICs9IDQ7XG4gICAgICAgIGF0dHJzLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHAgPSA5O1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICsgMSArIDQgKyA0ICsgbmFtZXNMZW4pO1xuXG4gICAgd3JpdGVVSW50MzJCRShidWYsIGJ1Zi5sZW5ndGggLSA0LCAwKTtcbiAgICBidWZbNF0gPSBSRVNQT05TRS5OQU1FO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCByZXFpZCwgNSk7XG5cbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgY291bnQsIHApO1xuXG4gICAgcCArPSA0O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG5cbiAgICAgIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoXG4gICAgICAgICAgIW5hbWUgfHwgIW5hbWUuZmlsZW5hbWUgfHwgdHlwZW9mIG5hbWUuZmlsZW5hbWUgIT09ICdzdHJpbmcnXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogbmFtZS5maWxlbmFtZVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChmaWxlbmFtZSk7XG4gICAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBsZW4sIHApO1xuICAgICAgICBwICs9IDQ7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICBidWYudXRmOFdyaXRlKGZpbGVuYW1lLCBwLCBsZW4pO1xuICAgICAgICAgIHAgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgY29uc3QgbG9uZ25hbWUgPSAoXG4gICAgICAgICAgIW5hbWUgfHwgIW5hbWUubG9uZ25hbWUgfHwgdHlwZW9mIG5hbWUubG9uZ25hbWUgIT09ICdzdHJpbmcnXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogbmFtZS5sb25nbmFtZVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChsb25nbmFtZSk7XG4gICAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBsZW4sIHApO1xuICAgICAgICBwICs9IDQ7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICBidWYudXRmOFdyaXRlKGxvbmduYW1lLCBwLCBsZW4pO1xuICAgICAgICAgIHAgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgIHdyaXRlVUludDMyQkUoYnVmLCBhdHRyLmZsYWdzLCBwKTtcbiAgICAgICAgcCArPSA0O1xuICAgICAgICBpZiAoYXR0ci5mbGFncyAmJiBhdHRyLmJ5dGVzKSB7XG4gICAgICAgICAgYnVmLnNldChhdHRyLmJ5dGVzLCBwKTtcbiAgICAgICAgICBwICs9IGF0dHIubmI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlVUludDMyQkUoYnVmLCAwLCBwKTtcbiAgICAgICAgcCArPSA0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzQnVmZmVyZWQgPSBzZW5kT3JCdWZmZXIodGhpcywgYnVmKTtcbiAgICB0aGlzLl9kZWJ1ZyAmJiB0aGlzLl9kZWJ1ZyhcbiAgICAgIGBTRlRQOiBPdXRib3VuZDogJHtpc0J1ZmZlcmVkID8gJ0J1ZmZlcmVkJyA6ICdTZW5kaW5nJ30gTkFNRWBcbiAgICApO1xuICB9XG4gIGF0dHJzKHJlcWlkLCBhdHRycykge1xuICAgIGlmICghdGhpcy5zZXJ2ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlci1vbmx5IG1ldGhvZCBjYWxsZWQgaW4gY2xpZW50IG1vZGUnKTtcblxuICAgIGlmICh0eXBlb2YgYXR0cnMgIT09ICdvYmplY3QnIHx8IGF0dHJzID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRycyBpcyBub3QgYW4gb2JqZWN0Jyk7XG5cbiAgICBhdHRycyA9IGF0dHJzVG9CeXRlcyhhdHRycyk7XG4gICAgY29uc3QgZmxhZ3MgPSBhdHRycy5mbGFncztcbiAgICBjb25zdCBhdHRyc0xlbiA9IGF0dHJzLm5iO1xuICAgIGxldCBwID0gOTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyA0ICsgNCArIGF0dHJzTGVuKTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBidWYubGVuZ3RoIC0gNCwgMCk7XG4gICAgYnVmWzRdID0gUkVTUE9OU0UuQVRUUlM7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIHJlcWlkLCA1KTtcblxuICAgIHdyaXRlVUludDMyQkUoYnVmLCBmbGFncywgcCk7XG4gICAgaWYgKGF0dHJzTGVuKSB7XG4gICAgICBwICs9IDQ7XG5cbiAgICAgIGlmIChhdHRyc0xlbiA9PT0gQVRUUlNfQlVGLmxlbmd0aClcbiAgICAgICAgYnVmLnNldChBVFRSU19CVUYsIHApO1xuICAgICAgZWxzZVxuICAgICAgICBidWZmZXJDb3B5KEFUVFJTX0JVRiwgYnVmLCAwLCBhdHRyc0xlbiwgcCk7XG5cbiAgICAgIHAgKz0gYXR0cnNMZW47XG4gICAgfVxuXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcih0aGlzLCBidWYpO1xuICAgIHRoaXMuX2RlYnVnICYmIHRoaXMuX2RlYnVnKFxuICAgICAgYFNGVFA6IE91dGJvdW5kOiAke2lzQnVmZmVyZWQgPyAnQnVmZmVyZWQnIDogJ1NlbmRpbmcnfSBBVFRSU2BcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNyZWF0ZUJ1ZmZlcihzaXplKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICByZXR1cm4gZXg7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZF8oc2VsZiwgaGFuZGxlLCBidWYsIG9mZiwgbGVuLCBwb3NpdGlvbiwgY2IsIHJlcV8pIHtcbiAgY29uc3QgbWF4RGF0YUxlbiA9IHNlbGYuX21heFJlYWRMZW47XG4gIGNvbnN0IG92ZXJmbG93ID0gTWF0aC5tYXgobGVuIC0gbWF4RGF0YUxlbiwgMCk7XG5cbiAgaWYgKG92ZXJmbG93KVxuICAgIGxlbiA9IG1heERhdGFMZW47XG5cbiAgLypcbiAgICB1aW50MzIgICAgIGlkXG4gICAgc3RyaW5nICAgICBoYW5kbGVcbiAgICB1aW50NjQgICAgIG9mZnNldFxuICAgIHVpbnQzMiAgICAgbGVuXG4gICovXG4gIGNvbnN0IGhhbmRsZUxlbiA9IGhhbmRsZS5sZW5ndGg7XG4gIGxldCBwID0gOTtcbiAgbGV0IHBvcyA9IHBvc2l0aW9uO1xuICBjb25zdCBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyA0ICsgNCArIGhhbmRsZUxlbiArIDggKyA0KTtcblxuICB3cml0ZVVJbnQzMkJFKG91dCwgb3V0Lmxlbmd0aCAtIDQsIDApO1xuICBvdXRbNF0gPSBSRVFVRVNULlJFQUQ7XG4gIGNvbnN0IHJlcWlkID0gc2VsZi5fd3JpdGVSZXFpZCA9IChzZWxmLl93cml0ZVJlcWlkICsgMSkgJiBNQVhfUkVRSUQ7XG4gIHdyaXRlVUludDMyQkUob3V0LCByZXFpZCwgNSk7XG5cbiAgd3JpdGVVSW50MzJCRShvdXQsIGhhbmRsZUxlbiwgcCk7XG4gIG91dC5zZXQoaGFuZGxlLCBwICs9IDQpO1xuICBwICs9IGhhbmRsZUxlbjtcbiAgZm9yIChsZXQgaSA9IDc7IGkgPj0gMDsgLS1pKSB7XG4gICAgb3V0W3AgKyBpXSA9IHBvcyAmIDB4RkY7XG4gICAgcG9zIC89IDI1NjtcbiAgfVxuICB3cml0ZVVJbnQzMkJFKG91dCwgbGVuLCBwICs9IDgpO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBub29wO1xuXG4gIGNvbnN0IHJlcSA9IChyZXFfIHx8IHtcbiAgICBuYjogMCxcbiAgICBwb3NpdGlvbixcbiAgICBvZmYsXG4gICAgb3JpZ09mZjogb2ZmLFxuICAgIGxlbjogdW5kZWZpbmVkLFxuICAgIG92ZXJmbG93OiB1bmRlZmluZWQsXG4gICAgY2I6IChlcnIsIGRhdGEsIG5iKSA9PiB7XG4gICAgICBjb25zdCBsZW4gPSByZXEubGVuO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSByZXEub3ZlcmZsb3c7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGNiLl93YW50RU9GRXJyb3IgfHwgZXJyLmNvZGUgIT09IFNUQVRVU19DT0RFLkVPRilcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAobmIgPiBsZW4pIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignUmVjZWl2ZWQgbW9yZSBkYXRhIHRoYW4gcmVxdWVzdGVkJykpO1xuICAgICAgfSBlbHNlIGlmIChuYiA9PT0gbGVuICYmIG92ZXJmbG93KSB7XG4gICAgICAgIHJlcS5uYiArPSBuYjtcbiAgICAgICAgcmVxLnBvc2l0aW9uICs9IG5iO1xuICAgICAgICByZXEub2ZmICs9IG5iO1xuICAgICAgICByZWFkXyhzZWxmLCBoYW5kbGUsIGJ1ZiwgcmVxLm9mZiwgb3ZlcmZsb3csIHJlcS5wb3NpdGlvbiwgY2IsIHJlcSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmIgPSAobmIgfHwgMCk7XG4gICAgICBpZiAocmVxLm9yaWdPZmYgPT09IDAgJiYgYnVmLmxlbmd0aCA9PT0gcmVxLm5iKVxuICAgICAgICBkYXRhID0gYnVmO1xuICAgICAgZWxzZVxuICAgICAgICBkYXRhID0gYnVmZmVyU2xpY2UoYnVmLCByZXEub3JpZ09mZiwgcmVxLm9yaWdPZmYgKyByZXEubmIgKyBuYik7XG4gICAgICBjYih1bmRlZmluZWQsIHJlcS5uYiArIG5iLCBkYXRhLCByZXEucG9zaXRpb24pO1xuICAgIH0sXG4gICAgYnVmZmVyOiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIHJlcS5sZW4gPSBsZW47XG4gIHJlcS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuXG4gIC8vIFRPRE86IGF2b2lkIGNyZWF0aW5nIG11bHRpcGxlIGJ1ZmZlciBzbGljZXMgd2hlbiB3ZSBuZWVkIHRvIHJlLWNhbGwgcmVhZF8oKVxuICAvLyBiZWNhdXNlIG9mIG92ZXJmbG93XG4gIHJlcS5idWZmZXIgPSBidWZmZXJTbGljZShidWYsIG9mZiwgb2ZmICsgbGVuKTtcblxuICBzZWxmLl9yZXF1ZXN0c1tyZXFpZF0gPSByZXE7XG5cbiAgY29uc3QgaXNCdWZmZXJlZCA9IHNlbmRPckJ1ZmZlcihzZWxmLCBvdXQpO1xuICBzZWxmLl9kZWJ1ZyAmJiBzZWxmLl9kZWJ1ZyhcbiAgICBgU0ZUUDogT3V0Ym91bmQ6ICR7aXNCdWZmZXJlZCA/ICdCdWZmZXJlZCcgOiAnU2VuZGluZyd9IFJFQURgXG4gICk7XG59XG5cbmZ1bmN0aW9uIGZhc3RYZmVyKHNyYywgZHN0LCBzcmNQYXRoLCBkc3RQYXRoLCBvcHRzLCBjYikge1xuICBsZXQgY29uY3VycmVuY3kgPSA2NDtcbiAgbGV0IGNodW5rU2l6ZSA9IDMyNzY4O1xuICBsZXQgb25zdGVwO1xuICBsZXQgbW9kZTtcbiAgbGV0IGZpbGVTaXplO1xuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0cztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgb3B0cyAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2Ygb3B0cy5jb25jdXJyZW5jeSA9PT0gJ251bWJlcidcbiAgICAgICAgJiYgb3B0cy5jb25jdXJyZW5jeSA+IDBcbiAgICAgICAgJiYgIWlzTmFOKG9wdHMuY29uY3VycmVuY3kpKSB7XG4gICAgICBjb25jdXJyZW5jeSA9IG9wdHMuY29uY3VycmVuY3k7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jaHVua1NpemUgPT09ICdudW1iZXInXG4gICAgICAgICYmIG9wdHMuY2h1bmtTaXplID4gMFxuICAgICAgICAmJiAhaXNOYU4ob3B0cy5jaHVua1NpemUpKSB7XG4gICAgICBjaHVua1NpemUgPSBvcHRzLmNodW5rU2l6ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmZpbGVTaXplID09PSAnbnVtYmVyJ1xuICAgICAgICAmJiBvcHRzLmZpbGVTaXplID4gMFxuICAgICAgICAmJiAhaXNOYU4ob3B0cy5maWxlU2l6ZSkpIHtcbiAgICAgIGZpbGVTaXplID0gb3B0cy5maWxlU2l6ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnN0ZXAgPT09ICdmdW5jdGlvbicpXG4gICAgICBvbnN0ZXAgPSBvcHRzLnN0ZXA7XG5cbiAgICBpZiAodHlwZW9mIG9wdHMubW9kZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9wdHMubW9kZSA9PT0gJ251bWJlcicpXG4gICAgICBtb2RlID0gbW9kZU51bShvcHRzLm1vZGUpO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgc3RhdGUgdmFyaWFibGVzXG4gIGxldCBmc2l6ZTtcbiAgbGV0IHBkc3QgPSAwO1xuICBsZXQgdG90YWwgPSAwO1xuICBsZXQgaGFkRXJyb3IgPSBmYWxzZTtcbiAgbGV0IHNyY0hhbmRsZTtcbiAgbGV0IGRzdEhhbmRsZTtcbiAgbGV0IHJlYWRidWY7XG4gIGxldCBidWZzaXplID0gY2h1bmtTaXplICogY29uY3VycmVuY3k7XG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBpZiAoaGFkRXJyb3IpXG4gICAgICByZXR1cm47XG5cbiAgICBoYWRFcnJvciA9IHRydWU7XG5cbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNiZmluYWw7XG5cbiAgICBpZiAoc3JjSGFuZGxlIHx8IGRzdEhhbmRsZSkge1xuICAgICAgY2JmaW5hbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKC0tbGVmdCA9PT0gMClcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgfTtcbiAgICAgIGlmIChzcmNIYW5kbGUgJiYgKHNyYyA9PT0gZnMgfHwgc3JjLm91dGdvaW5nLnN0YXRlID09PSAnb3BlbicpKVxuICAgICAgICArK2xlZnQ7XG4gICAgICBpZiAoZHN0SGFuZGxlICYmIChkc3QgPT09IGZzIHx8IGRzdC5vdXRnb2luZy5zdGF0ZSA9PT0gJ29wZW4nKSlcbiAgICAgICAgKytsZWZ0O1xuICAgICAgaWYgKHNyY0hhbmRsZSAmJiAoc3JjID09PSBmcyB8fCBzcmMub3V0Z29pbmcuc3RhdGUgPT09ICdvcGVuJykpXG4gICAgICAgIHNyYy5jbG9zZShzcmNIYW5kbGUsIGNiZmluYWwpO1xuICAgICAgaWYgKGRzdEhhbmRsZSAmJiAoZHN0ID09PSBmcyB8fCBkc3Qub3V0Z29pbmcuc3RhdGUgPT09ICdvcGVuJykpXG4gICAgICAgIGRzdC5jbG9zZShkc3RIYW5kbGUsIGNiZmluYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHNyYy5vcGVuKHNyY1BhdGgsICdyJywgKGVyciwgc291cmNlSGFuZGxlKSA9PiB7XG4gICAgaWYgKGVycilcbiAgICAgIHJldHVybiBvbmVycm9yKGVycik7XG5cbiAgICBzcmNIYW5kbGUgPSBzb3VyY2VIYW5kbGU7XG5cbiAgICBpZiAoZmlsZVNpemUgPT09IHVuZGVmaW5lZClcbiAgICAgIHNyYy5mc3RhdChzcmNIYW5kbGUsIHRyeVN0YXQpO1xuICAgIGVsc2VcbiAgICAgIHRyeVN0YXQobnVsbCwgeyBzaXplOiBmaWxlU2l6ZSB9KTtcblxuICAgIGZ1bmN0aW9uIHRyeVN0YXQoZXJyLCBhdHRycykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoc3JjICE9PSBmcykge1xuICAgICAgICAgIC8vIFRyeSBzdGF0KCkgZm9yIHNmdHAgc2VydmVycyB0aGF0IG1heSBub3Qgc3VwcG9ydCBmc3RhdCgpIGZvclxuICAgICAgICAgIC8vIHdoYXRldmVyIHJlYXNvblxuICAgICAgICAgIHNyYy5zdGF0KHNyY1BhdGgsIChlcnJfLCBhdHRyc18pID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJfKVxuICAgICAgICAgICAgICByZXR1cm4gb25lcnJvcihlcnIpO1xuICAgICAgICAgICAgdHJ5U3RhdChudWxsLCBhdHRyc18pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb25lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgZnNpemUgPSBhdHRycy5zaXplO1xuXG4gICAgICBkc3Qub3Blbihkc3RQYXRoLCAndycsIChlcnIsIGRlc3RIYW5kbGUpID0+IHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICByZXR1cm4gb25lcnJvcihlcnIpO1xuXG4gICAgICAgIGRzdEhhbmRsZSA9IGRlc3RIYW5kbGU7XG5cbiAgICAgICAgaWYgKGZzaXplIDw9IDApXG4gICAgICAgICAgcmV0dXJuIG9uZXJyb3IoKTtcblxuICAgICAgICAvLyBVc2UgbGVzcyBtZW1vcnkgd2hlcmUgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKGJ1ZnNpemUgPiBmc2l6ZSkge1xuICAgICAgICAgIGlmIChjb25jdXJyZW5jeSA9PT0gMSkge1xuICAgICAgICAgICAgYnVmc2l6ZSA9IGZzaXplO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZnNpemUgLT0gY2h1bmtTaXplO1xuICAgICAgICAgIC0tY29uY3VycmVuY3k7XG4gICAgICAgIH1cblxuICAgICAgICByZWFkYnVmID0gdHJ5Q3JlYXRlQnVmZmVyKGJ1ZnNpemUpO1xuICAgICAgICBpZiAocmVhZGJ1ZiBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICAgIHJldHVybiBvbmVycm9yKHJlYWRidWYpO1xuXG4gICAgICAgIGlmIChtb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkc3QuZmNobW9kKGRzdEhhbmRsZSwgbW9kZSwgZnVuY3Rpb24gdHJ5QWdhaW4oZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIC8vIFRyeSBjaG1vZCgpIGZvciBzZnRwIHNlcnZlcnMgdGhhdCBtYXkgbm90IHN1cHBvcnQgZmNobW9kKClcbiAgICAgICAgICAgICAgLy8gZm9yIHdoYXRldmVyIHJlYXNvblxuICAgICAgICAgICAgICBkc3QuY2htb2QoZHN0UGF0aCwgbW9kZSwgKGVycl8pID0+IHRyeUFnYWluKCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydFJlYWRzKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRSZWFkcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25yZWFkKGVyciwgbmIsIGRhdGEsIGRzdHBvcywgZGF0YXBvcywgb3JpZ0NodW5rTGVuKSB7XG4gICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIHJldHVybiBvbmVycm9yKGVycik7XG5cbiAgICAgICAgICBkYXRhcG9zID0gZGF0YXBvcyB8fCAwO1xuXG4gICAgICAgICAgZHN0LndyaXRlKGRzdEhhbmRsZSwgcmVhZGJ1ZiwgZGF0YXBvcywgbmIsIGRzdHBvcywgd3JpdGVDYik7XG5cbiAgICAgICAgICBmdW5jdGlvbiB3cml0ZUNiKGVycikge1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZXJyKTtcblxuICAgICAgICAgICAgdG90YWwgKz0gbmI7XG4gICAgICAgICAgICBvbnN0ZXAgJiYgb25zdGVwKHRvdGFsLCBuYiwgZnNpemUpO1xuXG4gICAgICAgICAgICBpZiAobmIgPCBvcmlnQ2h1bmtMZW4pXG4gICAgICAgICAgICAgIHJldHVybiBzaW5nbGVSZWFkKGRhdGFwb3MsIGRzdHBvcyArIG5iLCBvcmlnQ2h1bmtMZW4gLSBuYik7XG5cbiAgICAgICAgICAgIGlmICh0b3RhbCA9PT0gZnNpemUpIHtcbiAgICAgICAgICAgICAgZHN0LmNsb3NlKGRzdEhhbmRsZSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGRzdEhhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICBzcmMuY2xvc2Uoc3JjSGFuZGxlLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICBzcmNIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBkc3QgPj0gZnNpemUpXG4gICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3QgY2h1bmsgPVxuICAgICAgICAgICAgICAocGRzdCArIGNodW5rU2l6ZSA+IGZzaXplID8gZnNpemUgLSBwZHN0IDogY2h1bmtTaXplKTtcbiAgICAgICAgICAgIHNpbmdsZVJlYWQoZGF0YXBvcywgcGRzdCwgY2h1bmspO1xuICAgICAgICAgICAgcGRzdCArPSBjaHVuaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYWtlQ2IocHNyYywgcGRzdCwgY2h1bmspIHtcbiAgICAgICAgICByZXR1cm4gKGVyciwgbmIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIG9ucmVhZChlcnIsIG5iLCBkYXRhLCBwZHN0LCBwc3JjLCBjaHVuayk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNpbmdsZVJlYWQocHNyYywgcGRzdCwgY2h1bmspIHtcbiAgICAgICAgICBzcmMucmVhZChzcmNIYW5kbGUsXG4gICAgICAgICAgICAgICAgICAgcmVhZGJ1ZixcbiAgICAgICAgICAgICAgICAgICBwc3JjLFxuICAgICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICAgICAgIHBkc3QsXG4gICAgICAgICAgICAgICAgICAgbWFrZUNiKHBzcmMsIHBkc3QsIGNodW5rKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzdGFydFJlYWRzKCkge1xuICAgICAgICAgIGxldCByZWFkcyA9IDA7XG4gICAgICAgICAgbGV0IHBzcmMgPSAwO1xuICAgICAgICAgIHdoaWxlIChwZHN0IDwgZnNpemUgJiYgcmVhZHMgPCBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPVxuICAgICAgICAgICAgICAocGRzdCArIGNodW5rU2l6ZSA+IGZzaXplID8gZnNpemUgLSBwZHN0IDogY2h1bmtTaXplKTtcbiAgICAgICAgICAgIHNpbmdsZVJlYWQocHNyYywgcGRzdCwgY2h1bmspO1xuICAgICAgICAgICAgcHNyYyArPSBjaHVuaztcbiAgICAgICAgICAgIHBkc3QgKz0gY2h1bms7XG4gICAgICAgICAgICArK3JlYWRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd3JpdGVBbGwoc2Z0cCwgaGFuZGxlLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2tfKSB7XG4gIGNvbnN0IGNhbGxiYWNrID0gKHR5cGVvZiBjYWxsYmFja18gPT09ICdmdW5jdGlvbicgPyBjYWxsYmFja18gOiB1bmRlZmluZWQpO1xuXG4gIHNmdHAud3JpdGUoaGFuZGxlLFxuICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICh3cml0ZUVyciwgd3JpdHRlbikgPT4ge1xuICAgIGlmICh3cml0ZUVycikge1xuICAgICAgcmV0dXJuIHNmdHAuY2xvc2UoaGFuZGxlLCAoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHdyaXRlRXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAod3JpdHRlbiA9PT0gbGVuZ3RoKSB7XG4gICAgICBzZnRwLmNsb3NlKGhhbmRsZSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgKz0gd3JpdHRlbjtcbiAgICAgIGxlbmd0aCAtPSB3cml0dGVuO1xuICAgICAgcG9zaXRpb24gKz0gd3JpdHRlbjtcbiAgICAgIHdyaXRlQWxsKHNmdHAsIGhhbmRsZSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jbGFzcyBTdGF0cyB7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWwpIHtcbiAgICB0aGlzLm1vZGUgPSAoaW5pdGlhbCAmJiBpbml0aWFsLm1vZGUpO1xuICAgIHRoaXMudWlkID0gKGluaXRpYWwgJiYgaW5pdGlhbC51aWQpO1xuICAgIHRoaXMuZ2lkID0gKGluaXRpYWwgJiYgaW5pdGlhbC5naWQpO1xuICAgIHRoaXMuc2l6ZSA9IChpbml0aWFsICYmIGluaXRpYWwuc2l6ZSk7XG4gICAgdGhpcy5hdGltZSA9IChpbml0aWFsICYmIGluaXRpYWwuYXRpbWUpO1xuICAgIHRoaXMubXRpbWUgPSAoaW5pdGlhbCAmJiBpbml0aWFsLm10aW1lKTtcbiAgICB0aGlzLmV4dGVuZGVkID0gKGluaXRpYWwgJiYgaW5pdGlhbC5leHRlbmRlZCk7XG4gIH1cbiAgaXNEaXJlY3RvcnkoKSB7XG4gICAgcmV0dXJuICgodGhpcy5tb2RlICYgY29uc3RhbnRzLlNfSUZNVCkgPT09IGNvbnN0YW50cy5TX0lGRElSKTtcbiAgfVxuICBpc0ZpbGUoKSB7XG4gICAgcmV0dXJuICgodGhpcy5tb2RlICYgY29uc3RhbnRzLlNfSUZNVCkgPT09IGNvbnN0YW50cy5TX0lGUkVHKTtcbiAgfVxuICBpc0Jsb2NrRGV2aWNlKCkge1xuICAgIHJldHVybiAoKHRoaXMubW9kZSAmIGNvbnN0YW50cy5TX0lGTVQpID09PSBjb25zdGFudHMuU19JRkJMSyk7XG4gIH1cbiAgaXNDaGFyYWN0ZXJEZXZpY2UoKSB7XG4gICAgcmV0dXJuICgodGhpcy5tb2RlICYgY29uc3RhbnRzLlNfSUZNVCkgPT09IGNvbnN0YW50cy5TX0lGQ0hSKTtcbiAgfVxuICBpc1N5bWJvbGljTGluaygpIHtcbiAgICByZXR1cm4gKCh0aGlzLm1vZGUgJiBjb25zdGFudHMuU19JRk1UKSA9PT0gY29uc3RhbnRzLlNfSUZMTkspO1xuICB9XG4gIGlzRklGTygpIHtcbiAgICByZXR1cm4gKCh0aGlzLm1vZGUgJiBjb25zdGFudHMuU19JRk1UKSA9PT0gY29uc3RhbnRzLlNfSUZJRk8pO1xuICB9XG4gIGlzU29ja2V0KCkge1xuICAgIHJldHVybiAoKHRoaXMubW9kZSAmIGNvbnN0YW50cy5TX0lGTVQpID09PSBjb25zdGFudHMuU19JRlNPQ0spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF0dHJzVG9CeXRlcyhhdHRycykge1xuICBsZXQgZmxhZ3MgPSAwO1xuICBsZXQgbmIgPSAwO1xuXG4gIGlmICh0eXBlb2YgYXR0cnMgPT09ICdvYmplY3QnICYmIGF0dHJzICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgZmxhZ3MgfD0gQVRUUi5TSVpFO1xuICAgICAgY29uc3QgdmFsID0gYXR0cnMuc2l6ZTtcbiAgICAgIC8vIEJpZyBFbmRpYW5cbiAgICAgIEFUVFJTX0JVRltuYisrXSA9IHZhbCAvIDcyMDU3NTk0MDM3OTI3OTQwOyAvLyAyKio1NlxuICAgICAgQVRUUlNfQlVGW25iKytdID0gdmFsIC8gMjgxNDc0OTc2NzEwNjU2OyAvLyAyKio0OFxuICAgICAgQVRUUlNfQlVGW25iKytdID0gdmFsIC8gMTA5OTUxMTYyNzc3NjsgLy8gMioqNDBcbiAgICAgIEFUVFJTX0JVRltuYisrXSA9IHZhbCAvIDQyOTQ5NjcyOTY7IC8vIDIqKjMyXG4gICAgICBBVFRSU19CVUZbbmIrK10gPSB2YWwgLyAxNjc3NzIxNjsgLy8gMioqMjRcbiAgICAgIEFUVFJTX0JVRltuYisrXSA9IHZhbCAvIDY1NTM2OyAvLyAyKioxNlxuICAgICAgQVRUUlNfQlVGW25iKytdID0gdmFsIC8gMjU2OyAvLyAyKio4XG4gICAgICBBVFRSU19CVUZbbmIrK10gPSB2YWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXR0cnMudWlkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXR0cnMuZ2lkID09PSAnbnVtYmVyJykge1xuICAgICAgZmxhZ3MgfD0gQVRUUi5VSURHSUQ7XG4gICAgICBjb25zdCB1aWQgPSBhdHRycy51aWQ7XG4gICAgICBjb25zdCBnaWQgPSBhdHRycy5naWQ7XG4gICAgICAvLyBCaWcgRW5kaWFuXG4gICAgICBBVFRSU19CVUZbbmIrK10gPSB1aWQgPj4+IDI0O1xuICAgICAgQVRUUlNfQlVGW25iKytdID0gdWlkID4+PiAxNjtcbiAgICAgIEFUVFJTX0JVRltuYisrXSA9IHVpZCA+Pj4gODtcbiAgICAgIEFUVFJTX0JVRltuYisrXSA9IHVpZDtcbiAgICAgIEFUVFJTX0JVRltuYisrXSA9IGdpZCA+Pj4gMjQ7XG4gICAgICBBVFRSU19CVUZbbmIrK10gPSBnaWQgPj4+IDE2O1xuICAgICAgQVRUUlNfQlVGW25iKytdID0gZ2lkID4+PiA4O1xuICAgICAgQVRUUlNfQlVGW25iKytdID0gZ2lkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGF0dHJzLm1vZGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBhdHRycy5tb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbW9kZSA9IG1vZGVOdW0oYXR0cnMubW9kZSk7XG4gICAgICBmbGFncyB8PSBBVFRSLlBFUk1JU1NJT05TO1xuICAgICAgLy8gQmlnIEVuZGlhblxuICAgICAgQVRUUlNfQlVGW25iKytdID0gbW9kZSA+Pj4gMjQ7XG4gICAgICBBVFRSU19CVUZbbmIrK10gPSBtb2RlID4+PiAxNjtcbiAgICAgIEFUVFJTX0JVRltuYisrXSA9IG1vZGUgPj4+IDg7XG4gICAgICBBVFRSU19CVUZbbmIrK10gPSBtb2RlO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiBhdHRycy5hdGltZSA9PT0gJ251bWJlcicgfHwgaXNEYXRlKGF0dHJzLmF0aW1lKSlcbiAgICAgICAgJiYgKHR5cGVvZiBhdHRycy5tdGltZSA9PT0gJ251bWJlcicgfHwgaXNEYXRlKGF0dHJzLm10aW1lKSkpIHtcbiAgICAgIGNvbnN0IGF0aW1lID0gdG9Vbml4VGltZXN0YW1wKGF0dHJzLmF0aW1lKTtcbiAgICAgIGNvbnN0IG10aW1lID0gdG9Vbml4VGltZXN0YW1wKGF0dHJzLm10aW1lKTtcblxuICAgICAgZmxhZ3MgfD0gQVRUUi5BQ01PRFRJTUU7XG4gICAgICAvLyBCaWcgRW5kaWFuXG4gICAgICBBVFRSU19CVUZbbmIrK10gPSBhdGltZSA+Pj4gMjQ7XG4gICAgICBBVFRSU19CVUZbbmIrK10gPSBhdGltZSA+Pj4gMTY7XG4gICAgICBBVFRSU19CVUZbbmIrK10gPSBhdGltZSA+Pj4gODtcbiAgICAgIEFUVFJTX0JVRltuYisrXSA9IGF0aW1lO1xuICAgICAgQVRUUlNfQlVGW25iKytdID0gbXRpbWUgPj4+IDI0O1xuICAgICAgQVRUUlNfQlVGW25iKytdID0gbXRpbWUgPj4+IDE2O1xuICAgICAgQVRUUlNfQlVGW25iKytdID0gbXRpbWUgPj4+IDg7XG4gICAgICBBVFRSU19CVUZbbmIrK10gPSBtdGltZTtcbiAgICB9XG4gICAgLy8gVE9ETzogZXh0ZW5kZWQgYXR0cmlidXRlc1xuICB9XG5cbiAgcmV0dXJuIHsgZmxhZ3MsIG5iIH07XG59XG5cbmZ1bmN0aW9uIHRvVW5peFRpbWVzdGFtcCh0aW1lKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJyAmJiB0aW1lID09PSB0aW1lKSAvLyBWYWxpZCwgbm9uLU5hTiBudW1iZXJcbiAgICByZXR1cm4gdGltZTtcbiAgaWYgKGlzRGF0ZSh0aW1lKSlcbiAgICByZXR1cm4gcGFyc2VJbnQodGltZS5nZXRUaW1lKCkgLyAxMDAwLCAxMCk7XG4gIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIHRpbWU6ICR7dGltZX1gKTtcbn1cblxuZnVuY3Rpb24gbW9kZU51bShtb2RlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHR5cGVvZiBtb2RlID09PSAnbnVtYmVyJyAmJiBtb2RlID09PSBtb2RlKSAvLyBWYWxpZCwgbm9uLU5hTiBudW1iZXJcbiAgICByZXR1cm4gbW9kZTtcbiAgaWYgKHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJylcbiAgICByZXR1cm4gbW9kZU51bShwYXJzZUludChtb2RlLCA4KSk7XG4gIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIG1vZGU6ICR7bW9kZX1gKTtcbn1cblxuY29uc3Qgc3RyaW5nRmxhZ01hcCA9IHtcbiAgJ3InOiBPUEVOX01PREUuUkVBRCxcbiAgJ3IrJzogT1BFTl9NT0RFLlJFQUQgfCBPUEVOX01PREUuV1JJVEUsXG4gICd3JzogT1BFTl9NT0RFLlRSVU5DIHwgT1BFTl9NT0RFLkNSRUFUIHwgT1BFTl9NT0RFLldSSVRFLFxuICAnd3gnOiBPUEVOX01PREUuVFJVTkMgfCBPUEVOX01PREUuQ1JFQVQgfCBPUEVOX01PREUuV1JJVEUgfCBPUEVOX01PREUuRVhDTCxcbiAgJ3h3JzogT1BFTl9NT0RFLlRSVU5DIHwgT1BFTl9NT0RFLkNSRUFUIHwgT1BFTl9NT0RFLldSSVRFIHwgT1BFTl9NT0RFLkVYQ0wsXG4gICd3Kyc6IE9QRU5fTU9ERS5UUlVOQyB8IE9QRU5fTU9ERS5DUkVBVCB8IE9QRU5fTU9ERS5SRUFEIHwgT1BFTl9NT0RFLldSSVRFLFxuICAnd3grJzogT1BFTl9NT0RFLlRSVU5DIHwgT1BFTl9NT0RFLkNSRUFUIHwgT1BFTl9NT0RFLlJFQUQgfCBPUEVOX01PREUuV1JJVEVcbiAgICAgICAgIHwgT1BFTl9NT0RFLkVYQ0wsXG4gICd4dysnOiBPUEVOX01PREUuVFJVTkMgfCBPUEVOX01PREUuQ1JFQVQgfCBPUEVOX01PREUuUkVBRCB8IE9QRU5fTU9ERS5XUklURVxuICAgICAgICAgfCBPUEVOX01PREUuRVhDTCxcbiAgJ2EnOiBPUEVOX01PREUuQVBQRU5EIHwgT1BFTl9NT0RFLkNSRUFUIHwgT1BFTl9NT0RFLldSSVRFLFxuICAnYXgnOiBPUEVOX01PREUuQVBQRU5EIHwgT1BFTl9NT0RFLkNSRUFUIHwgT1BFTl9NT0RFLldSSVRFIHwgT1BFTl9NT0RFLkVYQ0wsXG4gICd4YSc6IE9QRU5fTU9ERS5BUFBFTkQgfCBPUEVOX01PREUuQ1JFQVQgfCBPUEVOX01PREUuV1JJVEUgfCBPUEVOX01PREUuRVhDTCxcbiAgJ2ErJzogT1BFTl9NT0RFLkFQUEVORCB8IE9QRU5fTU9ERS5DUkVBVCB8IE9QRU5fTU9ERS5SRUFEIHwgT1BFTl9NT0RFLldSSVRFLFxuICAnYXgrJzogT1BFTl9NT0RFLkFQUEVORCB8IE9QRU5fTU9ERS5DUkVBVCB8IE9QRU5fTU9ERS5SRUFEIHwgT1BFTl9NT0RFLldSSVRFXG4gICAgICAgICB8IE9QRU5fTU9ERS5FWENMLFxuICAneGErJzogT1BFTl9NT0RFLkFQUEVORCB8IE9QRU5fTU9ERS5DUkVBVCB8IE9QRU5fTU9ERS5SRUFEIHwgT1BFTl9NT0RFLldSSVRFXG4gICAgICAgICB8IE9QRU5fTU9ERS5FWENMXG59O1xuXG5mdW5jdGlvbiBzdHJpbmdUb0ZsYWdzKHN0cikge1xuICBjb25zdCBmbGFncyA9IHN0cmluZ0ZsYWdNYXBbc3RyXTtcbiAgcmV0dXJuIChmbGFncyAhPT0gdW5kZWZpbmVkID8gZmxhZ3MgOiBudWxsKTtcbn1cblxuY29uc3QgZmxhZ3NUb1N0cmluZyA9ICgoKSA9PiB7XG4gIGNvbnN0IHN0cmluZ0ZsYWdNYXBLZXlzID0gT2JqZWN0LmtleXMoc3RyaW5nRmxhZ01hcCk7XG4gIHJldHVybiAoZmxhZ3MpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ0ZsYWdNYXBLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBrZXkgPSBzdHJpbmdGbGFnTWFwS2V5c1tpXTtcbiAgICAgIGlmIChzdHJpbmdGbGFnTWFwW2tleV0gPT09IGZsYWdzKVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIHJlYWRBdHRycyhiaU9wdCkge1xuICAvKlxuICAgIHVpbnQzMiAgIGZsYWdzXG4gICAgdWludDY0ICAgc2l6ZSAgICAgICAgICAgcHJlc2VudCBvbmx5IGlmIGZsYWcgU1NIX0ZJTEVYRkVSX0FUVFJfU0laRVxuICAgIHVpbnQzMiAgIHVpZCAgICAgICAgICAgIHByZXNlbnQgb25seSBpZiBmbGFnIFNTSF9GSUxFWEZFUl9BVFRSX1VJREdJRFxuICAgIHVpbnQzMiAgIGdpZCAgICAgICAgICAgIHByZXNlbnQgb25seSBpZiBmbGFnIFNTSF9GSUxFWEZFUl9BVFRSX1VJREdJRFxuICAgIHVpbnQzMiAgIHBlcm1pc3Npb25zICAgIHByZXNlbnQgb25seSBpZiBmbGFnIFNTSF9GSUxFWEZFUl9BVFRSX1BFUk1JU1NJT05TXG4gICAgdWludDMyICAgYXRpbWUgICAgICAgICAgcHJlc2VudCBvbmx5IGlmIGZsYWcgU1NIX0ZJTEVYRkVSX0FDTU9EVElNRVxuICAgIHVpbnQzMiAgIG10aW1lICAgICAgICAgIHByZXNlbnQgb25seSBpZiBmbGFnIFNTSF9GSUxFWEZFUl9BQ01PRFRJTUVcbiAgICB1aW50MzIgICBleHRlbmRlZF9jb3VudCBwcmVzZW50IG9ubHkgaWYgZmxhZyBTU0hfRklMRVhGRVJfQVRUUl9FWFRFTkRFRFxuICAgIHN0cmluZyAgIGV4dGVuZGVkX3R5cGVcbiAgICBzdHJpbmcgICBleHRlbmRlZF9kYXRhXG4gICAgLi4uICAgICAgbW9yZSBleHRlbmRlZCBkYXRhIChleHRlbmRlZF90eXBlIC0gZXh0ZW5kZWRfZGF0YSBwYWlycyksXG4gICAgICAgICAgICAgICBzbyB0aGF0IG51bWJlciBvZiBwYWlycyBlcXVhbHMgZXh0ZW5kZWRfY291bnRcbiAgKi9cbiAgY29uc3QgZmxhZ3MgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybjtcblxuICBjb25zdCBhdHRycyA9IG5ldyBTdGF0cygpO1xuICBpZiAoZmxhZ3MgJiBBVFRSLlNJWkUpIHtcbiAgICBjb25zdCBzaXplID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50NjRCRShiaU9wdCk7XG4gICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybjtcbiAgICBhdHRycy5zaXplID0gc2l6ZTtcbiAgfVxuXG4gIGlmIChmbGFncyAmIEFUVFIuVUlER0lEKSB7XG4gICAgY29uc3QgdWlkID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGNvbnN0IGdpZCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBpZiAoZ2lkID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm47XG4gICAgYXR0cnMudWlkID0gdWlkO1xuICAgIGF0dHJzLmdpZCA9IGdpZDtcbiAgfVxuXG4gIGlmIChmbGFncyAmIEFUVFIuUEVSTUlTU0lPTlMpIHtcbiAgICBjb25zdCBtb2RlID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm47XG4gICAgYXR0cnMubW9kZSA9IG1vZGU7XG4gIH1cblxuICBpZiAoZmxhZ3MgJiBBVFRSLkFDTU9EVElNRSkge1xuICAgIGNvbnN0IGF0aW1lID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGNvbnN0IG10aW1lID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGlmIChtdGltZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuO1xuICAgIGF0dHJzLmF0aW1lID0gYXRpbWU7XG4gICAgYXR0cnMubXRpbWUgPSBtdGltZTtcbiAgfVxuXG4gIGlmIChmbGFncyAmIEFUVFIuRVhURU5ERUQpIHtcbiAgICBjb25zdCBjb3VudCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBleHRlbmRlZCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgdHlwZSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBleHRlbmRlZFt0eXBlXSA9IGRhdGE7XG4gICAgfVxuICAgIGF0dHJzLmV4dGVuZGVkID0gZXh0ZW5kZWQ7XG4gIH1cblxuICByZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIHNlbmRPckJ1ZmZlcihzZnRwLCBwYXlsb2FkKSB7XG4gIGNvbnN0IHJldCA9IHRyeVdyaXRlUGF5bG9hZChzZnRwLCBwYXlsb2FkKTtcbiAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2Z0cC5fYnVmZmVyLnB1c2gocmV0KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHRyeVdyaXRlUGF5bG9hZChzZnRwLCBwYXlsb2FkKSB7XG4gIGNvbnN0IG91dGdvaW5nID0gc2Z0cC5vdXRnb2luZztcbiAgaWYgKG91dGdvaW5nLnN0YXRlICE9PSAnb3BlbicpXG4gICAgcmV0dXJuO1xuXG4gIGlmIChvdXRnb2luZy53aW5kb3cgPT09IDApIHtcbiAgICBzZnRwLl93YWl0V2luZG93ID0gdHJ1ZTtcbiAgICBzZnRwLl9jaHVua2NiID0gZHJhaW5CdWZmZXI7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH1cblxuICBsZXQgcmV0O1xuICBjb25zdCBsZW4gPSBwYXlsb2FkLmxlbmd0aDtcbiAgbGV0IHAgPSAwO1xuXG4gIHdoaWxlIChsZW4gLSBwID4gMCAmJiBvdXRnb2luZy53aW5kb3cgPiAwKSB7XG4gICAgY29uc3QgYWN0dWFsTGVuID0gTWF0aC5taW4obGVuIC0gcCwgb3V0Z29pbmcud2luZG93LCBvdXRnb2luZy5wYWNrZXRTaXplKTtcbiAgICBvdXRnb2luZy53aW5kb3cgLT0gYWN0dWFsTGVuO1xuICAgIGlmIChvdXRnb2luZy53aW5kb3cgPT09IDApIHtcbiAgICAgIHNmdHAuX3dhaXRXaW5kb3cgPSB0cnVlO1xuICAgICAgc2Z0cC5fY2h1bmtjYiA9IGRyYWluQnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChwID09PSAwICYmIGFjdHVhbExlbiA9PT0gbGVuKSB7XG4gICAgICBzZnRwLl9wcm90b2NvbC5jaGFubmVsRGF0YShzZnRwLm91dGdvaW5nLmlkLCBwYXlsb2FkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Z0cC5fcHJvdG9jb2wuY2hhbm5lbERhdGEoc2Z0cC5vdXRnb2luZy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclNsaWNlKHBheWxvYWQsIHAsIHAgKyBhY3R1YWxMZW4pKTtcbiAgICB9XG5cbiAgICBwICs9IGFjdHVhbExlbjtcbiAgfVxuXG4gIGlmIChsZW4gLSBwID4gMCkge1xuICAgIGlmIChwID4gMClcbiAgICAgIHJldCA9IGJ1ZmZlclNsaWNlKHBheWxvYWQsIHAsIGxlbik7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gcGF5bG9hZDsgLy8gWFhYOiBzaG91bGQgbmV2ZXIgZ2V0IGhlcmU/XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkcmFpbkJ1ZmZlcigpIHtcbiAgdGhpcy5fY2h1bmtjYiA9IHVuZGVmaW5lZDtcbiAgY29uc3QgYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgIGNvbnN0IHBheWxvYWQgPSBidWZmZXJbaV07XG4gICAgY29uc3QgcmV0ID0gdHJ5V3JpdGVQYXlsb2FkKHRoaXMsIHBheWxvYWQpO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHJldCAhPT0gcGF5bG9hZClcbiAgICAgICAgYnVmZmVyW2ldID0gcmV0O1xuICAgICAgaWYgKGkgPiAwKVxuICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZmZXIuc2xpY2UoaSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICsraTtcbiAgfVxuICBpZiAoaSA+IDApXG4gICAgdGhpcy5fYnVmZmVyID0gW107XG59XG5cbmZ1bmN0aW9uIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgbXNnLCBub0RlYnVnKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIubGV2ZWwgPSAnc2Z0cC1wcm90b2NvbCc7XG4gIGlmICghbm9EZWJ1ZyAmJiBzZnRwLl9kZWJ1ZylcbiAgICBzZnRwLl9kZWJ1ZyhgU0ZUUDogSW5ib3VuZDogJHttc2d9YCk7XG4gIHNmdHAuZW1pdCgnZXJyb3InLCBlcnIpO1xuICBzZnRwLmRlc3Ryb3koKTtcbiAgY2xlYW51cFJlcXVlc3RzKHNmdHApO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNsZWFudXBSZXF1ZXN0cyhzZnRwKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzZnRwLl9yZXF1ZXN0cyk7XG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG5cbiAgY29uc3QgcmVxcyA9IHNmdHAuX3JlcXVlc3RzO1xuICBzZnRwLl9yZXF1ZXN0cyA9IHt9O1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ05vIHJlc3BvbnNlIGZyb20gc2VydmVyJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHJlcSA9IHJlcXNba2V5c1tpXV07XG4gICAgaWYgKHR5cGVvZiByZXEuY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICByZXEuY2IoZXJyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1ZXN0TGltaXRzKHNmdHAsIGNiKSB7XG4gIC8qXG4gICAgdWludDMyICAgIGlkXG4gICAgc3RyaW5nICAgIFwibGltaXRzQG9wZW5zc2guY29tXCJcbiAgKi9cbiAgbGV0IHAgPSA5O1xuICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIDEgKyA0ICsgNCArIDE4KTtcblxuICB3cml0ZVVJbnQzMkJFKGJ1ZiwgYnVmLmxlbmd0aCAtIDQsIDApO1xuICBidWZbNF0gPSBSRVFVRVNULkVYVEVOREVEO1xuICBjb25zdCByZXFpZCA9IHNmdHAuX3dyaXRlUmVxaWQgPSAoc2Z0cC5fd3JpdGVSZXFpZCArIDEpICYgTUFYX1JFUUlEO1xuICB3cml0ZVVJbnQzMkJFKGJ1ZiwgcmVxaWQsIDUpO1xuXG4gIHdyaXRlVUludDMyQkUoYnVmLCAxOCwgcCk7XG4gIGJ1Zi51dGY4V3JpdGUoJ2xpbWl0c0BvcGVuc3NoLmNvbScsIHAgKz0gNCwgMTgpO1xuXG4gIHNmdHAuX3JlcXVlc3RzW3JlcWlkXSA9IHsgZXh0ZW5kZWQ6ICdsaW1pdHNAb3BlbnNzaC5jb20nLCBjYiB9O1xuXG4gIGNvbnN0IGlzQnVmZmVyZWQgPSBzZW5kT3JCdWZmZXIoc2Z0cCwgYnVmKTtcbiAgaWYgKHNmdHAuX2RlYnVnKSB7XG4gICAgY29uc3Qgd2hpY2ggPSAoaXNCdWZmZXJlZCA/ICdCdWZmZXJlZCcgOiAnU2VuZGluZycpO1xuICAgIHNmdHAuX2RlYnVnKGBTRlRQOiBPdXRib3VuZDogJHt3aGljaH0gbGltaXRzQG9wZW5zc2guY29tYCk7XG4gIH1cbn1cblxuY29uc3QgQ0xJRU5UX0hBTkRMRVJTID0ge1xuICBbUkVTUE9OU0UuVkVSU0lPTl06IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgaWYgKHNmdHAuX3ZlcnNpb24gIT09IC0xKVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ0R1cGxpY2F0ZSBWRVJTSU9OIHBhY2tldCcpO1xuXG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgLypcbiAgICAgIHVpbnQzMiB2ZXJzaW9uXG4gICAgICA8ZXh0ZW5zaW9uIGRhdGE+XG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBsZXQgdmVyc2lvbiA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICB3aGlsZSAoYnVmZmVyUGFyc2VyLmF2YWlsKCkpIHtcbiAgICAgIGNvbnN0IGV4dE5hbWUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgIGNvbnN0IGV4dERhdGEgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgIGlmIChleHREYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmVyc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBleHRlbnNpb25zW2V4dE5hbWVdID0gZXh0RGF0YTtcbiAgICB9XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAodmVyc2lvbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ01hbGZvcm1lZCBWRVJTSU9OIHBhY2tldCcpO1xuXG4gICAgaWYgKHNmdHAuX2RlYnVnKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuICAgICAgaWYgKG5hbWVzLmxlbmd0aCkge1xuICAgICAgICBzZnRwLl9kZWJ1ZyhcbiAgICAgICAgICBgU0ZUUDogSW5ib3VuZDogUmVjZWl2ZWQgVkVSU0lPTiAodiR7dmVyc2lvbn0sIGV4dHM6JHtuYW1lc30pYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Z0cC5fZGVidWcoYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIFZFUlNJT04gKHYke3ZlcnNpb259KWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNmdHAuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHNmdHAuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuXG4gICAgaWYgKGV4dGVuc2lvbnNbJ2xpbWl0c0BvcGVuc3NoLmNvbSddID09PSAnMScpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0TGltaXRzKHNmdHAsIChlcnIsIGxpbWl0cykgPT4ge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIGlmIChsaW1pdHMubWF4UGt0TGVuID4gMClcbiAgICAgICAgICAgIHNmdHAuX21heE91dFBrdExlbiA9IGxpbWl0cy5tYXhQa3RMZW47XG4gICAgICAgICAgaWYgKGxpbWl0cy5tYXhSZWFkTGVuID4gMClcbiAgICAgICAgICAgIHNmdHAuX21heFJlYWRMZW4gPSBsaW1pdHMubWF4UmVhZExlbjtcbiAgICAgICAgICBpZiAobGltaXRzLm1heFdyaXRlTGVuID4gMClcbiAgICAgICAgICAgIHNmdHAuX21heFdyaXRlTGVuID0gbGltaXRzLm1heFdyaXRlTGVuO1xuICAgICAgICAgIHNmdHAubWF4T3BlbkhhbmRsZXMgPSAoXG4gICAgICAgICAgICBsaW1pdHMubWF4T3BlbkhhbmRsZXMgPiAwID8gbGltaXRzLm1heE9wZW5IYW5kbGVzIDogSW5maW5pdHlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHNmdHAuZW1pdCgncmVhZHknKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNmdHAuZW1pdCgncmVhZHknKTtcbiAgfSxcbiAgW1JFU1BPTlNFLlNUQVRVU106IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgcmVxSUQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgLypcbiAgICAgIHVpbnQzMiAgICAgZXJyb3Ivc3RhdHVzIGNvZGVcbiAgICAgIHN0cmluZyAgICAgZXJyb3IgbWVzc2FnZSAoSVNPLTEwNjQ2IFVURi04KVxuICAgICAgc3RyaW5nICAgICBsYW5ndWFnZSB0YWdcbiAgICAqL1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICBjb25zdCBlcnJvck1zZyA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgLy8gTm90ZTogd2UgYXZvaWQgY2hlY2tpbmcgdGhhdCB0aGUgZXJyb3IgbWVzc2FnZSBhbmQgbGFuZ3VhZ2UgdGFnIGFyZSBpblxuICAgIC8vIHRoZSBwYWNrZXQgYmVjYXVzZSB0aGVyZSBhcmUgc29tZSBicm9rZW4gaW1wbGVtZW50YXRpb25zIHRoYXQgaW5jb3JyZWN0bHlcbiAgICAvLyBvbWl0IHRoZW0uIFRoZSBsYW5ndWFnZSB0YWcgaW4gZ2VuZXJhbCB3YXMgbmV2ZXIgcmVhbGx5IHVzZWQgYW1vbmdzdCBzc2hcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMsIHNvIGluIHRoZSBjYXNlIG9mIGEgbWlzc2luZyBlcnJvciBtZXNzYWdlIHdlIGp1c3RcbiAgICAvLyBkZWZhdWx0IHRvIHNvbWV0aGluZyBzZW5zaWJsZS5cblxuICAgIGlmIChzZnRwLl9kZWJ1Zykge1xuICAgICAgY29uc3QganNvbk1zZyA9IEpTT04uc3RyaW5naWZ5KGVycm9yTXNnKTtcbiAgICAgIHNmdHAuX2RlYnVnKFxuICAgICAgICBgU0ZUUDogSW5ib3VuZDogUmVjZWl2ZWQgU1RBVFVTIChpZDoke3JlcUlEfSwgJHtlcnJvckNvZGV9LCAke2pzb25Nc2d9KWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlcSA9IHNmdHAuX3JlcXVlc3RzW3JlcUlEXTtcbiAgICBkZWxldGUgc2Z0cC5fcmVxdWVzdHNbcmVxSURdO1xuICAgIGlmIChyZXEgJiYgdHlwZW9mIHJlcS5jYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGVycm9yQ29kZSA9PT0gU1RBVFVTX0NPREUuT0spIHtcbiAgICAgICAgcmVxLmNiKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihlcnJvck1zZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IFNUQVRVU19DT0RFX1NUUltlcnJvckNvZGVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgJ1Vua25vd24gc3RhdHVzJyk7XG4gICAgICBlcnIuY29kZSA9IGVycm9yQ29kZTtcbiAgICAgIHJlcS5jYihlcnIpO1xuICAgIH1cbiAgfSxcbiAgW1JFU1BPTlNFLkhBTkRMRV06IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgcmVxSUQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgLypcbiAgICAgIHN0cmluZyAgICAgaGFuZGxlXG4gICAgKi9cbiAgICBjb25zdCBoYW5kbGUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKGhhbmRsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocmVxSUQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgZGVsZXRlIHNmdHAuX3JlcXVlc3RzW3JlcUlEXTtcbiAgICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKHNmdHAsICdNYWxmb3JtZWQgSEFORExFIHBhY2tldCcpO1xuICAgIH1cblxuICAgIHNmdHAuX2RlYnVnICYmIHNmdHAuX2RlYnVnKGBTRlRQOiBJbmJvdW5kOiBSZWNlaXZlZCBIQU5ETEUgKGlkOiR7cmVxSUR9KWApO1xuXG4gICAgY29uc3QgcmVxID0gc2Z0cC5fcmVxdWVzdHNbcmVxSURdO1xuICAgIGRlbGV0ZSBzZnRwLl9yZXF1ZXN0c1tyZXFJRF07XG4gICAgaWYgKHJlcSAmJiB0eXBlb2YgcmVxLmNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgcmVxLmNiKHVuZGVmaW5lZCwgaGFuZGxlKTtcbiAgfSxcbiAgW1JFU1BPTlNFLkRBVEFdOiAoc2Z0cCwgcGF5bG9hZCkgPT4ge1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlcUlEID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGxldCByZXE7XG4gICAgaWYgKHJlcUlEICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcSA9IHNmdHAuX3JlcXVlc3RzW3JlcUlEXTtcbiAgICAgIGRlbGV0ZSBzZnRwLl9yZXF1ZXN0c1tyZXFJRF07XG4gICAgfVxuICAgIC8qXG4gICAgICBzdHJpbmcgICAgIGRhdGFcbiAgICAqL1xuICAgIGlmIChyZXEgJiYgdHlwZW9mIHJlcS5jYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHJlcS5idWZmZXIpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHByZS1hbGxvY2F0ZWQgc3BhY2UgdG8gc3RvcmUgdGhlIGRhdGFcblxuICAgICAgICBjb25zdCBuYiA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHJlcS5idWZmZXIpO1xuICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgICAgICBpZiAobmIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNmdHAuX2RlYnVnICYmIHNmdHAuX2RlYnVnKFxuICAgICAgICAgICAgYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIERBVEEgKGlkOiR7cmVxSUR9LCAke25ifSlgXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXEuY2IodW5kZWZpbmVkLCByZXEuYnVmZmVyLCBuYik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkYXRhID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNmdHAuX2RlYnVnICYmIHNmdHAuX2RlYnVnKFxuICAgICAgICAgICAgYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIERBVEEgKGlkOiR7cmVxSUR9LCAke2RhdGEubGVuZ3RofSlgXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXEuY2IodW5kZWZpbmVkLCBkYXRhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmIgPSBidWZmZXJQYXJzZXIuc2tpcFN0cmluZygpO1xuICAgICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG4gICAgICBpZiAobmIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZnRwLl9kZWJ1ZyAmJiBzZnRwLl9kZWJ1ZyhcbiAgICAgICAgICBgU0ZUUDogSW5ib3VuZDogUmVjZWl2ZWQgREFUQSAoaWQ6JHtyZXFJRH0sICR7bmJ9KWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKHNmdHAsICdNYWxmb3JtZWQgREFUQSBwYWNrZXQnKTtcbiAgfSxcbiAgW1JFU1BPTlNFLk5BTUVdOiAoc2Z0cCwgcGF5bG9hZCkgPT4ge1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlcUlEID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGxldCByZXE7XG4gICAgaWYgKHJlcUlEICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcSA9IHNmdHAuX3JlcXVlc3RzW3JlcUlEXTtcbiAgICAgIGRlbGV0ZSBzZnRwLl9yZXF1ZXN0c1tyZXFJRF07XG4gICAgfVxuICAgIC8qXG4gICAgICB1aW50MzIgICAgIGNvdW50XG4gICAgICByZXBlYXRzIGNvdW50IHRpbWVzOlxuICAgICAgICAgICAgICBzdHJpbmcgICAgIGZpbGVuYW1lXG4gICAgICAgICAgICAgIHN0cmluZyAgICAgbG9uZ25hbWVcbiAgICAgICAgICAgICAgQVRUUlMgICAgICBhdHRyc1xuICAgICovXG4gICAgY29uc3QgY291bnQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgaWYgKGNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBuYW1lcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byBhc3N1bWUgVVRGLTggZm9yIGZpbGVuYW1lcyBkZXNwaXRlIHRoZSBTRlRQdjNcbiAgICAgICAgLy8gc3BlYyBub3Qgc3BlY2lmeWluZyBhbiBlbmNvZGluZyBiZWNhdXNlIHRoZSBzcGVjcyBmb3IgbmV3ZXJcbiAgICAgICAgLy8gdmVyc2lvbnMgb2YgdGhlIHByb3RvY29sIGFsbCBleHBsaWNpdGx5IHNwZWNpZnkgVVRGLTggZm9yXG4gICAgICAgIC8vIGZpbGVuYW1lc1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuXG4gICAgICAgIC8vIGBsb25nbmFtZWAgb25seSBleGlzdHMgaW4gU0ZUUHYzIGFuZCBzaW5jZSBpdCB0eXBpY2FsbHkgd2lsbFxuICAgICAgICAvLyBjb250YWluIHRoZSBmaWxlbmFtZSwgd2UgYXNzdW1lIGl0IGlzIGFsc28gVVRGLThcbiAgICAgICAgY29uc3QgbG9uZ25hbWUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcblxuICAgICAgICBjb25zdCBhdHRycyA9IHJlYWRBdHRycyhzZnRwLl9iaU9wdCk7XG4gICAgICAgIGlmIChhdHRycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmFtZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXMucHVzaCh7IGZpbGVuYW1lLCBsb25nbmFtZSwgYXR0cnMgfSk7XG4gICAgICB9XG4gICAgICBpZiAobmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZnRwLl9kZWJ1ZyAmJiBzZnRwLl9kZWJ1ZyhcbiAgICAgICAgICBgU0ZUUDogSW5ib3VuZDogUmVjZWl2ZWQgTkFNRSAoaWQ6JHtyZXFJRH0sICR7bmFtZXMubGVuZ3RofSlgXG4gICAgICAgICk7XG4gICAgICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuICAgICAgICBpZiAocmVxICYmIHR5cGVvZiByZXEuY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgcmVxLmNiKHVuZGVmaW5lZCwgbmFtZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG4gICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ01hbGZvcm1lZCBOQU1FIHBhY2tldCcpO1xuICB9LFxuICBbUkVTUE9OU0UuQVRUUlNdOiAoc2Z0cCwgcGF5bG9hZCkgPT4ge1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlcUlEID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGxldCByZXE7XG4gICAgaWYgKHJlcUlEICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcSA9IHNmdHAuX3JlcXVlc3RzW3JlcUlEXTtcbiAgICAgIGRlbGV0ZSBzZnRwLl9yZXF1ZXN0c1tyZXFJRF07XG4gICAgfVxuICAgIC8qXG4gICAgICBBVFRSUyAgICAgIGF0dHJzXG4gICAgKi9cbiAgICBjb25zdCBhdHRycyA9IHJlYWRBdHRycyhzZnRwLl9iaU9wdCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG4gICAgaWYgKGF0dHJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNmdHAuX2RlYnVnICYmIHNmdHAuX2RlYnVnKGBTRlRQOiBJbmJvdW5kOiBSZWNlaXZlZCBBVFRSUyAoaWQ6JHtyZXFJRH0pYCk7XG4gICAgICBpZiAocmVxICYmIHR5cGVvZiByZXEuY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJlcS5jYih1bmRlZmluZWQsIGF0dHJzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9GYXRhbFNGVFBFcnJvcihzZnRwLCAnTWFsZm9ybWVkIEFUVFJTIHBhY2tldCcpO1xuICB9LFxuICBbUkVTUE9OU0UuRVhURU5ERURdOiAoc2Z0cCwgcGF5bG9hZCkgPT4ge1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlcUlEID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGlmIChyZXFJRCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCByZXEgPSBzZnRwLl9yZXF1ZXN0c1tyZXFJRF07XG4gICAgICBpZiAocmVxKSB7XG4gICAgICAgIGRlbGV0ZSBzZnRwLl9yZXF1ZXN0c1tyZXFJRF07XG4gICAgICAgIHN3aXRjaCAocmVxLmV4dGVuZGVkKSB7XG4gICAgICAgICAgY2FzZSAnc3RhdHZmc0BvcGVuc3NoLmNvbSc6XG4gICAgICAgICAgY2FzZSAnZnN0YXR2ZnNAb3BlbnNzaC5jb20nOiB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICB1aW50NjQgICAgZl9ic2l6ZSAgIC8vIGZpbGUgc3lzdGVtIGJsb2NrIHNpemVcbiAgICAgICAgICAgICAgdWludDY0ICAgIGZfZnJzaXplICAvLyBmdW5kYW1lbnRhbCBmcyBibG9jayBzaXplXG4gICAgICAgICAgICAgIHVpbnQ2NCAgICBmX2Jsb2NrcyAgLy8gbnVtYmVyIG9mIGJsb2NrcyAodW5pdCBmX2Zyc2l6ZSlcbiAgICAgICAgICAgICAgdWludDY0ICAgIGZfYmZyZWUgICAvLyBmcmVlIGJsb2NrcyBpbiBmaWxlIHN5c3RlbVxuICAgICAgICAgICAgICB1aW50NjQgICAgZl9iYXZhaWwgIC8vIGZyZWUgYmxvY2tzIGZvciBub24tcm9vdFxuICAgICAgICAgICAgICB1aW50NjQgICAgZl9maWxlcyAgIC8vIHRvdGFsIGZpbGUgaW5vZGVzXG4gICAgICAgICAgICAgIHVpbnQ2NCAgICBmX2ZmcmVlICAgLy8gZnJlZSBmaWxlIGlub2Rlc1xuICAgICAgICAgICAgICB1aW50NjQgICAgZl9mYXZhaWwgIC8vIGZyZWUgZmlsZSBpbm9kZXMgZm9yIHRvIG5vbi1yb290XG4gICAgICAgICAgICAgIHVpbnQ2NCAgICBmX2ZzaWQgICAgLy8gZmlsZSBzeXN0ZW0gaWRcbiAgICAgICAgICAgICAgdWludDY0ICAgIGZfZmxhZyAgICAvLyBiaXQgbWFzayBvZiBmX2ZsYWcgdmFsdWVzXG4gICAgICAgICAgICAgIHVpbnQ2NCAgICBmX25hbWVtYXggLy8gbWF4aW11bSBmaWxlbmFtZSBsZW5ndGhcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBiaU9wdCA9IHNmdHAuX2JpT3B0O1xuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICAgICAgICAgIGZfYnNpemU6IGJ1ZmZlclBhcnNlci5yZWFkVUludDY0QkUoYmlPcHQpLFxuICAgICAgICAgICAgICBmX2Zyc2l6ZTogYnVmZmVyUGFyc2VyLnJlYWRVSW50NjRCRShiaU9wdCksXG4gICAgICAgICAgICAgIGZfYmxvY2tzOiBidWZmZXJQYXJzZXIucmVhZFVJbnQ2NEJFKGJpT3B0KSxcbiAgICAgICAgICAgICAgZl9iZnJlZTogYnVmZmVyUGFyc2VyLnJlYWRVSW50NjRCRShiaU9wdCksXG4gICAgICAgICAgICAgIGZfYmF2YWlsOiBidWZmZXJQYXJzZXIucmVhZFVJbnQ2NEJFKGJpT3B0KSxcbiAgICAgICAgICAgICAgZl9maWxlczogYnVmZmVyUGFyc2VyLnJlYWRVSW50NjRCRShiaU9wdCksXG4gICAgICAgICAgICAgIGZfZmZyZWU6IGJ1ZmZlclBhcnNlci5yZWFkVUludDY0QkUoYmlPcHQpLFxuICAgICAgICAgICAgICBmX2ZhdmFpbDogYnVmZmVyUGFyc2VyLnJlYWRVSW50NjRCRShiaU9wdCksXG4gICAgICAgICAgICAgIGZfc2lkOiBidWZmZXJQYXJzZXIucmVhZFVJbnQ2NEJFKGJpT3B0KSxcbiAgICAgICAgICAgICAgZl9mbGFnOiBidWZmZXJQYXJzZXIucmVhZFVJbnQ2NEJFKGJpT3B0KSxcbiAgICAgICAgICAgICAgZl9uYW1lbWF4OiBidWZmZXJQYXJzZXIucmVhZFVJbnQ2NEJFKGJpT3B0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc3RhdHMuZl9uYW1lbWF4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHNmdHAuX2RlYnVnKSB7XG4gICAgICAgICAgICAgIHNmdHAuX2RlYnVnKFxuICAgICAgICAgICAgICAgICdTRlRQOiBJbmJvdW5kOiBSZWNlaXZlZCBFWFRFTkRFRF9SRVBMWSAnXG4gICAgICAgICAgICAgICAgICArIGAoaWQ6JHtyZXFJRH0sICR7cmVxLmV4dGVuZGVkfSlgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVxLmNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICByZXEuY2IodW5kZWZpbmVkLCBzdGF0cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2xpbWl0c0BvcGVuc3NoLmNvbSc6IHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIHVpbnQ2NCAgICAgICAgICBtYXgtcGFja2V0LWxlbmd0aFxuICAgICAgICAgICAgICB1aW50NjQgICAgICAgICAgbWF4LXJlYWQtbGVuZ3RoXG4gICAgICAgICAgICAgIHVpbnQ2NCAgICAgICAgICBtYXgtd3JpdGUtbGVuZ3RoXG4gICAgICAgICAgICAgIHVpbnQ2NCAgICAgICAgICBtYXgtb3Blbi1oYW5kbGVzXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgbGltaXRzID0ge1xuICAgICAgICAgICAgICBtYXhQa3RMZW46IGJ1ZmZlclBhcnNlci5yZWFkVUludDY0QkUoKSxcbiAgICAgICAgICAgICAgbWF4UmVhZExlbjogYnVmZmVyUGFyc2VyLnJlYWRVSW50NjRCRSgpLFxuICAgICAgICAgICAgICBtYXhXcml0ZUxlbjogYnVmZmVyUGFyc2VyLnJlYWRVSW50NjRCRSgpLFxuICAgICAgICAgICAgICBtYXhPcGVuSGFuZGxlczogYnVmZmVyUGFyc2VyLnJlYWRVSW50NjRCRSgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChsaW1pdHMubWF4T3BlbkhhbmRsZXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoc2Z0cC5fZGVidWcpIHtcbiAgICAgICAgICAgICAgc2Z0cC5fZGVidWcoXG4gICAgICAgICAgICAgICAgJ1NGVFA6IEluYm91bmQ6IFJlY2VpdmVkIEVYVEVOREVEX1JFUExZICdcbiAgICAgICAgICAgICAgICAgICsgYChpZDoke3JlcUlEfSwgJHtyZXEuZXh0ZW5kZWR9KWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXEuY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgIHJlcS5jYih1bmRlZmluZWQsIGxpbWl0cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3VzZXJzLWdyb3Vwcy1ieS1pZEBvcGVuc3NoLmNvbSc6IHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIHN0cmluZyAgICB1c2VybmFtZXNcbiAgICAgICAgICAgICAgICBzdHJpbmcgICAgdXNlcm5hbWUxXG4gICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICAgIHN0cmluZyAgICBncm91cG5hbWVzXG4gICAgICAgICAgICAgICAgc3RyaW5nICAgIGdyb3VwbmFtZTFcbiAgICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB1c2VybmFtZUNvdW50ID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICAgICAgaWYgKHVzZXJuYW1lQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCB1c2VybmFtZXMgPSBuZXcgQXJyYXkodXNlcm5hbWVDb3VudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVzZXJuYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgdXNlcm5hbWVzW2ldID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGdyb3VwbmFtZUNvdW50ID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgICAgICAgaWYgKGdyb3VwbmFtZUNvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBuYW1lcyA9IG5ldyBBcnJheShncm91cG5hbWVDb3VudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwbmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGdyb3VwbmFtZXNbaV0gPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgICAgICAgIGlmIChncm91cG5hbWVzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAmJiBncm91cG5hbWVzW2dyb3VwbmFtZXMubGVuZ3RoIC0gMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNmdHAuX2RlYnVnKSB7XG4gICAgICAgICAgICAgIHNmdHAuX2RlYnVnKFxuICAgICAgICAgICAgICAgICdTRlRQOiBJbmJvdW5kOiBSZWNlaXZlZCBFWFRFTkRFRF9SRVBMWSAnXG4gICAgICAgICAgICAgICAgICArIGAoaWQ6JHtyZXFJRH0sICR7cmVxLmV4dGVuZGVkfSlgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVxLmNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICByZXEuY2IodW5kZWZpbmVkLCB1c2VybmFtZXMsIGdyb3VwbmFtZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gVW5rbm93biBleHRlbmRlZCByZXF1ZXN0XG4gICAgICAgICAgICBzZnRwLl9kZWJ1ZyAmJiBzZnRwLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIEVYVEVOREVEX1JFUExZIChpZDoke3JlcUlEfSwgPz8/KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVxLmNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICByZXEuY2IoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Z0cC5fZGVidWcgJiYgc2Z0cC5fZGVidWcoXG4gICAgICAgICAgYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIEVYVEVOREVEX1JFUExZIChpZDoke3JlcUlEfSwgPz8/KWBcbiAgICAgICAgKTtcbiAgICAgICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcbiAgICByZXR1cm4gZG9GYXRhbFNGVFBFcnJvcihzZnRwLCAnTWFsZm9ybWVkIEVYVEVOREVEX1JFUExZIHBhY2tldCcpO1xuICB9LFxufTtcbmNvbnN0IFNFUlZFUl9IQU5ETEVSUyA9IHtcbiAgW1JFUVVFU1QuSU5JVF06IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgaWYgKHNmdHAuX3ZlcnNpb24gIT09IC0xKVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ0R1cGxpY2F0ZSBJTklUIHBhY2tldCcpO1xuXG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgLypcbiAgICAgIHVpbnQzMiB2ZXJzaW9uXG4gICAgICA8ZXh0ZW5zaW9uIGRhdGE+XG4gICAgKi9cbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBsZXQgdmVyc2lvbiA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICB3aGlsZSAoYnVmZmVyUGFyc2VyLmF2YWlsKCkpIHtcbiAgICAgIGNvbnN0IGV4dE5hbWUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgIGNvbnN0IGV4dERhdGEgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICAgIGlmIChleHREYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmVyc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBleHRlbnNpb25zW2V4dE5hbWVdID0gZXh0RGF0YTtcbiAgICB9XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAodmVyc2lvbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ01hbGZvcm1lZCBJTklUIHBhY2tldCcpO1xuXG4gICAgaWYgKHNmdHAuX2RlYnVnKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuICAgICAgaWYgKG5hbWVzLmxlbmd0aCkge1xuICAgICAgICBzZnRwLl9kZWJ1ZyhcbiAgICAgICAgICBgU0ZUUDogSW5ib3VuZDogUmVjZWl2ZWQgSU5JVCAodiR7dmVyc2lvbn0sIGV4dHM6JHtuYW1lc30pYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Z0cC5fZGVidWcoYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIElOSVQgKHYke3ZlcnNpb259KWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbmRPckJ1ZmZlcihzZnRwLCBTRVJWRVJfVkVSU0lPTl9CVUZGRVIpO1xuXG4gICAgc2Z0cC5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgc2Z0cC5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgc2Z0cC5lbWl0KCdyZWFkeScpO1xuICB9LFxuICBbUkVRVUVTVC5PUEVOXTogKHNmdHAsIHBheWxvYWQpID0+IHtcbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZXFJRCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAvKlxuICAgICAgc3RyaW5nICAgICAgICBmaWxlbmFtZVxuICAgICAgdWludDMyICAgICAgICBwZmxhZ3NcbiAgICAgIEFUVFJTICAgICAgICAgYXR0cnNcbiAgICAqL1xuICAgIGNvbnN0IGZpbGVuYW1lID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgY29uc3QgcGZsYWdzID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGNvbnN0IGF0dHJzID0gcmVhZEF0dHJzKHNmdHAuX2JpT3B0KTtcbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgIGlmIChhdHRycyA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ01hbGZvcm1lZCBPUEVOIHBhY2tldCcpO1xuXG4gICAgc2Z0cC5fZGVidWcgJiYgc2Z0cC5fZGVidWcoYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIE9QRU4gKGlkOiR7cmVxSUR9KWApO1xuXG4gICAgaWYgKCFzZnRwLmVtaXQoJ09QRU4nLCByZXFJRCwgZmlsZW5hbWUsIHBmbGFncywgYXR0cnMpKSB7XG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlamVjdCByZXF1ZXN0IGlmIG5vIGhhbmRsZXIgZm9yIHJlcXVlc3QgdHlwZVxuICAgICAgc2Z0cC5zdGF0dXMocmVxSUQsIFNUQVRVU19DT0RFLk9QX1VOU1VQUE9SVEVEKTtcbiAgICB9XG4gIH0sXG4gIFtSRVFVRVNULkNMT1NFXTogKHNmdHAsIHBheWxvYWQpID0+IHtcbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZXFJRCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAvKlxuICAgICAgc3RyaW5nICAgICAgICBoYW5kbGVcbiAgICAqL1xuICAgIGNvbnN0IGhhbmRsZSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAoaGFuZGxlID09PSB1bmRlZmluZWQgfHwgaGFuZGxlLmxlbmd0aCA+IDI1NilcbiAgICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKHNmdHAsICdNYWxmb3JtZWQgQ0xPU0UgcGFja2V0Jyk7XG5cbiAgICBzZnRwLl9kZWJ1ZyAmJiBzZnRwLl9kZWJ1ZyhgU0ZUUDogSW5ib3VuZDogUmVjZWl2ZWQgQ0xPU0UgKGlkOiR7cmVxSUR9KWApO1xuXG4gICAgaWYgKCFzZnRwLmVtaXQoJ0NMT1NFJywgcmVxSUQsIGhhbmRsZSkpIHtcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVqZWN0IHJlcXVlc3QgaWYgbm8gaGFuZGxlciBmb3IgcmVxdWVzdCB0eXBlXG4gICAgICBzZnRwLnN0YXR1cyhyZXFJRCwgU1RBVFVTX0NPREUuT1BfVU5TVVBQT1JURUQpO1xuICAgIH1cbiAgfSxcbiAgW1JFUVVFU1QuUkVBRF06IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgcmVxSUQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgLypcbiAgICAgIHN0cmluZyAgICAgaGFuZGxlXG4gICAgICB1aW50NjQgICAgIG9mZnNldFxuICAgICAgdWludDMyICAgICBsZW5cbiAgICAqL1xuICAgIGNvbnN0IGhhbmRsZSA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50NjRCRShzZnRwLl9iaU9wdCk7XG4gICAgY29uc3QgbGVuID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkIHx8IGhhbmRsZS5sZW5ndGggPiAyNTYpXG4gICAgICByZXR1cm4gZG9GYXRhbFNGVFBFcnJvcihzZnRwLCAnTWFsZm9ybWVkIFJFQUQgcGFja2V0Jyk7XG5cbiAgICBzZnRwLl9kZWJ1ZyAmJiBzZnRwLl9kZWJ1ZyhgU0ZUUDogSW5ib3VuZDogUmVjZWl2ZWQgUkVBRCAoaWQ6JHtyZXFJRH0pYCk7XG5cbiAgICBpZiAoIXNmdHAuZW1pdCgnUkVBRCcsIHJlcUlELCBoYW5kbGUsIG9mZnNldCwgbGVuKSkge1xuICAgICAgLy8gQXV0b21hdGljYWxseSByZWplY3QgcmVxdWVzdCBpZiBubyBoYW5kbGVyIGZvciByZXF1ZXN0IHR5cGVcbiAgICAgIHNmdHAuc3RhdHVzKHJlcUlELCBTVEFUVVNfQ09ERS5PUF9VTlNVUFBPUlRFRCk7XG4gICAgfVxuICB9LFxuICBbUkVRVUVTVC5XUklURV06IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgcmVxSUQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgLypcbiAgICAgIHN0cmluZyAgICAgaGFuZGxlXG4gICAgICB1aW50NjQgICAgIG9mZnNldFxuICAgICAgc3RyaW5nICAgICBkYXRhXG4gICAgKi9cbiAgICBjb25zdCBoYW5kbGUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgIGNvbnN0IG9mZnNldCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDY0QkUoc2Z0cC5fYmlPcHQpO1xuICAgIGNvbnN0IGRhdGEgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCBoYW5kbGUubGVuZ3RoID4gMjU2KVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ01hbGZvcm1lZCBXUklURSBwYWNrZXQnKTtcblxuICAgIHNmdHAuX2RlYnVnICYmIHNmdHAuX2RlYnVnKGBTRlRQOiBJbmJvdW5kOiBSZWNlaXZlZCBXUklURSAoaWQ6JHtyZXFJRH0pYCk7XG5cbiAgICBpZiAoIXNmdHAuZW1pdCgnV1JJVEUnLCByZXFJRCwgaGFuZGxlLCBvZmZzZXQsIGRhdGEpKSB7XG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlamVjdCByZXF1ZXN0IGlmIG5vIGhhbmRsZXIgZm9yIHJlcXVlc3QgdHlwZVxuICAgICAgc2Z0cC5zdGF0dXMocmVxSUQsIFNUQVRVU19DT0RFLk9QX1VOU1VQUE9SVEVEKTtcbiAgICB9XG4gIH0sXG4gIFtSRVFVRVNULkxTVEFUXTogKHNmdHAsIHBheWxvYWQpID0+IHtcbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZXFJRCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAvKlxuICAgICAgc3RyaW5nICAgICBwYXRoXG4gICAgKi9cbiAgICBjb25zdCBwYXRoID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ01hbGZvcm1lZCBMU1RBVCBwYWNrZXQnKTtcblxuICAgIHNmdHAuX2RlYnVnICYmIHNmdHAuX2RlYnVnKGBTRlRQOiBJbmJvdW5kOiBSZWNlaXZlZCBMU1RBVCAoaWQ6JHtyZXFJRH0pYCk7XG5cbiAgICBpZiAoIXNmdHAuZW1pdCgnTFNUQVQnLCByZXFJRCwgcGF0aCkpIHtcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVqZWN0IHJlcXVlc3QgaWYgbm8gaGFuZGxlciBmb3IgcmVxdWVzdCB0eXBlXG4gICAgICBzZnRwLnN0YXR1cyhyZXFJRCwgU1RBVFVTX0NPREUuT1BfVU5TVVBQT1JURUQpO1xuICAgIH1cbiAgfSxcbiAgW1JFUVVFU1QuRlNUQVRdOiAoc2Z0cCwgcGF5bG9hZCkgPT4ge1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlcUlEID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIC8qXG4gICAgICBzdHJpbmcgICAgICAgIGhhbmRsZVxuICAgICovXG4gICAgY29uc3QgaGFuZGxlID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgIGlmIChoYW5kbGUgPT09IHVuZGVmaW5lZCB8fCBoYW5kbGUubGVuZ3RoID4gMjU2KVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ01hbGZvcm1lZCBGU1RBVCBwYWNrZXQnKTtcblxuICAgIHNmdHAuX2RlYnVnICYmIHNmdHAuX2RlYnVnKGBTRlRQOiBJbmJvdW5kOiBSZWNlaXZlZCBGU1RBVCAoaWQ6JHtyZXFJRH0pYCk7XG5cbiAgICBpZiAoIXNmdHAuZW1pdCgnRlNUQVQnLCByZXFJRCwgaGFuZGxlKSkge1xuICAgICAgLy8gQXV0b21hdGljYWxseSByZWplY3QgcmVxdWVzdCBpZiBubyBoYW5kbGVyIGZvciByZXF1ZXN0IHR5cGVcbiAgICAgIHNmdHAuc3RhdHVzKHJlcUlELCBTVEFUVVNfQ09ERS5PUF9VTlNVUFBPUlRFRCk7XG4gICAgfVxuICB9LFxuICBbUkVRVUVTVC5TRVRTVEFUXTogKHNmdHAsIHBheWxvYWQpID0+IHtcbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZXFJRCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAvKlxuICAgICAgc3RyaW5nICAgICBwYXRoXG4gICAgICBBVFRSUyAgICAgIGF0dHJzXG4gICAgKi9cbiAgICBjb25zdCBwYXRoID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgY29uc3QgYXR0cnMgPSByZWFkQXR0cnMoc2Z0cC5fYmlPcHQpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKGF0dHJzID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gZG9GYXRhbFNGVFBFcnJvcihzZnRwLCAnTWFsZm9ybWVkIFNFVFNUQVQgcGFja2V0Jyk7XG5cbiAgICBzZnRwLl9kZWJ1ZyAmJiBzZnRwLl9kZWJ1ZyhgU0ZUUDogSW5ib3VuZDogUmVjZWl2ZWQgU0VUU1RBVCAoaWQ6JHtyZXFJRH0pYCk7XG5cbiAgICBpZiAoIXNmdHAuZW1pdCgnU0VUU1RBVCcsIHJlcUlELCBwYXRoLCBhdHRycykpIHtcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVqZWN0IHJlcXVlc3QgaWYgbm8gaGFuZGxlciBmb3IgcmVxdWVzdCB0eXBlXG4gICAgICBzZnRwLnN0YXR1cyhyZXFJRCwgU1RBVFVTX0NPREUuT1BfVU5TVVBQT1JURUQpO1xuICAgIH1cbiAgfSxcbiAgW1JFUVVFU1QuRlNFVFNUQVRdOiAoc2Z0cCwgcGF5bG9hZCkgPT4ge1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlcUlEID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIC8qXG4gICAgICBzdHJpbmcgICAgIGhhbmRsZVxuICAgICAgQVRUUlMgICAgICBhdHRyc1xuICAgICovXG4gICAgY29uc3QgaGFuZGxlID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICBjb25zdCBhdHRycyA9IHJlYWRBdHRycyhzZnRwLl9iaU9wdCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAoYXR0cnMgPT09IHVuZGVmaW5lZCB8fCBoYW5kbGUubGVuZ3RoID4gMjU2KVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ01hbGZvcm1lZCBGU0VUU1RBVCBwYWNrZXQnKTtcblxuICAgIHNmdHAuX2RlYnVnICYmIHNmdHAuX2RlYnVnKFxuICAgICAgYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIEZTRVRTVEFUIChpZDoke3JlcUlEfSlgXG4gICAgKTtcblxuICAgIGlmICghc2Z0cC5lbWl0KCdGU0VUU1RBVCcsIHJlcUlELCBoYW5kbGUsIGF0dHJzKSkge1xuICAgICAgLy8gQXV0b21hdGljYWxseSByZWplY3QgcmVxdWVzdCBpZiBubyBoYW5kbGVyIGZvciByZXF1ZXN0IHR5cGVcbiAgICAgIHNmdHAuc3RhdHVzKHJlcUlELCBTVEFUVVNfQ09ERS5PUF9VTlNVUFBPUlRFRCk7XG4gICAgfVxuICB9LFxuICBbUkVRVUVTVC5PUEVORElSXTogKHNmdHAsIHBheWxvYWQpID0+IHtcbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZXFJRCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAvKlxuICAgICAgc3RyaW5nICAgICBwYXRoXG4gICAgKi9cbiAgICBjb25zdCBwYXRoID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ01hbGZvcm1lZCBPUEVORElSIHBhY2tldCcpO1xuXG4gICAgc2Z0cC5fZGVidWcgJiYgc2Z0cC5fZGVidWcoYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIE9QRU5ESVIgKGlkOiR7cmVxSUR9KWApO1xuXG4gICAgaWYgKCFzZnRwLmVtaXQoJ09QRU5ESVInLCByZXFJRCwgcGF0aCkpIHtcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVqZWN0IHJlcXVlc3QgaWYgbm8gaGFuZGxlciBmb3IgcmVxdWVzdCB0eXBlXG4gICAgICBzZnRwLnN0YXR1cyhyZXFJRCwgU1RBVFVTX0NPREUuT1BfVU5TVVBQT1JURUQpO1xuICAgIH1cbiAgfSxcbiAgW1JFUVVFU1QuUkVBRERJUl06IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgcmVxSUQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgLypcbiAgICAgIHN0cmluZyAgICAgICAgaGFuZGxlXG4gICAgKi9cbiAgICBjb25zdCBoYW5kbGUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZygpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKGhhbmRsZSA9PT0gdW5kZWZpbmVkIHx8IGhhbmRsZS5sZW5ndGggPiAyNTYpXG4gICAgICByZXR1cm4gZG9GYXRhbFNGVFBFcnJvcihzZnRwLCAnTWFsZm9ybWVkIFJFQURESVIgcGFja2V0Jyk7XG5cbiAgICBzZnRwLl9kZWJ1ZyAmJiBzZnRwLl9kZWJ1ZyhgU0ZUUDogSW5ib3VuZDogUmVjZWl2ZWQgUkVBRERJUiAoaWQ6JHtyZXFJRH0pYCk7XG5cbiAgICBpZiAoIXNmdHAuZW1pdCgnUkVBRERJUicsIHJlcUlELCBoYW5kbGUpKSB7XG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlamVjdCByZXF1ZXN0IGlmIG5vIGhhbmRsZXIgZm9yIHJlcXVlc3QgdHlwZVxuICAgICAgc2Z0cC5zdGF0dXMocmVxSUQsIFNUQVRVU19DT0RFLk9QX1VOU1VQUE9SVEVEKTtcbiAgICB9XG4gIH0sXG4gIFtSRVFVRVNULlJFTU9WRV06IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgcmVxSUQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgLypcbiAgICAgIHN0cmluZyAgICAgcGF0aFxuICAgICovXG4gICAgY29uc3QgcGF0aCA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKHNmdHAsICdNYWxmb3JtZWQgUkVNT1ZFIHBhY2tldCcpO1xuXG4gICAgc2Z0cC5fZGVidWcgJiYgc2Z0cC5fZGVidWcoYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIFJFTU9WRSAoaWQ6JHtyZXFJRH0pYCk7XG5cbiAgICBpZiAoIXNmdHAuZW1pdCgnUkVNT1ZFJywgcmVxSUQsIHBhdGgpKSB7XG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlamVjdCByZXF1ZXN0IGlmIG5vIGhhbmRsZXIgZm9yIHJlcXVlc3QgdHlwZVxuICAgICAgc2Z0cC5zdGF0dXMocmVxSUQsIFNUQVRVU19DT0RFLk9QX1VOU1VQUE9SVEVEKTtcbiAgICB9XG4gIH0sXG4gIFtSRVFVRVNULk1LRElSXTogKHNmdHAsIHBheWxvYWQpID0+IHtcbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZXFJRCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAvKlxuICAgICAgc3RyaW5nICAgICBwYXRoXG4gICAgICBBVFRSUyAgICAgIGF0dHJzXG4gICAgKi9cbiAgICBjb25zdCBwYXRoID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgY29uc3QgYXR0cnMgPSByZWFkQXR0cnMoc2Z0cC5fYmlPcHQpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKGF0dHJzID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gZG9GYXRhbFNGVFBFcnJvcihzZnRwLCAnTWFsZm9ybWVkIE1LRElSIHBhY2tldCcpO1xuXG4gICAgc2Z0cC5fZGVidWcgJiYgc2Z0cC5fZGVidWcoYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIE1LRElSIChpZDoke3JlcUlEfSlgKTtcblxuICAgIGlmICghc2Z0cC5lbWl0KCdNS0RJUicsIHJlcUlELCBwYXRoLCBhdHRycykpIHtcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVqZWN0IHJlcXVlc3QgaWYgbm8gaGFuZGxlciBmb3IgcmVxdWVzdCB0eXBlXG4gICAgICBzZnRwLnN0YXR1cyhyZXFJRCwgU1RBVFVTX0NPREUuT1BfVU5TVVBQT1JURUQpO1xuICAgIH1cbiAgfSxcbiAgW1JFUVVFU1QuUk1ESVJdOiAoc2Z0cCwgcGF5bG9hZCkgPT4ge1xuICAgIGJ1ZmZlclBhcnNlci5pbml0KHBheWxvYWQsIDEpO1xuICAgIGNvbnN0IHJlcUlEID0gYnVmZmVyUGFyc2VyLnJlYWRVSW50MzJCRSgpO1xuICAgIC8qXG4gICAgICBzdHJpbmcgICAgIHBhdGhcbiAgICAqL1xuICAgIGNvbnN0IHBhdGggPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gZG9GYXRhbFNGVFBFcnJvcihzZnRwLCAnTWFsZm9ybWVkIFJNRElSIHBhY2tldCcpO1xuXG4gICAgc2Z0cC5fZGVidWcgJiYgc2Z0cC5fZGVidWcoYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIFJNRElSIChpZDoke3JlcUlEfSlgKTtcblxuICAgIGlmICghc2Z0cC5lbWl0KCdSTURJUicsIHJlcUlELCBwYXRoKSkge1xuICAgICAgLy8gQXV0b21hdGljYWxseSByZWplY3QgcmVxdWVzdCBpZiBubyBoYW5kbGVyIGZvciByZXF1ZXN0IHR5cGVcbiAgICAgIHNmdHAuc3RhdHVzKHJlcUlELCBTVEFUVVNfQ09ERS5PUF9VTlNVUFBPUlRFRCk7XG4gICAgfVxuICB9LFxuICBbUkVRVUVTVC5SRUFMUEFUSF06IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgcmVxSUQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgLypcbiAgICAgIHN0cmluZyAgICAgcGF0aFxuICAgICovXG4gICAgY29uc3QgcGF0aCA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKHNmdHAsICdNYWxmb3JtZWQgUkVBTFBBVEggcGFja2V0Jyk7XG5cbiAgICBzZnRwLl9kZWJ1ZyAmJiBzZnRwLl9kZWJ1ZyhcbiAgICAgIGBTRlRQOiBJbmJvdW5kOiBSZWNlaXZlZCBSRUFMUEFUSCAoaWQ6JHtyZXFJRH0pYFxuICAgICk7XG5cbiAgICBpZiAoIXNmdHAuZW1pdCgnUkVBTFBBVEgnLCByZXFJRCwgcGF0aCkpIHtcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVqZWN0IHJlcXVlc3QgaWYgbm8gaGFuZGxlciBmb3IgcmVxdWVzdCB0eXBlXG4gICAgICBzZnRwLnN0YXR1cyhyZXFJRCwgU1RBVFVTX0NPREUuT1BfVU5TVVBQT1JURUQpO1xuICAgIH1cbiAgfSxcbiAgW1JFUVVFU1QuU1RBVF06IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgcmVxSUQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgLypcbiAgICAgIHN0cmluZyAgICAgcGF0aFxuICAgICovXG4gICAgY29uc3QgcGF0aCA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKHNmdHAsICdNYWxmb3JtZWQgU1RBVCBwYWNrZXQnKTtcblxuICAgIHNmdHAuX2RlYnVnICYmIHNmdHAuX2RlYnVnKGBTRlRQOiBJbmJvdW5kOiBSZWNlaXZlZCBTVEFUIChpZDoke3JlcUlEfSlgKTtcblxuICAgIGlmICghc2Z0cC5lbWl0KCdTVEFUJywgcmVxSUQsIHBhdGgpKSB7XG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlamVjdCByZXF1ZXN0IGlmIG5vIGhhbmRsZXIgZm9yIHJlcXVlc3QgdHlwZVxuICAgICAgc2Z0cC5zdGF0dXMocmVxSUQsIFNUQVRVU19DT0RFLk9QX1VOU1VQUE9SVEVEKTtcbiAgICB9XG4gIH0sXG4gIFtSRVFVRVNULlJFTkFNRV06IChzZnRwLCBwYXlsb2FkKSA9PiB7XG4gICAgYnVmZmVyUGFyc2VyLmluaXQocGF5bG9hZCwgMSk7XG4gICAgY29uc3QgcmVxSUQgPSBidWZmZXJQYXJzZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgLypcbiAgICAgIHN0cmluZyAgICAgb2xkcGF0aFxuICAgICAgc3RyaW5nICAgICBuZXdwYXRoXG4gICAgKi9cbiAgICBjb25zdCBvbGRQYXRoID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgY29uc3QgbmV3UGF0aCA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgIGJ1ZmZlclBhcnNlci5jbGVhcigpO1xuXG4gICAgaWYgKG5ld1BhdGggPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKHNmdHAsICdNYWxmb3JtZWQgUkVOQU1FIHBhY2tldCcpO1xuXG4gICAgc2Z0cC5fZGVidWcgJiYgc2Z0cC5fZGVidWcoYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIFJFTkFNRSAoaWQ6JHtyZXFJRH0pYCk7XG5cbiAgICBpZiAoIXNmdHAuZW1pdCgnUkVOQU1FJywgcmVxSUQsIG9sZFBhdGgsIG5ld1BhdGgpKSB7XG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlamVjdCByZXF1ZXN0IGlmIG5vIGhhbmRsZXIgZm9yIHJlcXVlc3QgdHlwZVxuICAgICAgc2Z0cC5zdGF0dXMocmVxSUQsIFNUQVRVU19DT0RFLk9QX1VOU1VQUE9SVEVEKTtcbiAgICB9XG4gIH0sXG4gIFtSRVFVRVNULlJFQURMSU5LXTogKHNmdHAsIHBheWxvYWQpID0+IHtcbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZXFJRCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAvKlxuICAgICAgc3RyaW5nICAgICBwYXRoXG4gICAgKi9cbiAgICBjb25zdCBwYXRoID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIGRvRmF0YWxTRlRQRXJyb3Ioc2Z0cCwgJ01hbGZvcm1lZCBSRUFETElOSyBwYWNrZXQnKTtcblxuICAgIHNmdHAuX2RlYnVnICYmIHNmdHAuX2RlYnVnKFxuICAgICAgYFNGVFA6IEluYm91bmQ6IFJlY2VpdmVkIFJFQURMSU5LIChpZDoke3JlcUlEfSlgXG4gICAgKTtcblxuICAgIGlmICghc2Z0cC5lbWl0KCdSRUFETElOSycsIHJlcUlELCBwYXRoKSkge1xuICAgICAgLy8gQXV0b21hdGljYWxseSByZWplY3QgcmVxdWVzdCBpZiBubyBoYW5kbGVyIGZvciByZXF1ZXN0IHR5cGVcbiAgICAgIHNmdHAuc3RhdHVzKHJlcUlELCBTVEFUVVNfQ09ERS5PUF9VTlNVUFBPUlRFRCk7XG4gICAgfVxuICB9LFxuICBbUkVRVUVTVC5TWU1MSU5LXTogKHNmdHAsIHBheWxvYWQpID0+IHtcbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZXFJRCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAvKlxuICAgICAgc3RyaW5nICAgICBsaW5rcGF0aFxuICAgICAgc3RyaW5nICAgICB0YXJnZXRwYXRoXG4gICAgKi9cbiAgICBjb25zdCBsaW5rUGF0aCA9IGJ1ZmZlclBhcnNlci5yZWFkU3RyaW5nKHRydWUpO1xuICAgIGNvbnN0IHRhcmdldFBhdGggPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgIGlmICh0YXJnZXRQYXRoID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gZG9GYXRhbFNGVFBFcnJvcihzZnRwLCAnTWFsZm9ybWVkIFNZTUxJTksgcGFja2V0Jyk7XG5cbiAgICBzZnRwLl9kZWJ1ZyAmJiBzZnRwLl9kZWJ1ZyhgU0ZUUDogSW5ib3VuZDogUmVjZWl2ZWQgU1lNTElOSyAoaWQ6JHtyZXFJRH0pYCk7XG5cbiAgICBsZXQgaGFuZGxlZDtcbiAgICBpZiAoc2Z0cC5faXNPcGVuU1NIKSB7XG4gICAgICAvLyBPcGVuU1NIIGhhcyBsaW5rcGF0aCBhbmQgdGFyZ2V0cGF0aCBwb3NpdGlvbnMgc3dpdGNoZWRcbiAgICAgIGhhbmRsZWQgPSBzZnRwLmVtaXQoJ1NZTUxJTksnLCByZXFJRCwgdGFyZ2V0UGF0aCwgbGlua1BhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVkID0gc2Z0cC5lbWl0KCdTWU1MSU5LJywgcmVxSUQsIGxpbmtQYXRoLCB0YXJnZXRQYXRoKTtcbiAgICB9XG4gICAgaWYgKCFoYW5kbGVkKSB7XG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlamVjdCByZXF1ZXN0IGlmIG5vIGhhbmRsZXIgZm9yIHJlcXVlc3QgdHlwZVxuICAgICAgc2Z0cC5zdGF0dXMocmVxSUQsIFNUQVRVU19DT0RFLk9QX1VOU1VQUE9SVEVEKTtcbiAgICB9XG4gIH0sXG4gIFtSRVFVRVNULkVYVEVOREVEXTogKHNmdHAsIHBheWxvYWQpID0+IHtcbiAgICBidWZmZXJQYXJzZXIuaW5pdChwYXlsb2FkLCAxKTtcbiAgICBjb25zdCByZXFJRCA9IGJ1ZmZlclBhcnNlci5yZWFkVUludDMyQkUoKTtcbiAgICAvKlxuICAgICAgc3RyaW5nICAgICBleHRlbmRlZC1yZXF1ZXN0XG4gICAgICAuLi4gYW55IHJlcXVlc3Qtc3BlY2lmaWMgZGF0YSAuLi5cbiAgICAqL1xuICAgIGNvbnN0IGV4dE5hbWUgPSBidWZmZXJQYXJzZXIucmVhZFN0cmluZyh0cnVlKTtcbiAgICBpZiAoZXh0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcbiAgICAgIHJldHVybiBkb0ZhdGFsU0ZUUEVycm9yKHNmdHAsICdNYWxmb3JtZWQgRVhURU5ERUQgcGFja2V0Jyk7XG4gICAgfVxuXG4gICAgbGV0IGV4dERhdGE7XG4gICAgaWYgKGJ1ZmZlclBhcnNlci5hdmFpbCgpKVxuICAgICAgZXh0RGF0YSA9IGJ1ZmZlclBhcnNlci5yZWFkUmF3KCk7XG4gICAgYnVmZmVyUGFyc2VyLmNsZWFyKCk7XG5cbiAgICBzZnRwLl9kZWJ1ZyAmJiBzZnRwLl9kZWJ1ZyhcbiAgICAgIGBTRlRQOiBJbmJvdW5kOiBSZWNlaXZlZCBFWFRFTkRFRCAoaWQ6JHtyZXFJRH0pYFxuICAgICk7XG5cbiAgICBpZiAoIXNmdHAuZW1pdCgnRVhURU5ERUQnLCByZXFJRCwgZXh0TmFtZSwgZXh0RGF0YSkpIHtcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVqZWN0IHJlcXVlc3QgaWYgbm8gaGFuZGxlciBmb3IgcmVxdWVzdCB0eXBlXG4gICAgICBzZnRwLnN0YXR1cyhyZXFJRCwgU1RBVFVTX0NPREUuT1BfVU5TVVBQT1JURUQpO1xuICAgIH1cbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSZWFkU3RyZWFtL1dyaXRlU3RyZWFtLXJlbGF0ZWQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IHtcbiAgRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gIEVSUl9PVVRfT0ZfUkFOR0UsXG4gIHZhbGlkYXRlTnVtYmVyXG59ID0gcmVxdWlyZSgnLi9ub2RlLWZzLWNvbXBhdCcpO1xuXG5jb25zdCBrTWluUG9vbFNwYWNlID0gMTI4O1xuXG5sZXQgcG9vbDtcbi8vIEl0IGNhbiBoYXBwZW4gdGhhdCB3ZSBleHBlY3QgdG8gcmVhZCBhIGxhcmdlIGNodW5rIG9mIGRhdGEsIGFuZCByZXNlcnZlXG4vLyBhIGxhcmdlIGNodW5rIG9mIHRoZSBwb29sIGFjY29yZGluZ2x5LCBidXQgdGhlIHJlYWQoKSBjYWxsIG9ubHkgZmlsbGVkXG4vLyBhIHBvcnRpb24gb2YgaXQuIElmIGEgY29uY3VycmVudGx5IGV4ZWN1dGluZyByZWFkKCkgdGhlbiB1c2VzIHRoZSBzYW1lIHBvb2wsXG4vLyB0aGUgXCJyZXNlcnZlZFwiIHBvcnRpb24gY2Fubm90IGJlIHVzZWQsIHNvIHdlIGFsbG93IGl0IHRvIGJlIHJlLXVzZWQgYXMgYVxuLy8gbmV3IHBvb2wgbGF0ZXIuXG5jb25zdCBwb29sRnJhZ21lbnRzID0gW107XG5cbmZ1bmN0aW9uIGFsbG9jTmV3UG9vbChwb29sU2l6ZSkge1xuICBpZiAocG9vbEZyYWdtZW50cy5sZW5ndGggPiAwKVxuICAgIHBvb2wgPSBwb29sRnJhZ21lbnRzLnBvcCgpO1xuICBlbHNlXG4gICAgcG9vbCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShwb29sU2l6ZSk7XG4gIHBvb2wudXNlZCA9IDA7XG59XG5cbi8vIENoZWNrIHRoZSBgdGhpcy5zdGFydGAgYW5kIGB0aGlzLmVuZGAgb2Ygc3RyZWFtLlxuZnVuY3Rpb24gY2hlY2tQb3NpdGlvbihwb3MsIG5hbWUpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihwb3MpKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIocG9zLCBuYW1lKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocG9zKSlcbiAgICAgIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKG5hbWUsICdhbiBpbnRlZ2VyJywgcG9zKTtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShuYW1lLCAnPj0gMCBhbmQgPD0gMiAqKiA1MyAtIDEnLCBwb3MpO1xuICB9XG4gIGlmIChwb3MgPCAwKVxuICAgIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKG5hbWUsICc+PSAwIGFuZCA8PSAyICoqIDUzIC0gMScsIHBvcyk7XG59XG5cbmZ1bmN0aW9uIHJvdW5kVXBUb011bHRpcGxlT2Y4KG4pIHtcbiAgcmV0dXJuIChuICsgNykgJiB+NzsgIC8vIEFsaWduIHRvIDggYnl0ZSBib3VuZGFyeS5cbn1cblxuZnVuY3Rpb24gUmVhZFN0cmVhbShzZnRwLCBwYXRoLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG4gICAgb3B0aW9ucyA9IHt9O1xuICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfTtcbiAgZWxzZSBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zXCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBvYmplY3QnKTtcbiAgZWxzZVxuICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMpO1xuXG4gIC8vIEEgbGl0dGxlIGJpdCBiaWdnZXIgYnVmZmVyIGFuZCB3YXRlciBtYXJrcyBieSBkZWZhdWx0XG4gIGlmIChvcHRpb25zLmhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZClcbiAgICBvcHRpb25zLmhpZ2hXYXRlck1hcmsgPSA2NCAqIDEwMjQ7XG5cbiAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQgZG8gbm90IGVtaXQgY2xvc2Ugb24gZGVzdHJveS5cbiAgb3B0aW9ucy5lbWl0Q2xvc2UgPSBmYWxzZTtcbiAgb3B0aW9ucy5hdXRvRGVzdHJveSA9IGZhbHNlOyAvLyBOb2RlIDE0IG1ham9yIGNoYW5nZS5cblxuICBSZWFkYWJsZVN0cmVhbS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMuZmxhZ3MgPSBvcHRpb25zLmZsYWdzID09PSB1bmRlZmluZWQgPyAncicgOiBvcHRpb25zLmZsYWdzO1xuICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgPT09IHVuZGVmaW5lZCA/IDBvNjY2IDogb3B0aW9ucy5tb2RlO1xuXG4gIHRoaXMuc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICB0aGlzLmVuZCA9IG9wdGlvbnMuZW5kO1xuICB0aGlzLmF1dG9DbG9zZSA9IG9wdGlvbnMuYXV0b0Nsb3NlID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5hdXRvQ2xvc2U7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5ieXRlc1JlYWQgPSAwO1xuICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG5cbiAgdGhpcy5oYW5kbGUgPSBvcHRpb25zLmhhbmRsZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuaGFuZGxlO1xuICB0aGlzLnNmdHAgPSBzZnRwO1xuICB0aGlzLl9vcGVuaW5nID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNoZWNrUG9zaXRpb24odGhpcy5zdGFydCwgJ3N0YXJ0Jyk7XG5cbiAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gIH1cblxuICBpZiAodGhpcy5lbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gIH0gZWxzZSBpZiAodGhpcy5lbmQgIT09IEluZmluaXR5KSB7XG4gICAgY2hlY2tQb3NpdGlvbih0aGlzLmVuZCwgJ2VuZCcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnN0YXJ0ID4gdGhpcy5lbmQpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKFxuICAgICAgICAnc3RhcnQnLFxuICAgICAgICBgPD0gXCJlbmRcIiAoaGVyZTogJHt0aGlzLmVuZH0pYCxcbiAgICAgICAgdGhpcy5zdGFydFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hdXRvQ2xvc2UpXG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfSk7XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcy5oYW5kbGUpKVxuICAgIHRoaXMub3BlbigpO1xufVxuaW5oZXJpdHMoUmVhZFN0cmVhbSwgUmVhZGFibGVTdHJlYW0pO1xuXG5SZWFkU3RyZWFtLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9vcGVuaW5nKVxuICAgIHJldHVybjtcblxuICB0aGlzLl9vcGVuaW5nID0gdHJ1ZTtcblxuICB0aGlzLnNmdHAub3Blbih0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgKGVyLCBoYW5kbGUpID0+IHtcbiAgICB0aGlzLl9vcGVuaW5nID0gZmFsc2U7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpXG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlID0gaGFuZGxlO1xuICAgIHRoaXMuZW1pdCgnb3BlbicsIGhhbmRsZSk7XG4gICAgdGhpcy5lbWl0KCdyZWFkeScpO1xuICAgIC8vIFN0YXJ0IHRoZSBmbG93IG9mIGRhdGEuXG4gICAgdGhpcy5yZWFkKCk7XG4gIH0pO1xufTtcblxuUmVhZFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMuaGFuZGxlKSlcbiAgICByZXR1cm4gdGhpcy5vbmNlKCdvcGVuJywgKCkgPT4gdGhpcy5fcmVhZChuKSk7XG5cbiAgLy8gWFhYOiBzYWZlIHRvIHJlbW92ZSB0aGlzP1xuICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgcmV0dXJuO1xuXG4gIGlmICghcG9vbCB8fCBwb29sLmxlbmd0aCAtIHBvb2wudXNlZCA8IGtNaW5Qb29sU3BhY2UpIHtcbiAgICAvLyBEaXNjYXJkIHRoZSBvbGQgcG9vbC5cbiAgICBhbGxvY05ld1Bvb2wodGhpcy5yZWFkYWJsZUhpZ2hXYXRlck1hcmtcbiAgICAgICAgICAgICAgICAgfHwgdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxuXG4gIC8vIEdyYWIgYW5vdGhlciByZWZlcmVuY2UgdG8gdGhlIHBvb2wgaW4gdGhlIGNhc2UgdGhhdCB3aGlsZSB3ZSdyZVxuICAvLyBpbiB0aGUgdGhyZWFkIHBvb2wgYW5vdGhlciByZWFkKCkgZmluaXNoZXMgdXAgdGhlIHBvb2wsIGFuZFxuICAvLyBhbGxvY2F0ZXMgYSBuZXcgb25lLlxuICBjb25zdCB0aGlzUG9vbCA9IHBvb2w7XG4gIGxldCB0b1JlYWQgPSBNYXRoLm1pbihwb29sLmxlbmd0aCAtIHBvb2wudXNlZCwgbik7XG4gIGNvbnN0IHN0YXJ0ID0gcG9vbC51c2VkO1xuXG4gIGlmICh0aGlzLmVuZCAhPT0gdW5kZWZpbmVkKVxuICAgIHRvUmVhZCA9IE1hdGgubWluKHRoaXMuZW5kIC0gdGhpcy5wb3MgKyAxLCB0b1JlYWQpO1xuXG4gIC8vIEFscmVhZHkgcmVhZCBldmVyeXRoaW5nIHdlIHdlcmUgc3VwcG9zZWQgdG8gcmVhZCFcbiAgLy8gdHJlYXQgYXMgRU9GLlxuICBpZiAodG9SZWFkIDw9IDApXG4gICAgcmV0dXJuIHRoaXMucHVzaChudWxsKTtcblxuICAvLyB0aGUgYWN0dWFsIHJlYWQuXG4gIHRoaXMuc2Z0cC5yZWFkKHRoaXMuaGFuZGxlLFxuICAgICAgICAgICAgICAgICBwb29sLFxuICAgICAgICAgICAgICAgICBwb29sLnVzZWQsXG4gICAgICAgICAgICAgICAgIHRvUmVhZCxcbiAgICAgICAgICAgICAgICAgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgIChlciwgYnl0ZXNSZWFkKSA9PiB7XG4gICAgaWYgKGVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgaWYgKHRoaXMuYXV0b0Nsb3NlKVxuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGIgPSBudWxsO1xuXG4gICAgLy8gTm93IHRoYXQgd2Uga25vdyBob3cgbXVjaCBkYXRhIHdlIGhhdmUgYWN0dWFsbHkgcmVhZCwgcmUtd2luZCB0aGVcbiAgICAvLyAndXNlZCcgZmllbGQgaWYgd2UgY2FuLCBhbmQgb3RoZXJ3aXNlIGFsbG93IHRoZSByZW1haW5kZXIgb2Ygb3VyXG4gICAgLy8gcmVzZXJ2YXRpb24gdG8gYmUgdXNlZCBhcyBhIG5ldyBwb29sIGxhdGVyLlxuICAgIGlmIChzdGFydCArIHRvUmVhZCA9PT0gdGhpc1Bvb2wudXNlZCAmJiB0aGlzUG9vbCA9PT0gcG9vbCkge1xuICAgICAgdGhpc1Bvb2wudXNlZCA9IHJvdW5kVXBUb011bHRpcGxlT2Y4KHRoaXNQb29sLnVzZWQgKyBieXRlc1JlYWQgLSB0b1JlYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSb3VuZCBkb3duIHRvIHRoZSBuZXh0IGxvd2VzdCBtdWx0aXBsZSBvZiA4IHRvIGVuc3VyZSB0aGUgbmV3IHBvb2xcbiAgICAgIC8vIGZyYWdtZW50IHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIGFyZSBhbGlnbmVkIHRvIGFuIDggYnl0ZSBib3VuZGFyeS5cbiAgICAgIGNvbnN0IGFsaWduZWRFbmQgPSAoc3RhcnQgKyB0b1JlYWQpICYgfjc7XG4gICAgICBjb25zdCBhbGlnbmVkU3RhcnQgPSByb3VuZFVwVG9NdWx0aXBsZU9mOChzdGFydCArIGJ5dGVzUmVhZCk7XG4gICAgICBpZiAoYWxpZ25lZEVuZCAtIGFsaWduZWRTdGFydCA+PSBrTWluUG9vbFNwYWNlKVxuICAgICAgICBwb29sRnJhZ21lbnRzLnB1c2godGhpc1Bvb2wuc2xpY2UoYWxpZ25lZFN0YXJ0LCBhbGlnbmVkRW5kKSk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVzUmVhZCA+IDApIHtcbiAgICAgIHRoaXMuYnl0ZXNSZWFkICs9IGJ5dGVzUmVhZDtcbiAgICAgIGIgPSB0aGlzUG9vbC5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlc1JlYWQpO1xuICAgIH1cblxuICAgIC8vIE1vdmUgdGhlIHBvb2wgcG9zaXRpb25zLCBhbmQgaW50ZXJuYWwgcG9zaXRpb24gZm9yIHJlYWRpbmcuXG4gICAgdGhpcy5wb3MgKz0gYnl0ZXNSZWFkO1xuXG4gICAgdGhpcy5wdXNoKGIpO1xuICB9KTtcblxuICBwb29sLnVzZWQgPSByb3VuZFVwVG9NdWx0aXBsZU9mOChwb29sLnVzZWQgKyB0b1JlYWQpO1xufTtcblxuUmVhZFN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIsIGNiKSB7XG4gIGlmICh0aGlzLl9vcGVuaW5nICYmICFCdWZmZXIuaXNCdWZmZXIodGhpcy5oYW5kbGUpKSB7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2VTdHJlYW0uYmluZChudWxsLCB0aGlzLCBjYiwgZXJyKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY2xvc2VTdHJlYW0odGhpcywgY2IsIGVycik7XG4gIHRoaXMuaGFuZGxlID0gbnVsbDtcbiAgdGhpcy5fb3BlbmluZyA9IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gY2xvc2VTdHJlYW0oc3RyZWFtLCBjYiwgZXJyKSB7XG4gIGlmICghc3RyZWFtLmhhbmRsZSlcbiAgICByZXR1cm4gb25jbG9zZSgpO1xuXG4gIHN0cmVhbS5zZnRwLmNsb3NlKHN0cmVhbS5oYW5kbGUsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoZXIpIHtcbiAgICBlciA9IGVyIHx8IGVycjtcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICBpZiAoIWVyKVxuICAgICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJyk7XG4gIH1cbn1cblxuUmVhZFN0cmVhbS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjYikge1xuICB0aGlzLmRlc3Ryb3kobnVsbCwgY2IpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRTdHJlYW0ucHJvdG90eXBlLCAncGVuZGluZycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZSA9PT0gbnVsbDtcbiAgfSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuLy8gVE9ETzogYWRkIGBjb25jdXJyZW5jeWAgc2V0dGluZyB0byBhbGxvdyBtb3JlIHRoYW4gb25lIGluLWZsaWdodCBXUklURVxuLy8gcmVxdWVzdCB0byBzZXJ2ZXIgdG8gaW1wcm92ZSB0aHJvdWdocHV0XG5mdW5jdGlvbiBXcml0ZVN0cmVhbShzZnRwLCBwYXRoLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG4gICAgb3B0aW9ucyA9IHt9O1xuICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfTtcbiAgZWxzZSBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zXCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBvYmplY3QnKTtcbiAgZWxzZVxuICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMpO1xuXG4gIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0IGRvIG5vdCBlbWl0IGNsb3NlIG9uIGRlc3Ryb3kuXG4gIG9wdGlvbnMuZW1pdENsb3NlID0gZmFsc2U7XG4gIG9wdGlvbnMuYXV0b0Rlc3Ryb3kgPSBmYWxzZTsgLy8gTm9kZSAxNCBtYWpvciBjaGFuZ2UuXG5cbiAgV3JpdGFibGVTdHJlYW0uY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLnBhdGggPSBwYXRoO1xuICB0aGlzLmZsYWdzID0gb3B0aW9ucy5mbGFncyA9PT0gdW5kZWZpbmVkID8gJ3cnIDogb3B0aW9ucy5mbGFncztcbiAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlID09PSB1bmRlZmluZWQgPyAwbzY2NiA6IG9wdGlvbnMubW9kZTtcblxuICB0aGlzLnN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcbiAgdGhpcy5hdXRvQ2xvc2UgPSBvcHRpb25zLmF1dG9DbG9zZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuYXV0b0Nsb3NlO1xuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgdGhpcy5pc0Nsb3NlZCA9IGZhbHNlO1xuXG4gIHRoaXMuaGFuZGxlID0gb3B0aW9ucy5oYW5kbGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmhhbmRsZTtcbiAgdGhpcy5zZnRwID0gc2Z0cDtcbiAgdGhpcy5fb3BlbmluZyA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjaGVja1Bvc2l0aW9uKHRoaXMuc3RhcnQsICdzdGFydCcpO1xuXG4gICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpXG4gICAgdGhpcy5zZXREZWZhdWx0RW5jb2Rpbmcob3B0aW9ucy5lbmNvZGluZyk7XG5cbiAgLy8gTm9kZSB2Ni54IG9ubHlcbiAgdGhpcy5vbignZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuYXV0b0Nsb3NlKVxuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gIH0pO1xuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMuaGFuZGxlKSlcbiAgICB0aGlzLm9wZW4oKTtcbn1cbmluaGVyaXRzKFdyaXRlU3RyZWFtLCBXcml0YWJsZVN0cmVhbSk7XG5cbldyaXRlU3RyZWFtLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbihjYikge1xuICBpZiAodGhpcy5hdXRvQ2xvc2UpXG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIGNiKCk7XG59O1xuXG5Xcml0ZVN0cmVhbS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fb3BlbmluZylcbiAgICByZXR1cm47XG5cbiAgdGhpcy5fb3BlbmluZyA9IHRydWU7XG5cbiAgdGhpcy5zZnRwLm9wZW4odGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIChlciwgaGFuZGxlKSA9PiB7XG4gICAgdGhpcy5fb3BlbmluZyA9IGZhbHNlO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgaWYgKHRoaXMuYXV0b0Nsb3NlKVxuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZSA9IGhhbmRsZTtcblxuICAgIGNvbnN0IHRyeUFnYWluID0gKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBUcnkgY2htb2QoKSBmb3Igc2Z0cCBzZXJ2ZXJzIHRoYXQgbWF5IG5vdCBzdXBwb3J0IGZjaG1vZCgpIGZvclxuICAgICAgICAvLyB3aGF0ZXZlciByZWFzb25cbiAgICAgICAgdGhpcy5zZnRwLmNobW9kKHRoaXMucGF0aCwgdGhpcy5tb2RlLCAoZXJyXykgPT4gdHJ5QWdhaW4oKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU0ZUUHYzIHJlcXVpcmVzIGFic29sdXRlIG9mZnNldHMsIG5vIG1hdHRlciB0aGUgb3BlbiBmbGFnIHVzZWRcbiAgICAgIGlmICh0aGlzLmZsYWdzWzBdID09PSAnYScpIHtcbiAgICAgICAgY29uc3QgdHJ5U3RhdCA9IChlcnIsIHN0KSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgLy8gVHJ5IHN0YXQoKSBmb3Igc2Z0cCBzZXJ2ZXJzIHRoYXQgbWF5IG5vdCBzdXBwb3J0IGZzdGF0KCkgZm9yXG4gICAgICAgICAgICAvLyB3aGF0ZXZlciByZWFzb25cbiAgICAgICAgICAgIHRoaXMuc2Z0cC5zdGF0KHRoaXMucGF0aCwgKGVycl8sIHN0XykgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyXykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnlTdGF0KG51bGwsIHN0Xyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBvcyA9IHN0LnNpemU7XG4gICAgICAgICAgdGhpcy5lbWl0KCdvcGVuJywgaGFuZGxlKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZnRwLmZzdGF0KGhhbmRsZSwgdHJ5U3RhdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KCdvcGVuJywgaGFuZGxlKTtcbiAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZnRwLmZjaG1vZChoYW5kbGUsIHRoaXMubW9kZSwgdHJ5QWdhaW4pO1xuICB9KTtcbn07XG5cbldyaXRlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihkYXRhLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2RhdGEnLCAnQnVmZmVyJywgZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcy5oYW5kbGUpKSB7XG4gICAgcmV0dXJuIHRoaXMub25jZSgnb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fd3JpdGUoZGF0YSwgZW5jb2RpbmcsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc2Z0cC53cml0ZSh0aGlzLmhhbmRsZSxcbiAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgIChlciwgYnl0ZXMpID0+IHtcbiAgICBpZiAoZXIpIHtcbiAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSlcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gY2IoZXIpO1xuICAgIH1cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBieXRlcztcbiAgICBjYigpO1xuICB9KTtcblxuICB0aGlzLnBvcyArPSBkYXRhLmxlbmd0aDtcbn07XG5cbldyaXRlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGV2ID0gZnVuY3Rpb24oZGF0YSwgY2IpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcy5oYW5kbGUpKSB7XG4gICAgcmV0dXJuIHRoaXMub25jZSgnb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fd3JpdGV2KGRhdGEsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNmdHAgPSB0aGlzLnNmdHA7XG4gIGNvbnN0IGhhbmRsZSA9IHRoaXMuaGFuZGxlO1xuICBsZXQgd3JpdGVzTGVmdCA9IGRhdGEubGVuZ3RoO1xuXG4gIGNvbnN0IG9ud3JpdGUgPSAoZXIsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKGVyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIHJldHVybiBjYihlcik7XG4gICAgfVxuICAgIHRoaXMuYnl0ZXNXcml0dGVuICs9IGJ5dGVzO1xuICAgIGlmICgtLXdyaXRlc0xlZnQgPT09IDApXG4gICAgICBjYigpO1xuICB9O1xuXG4gIC8vIFRPRE86IHRyeSB0byBjb21iaW5lIGNodW5rcyB0byByZWR1Y2UgbnVtYmVyIG9mIHJlcXVlc3RzIHRvIHRoZSBzZXJ2ZXI/XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNodW5rID0gZGF0YVtpXS5jaHVuaztcblxuICAgIHNmdHAud3JpdGUoaGFuZGxlLCBjaHVuaywgMCwgY2h1bmsubGVuZ3RoLCB0aGlzLnBvcywgb253cml0ZSk7XG4gICAgdGhpcy5wb3MgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG59O1xuXG5pZiAodHlwZW9mIFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ICE9PSAnZnVuY3Rpb24nKVxuICBXcml0ZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IFJlYWRTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3k7XG5cbldyaXRlU3RyZWFtLnByb3RvdHlwZS5fZGVzdHJveSA9IFJlYWRTdHJlYW0ucHJvdG90eXBlLl9kZXN0cm95O1xuV3JpdGVTdHJlYW0ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9uKCdjbG9zZScsIGNiKTtcbiAgfVxuXG4gIC8vIElmIHdlIGFyZSBub3QgYXV0b0Nsb3NpbmcsIHdlIHNob3VsZCBjYWxsXG4gIC8vIGRlc3Ryb3kgb24gJ2ZpbmlzaCcuXG4gIGlmICghdGhpcy5hdXRvQ2xvc2UpXG4gICAgdGhpcy5vbignZmluaXNoJywgdGhpcy5kZXN0cm95LmJpbmQodGhpcykpO1xuXG4gIHRoaXMuZW5kKCk7XG59O1xuXG4vLyBUaGVyZSBpcyBubyBzaHV0ZG93bigpIGZvciBmaWxlcy5cbldyaXRlU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95U29vbiA9IFdyaXRlU3RyZWFtLnByb3RvdHlwZS5lbmQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0ZVN0cmVhbS5wcm90b3R5cGUsICdwZW5kaW5nJywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlID09PSBudWxsO1xuICB9LFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZsYWdzVG9TdHJpbmcsXG4gIE9QRU5fTU9ERSxcbiAgU0ZUUCxcbiAgU3RhdHMsXG4gIFNUQVRVU19DT0RFLFxuICBzdHJpbmdUb0ZsYWdzLFxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgRHVwbGV4OiBEdXBsZXhTdHJlYW0sXG4gIFJlYWRhYmxlOiBSZWFkYWJsZVN0cmVhbSxcbiAgV3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtLFxufSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCB7XG4gIENIQU5ORUxfRVhURU5ERURfREFUQVRZUEU6IHsgU1RERVJSIH0sXG59ID0gcmVxdWlyZSgnLi9wcm90b2NvbC9jb25zdGFudHMuanMnKTtcbmNvbnN0IHsgYnVmZmVyU2xpY2UgfSA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvdXRpbHMuanMnKTtcblxuY29uc3QgUEFDS0VUX1NJWkUgPSAzMiAqIDEwMjQ7XG5jb25zdCBNQVhfV0lORE9XID0gMiAqIDEwMjQgKiAxMDI0O1xuY29uc3QgV0lORE9XX1RIUkVTSE9MRCA9IE1BWF9XSU5ET1cgLyAyO1xuXG5jbGFzcyBDbGllbnRTdGRlcnIgZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwsIHN0cmVhbU9wdHMpIHtcbiAgICBzdXBlcihzdHJlYW1PcHRzKTtcblxuICAgIHRoaXMuX2NoYW5uZWwgPSBjaGFubmVsO1xuICB9XG4gIF9yZWFkKG4pIHtcbiAgICBpZiAodGhpcy5fY2hhbm5lbC5fd2FpdENoYW5EcmFpbikge1xuICAgICAgdGhpcy5fY2hhbm5lbC5fd2FpdENoYW5EcmFpbiA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX2NoYW5uZWwuaW5jb21pbmcud2luZG93IDw9IFdJTkRPV19USFJFU0hPTEQpXG4gICAgICAgIHdpbmRvd0FkanVzdCh0aGlzLl9jaGFubmVsKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgU2VydmVyU3RkZXJyIGV4dGVuZHMgV3JpdGFibGVTdHJlYW0ge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgc3VwZXIoeyBoaWdoV2F0ZXJNYXJrOiBNQVhfV0lORE9XIH0pO1xuXG4gICAgdGhpcy5fY2hhbm5lbCA9IGNoYW5uZWw7XG4gIH1cblxuICBfd3JpdGUoZGF0YSwgZW5jb2RpbmcsIGNiKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuX2NoYW5uZWw7XG4gICAgY29uc3QgcHJvdG9jb2wgPSBjaGFubmVsLl9jbGllbnQuX3Byb3RvY29sO1xuICAgIGNvbnN0IG91dGdvaW5nID0gY2hhbm5lbC5vdXRnb2luZztcbiAgICBjb25zdCBwYWNrZXRTaXplID0gb3V0Z29pbmcucGFja2V0U2l6ZTtcbiAgICBjb25zdCBpZCA9IG91dGdvaW5nLmlkO1xuICAgIGxldCB3aW5kb3cgPSBvdXRnb2luZy53aW5kb3c7XG4gICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IHAgPSAwO1xuXG4gICAgaWYgKG91dGdvaW5nLnN0YXRlICE9PSAnb3BlbicpXG4gICAgICByZXR1cm47XG5cbiAgICB3aGlsZSAobGVuIC0gcCA+IDAgJiYgd2luZG93ID4gMCkge1xuICAgICAgbGV0IHNsaWNlTGVuID0gbGVuIC0gcDtcbiAgICAgIGlmIChzbGljZUxlbiA+IHdpbmRvdylcbiAgICAgICAgc2xpY2VMZW4gPSB3aW5kb3c7XG4gICAgICBpZiAoc2xpY2VMZW4gPiBwYWNrZXRTaXplKVxuICAgICAgICBzbGljZUxlbiA9IHBhY2tldFNpemU7XG5cbiAgICAgIGlmIChwID09PSAwICYmIHNsaWNlTGVuID09PSBsZW4pXG4gICAgICAgIHByb3RvY29sLmNoYW5uZWxFeHREYXRhKGlkLCBkYXRhLCBTVERFUlIpO1xuICAgICAgZWxzZVxuICAgICAgICBwcm90b2NvbC5jaGFubmVsRXh0RGF0YShpZCwgYnVmZmVyU2xpY2UoZGF0YSwgcCwgcCArIHNsaWNlTGVuKSwgU1RERVJSKTtcblxuICAgICAgcCArPSBzbGljZUxlbjtcbiAgICAgIHdpbmRvdyAtPSBzbGljZUxlbjtcbiAgICB9XG5cbiAgICBvdXRnb2luZy53aW5kb3cgPSB3aW5kb3c7XG5cbiAgICBpZiAobGVuIC0gcCA+IDApIHtcbiAgICAgIGlmICh3aW5kb3cgPT09IDApXG4gICAgICAgIGNoYW5uZWwuX3dhaXRXaW5kb3cgPSB0cnVlO1xuICAgICAgaWYgKHAgPiAwKVxuICAgICAgICBjaGFubmVsLl9jaHVua0VyciA9IGJ1ZmZlclNsaWNlKGRhdGEsIHAsIGxlbik7XG4gICAgICBlbHNlXG4gICAgICAgIGNoYW5uZWwuX2NodW5rRXJyID0gZGF0YTtcbiAgICAgIGNoYW5uZWwuX2NodW5rY2JFcnIgPSBjYjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYigpO1xuICB9XG59XG5cbmNsYXNzIENoYW5uZWwgZXh0ZW5kcyBEdXBsZXhTdHJlYW0ge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGluZm8sIG9wdHMpIHtcbiAgICBjb25zdCBzdHJlYW1PcHRzID0ge1xuICAgICAgaGlnaFdhdGVyTWFyazogTUFYX1dJTkRPVyxcbiAgICAgIGFsbG93SGFsZk9wZW46ICghb3B0cyB8fCAob3B0cyAmJiBvcHRzLmFsbG93SGFsZk9wZW4gIT09IGZhbHNlKSksXG4gICAgICBlbWl0Q2xvc2U6IGZhbHNlLFxuICAgIH07XG4gICAgc3VwZXIoc3RyZWFtT3B0cyk7XG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gc3RyZWFtT3B0cy5hbGxvd0hhbGZPcGVuO1xuXG4gICAgY29uc3Qgc2VydmVyID0gISEob3B0cyAmJiBvcHRzLnNlcnZlcik7XG5cbiAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICB0aGlzLnR5cGUgPSBpbmZvLnR5cGU7XG4gICAgdGhpcy5zdWJ0eXBlID0gdW5kZWZpbmVkO1xuXG4gICAgLypcbiAgICAgIGluY29taW5nIGFuZCBvdXRnb2luZyBjb250YWluIHRoZXNlIHByb3BlcnRpZXM6XG4gICAgICB7XG4gICAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICAgIHdpbmRvdzogdW5kZWZpbmVkLFxuICAgICAgICBwYWNrZXRTaXplOiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXRlOiAnY2xvc2VkJ1xuICAgICAgfVxuICAgICovXG4gICAgdGhpcy5pbmNvbWluZyA9IGluZm8uaW5jb21pbmc7XG4gICAgdGhpcy5vdXRnb2luZyA9IGluZm8ub3V0Z29pbmc7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG5cbiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5faGFzWDExID0gZmFsc2U7XG4gICAgdGhpcy5fZXhpdCA9IHtcbiAgICAgIGNvZGU6IHVuZGVmaW5lZCxcbiAgICAgIHNpZ25hbDogdW5kZWZpbmVkLFxuICAgICAgZHVtcDogdW5kZWZpbmVkLFxuICAgICAgZGVzYzogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICB0aGlzLnN0ZGluID0gdGhpcy5zdGRvdXQgPSB0aGlzO1xuXG4gICAgaWYgKHNlcnZlcilcbiAgICAgIHRoaXMuc3RkZXJyID0gbmV3IFNlcnZlclN0ZGVycih0aGlzKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnN0ZGVyciA9IG5ldyBDbGllbnRTdGRlcnIodGhpcywgc3RyZWFtT3B0cyk7XG5cbiAgICAvLyBPdXRnb2luZyBkYXRhXG4gICAgdGhpcy5fd2FpdFdpbmRvdyA9IGZhbHNlOyAvLyBTU0gtbGV2ZWwgYmFja3ByZXNzdXJlXG5cbiAgICAvLyBJbmNvbWluZyBkYXRhXG4gICAgdGhpcy5fd2FpdENoYW5EcmFpbiA9IGZhbHNlOyAvLyBDaGFubmVsIFJlYWRhYmxlIHNpZGUgYmFja3ByZXNzdXJlXG5cbiAgICB0aGlzLl9jaHVuayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaHVua2NiID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NodW5rRXJyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NodW5rY2JFcnIgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLm9uKCdmaW5pc2gnLCBvbkZpbmlzaClcbiAgICAgICAgLm9uKCdwcmVmaW5pc2gnLCBvbkZpbmlzaCk7IC8vIEZvciBub2RlIHYwLjExK1xuXG4gICAgdGhpcy5vbignZW5kJywgb25FbmQpLm9uKCdjbG9zZScsIG9uRW5kKTtcbiAgfVxuXG4gIF9yZWFkKG4pIHtcbiAgICBpZiAodGhpcy5fd2FpdENoYW5EcmFpbikge1xuICAgICAgdGhpcy5fd2FpdENoYW5EcmFpbiA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaW5jb21pbmcud2luZG93IDw9IFdJTkRPV19USFJFU0hPTEQpXG4gICAgICAgIHdpbmRvd0FkanVzdCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBfd3JpdGUoZGF0YSwgZW5jb2RpbmcsIGNiKSB7XG4gICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLl9jbGllbnQuX3Byb3RvY29sO1xuICAgIGNvbnN0IG91dGdvaW5nID0gdGhpcy5vdXRnb2luZztcbiAgICBjb25zdCBwYWNrZXRTaXplID0gb3V0Z29pbmcucGFja2V0U2l6ZTtcbiAgICBjb25zdCBpZCA9IG91dGdvaW5nLmlkO1xuICAgIGxldCB3aW5kb3cgPSBvdXRnb2luZy53aW5kb3c7XG4gICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IHAgPSAwO1xuXG4gICAgaWYgKG91dGdvaW5nLnN0YXRlICE9PSAnb3BlbicpXG4gICAgICByZXR1cm47XG5cbiAgICB3aGlsZSAobGVuIC0gcCA+IDAgJiYgd2luZG93ID4gMCkge1xuICAgICAgbGV0IHNsaWNlTGVuID0gbGVuIC0gcDtcbiAgICAgIGlmIChzbGljZUxlbiA+IHdpbmRvdylcbiAgICAgICAgc2xpY2VMZW4gPSB3aW5kb3c7XG4gICAgICBpZiAoc2xpY2VMZW4gPiBwYWNrZXRTaXplKVxuICAgICAgICBzbGljZUxlbiA9IHBhY2tldFNpemU7XG5cbiAgICAgIGlmIChwID09PSAwICYmIHNsaWNlTGVuID09PSBsZW4pXG4gICAgICAgIHByb3RvY29sLmNoYW5uZWxEYXRhKGlkLCBkYXRhKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcHJvdG9jb2wuY2hhbm5lbERhdGEoaWQsIGJ1ZmZlclNsaWNlKGRhdGEsIHAsIHAgKyBzbGljZUxlbikpO1xuXG4gICAgICBwICs9IHNsaWNlTGVuO1xuICAgICAgd2luZG93IC09IHNsaWNlTGVuO1xuICAgIH1cblxuICAgIG91dGdvaW5nLndpbmRvdyA9IHdpbmRvdztcblxuICAgIGlmIChsZW4gLSBwID4gMCkge1xuICAgICAgaWYgKHdpbmRvdyA9PT0gMClcbiAgICAgICAgdGhpcy5fd2FpdFdpbmRvdyA9IHRydWU7XG4gICAgICBpZiAocCA+IDApXG4gICAgICAgIHRoaXMuX2NodW5rID0gYnVmZmVyU2xpY2UoZGF0YSwgcCwgbGVuKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5fY2h1bmsgPSBkYXRhO1xuICAgICAgdGhpcy5fY2h1bmtjYiA9IGNiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNiKCk7XG4gIH1cblxuICBlb2YoKSB7XG4gICAgaWYgKHRoaXMub3V0Z29pbmcuc3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgdGhpcy5vdXRnb2luZy5zdGF0ZSA9ICdlb2YnO1xuICAgICAgdGhpcy5fY2xpZW50Ll9wcm90b2NvbC5jaGFubmVsRU9GKHRoaXMub3V0Z29pbmcuaWQpO1xuICAgIH1cbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLm91dGdvaW5nLnN0YXRlID09PSAnb3BlbicgfHwgdGhpcy5vdXRnb2luZy5zdGF0ZSA9PT0gJ2VvZicpIHtcbiAgICAgIHRoaXMub3V0Z29pbmcuc3RhdGUgPSAnY2xvc2luZyc7XG4gICAgICB0aGlzLl9jbGllbnQuX3Byb3RvY29sLmNoYW5uZWxDbG9zZSh0aGlzLm91dGdvaW5nLmlkKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZW5kKCk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gU2Vzc2lvbiB0eXBlLXNwZWNpZmljIG1ldGhvZHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHNldFdpbmRvdyhyb3dzLCBjb2xzLCBoZWlnaHQsIHdpZHRoKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtb25seSBtZXRob2QgY2FsbGVkIGluIHNlcnZlciBtb2RlJyk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAnc2Vzc2lvbidcbiAgICAgICAgJiYgKHRoaXMuc3VidHlwZSA9PT0gJ3NoZWxsJyB8fCB0aGlzLnN1YnR5cGUgPT09ICdleGVjJylcbiAgICAgICAgJiYgdGhpcy53cml0YWJsZVxuICAgICAgICAmJiB0aGlzLm91dGdvaW5nLnN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuX2NsaWVudC5fcHJvdG9jb2wud2luZG93Q2hhbmdlKHRoaXMub3V0Z29pbmcuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29scyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoKTtcbiAgICB9XG4gIH1cblxuICBzaWduYWwoc2lnbmFsTmFtZSkge1xuICAgIGlmICh0aGlzLnNlcnZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50LW9ubHkgbWV0aG9kIGNhbGxlZCBpbiBzZXJ2ZXIgbW9kZScpO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3Nlc3Npb24nXG4gICAgICAgICYmIHRoaXMud3JpdGFibGVcbiAgICAgICAgJiYgdGhpcy5vdXRnb2luZy5zdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICB0aGlzLl9jbGllbnQuX3Byb3RvY29sLnNpZ25hbCh0aGlzLm91dGdvaW5nLmlkLCBzaWduYWxOYW1lKTtcbiAgICB9XG4gIH1cblxuICBleGl0KHN0YXR1c09yU2lnbmFsLCBjb3JlRHVtcGVkLCBtc2cpIHtcbiAgICBpZiAoIXRoaXMuc2VydmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXItb25seSBtZXRob2QgY2FsbGVkIGluIGNsaWVudCBtb2RlJyk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAnc2Vzc2lvbidcbiAgICAgICAgJiYgdGhpcy53cml0YWJsZVxuICAgICAgICAmJiB0aGlzLm91dGdvaW5nLnN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RhdHVzT3JTaWduYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuX2NsaWVudC5fcHJvdG9jb2wuZXhpdFN0YXR1cyh0aGlzLm91dGdvaW5nLmlkLCBzdGF0dXNPclNpZ25hbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jbGllbnQuX3Byb3RvY29sLmV4aXRTaWduYWwodGhpcy5vdXRnb2luZy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c09yU2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZUR1bXBlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuZnVuY3Rpb24gb25GaW5pc2goKSB7XG4gIHRoaXMuZW9mKCk7XG4gIGlmICh0aGlzLnNlcnZlciB8fCAhdGhpcy5hbGxvd0hhbGZPcGVuKVxuICAgIHRoaXMuY2xvc2UoKTtcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkVuZCgpIHtcbiAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dBZGp1c3Qoc2VsZikge1xuICBpZiAoc2VsZi5vdXRnb2luZy5zdGF0ZSA9PT0gJ2Nsb3NlZCcpXG4gICAgcmV0dXJuO1xuICBjb25zdCBhbXQgPSBNQVhfV0lORE9XIC0gc2VsZi5pbmNvbWluZy53aW5kb3c7XG4gIGlmIChhbXQgPD0gMClcbiAgICByZXR1cm47XG4gIHNlbGYuaW5jb21pbmcud2luZG93ICs9IGFtdDtcbiAgc2VsZi5fY2xpZW50Ll9wcm90b2NvbC5jaGFubmVsV2luZG93QWRqdXN0KHNlbGYub3V0Z29pbmcuaWQsIGFtdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDaGFubmVsLFxuICBNQVhfV0lORE9XLFxuICBQQUNLRVRfU0laRSxcbiAgd2luZG93QWRqdXN0LFxuICBXSU5ET1dfVEhSRVNIT0xELFxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgU0ZUUCB9ID0gcmVxdWlyZSgnLi9wcm90b2NvbC9TRlRQLmpzJyk7XG5cbmNvbnN0IE1BWF9DSEFOTkVMID0gMiAqKiAzMiAtIDE7XG5cbmZ1bmN0aW9uIG9uQ2hhbm5lbE9wZW5GYWlsdXJlKHNlbGYsIHJlY2lwaWVudCwgaW5mbywgY2IpIHtcbiAgc2VsZi5fY2hhbk1nci5yZW1vdmUocmVjaXBpZW50KTtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm47XG5cbiAgbGV0IGVycjtcbiAgaWYgKGluZm8gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGVyciA9IGluZm87XG4gIH0gZWxzZSBpZiAodHlwZW9mIGluZm8gPT09ICdvYmplY3QnICYmIGluZm8gIT09IG51bGwpIHtcbiAgICBlcnIgPSBuZXcgRXJyb3IoYChTU0gpIENoYW5uZWwgb3BlbiBmYWlsdXJlOiAke2luZm8uZGVzY3JpcHRpb259YCk7XG4gICAgZXJyLnJlYXNvbiA9IGluZm8ucmVhc29uO1xuICB9IGVsc2Uge1xuICAgIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICcoU1NIKSBDaGFubmVsIG9wZW4gZmFpbHVyZTogc2VydmVyIGNsb3NlZCBjaGFubmVsIHVuZXhwZWN0ZWRseSdcbiAgICApO1xuICAgIGVyci5yZWFzb24gPSAnJztcbiAgfVxuXG4gIGNiKGVycik7XG59XG5cbmZ1bmN0aW9uIG9uQ0hBTk5FTF9DTE9TRShzZWxmLCByZWNpcGllbnQsIGNoYW5uZWwsIGVyciwgZGVhZCkge1xuICBpZiAodHlwZW9mIGNoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBXZSBnb3QgQ0hBTk5FTF9DTE9TRSBpbnN0ZWFkIG9mIENIQU5ORUxfT1BFTl9GQUlMVVJFIHdoZW5cbiAgICAvLyByZXF1ZXN0aW5nIHRvIG9wZW4gYSBjaGFubmVsXG4gICAgb25DaGFubmVsT3BlbkZhaWx1cmUoc2VsZiwgcmVjaXBpZW50LCBlcnIsIGNoYW5uZWwpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hhbm5lbCAhPT0gJ29iamVjdCcgfHwgY2hhbm5lbCA9PT0gbnVsbClcbiAgICByZXR1cm47XG5cbiAgaWYgKGNoYW5uZWwuaW5jb21pbmcgJiYgY2hhbm5lbC5pbmNvbWluZy5zdGF0ZSA9PT0gJ2Nsb3NlZCcpXG4gICAgcmV0dXJuO1xuXG4gIHNlbGYuX2NoYW5NZ3IucmVtb3ZlKHJlY2lwaWVudCk7XG5cbiAgaWYgKGNoYW5uZWwuc2VydmVyICYmIGNoYW5uZWwuY29uc3RydWN0b3IubmFtZSA9PT0gJ1Nlc3Npb24nKVxuICAgIHJldHVybjtcblxuICBjaGFubmVsLmluY29taW5nLnN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgaWYgKGNoYW5uZWwucmVhZGFibGUpXG4gICAgY2hhbm5lbC5wdXNoKG51bGwpO1xuICBpZiAoY2hhbm5lbC5zZXJ2ZXIpIHtcbiAgICBpZiAoY2hhbm5lbC5zdGRlcnIud3JpdGFibGUpXG4gICAgICBjaGFubmVsLnN0ZGVyci5lbmQoKTtcbiAgfSBlbHNlIGlmIChjaGFubmVsLnN0ZGVyci5yZWFkYWJsZSkge1xuICAgIGNoYW5uZWwuc3RkZXJyLnB1c2gobnVsbCk7XG4gIH1cblxuICBpZiAoY2hhbm5lbC5jb25zdHJ1Y3RvciAhPT0gU0ZUUFxuICAgICAgJiYgKGNoYW5uZWwub3V0Z29pbmcuc3RhdGUgPT09ICdvcGVuJ1xuICAgICAgICAgIHx8IGNoYW5uZWwub3V0Z29pbmcuc3RhdGUgPT09ICdlb2YnKVxuICAgICAgJiYgIWRlYWQpIHtcbiAgICBjaGFubmVsLmNsb3NlKCk7XG4gIH1cbiAgaWYgKGNoYW5uZWwub3V0Z29pbmcuc3RhdGUgPT09ICdjbG9zaW5nJylcbiAgICBjaGFubmVsLm91dGdvaW5nLnN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgY29uc3QgcmVhZFN0YXRlID0gY2hhbm5lbC5fcmVhZGFibGVTdGF0ZTtcbiAgY29uc3Qgd3JpdGVTdGF0ZSA9IGNoYW5uZWwuX3dyaXRhYmxlU3RhdGU7XG4gIGlmICh3cml0ZVN0YXRlICYmICF3cml0ZVN0YXRlLmVuZGluZyAmJiAhd3JpdGVTdGF0ZS5maW5pc2hlZCAmJiAhZGVhZClcbiAgICBjaGFubmVsLmVuZCgpO1xuXG4gIC8vIFRha2UgY2FyZSBvZiBhbnkgb3V0c3RhbmRpbmcgY2hhbm5lbCByZXF1ZXN0c1xuICBjb25zdCBjaGFuQ2FsbGJhY2tzID0gY2hhbm5lbC5fY2FsbGJhY2tzO1xuICBjaGFubmVsLl9jYWxsYmFja3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuQ2FsbGJhY2tzLmxlbmd0aDsgKytpKVxuICAgIGNoYW5DYWxsYmFja3NbaV0odHJ1ZSk7XG5cbiAgaWYgKGNoYW5uZWwuc2VydmVyKSB7XG4gICAgaWYgKCFjaGFubmVsLnJlYWRhYmxlXG4gICAgICAgIHx8IGNoYW5uZWwuZGVzdHJveWVkXG4gICAgICAgIHx8IChyZWFkU3RhdGUgJiYgcmVhZFN0YXRlLmVuZEVtaXR0ZWQpKSB7XG4gICAgICBjaGFubmVsLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWwub25jZSgnZW5kJywgKCkgPT4gY2hhbm5lbC5lbWl0KCdjbG9zZScpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGRvQ2xvc2U7XG4gICAgc3dpdGNoIChjaGFubmVsLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2RpcmVjdC1zdHJlYW1sb2NhbEBvcGVuc3NoLmNvbSc6XG4gICAgICBjYXNlICdkaXJlY3QtdGNwaXAnOlxuICAgICAgICBkb0Nsb3NlID0gKCkgPT4gY2hhbm5lbC5lbWl0KCdjbG9zZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgLy8gQWxpZ24gbW9yZSB3aXRoIG5vZGUgY2hpbGQgcHJvY2Vzc2VzLCB3aGVyZSB0aGUgY2xvc2UgZXZlbnQgZ2V0c1xuICAgICAgICAvLyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhlIGV4aXQgZXZlbnRcbiAgICAgICAgY29uc3QgZXhpdCA9IGNoYW5uZWwuX2V4aXQ7XG4gICAgICAgIGRvQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGV4aXQuY29kZSA9PT0gbnVsbClcbiAgICAgICAgICAgIGNoYW5uZWwuZW1pdCgnY2xvc2UnLCBleGl0LmNvZGUsIGV4aXQuc2lnbmFsLCBleGl0LmR1bXAsIGV4aXQuZGVzYyk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2hhbm5lbC5lbWl0KCdjbG9zZScsIGV4aXQuY29kZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2hhbm5lbC5yZWFkYWJsZVxuICAgICAgICB8fCBjaGFubmVsLmRlc3Ryb3llZFxuICAgICAgICB8fCAocmVhZFN0YXRlICYmIHJlYWRTdGF0ZS5lbmRFbWl0dGVkKSkge1xuICAgICAgZG9DbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsLm9uY2UoJ2VuZCcsIGRvQ2xvc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGVyclJlYWRTdGF0ZSA9IGNoYW5uZWwuc3RkZXJyLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghY2hhbm5lbC5zdGRlcnIucmVhZGFibGVcbiAgICAgICAgfHwgY2hhbm5lbC5zdGRlcnIuZGVzdHJveWVkXG4gICAgICAgIHx8IChlcnJSZWFkU3RhdGUgJiYgZXJyUmVhZFN0YXRlLmVuZEVtaXR0ZWQpKSB7XG4gICAgICBjaGFubmVsLnN0ZGVyci5lbWl0KCdjbG9zZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsLnN0ZGVyci5vbmNlKCdlbmQnLCAoKSA9PiBjaGFubmVsLnN0ZGVyci5lbWl0KCdjbG9zZScpKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQ2hhbm5lbE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5fY2hhbm5lbHMgPSB7fTtcbiAgICB0aGlzLl9jdXIgPSAtMTtcbiAgICB0aGlzLl9jb3VudCA9IDA7XG4gIH1cbiAgYWRkKHZhbCkge1xuICAgIC8vIEF0dGVtcHQgdG8gcmVzZXJ2ZSBhbiBpZFxuXG4gICAgbGV0IGlkO1xuICAgIC8vIE9wdGltaXplZCBwYXRoc1xuICAgIGlmICh0aGlzLl9jdXIgPCBNQVhfQ0hBTk5FTCkge1xuICAgICAgaWQgPSArK3RoaXMuX2N1cjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NvdW50ID09PSAwKSB7XG4gICAgICAvLyBSZXZlcnQgYW5kIHJlc2V0IGJhY2sgdG8gZmFzdCBwYXRoIG9uY2Ugd2Ugbm8gbG9uZ2VyIGhhdmUgYW55IGNoYW5uZWxzXG4gICAgICAvLyBvcGVuXG4gICAgICB0aGlzLl9jdXIgPSAwO1xuICAgICAgaWQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbG93ZXIgbG9va3VwIHBhdGhcblxuICAgICAgLy8gVGhpcyBwYXRoIGlzIHRyaWdnZXJlZCB3ZSBoYXZlIG9wZW5lZCBhdCBsZWFzdCBNQVhfQ0hBTk5FTCBjaGFubmVsc1xuICAgICAgLy8gd2hpbGUgaGF2aW5nIGF0IGxlYXN0IG9uZSBjaGFubmVsIG9wZW4gYXQgYW55IGdpdmVuIHRpbWUsIHNvIHdlIGhhdmVcbiAgICAgIC8vIHRvIHNlYXJjaCBmb3IgYSBmcmVlIGlkLlxuICAgICAgY29uc3QgY2hhbm5lbHMgPSB0aGlzLl9jaGFubmVscztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0NIQU5ORUw7ICsraSkge1xuICAgICAgICBpZiAoY2hhbm5lbHNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlkID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIC0xO1xuXG4gICAgdGhpcy5fY2hhbm5lbHNbaWRdID0gKHZhbCB8fCB0cnVlKTtcbiAgICArK3RoaXMuX2NvdW50O1xuXG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHVwZGF0ZShpZCwgdmFsKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicgfHwgaWQgPCAwIHx8IGlkID49IE1BWF9DSEFOTkVMIHx8ICFpc0Zpbml0ZShpZCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhbm5lbCBpZDogJHtpZH1gKTtcblxuICAgIGlmICh2YWwgJiYgdGhpcy5fY2hhbm5lbHNbaWRdKVxuICAgICAgdGhpcy5fY2hhbm5lbHNbaWRdID0gdmFsO1xuICB9XG4gIGdldChpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInIHx8IGlkIDwgMCB8fCBpZCA+PSBNQVhfQ0hBTk5FTCB8fCAhaXNGaW5pdGUoaWQpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYW5uZWwgaWQ6ICR7aWR9YCk7XG5cbiAgICByZXR1cm4gdGhpcy5fY2hhbm5lbHNbaWRdO1xuICB9XG4gIHJlbW92ZShpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInIHx8IGlkIDwgMCB8fCBpZCA+PSBNQVhfQ0hBTk5FTCB8fCAhaXNGaW5pdGUoaWQpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYW5uZWwgaWQ6ICR7aWR9YCk7XG5cbiAgICBpZiAodGhpcy5fY2hhbm5lbHNbaWRdKSB7XG4gICAgICBkZWxldGUgdGhpcy5fY2hhbm5lbHNbaWRdO1xuICAgICAgaWYgKHRoaXMuX2NvdW50KVxuICAgICAgICAtLXRoaXMuX2NvdW50O1xuICAgIH1cbiAgfVxuICBjbGVhbnVwKGVycikge1xuICAgIGNvbnN0IGNoYW5uZWxzID0gdGhpcy5fY2hhbm5lbHM7XG4gICAgdGhpcy5fY2hhbm5lbHMgPSB7fTtcbiAgICB0aGlzLl9jdXIgPSAtMTtcbiAgICB0aGlzLl9jb3VudCA9IDA7XG5cbiAgICBjb25zdCBjaGFuSURzID0gT2JqZWN0LmtleXMoY2hhbm5lbHMpO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5JRHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGlkID0gK2NoYW5JRHNbaV07XG4gICAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHNbaWRdO1xuICAgICAgb25DSEFOTkVMX0NMT1NFKGNsaWVudCwgaWQsIGNoYW5uZWwuX2NoYW5uZWwgfHwgY2hhbm5lbCwgZXJyLCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNSZWdFeHAgPSAoKCkgPT4ge1xuICBjb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHJldHVybiAodmFsKSA9PiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufSkoKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVBbGdvcml0aG1MaXN0KGFsZ29MaXN0LCBkZWZhdWx0TGlzdCwgc3VwcG9ydGVkTGlzdCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhbGdvTGlzdCkgJiYgYWxnb0xpc3QubGVuZ3RoID4gMCkge1xuICAgIC8vIEV4YWN0IGxpc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsZ29MaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoc3VwcG9ydGVkTGlzdC5pbmRleE9mKGFsZ29MaXN0W2ldKSA9PT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAke2FsZ29MaXN0W2ldfWApO1xuICAgIH1cbiAgICByZXR1cm4gYWxnb0xpc3Q7XG4gIH1cblxuICBpZiAodHlwZW9mIGFsZ29MaXN0ID09PSAnb2JqZWN0JyAmJiBhbGdvTGlzdCAhPT0gbnVsbCkge1xuICAgIC8vIE9wZXJhdGlvbnMgYmFzZWQgb24gdGhlIGRlZmF1bHQgbGlzdFxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhbGdvTGlzdCk7XG4gICAgbGV0IGxpc3QgPSBkZWZhdWx0TGlzdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBsZXQgdmFsID0gYWxnb0xpc3Rba2V5XTtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ2FwcGVuZCc6XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICBjb25zdCBhcHBlbmQgPSB2YWxbal07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgYXBwZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICghYXBwZW5kIHx8IGxpc3QuaW5kZXhPZihhcHBlbmQpICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRMaXN0LmluZGV4T2YoYXBwZW5kKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFsZ29yaXRobTogJHthcHBlbmR9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3QgPT09IGRlZmF1bHRMaXN0KVxuICAgICAgICAgICAgICAgICAgbGlzdCA9IGxpc3Quc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goYXBwZW5kKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1JlZ0V4cChhcHBlbmQpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBzdXBwb3J0ZWRMaXN0Lmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbGdvID0gc3VwcG9ydGVkTGlzdFtrXTtcbiAgICAgICAgICAgICAgICAgIGlmIChhcHBlbmQudGVzdChhbGdvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdC5pbmRleE9mKGFsZ28pICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QgPT09IGRlZmF1bHRMaXN0KVxuICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChhbGdvKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ByZXBlbmQnOlxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgICAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IHZhbC5sZW5ndGg7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZXBlbmQgPSB2YWxbal07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlcGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXBlbmQgfHwgbGlzdC5pbmRleE9mKHByZXBlbmQpICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRMaXN0LmluZGV4T2YocHJlcGVuZCkgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhbGdvcml0aG06ICR7cHJlcGVuZH1gKTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdCA9PT0gZGVmYXVsdExpc3QpXG4gICAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGxpc3QudW5zaGlmdChwcmVwZW5kKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1JlZ0V4cChwcmVwZW5kKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSBzdXBwb3J0ZWRMaXN0Lmxlbmd0aDsgayA+PSAwOyAtLWspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFsZ28gPSBzdXBwb3J0ZWRMaXN0W2tdO1xuICAgICAgICAgICAgICAgICAgaWYgKHByZXBlbmQudGVzdChhbGdvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdC5pbmRleE9mKGFsZ28pICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QgPT09IGRlZmF1bHRMaXN0KVxuICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QudW5zaGlmdChhbGdvKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICBjb25zdCBzZWFyY2ggPSB2YWxbal07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICghc2VhcmNoKVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gbGlzdC5pbmRleE9mKHNlYXJjaCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdCA9PT0gZGVmYXVsdExpc3QpXG4gICAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAoc2VhcmNoKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGlzdC5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC50ZXN0KGxpc3Rba10pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ID09PSBkZWZhdWx0TGlzdClcbiAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgLS1rO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0TGlzdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENoYW5uZWxNYW5hZ2VyLFxuICBnZW5lcmF0ZUFsZ29yaXRobUxpc3QsXG4gIG9uQ2hhbm5lbE9wZW5GYWlsdXJlLFxuICBvbkNIQU5ORUxfQ0xPU0UsXG4gIGlzV3JpdGFibGU6IChzdHJlYW0pID0+IHtcbiAgICAvLyBYWFg6IGhhY2sgdG8gd29ya2Fyb3VuZCByZWdyZXNzaW9uIGluIG5vZGVcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzYwMjlcbiAgICByZXR1cm4gKHN0cmVhbVxuICAgICAgICAgICAgJiYgc3RyZWFtLndyaXRhYmxlXG4gICAgICAgICAgICAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgICAgICAgICAgICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9PT0gZmFsc2UpO1xuICB9LFxufTtcbiIsICIvLyBUT0RPOlxuLy8gICAgKiBhZGQgYC5jb25uZWN0ZWRgIG9yIHNpbWlsYXIgcHJvcGVydHkgdG8gYWxsb3cgaW1tZWRpYXRlIGNvbm5lY3Rpb25cbi8vICAgICAgc3RhdHVzIGNoZWNraW5nXG4vLyAgICAqIGFkZC9pbXByb3ZlIGRlYnVnIG91dHB1dCBkdXJpbmcgdXNlciBhdXRoZW50aWNhdGlvbiBwaGFzZVxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG4gIGNyZWF0ZUhhc2gsXG4gIGdldEhhc2hlcyxcbiAgcmFuZG9tRmlsbFN5bmMsXG59ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IFNvY2tldCB9ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB7IGxvb2t1cDogZG5zTG9va3VwIH0gPSByZXF1aXJlKCdkbnMnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgSEFTSEVTID0gZ2V0SGFzaGVzKCk7XG5cbmNvbnN0IHtcbiAgQ09NUEFULFxuICBDSEFOTkVMX0VYVEVOREVEX0RBVEFUWVBFOiB7IFNUREVSUiB9LFxuICBDSEFOTkVMX09QRU5fRkFJTFVSRSxcbiAgREVGQVVMVF9DSVBIRVIsXG4gIERFRkFVTFRfQ09NUFJFU1NJT04sXG4gIERFRkFVTFRfS0VYLFxuICBERUZBVUxUX01BQyxcbiAgREVGQVVMVF9TRVJWRVJfSE9TVF9LRVksXG4gIERJU0NPTk5FQ1RfUkVBU09OLFxuICBESVNDT05ORUNUX1JFQVNPTl9CWV9WQUxVRSxcbiAgU1VQUE9SVEVEX0NJUEhFUixcbiAgU1VQUE9SVEVEX0NPTVBSRVNTSU9OLFxuICBTVVBQT1JURURfS0VYLFxuICBTVVBQT1JURURfTUFDLFxuICBTVVBQT1JURURfU0VSVkVSX0hPU1RfS0VZLFxufSA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvY29uc3RhbnRzLmpzJyk7XG5jb25zdCB7IGluaXQ6IGNyeXB0b0luaXQgfSA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvY3J5cHRvLmpzJyk7XG5jb25zdCBQcm90b2NvbCA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvUHJvdG9jb2wuanMnKTtcbmNvbnN0IHsgcGFyc2VLZXkgfSA9IHJlcXVpcmUoJy4vcHJvdG9jb2wva2V5UGFyc2VyLmpzJyk7XG5jb25zdCB7IFNGVFAgfSA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvU0ZUUC5qcycpO1xuY29uc3Qge1xuICBidWZmZXJDb3B5LFxuICBtYWtlQnVmZmVyUGFyc2VyLFxuICBtYWtlRXJyb3IsXG4gIHJlYWRVSW50MzJCRSxcbiAgc2lnU1NIVG9BU04xLFxuICB3cml0ZVVJbnQzMkJFLFxufSA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvdXRpbHMuanMnKTtcblxuY29uc3QgeyBBZ2VudENvbnRleHQsIGNyZWF0ZUFnZW50LCBpc0FnZW50IH0gPSByZXF1aXJlKCcuL2FnZW50LmpzJyk7XG5jb25zdCB7XG4gIENoYW5uZWwsXG4gIE1BWF9XSU5ET1csXG4gIFBBQ0tFVF9TSVpFLFxuICB3aW5kb3dBZGp1c3QsXG4gIFdJTkRPV19USFJFU0hPTEQsXG59ID0gcmVxdWlyZSgnLi9DaGFubmVsLmpzJyk7XG5jb25zdCB7XG4gIENoYW5uZWxNYW5hZ2VyLFxuICBnZW5lcmF0ZUFsZ29yaXRobUxpc3QsXG4gIGlzV3JpdGFibGUsXG4gIG9uQ2hhbm5lbE9wZW5GYWlsdXJlLFxuICBvbkNIQU5ORUxfQ0xPU0UsXG59ID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuXG5jb25zdCBidWZmZXJQYXJzZXIgPSBtYWtlQnVmZmVyUGFyc2VyKCk7XG5jb25zdCBzaWdQYXJzZXIgPSBtYWtlQnVmZmVyUGFyc2VyKCk7XG5jb25zdCBSRV9PUEVOU1NIID0gL15PcGVuU1NIXyg/Oig/IVswLTRdKVxcZCl8KD86XFxkezIsfSkvO1xuY29uc3Qgbm9vcCA9IChlcnIpID0+IHt9O1xuXG5jbGFzcyBDbGllbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgICBwb3J0OiB1bmRlZmluZWQsXG4gICAgICBsb2NhbEFkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICAgIGxvY2FsUG9ydDogdW5kZWZpbmVkLFxuICAgICAgZm9yY2VJUHY0OiB1bmRlZmluZWQsXG4gICAgICBmb3JjZUlQdjY6IHVuZGVmaW5lZCxcbiAgICAgIGtlZXBhbGl2ZUNvdW50TWF4OiB1bmRlZmluZWQsXG4gICAgICBrZWVwYWxpdmVJbnRlcnZhbDogdW5kZWZpbmVkLFxuICAgICAgcmVhZHlUaW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICBpZGVudDogdW5kZWZpbmVkLFxuXG4gICAgICB1c2VybmFtZTogdW5kZWZpbmVkLFxuICAgICAgcGFzc3dvcmQ6IHVuZGVmaW5lZCxcbiAgICAgIHByaXZhdGVLZXk6IHVuZGVmaW5lZCxcbiAgICAgIHRyeUtleWJvYXJkOiB1bmRlZmluZWQsXG4gICAgICBhZ2VudDogdW5kZWZpbmVkLFxuICAgICAgYWxsb3dBZ2VudEZ3ZDogdW5kZWZpbmVkLFxuICAgICAgYXV0aEhhbmRsZXI6IHVuZGVmaW5lZCxcblxuICAgICAgaG9zdEhhc2hBbGdvOiB1bmRlZmluZWQsXG4gICAgICBob3N0SGFzaENiOiB1bmRlZmluZWQsXG4gICAgICBzdHJpY3RWZW5kb3I6IHVuZGVmaW5lZCxcbiAgICAgIGRlYnVnOiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgdGhpcy5fYWdlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVhZHlUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoYW5NZ3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZvcndhcmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZm9yd2FyZGluZ1VuaXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYWNjZXB0WDExID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2FnZW50RndkRW5hYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZW1vdGVWZXIgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl9wcm90b2NvbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb2NrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Jlc2V0S0EgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25uZWN0KGNmZykge1xuICAgIGlmICh0aGlzLl9zb2NrICYmIGlzV3JpdGFibGUodGhpcy5fc29jaykpIHtcbiAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29ubmVjdChjZmcpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVuZCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcuaG9zdCA9IGNmZy5ob3N0bmFtZSB8fCBjZmcuaG9zdCB8fCAnbG9jYWxob3N0JztcbiAgICB0aGlzLmNvbmZpZy5wb3J0ID0gY2ZnLnBvcnQgfHwgMjI7XG4gICAgdGhpcy5jb25maWcubG9jYWxBZGRyZXNzID0gKHR5cGVvZiBjZmcubG9jYWxBZGRyZXNzID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNmZy5sb2NhbEFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIHRoaXMuY29uZmlnLmxvY2FsUG9ydCA9ICh0eXBlb2YgY2ZnLmxvY2FsUG9ydCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgdHlwZW9mIGNmZy5sb2NhbFBvcnQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2ZnLmxvY2FsUG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5jb25maWcuZm9yY2VJUHY0ID0gY2ZnLmZvcmNlSVB2NCB8fCBmYWxzZTtcbiAgICB0aGlzLmNvbmZpZy5mb3JjZUlQdjYgPSBjZmcuZm9yY2VJUHY2IHx8IGZhbHNlO1xuICAgIHRoaXMuY29uZmlnLmtlZXBhbGl2ZUNvdW50TWF4ID0gKHR5cGVvZiBjZmcua2VlcGFsaXZlQ291bnRNYXggPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2ZnLmtlZXBhbGl2ZUNvdW50TWF4ID49IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNmZy5rZWVwYWxpdmVDb3VudE1heFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMyk7XG4gICAgdGhpcy5jb25maWcua2VlcGFsaXZlSW50ZXJ2YWwgPSAodHlwZW9mIGNmZy5rZWVwYWxpdmVJbnRlcnZhbCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBjZmcua2VlcGFsaXZlSW50ZXJ2YWwgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjZmcua2VlcGFsaXZlSW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDApO1xuICAgIHRoaXMuY29uZmlnLnJlYWR5VGltZW91dCA9ICh0eXBlb2YgY2ZnLnJlYWR5VGltZW91dCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2ZnLnJlYWR5VGltZW91dCA+PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2ZnLnJlYWR5VGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDIwMDAwKTtcbiAgICB0aGlzLmNvbmZpZy5pZGVudCA9ICh0eXBlb2YgY2ZnLmlkZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgIHx8IEJ1ZmZlci5pc0J1ZmZlcihjZmcuaWRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyBjZmcuaWRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG5cbiAgICBjb25zdCBhbGdvcml0aG1zID0ge1xuICAgICAga2V4OiB1bmRlZmluZWQsXG4gICAgICBzZXJ2ZXJIb3N0S2V5OiB1bmRlZmluZWQsXG4gICAgICBjczoge1xuICAgICAgICBjaXBoZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgbWFjOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbXByZXNzOiB1bmRlZmluZWQsXG4gICAgICAgIGxhbmc6IFtdLFxuICAgICAgfSxcbiAgICAgIHNjOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBsZXQgYWxsT2ZmZXJEZWZhdWx0cyA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjZmcuYWxnb3JpdGhtcyA9PT0gJ29iamVjdCcgJiYgY2ZnLmFsZ29yaXRobXMgIT09IG51bGwpIHtcbiAgICAgIGFsZ29yaXRobXMua2V4ID0gZ2VuZXJhdGVBbGdvcml0aG1MaXN0KGNmZy5hbGdvcml0aG1zLmtleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERFRkFVTFRfS0VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1VQUE9SVEVEX0tFWCk7XG4gICAgICBpZiAoYWxnb3JpdGhtcy5rZXggIT09IERFRkFVTFRfS0VYKVxuICAgICAgICBhbGxPZmZlckRlZmF1bHRzID0gZmFsc2U7XG5cbiAgICAgIGFsZ29yaXRobXMuc2VydmVySG9zdEtleSA9XG4gICAgICAgIGdlbmVyYXRlQWxnb3JpdGhtTGlzdChjZmcuYWxnb3JpdGhtcy5zZXJ2ZXJIb3N0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9TRVJWRVJfSE9TVF9LRVksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTVVBQT1JURURfU0VSVkVSX0hPU1RfS0VZKTtcbiAgICAgIGlmIChhbGdvcml0aG1zLnNlcnZlckhvc3RLZXkgIT09IERFRkFVTFRfU0VSVkVSX0hPU1RfS0VZKVxuICAgICAgICBhbGxPZmZlckRlZmF1bHRzID0gZmFsc2U7XG5cbiAgICAgIGFsZ29yaXRobXMuY3MuY2lwaGVyID0gZ2VuZXJhdGVBbGdvcml0aG1MaXN0KGNmZy5hbGdvcml0aG1zLmNpcGhlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERFRkFVTFRfQ0lQSEVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1VQUE9SVEVEX0NJUEhFUik7XG4gICAgICBpZiAoYWxnb3JpdGhtcy5jcy5jaXBoZXIgIT09IERFRkFVTFRfQ0lQSEVSKVxuICAgICAgICBhbGxPZmZlckRlZmF1bHRzID0gZmFsc2U7XG5cbiAgICAgIGFsZ29yaXRobXMuY3MubWFjID0gZ2VuZXJhdGVBbGdvcml0aG1MaXN0KGNmZy5hbGdvcml0aG1zLmhtYWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX01BQyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNVUFBPUlRFRF9NQUMpO1xuICAgICAgaWYgKGFsZ29yaXRobXMuY3MubWFjICE9PSBERUZBVUxUX01BQylcbiAgICAgICAgYWxsT2ZmZXJEZWZhdWx0cyA9IGZhbHNlO1xuXG4gICAgICBhbGdvcml0aG1zLmNzLmNvbXByZXNzID0gZ2VuZXJhdGVBbGdvcml0aG1MaXN0KGNmZy5hbGdvcml0aG1zLmNvbXByZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTVVBQT1JURURfQ09NUFJFU1NJT04pO1xuICAgICAgaWYgKGFsZ29yaXRobXMuY3MuY29tcHJlc3MgIT09IERFRkFVTFRfQ09NUFJFU1NJT04pXG4gICAgICAgIGFsbE9mZmVyRGVmYXVsdHMgPSBmYWxzZTtcblxuICAgICAgaWYgKCFhbGxPZmZlckRlZmF1bHRzKVxuICAgICAgICBhbGdvcml0aG1zLnNjID0gYWxnb3JpdGhtcy5jcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNmZy51c2VybmFtZSA9PT0gJ3N0cmluZycpXG4gICAgICB0aGlzLmNvbmZpZy51c2VybmFtZSA9IGNmZy51c2VybmFtZTtcbiAgICBlbHNlIGlmICh0eXBlb2YgY2ZnLnVzZXIgPT09ICdzdHJpbmcnKVxuICAgICAgdGhpcy5jb25maWcudXNlcm5hbWUgPSBjZmcudXNlcjtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlcm5hbWUnKTtcblxuICAgIHRoaXMuY29uZmlnLnBhc3N3b3JkID0gKHR5cGVvZiBjZmcucGFzc3dvcmQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjZmcucGFzc3dvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5jb25maWcucHJpdmF0ZUtleSA9ICh0eXBlb2YgY2ZnLnByaXZhdGVLZXkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBCdWZmZXIuaXNCdWZmZXIoY2ZnLnByaXZhdGVLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNmZy5wcml2YXRlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5jb25maWcubG9jYWxIb3N0bmFtZSA9ICh0eXBlb2YgY2ZnLmxvY2FsSG9zdG5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNmZy5sb2NhbEhvc3RuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5jb25maWcubG9jYWxVc2VybmFtZSA9ICh0eXBlb2YgY2ZnLmxvY2FsVXNlcm5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNmZy5sb2NhbFVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5jb25maWcudHJ5S2V5Ym9hcmQgPSAoY2ZnLnRyeUtleWJvYXJkID09PSB0cnVlKTtcbiAgICBpZiAodHlwZW9mIGNmZy5hZ2VudCA9PT0gJ3N0cmluZycgJiYgY2ZnLmFnZW50Lmxlbmd0aClcbiAgICAgIHRoaXMuY29uZmlnLmFnZW50ID0gY3JlYXRlQWdlbnQoY2ZnLmFnZW50KTtcbiAgICBlbHNlIGlmIChpc0FnZW50KGNmZy5hZ2VudCkpXG4gICAgICB0aGlzLmNvbmZpZy5hZ2VudCA9IGNmZy5hZ2VudDtcbiAgICBlbHNlXG4gICAgICB0aGlzLmNvbmZpZy5hZ2VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbmZpZy5hbGxvd0FnZW50RndkID0gKGNmZy5hZ2VudEZvcndhcmQgPT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMuY29uZmlnLmFnZW50ICE9PSB1bmRlZmluZWQpO1xuICAgIGxldCBhdXRoSGFuZGxlciA9IHRoaXMuY29uZmlnLmF1dGhIYW5kbGVyID0gKFxuICAgICAgdHlwZW9mIGNmZy5hdXRoSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgfHwgQXJyYXkuaXNBcnJheShjZmcuYXV0aEhhbmRsZXIpXG4gICAgICA/IGNmZy5hdXRoSGFuZGxlclxuICAgICAgOiB1bmRlZmluZWRcbiAgICApO1xuXG4gICAgdGhpcy5jb25maWcuc3RyaWN0VmVuZG9yID0gKHR5cGVvZiBjZmcuc3RyaWN0VmVuZG9yID09PSAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjZmcuc3RyaWN0VmVuZG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSk7XG5cbiAgICBjb25zdCBkZWJ1ZyA9IHRoaXMuY29uZmlnLmRlYnVnID0gKHR5cGVvZiBjZmcuZGVidWcgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2ZnLmRlYnVnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG5cbiAgICBpZiAoY2ZnLmFnZW50Rm9yd2FyZCA9PT0gdHJ1ZSAmJiAhdGhpcy5jb25maWcuYWxsb3dBZ2VudEZ3ZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91IG11c3Qgc2V0IGEgdmFsaWQgYWdlbnQgcGF0aCB0byBhbGxvdyBhZ2VudCBmb3J3YXJkaW5nJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5fY2hhbk1nciA9IG5ldyBDaGFubmVsTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLl9mb3J3YXJkaW5nID0ge307XG4gICAgdGhpcy5fZm9yd2FyZGluZ1VuaXggPSB7fTtcbiAgICB0aGlzLl9hY2NlcHRYMTEgPSAwO1xuICAgIHRoaXMuX2FnZW50RndkRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FnZW50ID0gKHRoaXMuY29uZmlnLmFnZW50ID8gdGhpcy5jb25maWcuYWdlbnQgOiB1bmRlZmluZWQpO1xuICAgIHRoaXMuX3JlbW90ZVZlciA9IHVuZGVmaW5lZDtcbiAgICBsZXQgcHJpdmF0ZUtleTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5wcml2YXRlS2V5KSB7XG4gICAgICBwcml2YXRlS2V5ID0gcGFyc2VLZXkodGhpcy5jb25maWcucHJpdmF0ZUtleSwgY2ZnLnBhc3NwaHJhc2UpO1xuICAgICAgaWYgKHByaXZhdGVLZXkgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgcHJpdmF0ZUtleTogJHtwcml2YXRlS2V5Lm1lc3NhZ2V9YCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcml2YXRlS2V5KSkge1xuICAgICAgICAvLyBPcGVuU1NIJ3MgbmV3ZXIgZm9ybWF0IG9ubHkgc3RvcmVzIDEga2V5IGZvciBub3dcbiAgICAgICAgcHJpdmF0ZUtleSA9IHByaXZhdGVLZXlbMF07XG4gICAgICB9XG4gICAgICBpZiAocHJpdmF0ZUtleS5nZXRQcml2YXRlUEVNKCkgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdwcml2YXRlS2V5IHZhbHVlIGRvZXMgbm90IGNvbnRhaW4gYSAodmFsaWQpIHByaXZhdGUga2V5J1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBob3N0VmVyaWZpZXI7XG4gICAgaWYgKHR5cGVvZiBjZmcuaG9zdFZlcmlmaWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBoYXNoQ2IgPSBjZmcuaG9zdFZlcmlmaWVyO1xuICAgICAgbGV0IGhhc2hlcjtcbiAgICAgIGlmIChIQVNIRVMuaW5kZXhPZihjZmcuaG9zdEhhc2gpICE9PSAtMSkge1xuICAgICAgICAvLyBEZWZhdWx0IHRvIG9sZCBiZWhhdmlvciBvZiBoYXNoaW5nIG9uIHVzZXIncyBiZWhhbGZcbiAgICAgICAgaGFzaGVyID0gY3JlYXRlSGFzaChjZmcuaG9zdEhhc2gpO1xuICAgICAgfVxuICAgICAgaG9zdFZlcmlmaWVyID0gKGtleSwgdmVyaWZ5KSA9PiB7XG4gICAgICAgIGlmIChoYXNoZXIpIHtcbiAgICAgICAgICBoYXNoZXIudXBkYXRlKGtleSk7XG4gICAgICAgICAga2V5ID0gaGFzaGVyLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gaGFzaENiKGtleSwgdmVyaWZ5KTtcbiAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHZlcmlmeShyZXQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzb2NrID0gdGhpcy5fc29jayA9IChjZmcuc29jayB8fCBuZXcgU29ja2V0KCkpO1xuICAgIGxldCByZWFkeSA9IGZhbHNlO1xuICAgIGxldCBzYXdIZWFkZXIgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fcHJvdG9jb2wpXG4gICAgICB0aGlzLl9wcm90b2NvbC5jbGVhbnVwKCk7XG4gICAgY29uc3QgREVCVUdfSEFORExFUiA9ICghZGVidWcgPyB1bmRlZmluZWQgOiAocCwgZGlzcGxheSwgbXNnKSA9PiB7XG4gICAgICBkZWJ1ZyhgRGVidWcgb3V0cHV0IGZyb20gc2VydmVyOiAke0pTT04uc3RyaW5naWZ5KG1zZyl9YCk7XG4gICAgfSk7XG4gICAgbGV0IHNlcnZlclNpZ0FsZ3M7XG4gICAgY29uc3QgcHJvdG8gPSB0aGlzLl9wcm90b2NvbCA9IG5ldyBQcm90b2NvbCh7XG4gICAgICBpZGVudDogdGhpcy5jb25maWcuaWRlbnQsXG4gICAgICBvZmZlcjogKGFsbE9mZmVyRGVmYXVsdHMgPyB1bmRlZmluZWQgOiBhbGdvcml0aG1zKSxcbiAgICAgIG9uV3JpdGU6IChkYXRhKSA9PiB7XG4gICAgICAgIGlmIChpc1dyaXRhYmxlKHNvY2spKVxuICAgICAgICAgIHNvY2sud3JpdGUoZGF0YSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyLmxldmVsID09PSAnaGFuZHNoYWtlJylcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVhZHlUaW1lb3V0KTtcbiAgICAgICAgaWYgKCFwcm90by5fZGVzdHJ1Y3QpXG4gICAgICAgICAgc29jay5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc29jay5lbmQoKTtcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfSxcbiAgICAgIG9uSGVhZGVyOiAoaGVhZGVyKSA9PiB7XG4gICAgICAgIHNhd0hlYWRlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlbW90ZVZlciA9IGhlYWRlci52ZXJzaW9ucy5zb2Z0d2FyZTtcbiAgICAgICAgaWYgKGhlYWRlci5ncmVldGluZylcbiAgICAgICAgICB0aGlzLmVtaXQoJ2dyZWV0aW5nJywgaGVhZGVyLmdyZWV0aW5nKTtcbiAgICAgIH0sXG4gICAgICBvbkhhbmRzaGFrZUNvbXBsZXRlOiAobmVnb3RpYXRlZCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIG5lZ290aWF0ZWQpO1xuICAgICAgICBpZiAoIXJlYWR5KSB7XG4gICAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHByb3RvLnNlcnZpY2UoJ3NzaC11c2VyYXV0aCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVidWcsXG4gICAgICBob3N0VmVyaWZpZXIsXG4gICAgICBtZXNzYWdlSGFuZGxlcnM6IHtcbiAgICAgICAgREVCVUc6IERFQlVHX0hBTkRMRVIsXG4gICAgICAgIERJU0NPTk5FQ1Q6IChwLCByZWFzb24sIGRlc2MpID0+IHtcbiAgICAgICAgICBpZiAocmVhc29uICE9PSBESVNDT05ORUNUX1JFQVNPTi5CWV9BUFBMSUNBVElPTikge1xuICAgICAgICAgICAgaWYgKCFkZXNjKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSBESVNDT05ORUNUX1JFQVNPTl9CWV9WQUxVRVtyZWFzb25dO1xuICAgICAgICAgICAgICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRlc2MgPSBgVW5leHBlY3RlZCBkaXNjb25uZWN0aW9uIHJlYXNvbjogJHtyZWFzb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihkZXNjKTtcbiAgICAgICAgICAgIGVyci5jb2RlID0gcmVhc29uO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2suZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFNFUlZJQ0VfQUNDRVBUOiAocCwgbmFtZSkgPT4ge1xuICAgICAgICAgIGlmIChuYW1lID09PSAnc3NoLXVzZXJhdXRoJylcbiAgICAgICAgICAgIHRyeU5leHRBdXRoKCk7XG4gICAgICAgIH0sXG4gICAgICAgIEVYVF9JTkZPOiAocCwgZXh0cykgPT4ge1xuICAgICAgICAgIGlmIChzZXJ2ZXJTaWdBbGdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXh0IG9mIGV4dHMpIHtcbiAgICAgICAgICAgICAgaWYgKGV4dC5uYW1lID09PSAnc2VydmVyLXNpZy1hbGdzJykge1xuICAgICAgICAgICAgICAgIHNlcnZlclNpZ0FsZ3MgPSBleHQuYWxncztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcnZlclNpZ0FsZ3MgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgVVNFUkFVVEhfQkFOTkVSOiAocCwgbXNnKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdiYW5uZXInLCBtc2cpO1xuICAgICAgICB9LFxuICAgICAgICBVU0VSQVVUSF9TVUNDRVNTOiAocCkgPT4ge1xuICAgICAgICAgIC8vIFN0YXJ0IGtlZXBhbGl2ZSBtZWNoYW5pc21cbiAgICAgICAgICByZXNldEtBKCk7XG5cbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVhZHlUaW1lb3V0KTtcblxuICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfSxcbiAgICAgICAgVVNFUkFVVEhfRkFJTFVSRTogKHAsIGF1dGhNZXRob2RzLCBwYXJ0aWFsU3VjY2VzcykgPT4ge1xuICAgICAgICAgIC8vIEZvciBrZXktYmFzZWQgYXV0aGVudGljYXRpb24sIGNoZWNrIGlmIHdlIHNob3VsZCByZXRyeSB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIGtleSB3aXRoIGEgZGlmZmVyZW50IGFsZ29yaXRobSBmaXJzdFxuICAgICAgICAgIGlmIChjdXJBdXRoLmtleUFsZ29zKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRLZXlBbGdvID0gY3VyQXV0aC5rZXlBbGdvc1swXVswXTtcbiAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgZGVidWcoYENsaWVudDogJHtjdXJBdXRoLnR5cGV9ICgke29sZEtleUFsZ299KSBhdXRoIGZhaWxlZGApO1xuICAgICAgICAgICAgY3VyQXV0aC5rZXlBbGdvcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGN1ckF1dGgua2V5QWxnb3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IFtrZXlBbGdvLCBoYXNoQWxnb10gPSBjdXJBdXRoLmtleUFsZ29zWzBdO1xuICAgICAgICAgICAgICBzd2l0Y2ggKGN1ckF1dGgudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FnZW50JzpcbiAgICAgICAgICAgICAgICAgIHByb3RvLmF1dGhQSyhcbiAgICAgICAgICAgICAgICAgICAgY3VyQXV0aC51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY3VyQXV0aC5hZ2VudEN0eC5jdXJyZW50S2V5KCksXG4gICAgICAgICAgICAgICAgICAgIGtleUFsZ29cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAncHVibGlja2V5JzpcbiAgICAgICAgICAgICAgICAgIHByb3RvLmF1dGhQSyhjdXJBdXRoLnVzZXJuYW1lLCBjdXJBdXRoLmtleSwga2V5QWxnbyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnaG9zdGJhc2VkJzpcbiAgICAgICAgICAgICAgICAgIHByb3RvLmF1dGhIb3N0YmFzZWQoY3VyQXV0aC51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyQXV0aC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckF1dGgubG9jYWxIb3N0bmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyQXV0aC5sb2NhbFVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlBbGdvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmLCBjYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBjdXJBdXRoLmtleS5zaWduKGJ1ZiwgaGFzaEFsZ28pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBgRXJyb3Igd2hpbGUgc2lnbmluZyB3aXRoIGtleTogJHtzaWduYXR1cmUubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5sZXZlbCA9ICdjbGllbnQtYXV0aGVudGljYXRpb24nO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlOZXh0QXV0aCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJBdXRoLmtleUFsZ29zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJBdXRoLnR5cGUgPT09ICdhZ2VudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGN1ckF1dGguYWdlbnRDdHgucG9zKCk7XG4gICAgICAgICAgICBkZWJ1ZyAmJiBkZWJ1ZyhgQ2xpZW50OiBBZ2VudCBrZXkgIyR7cG9zICsgMX0gZmFpbGVkYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ5TmV4dEFnZW50S2V5KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVidWcgJiYgZGVidWcoYENsaWVudDogJHtjdXJBdXRoLnR5cGV9IGF1dGggZmFpbGVkYCk7XG5cbiAgICAgICAgICBjdXJQYXJ0aWFsID0gcGFydGlhbFN1Y2Nlc3M7XG4gICAgICAgICAgY3VyQXV0aHNMZWZ0ID0gYXV0aE1ldGhvZHM7XG4gICAgICAgICAgdHJ5TmV4dEF1dGgoKTtcbiAgICAgICAgfSxcbiAgICAgICAgVVNFUkFVVEhfUEFTU1dEX0NIQU5HRVJFUTogKHAsIHByb21wdCkgPT4ge1xuICAgICAgICAgIGlmIChjdXJBdXRoLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYSBgY2hhbmdlUHJvbXB0KClgIG9uIGBjdXJBdXRoYCB0aGF0IGRlZmF1bHRzIHRvXG4gICAgICAgICAgICAvLyBlbWl0dGluZyAnY2hhbmdlIHBhc3N3b3JkJyBhcyBiZWZvcmVcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlIHBhc3N3b3JkJywgcHJvbXB0LCAobmV3UGFzc3dvcmQpID0+IHtcbiAgICAgICAgICAgICAgcHJvdG8uYXV0aFBhc3N3b3JkKFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIG5ld1Bhc3N3b3JkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFVTRVJBVVRIX1BLX09LOiAocCkgPT4ge1xuICAgICAgICAgIGxldCBrZXlBbGdvO1xuICAgICAgICAgIGxldCBoYXNoQWxnbztcbiAgICAgICAgICBpZiAoY3VyQXV0aC5rZXlBbGdvcylcbiAgICAgICAgICAgIFtrZXlBbGdvLCBoYXNoQWxnb10gPSBjdXJBdXRoLmtleUFsZ29zWzBdO1xuICAgICAgICAgIGlmIChjdXJBdXRoLnR5cGUgPT09ICdhZ2VudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGN1ckF1dGguYWdlbnRDdHguY3VycmVudEtleSgpO1xuICAgICAgICAgICAgcHJvdG8uYXV0aFBLKGN1ckF1dGgudXNlcm5hbWUsIGtleSwga2V5QWxnbywgKGJ1ZiwgY2IpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHsgaGFzaDogaGFzaEFsZ28gfTtcbiAgICAgICAgICAgICAgY3VyQXV0aC5hZ2VudEN0eC5zaWduKGtleSwgYnVmLCBvcHRzLCAoZXJyLCBzaWduZWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICBlcnIubGV2ZWwgPSAnYWdlbnQnO1xuICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYihzaWduZWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeU5leHRBZ2VudEtleSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VyQXV0aC50eXBlID09PSAncHVibGlja2V5Jykge1xuICAgICAgICAgICAgcHJvdG8uYXV0aFBLKGN1ckF1dGgudXNlcm5hbWUsIGN1ckF1dGgua2V5LCBrZXlBbGdvLCAoYnVmLCBjYikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBjdXJBdXRoLmtleS5zaWduKGJ1ZiwgaGFzaEFsZ28pO1xuICAgICAgICAgICAgICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICBgRXJyb3Igc2lnbmluZyBkYXRhIHdpdGgga2V5OiAke3NpZ25hdHVyZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLmxldmVsID0gJ2NsaWVudC1hdXRoZW50aWNhdGlvbic7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyeU5leHRBdXRoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgVVNFUkFVVEhfSU5GT19SRVFVRVNUOiAocCwgbmFtZSwgaW5zdHJ1Y3Rpb25zLCBwcm9tcHRzKSA9PiB7XG4gICAgICAgICAgaWYgKGN1ckF1dGgudHlwZSA9PT0gJ2tleWJvYXJkLWludGVyYWN0aXZlJykge1xuICAgICAgICAgICAgY29uc3QgbnByb21wdHMgPSAoQXJyYXkuaXNBcnJheShwcm9tcHRzKSA/IHByb21wdHMubGVuZ3RoIDogMCk7XG4gICAgICAgICAgICBpZiAobnByb21wdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgZGVidWcgJiYgZGVidWcoXG4gICAgICAgICAgICAgICAgJ0NsaWVudDogU2VuZGluZyBhdXRvbWF0aWMgVVNFUkFVVEhfSU5GT19SRVNQT05TRSdcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHJvdG8uYXV0aEluZm9SZXMoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugc2VudCBhIGtleWJvYXJkLWludGVyYWN0aXZlIHVzZXIgYXV0aGVudGljYXRpb24gcmVxdWVzdCBhbmRcbiAgICAgICAgICAgIC8vIG5vdyB0aGUgc2VydmVyIGlzIHNlbmRpbmcgdXMgdGhlIHByb21wdHMgd2UgbmVlZCB0byBwcmVzZW50IHRvXG4gICAgICAgICAgICAvLyB0aGUgdXNlclxuICAgICAgICAgICAgY3VyQXV0aC5wcm9tcHQoXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGluc3RydWN0aW9ucyxcbiAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgIHByb21wdHMsXG4gICAgICAgICAgICAgIChhbnN3ZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvdG8uYXV0aEluZm9SZXMoYW5zd2Vycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBSRVFVRVNUX1NVQ0NFU1M6IChwLCBkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBjYWxsYmFja3Muc2hpZnQoKShmYWxzZSwgZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIFJFUVVFU1RfRkFJTFVSRTogKHApID0+IHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zaGlmdCgpKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBHTE9CQUxfUkVRVUVTVDogKHAsIG5hbWUsIHdhbnRSZXBseSwgZGF0YSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnaG9zdGtleXMtMDBAb3BlbnNzaC5jb20nOlxuICAgICAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHZlcmlmeSBrZXlzIGJlZm9yZSBwYXNzaW5nIHRvIGVuZCB1c2VyXG4gICAgICAgICAgICAgIGhvc3RLZXlzUHJvdmUodGhpcywgZGF0YSwgKGVyciwga2V5cykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdob3N0a2V5cycsIGtleXMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHdhbnRSZXBseSlcbiAgICAgICAgICAgICAgICBwcm90by5yZXF1ZXN0U3VjY2VzcygpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIEF1dG8tcmVqZWN0IGFsbCBvdGhlciBnbG9iYWwgcmVxdWVzdHMsIHRoaXMgY2FuIGJlIGVzcGVjaWFsbHlcbiAgICAgICAgICAgICAgLy8gdXNlZnVsIGlmIHRoZSBzZXJ2ZXIgaXMgc2VuZGluZyB1cyBkdW1teSBrZWVwYWxpdmUgZ2xvYmFsXG4gICAgICAgICAgICAgIC8vIHJlcXVlc3RzXG4gICAgICAgICAgICAgIGlmICh3YW50UmVwbHkpXG4gICAgICAgICAgICAgICAgcHJvdG8ucmVxdWVzdEZhaWx1cmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIENIQU5ORUxfT1BFTjogKHAsIGluZm8pID0+IHtcbiAgICAgICAgICAvLyBIYW5kbGUgaW5jb21pbmcgcmVxdWVzdHMgZnJvbSBzZXJ2ZXIsIHR5cGljYWxseSBhIGZvcndhcmRlZCBUQ1Agb3JcbiAgICAgICAgICAvLyBYMTEgY29ubmVjdGlvblxuICAgICAgICAgIG9uQ0hBTk5FTF9PUEVOKHRoaXMsIGluZm8pO1xuICAgICAgICB9LFxuICAgICAgICBDSEFOTkVMX09QRU5fQ09ORklSTUFUSU9OOiAocCwgaW5mbykgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLl9jaGFuTWdyLmdldChpbmZvLnJlY2lwaWVudCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgY29uc3QgaXNTRlRQID0gKGNoYW5uZWwudHlwZSA9PT0gJ3NmdHAnKTtcbiAgICAgICAgICBjb25zdCB0eXBlID0gKGlzU0ZUUCA/ICdzZXNzaW9uJyA6IGNoYW5uZWwudHlwZSk7XG4gICAgICAgICAgY29uc3QgY2hhbkluZm8gPSB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgaW5jb21pbmc6IHtcbiAgICAgICAgICAgICAgaWQ6IGluZm8ucmVjaXBpZW50LFxuICAgICAgICAgICAgICB3aW5kb3c6IE1BWF9XSU5ET1csXG4gICAgICAgICAgICAgIHBhY2tldFNpemU6IFBBQ0tFVF9TSVpFLFxuICAgICAgICAgICAgICBzdGF0ZTogJ29wZW4nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3V0Z29pbmc6IHtcbiAgICAgICAgICAgICAgaWQ6IGluZm8uc2VuZGVyLFxuICAgICAgICAgICAgICB3aW5kb3c6IGluZm8ud2luZG93LFxuICAgICAgICAgICAgICBwYWNrZXRTaXplOiBpbmZvLnBhY2tldFNpemUsXG4gICAgICAgICAgICAgIHN0YXRlOiAnb3BlbidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gKFxuICAgICAgICAgICAgaXNTRlRQXG4gICAgICAgICAgICA/IG5ldyBTRlRQKHRoaXMsIGNoYW5JbmZvLCB7IGRlYnVnIH0pXG4gICAgICAgICAgICA6IG5ldyBDaGFubmVsKHRoaXMsIGNoYW5JbmZvKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fY2hhbk1nci51cGRhdGUoaW5mby5yZWNpcGllbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICBjaGFubmVsKHVuZGVmaW5lZCwgaW5zdGFuY2UpO1xuICAgICAgICB9LFxuICAgICAgICBDSEFOTkVMX09QRU5fRkFJTFVSRTogKHAsIHJlY2lwaWVudCwgcmVhc29uLCBkZXNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLl9jaGFuTWdyLmdldChyZWNpcGllbnQpO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2hhbm5lbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIGNvbnN0IGluZm8gPSB7IHJlYXNvbiwgZGVzY3JpcHRpb24gfTtcbiAgICAgICAgICBvbkNoYW5uZWxPcGVuRmFpbHVyZSh0aGlzLCByZWNpcGllbnQsIGluZm8sIGNoYW5uZWwpO1xuICAgICAgICB9LFxuICAgICAgICBDSEFOTkVMX0RBVEE6IChwLCByZWNpcGllbnQsIGRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5fY2hhbk1nci5nZXQocmVjaXBpZW50KTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT09ICdvYmplY3QnIHx8IGNoYW5uZWwgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAvLyBUaGUgcmVtb3RlIHBhcnR5IHNob3VsZCBub3QgYmUgc2VuZGluZyB1cyBkYXRhIGlmIHRoZXJlIGlzIG5vXG4gICAgICAgICAgLy8gd2luZG93IHNwYWNlIGF2YWlsYWJsZSAuLi5cbiAgICAgICAgICAvLyBUT0RPOiByYWlzZSBlcnJvciBvbiBkYXRhIHdpdGggbm90IGVub3VnaCB3aW5kb3c/XG4gICAgICAgICAgaWYgKGNoYW5uZWwuaW5jb21pbmcud2luZG93ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgY2hhbm5lbC5pbmNvbWluZy53aW5kb3cgLT0gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoY2hhbm5lbC5wdXNoKGRhdGEpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5fd2FpdENoYW5EcmFpbiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoYW5uZWwuaW5jb21pbmcud2luZG93IDw9IFdJTkRPV19USFJFU0hPTEQpXG4gICAgICAgICAgICB3aW5kb3dBZGp1c3QoY2hhbm5lbCk7XG4gICAgICAgIH0sXG4gICAgICAgIENIQU5ORUxfRVhURU5ERURfREFUQTogKHAsIHJlY2lwaWVudCwgZGF0YSwgdHlwZSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlICE9PSBTVERFUlIpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5fY2hhbk1nci5nZXQocmVjaXBpZW50KTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT09ICdvYmplY3QnIHx8IGNoYW5uZWwgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAvLyBUaGUgcmVtb3RlIHBhcnR5IHNob3VsZCBub3QgYmUgc2VuZGluZyB1cyBkYXRhIGlmIHRoZXJlIGlzIG5vXG4gICAgICAgICAgLy8gd2luZG93IHNwYWNlIGF2YWlsYWJsZSAuLi5cbiAgICAgICAgICAvLyBUT0RPOiByYWlzZSBlcnJvciBvbiBkYXRhIHdpdGggbm90IGVub3VnaCB3aW5kb3c/XG4gICAgICAgICAgaWYgKGNoYW5uZWwuaW5jb21pbmcud2luZG93ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgY2hhbm5lbC5pbmNvbWluZy53aW5kb3cgLT0gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoIWNoYW5uZWwuc3RkZXJyLnB1c2goZGF0YSkpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuX3dhaXRDaGFuRHJhaW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGFubmVsLmluY29taW5nLndpbmRvdyA8PSBXSU5ET1dfVEhSRVNIT0xEKVxuICAgICAgICAgICAgd2luZG93QWRqdXN0KGNoYW5uZWwpO1xuICAgICAgICB9LFxuICAgICAgICBDSEFOTkVMX1dJTkRPV19BREpVU1Q6IChwLCByZWNpcGllbnQsIGFtb3VudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLl9jaGFuTWdyLmdldChyZWNpcGllbnQpO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2hhbm5lbCAhPT0gJ29iamVjdCcgfHwgY2hhbm5lbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIC8vIFRoZSBvdGhlciBzaWRlIGlzIGFsbG93aW5nIHVzIHRvIHNlbmQgYGFtb3VudGAgbW9yZSBieXRlcyBvZiBkYXRhXG4gICAgICAgICAgY2hhbm5lbC5vdXRnb2luZy53aW5kb3cgKz0gYW1vdW50O1xuXG4gICAgICAgICAgaWYgKGNoYW5uZWwuX3dhaXRXaW5kb3cpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuX3dhaXRXaW5kb3cgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGNoYW5uZWwuX2NodW5rKSB7XG4gICAgICAgICAgICAgIGNoYW5uZWwuX3dyaXRlKGNoYW5uZWwuX2NodW5rLCBudWxsLCBjaGFubmVsLl9jaHVua2NiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5fY2h1bmtjYikge1xuICAgICAgICAgICAgICBjaGFubmVsLl9jaHVua2NiKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWwuX2NodW5rRXJyKSB7XG4gICAgICAgICAgICAgIGNoYW5uZWwuc3RkZXJyLl93cml0ZShjaGFubmVsLl9jaHVua0VycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLl9jaHVua2NiRXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5fY2h1bmtjYkVycikge1xuICAgICAgICAgICAgICBjaGFubmVsLl9jaHVua2NiRXJyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBDSEFOTkVMX1NVQ0NFU1M6IChwLCByZWNpcGllbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5fY2hhbk1nci5nZXQocmVjaXBpZW50KTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT09ICdvYmplY3QnIHx8IGNoYW5uZWwgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICB0aGlzLl9yZXNldEtBKCk7XG5cbiAgICAgICAgICBpZiAoY2hhbm5lbC5fY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgIGNoYW5uZWwuX2NhbGxiYWNrcy5zaGlmdCgpKGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgQ0hBTk5FTF9GQUlMVVJFOiAocCwgcmVjaXBpZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuX2NoYW5NZ3IuZ2V0KHJlY2lwaWVudCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9PSAnb2JqZWN0JyB8fCBjaGFubmVsID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgdGhpcy5fcmVzZXRLQSgpO1xuXG4gICAgICAgICAgaWYgKGNoYW5uZWwuX2NhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBjaGFubmVsLl9jYWxsYmFja3Muc2hpZnQoKSh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgQ0hBTk5FTF9SRVFVRVNUOiAocCwgcmVjaXBpZW50LCB0eXBlLCB3YW50UmVwbHksIGRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5fY2hhbk1nci5nZXQocmVjaXBpZW50KTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT09ICdvYmplY3QnIHx8IGNoYW5uZWwgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICBjb25zdCBleGl0ID0gY2hhbm5lbC5fZXhpdDtcbiAgICAgICAgICBpZiAoZXhpdC5jb2RlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdleGl0LXN0YXR1cyc6XG4gICAgICAgICAgICAgIGNoYW5uZWwuZW1pdCgnZXhpdCcsIGV4aXQuY29kZSA9IGRhdGEpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdleGl0LXNpZ25hbCc6XG4gICAgICAgICAgICAgIGNoYW5uZWwuZW1pdCgnZXhpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0LmNvZGUgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdC5zaWduYWwgPSBgU0lHJHtkYXRhLnNpZ25hbH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdC5kdW1wID0gZGF0YS5jb3JlRHVtcGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdC5kZXNjID0gZGF0YS5lcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gS2VlcGFsaXZlIHJlcXVlc3Q/IE9wZW5TU0ggd2lsbCBzZW5kIG9uZSBhcyBhIGNoYW5uZWwgcmVxdWVzdCBpZlxuICAgICAgICAgIC8vIHRoZXJlIGlzIGEgY2hhbm5lbCBvcGVuXG5cbiAgICAgICAgICBpZiAod2FudFJlcGx5KVxuICAgICAgICAgICAgcC5jaGFubmVsRmFpbHVyZShjaGFubmVsLm91dGdvaW5nLmlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgQ0hBTk5FTF9FT0Y6IChwLCByZWNpcGllbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5fY2hhbk1nci5nZXQocmVjaXBpZW50KTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT09ICdvYmplY3QnIHx8IGNoYW5uZWwgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICBpZiAoY2hhbm5lbC5pbmNvbWluZy5zdGF0ZSAhPT0gJ29wZW4nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNoYW5uZWwuaW5jb21pbmcuc3RhdGUgPSAnZW9mJztcblxuICAgICAgICAgIGlmIChjaGFubmVsLnJlYWRhYmxlKVxuICAgICAgICAgICAgY2hhbm5lbC5wdXNoKG51bGwpO1xuICAgICAgICAgIGlmIChjaGFubmVsLnN0ZGVyci5yZWFkYWJsZSlcbiAgICAgICAgICAgIGNoYW5uZWwuc3RkZXJyLnB1c2gobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIENIQU5ORUxfQ0xPU0U6IChwLCByZWNpcGllbnQpID0+IHtcbiAgICAgICAgICBvbkNIQU5ORUxfQ0xPU0UodGhpcywgcmVjaXBpZW50LCB0aGlzLl9jaGFuTWdyLmdldChyZWNpcGllbnQpKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBzb2NrLnBhdXNlKCk7XG5cbiAgICAvLyBUT0RPOiBjaGVjayBrZWVwYWxpdmUgaW1wbGVtZW50YXRpb25cbiAgICAvLyBLZWVwYWxpdmUtcmVsYXRlZFxuICAgIGNvbnN0IGthaW50ZXJ2YWwgPSB0aGlzLmNvbmZpZy5rZWVwYWxpdmVJbnRlcnZhbDtcbiAgICBjb25zdCBrYWNvdW50bWF4ID0gdGhpcy5jb25maWcua2VlcGFsaXZlQ291bnRNYXg7XG4gICAgbGV0IGthY291bnQgPSAwO1xuICAgIGxldCBrYXRpbWVyO1xuICAgIGNvbnN0IHNlbmRLQSA9ICgpID0+IHtcbiAgICAgIGlmICgrK2thY291bnQgPiBrYWNvdW50bWF4KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoa2F0aW1lcik7XG4gICAgICAgIGlmIChzb2NrLnJlYWRhYmxlKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdLZWVwYWxpdmUgdGltZW91dCcpO1xuICAgICAgICAgIGVyci5sZXZlbCA9ICdjbGllbnQtdGltZW91dCc7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgc29jay5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzV3JpdGFibGUoc29jaykpIHtcbiAgICAgICAgLy8gQXBwZW5kIGR1bW15IGNhbGxiYWNrIHRvIGtlZXAgY29ycmVjdCBjYWxsYmFjayBvcmRlclxuICAgICAgICBjYWxsYmFja3MucHVzaChyZXNldEtBKTtcbiAgICAgICAgcHJvdG8ucGluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChrYXRpbWVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlc2V0S0EoKSB7XG4gICAgICBpZiAoa2FpbnRlcnZhbCA+IDApIHtcbiAgICAgICAga2Fjb3VudCA9IDA7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoa2F0aW1lcik7XG4gICAgICAgIGlmIChpc1dyaXRhYmxlKHNvY2spKVxuICAgICAgICAgIGthdGltZXIgPSBzZXRJbnRlcnZhbChzZW5kS0EsIGthaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yZXNldEtBID0gcmVzZXRLQTtcblxuICAgIGNvbnN0IG9uRG9uZSA9ICgoKSA9PiB7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHdhc0Nvbm5lY3RlZCAmJiAhc2F3SGVhZGVyKSB7XG4gICAgICAgICAgY29uc3QgZXJyID1cbiAgICAgICAgICAgIG1ha2VFcnJvcignQ29ubmVjdGlvbiBsb3N0IGJlZm9yZSBoYW5kc2hha2UnLCAncHJvdG9jb2wnLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IG9uQ29ubmVjdCA9ICgoKSA9PiB7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgICAgICB3YXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBkZWJ1ZyAmJiBkZWJ1ZygnU29ja2V0IGNvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcblxuICAgICAgICBjcnlwdG9Jbml0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHByb3RvLnN0YXJ0KCk7XG4gICAgICAgICAgc29jay5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcm90by5wYXJzZShkYXRhLCAwLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXgpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChpc1dyaXRhYmxlKHNvY2spKVxuICAgICAgICAgICAgICAgICAgc29jay5lbmQoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRHJhaW4gc3RkZXJyIGlmIHdlIGFyZSBjb25uZWN0aW9uIGhvcHBpbmcgdXNpbmcgYW4gZXhlYyBzdHJlYW1cbiAgICAgICAgICBpZiAoc29jay5zdGRlcnIgJiYgdHlwZW9mIHNvY2suc3RkZXJyLnJlc3VtZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHNvY2suc3RkZXJyLnJlc3VtZSgpO1xuXG4gICAgICAgICAgc29jay5yZXN1bWUoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNXcml0YWJsZShzb2NrKSlcbiAgICAgICAgICAgICAgc29jay5lbmQoKTtcbiAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGxldCB3YXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICBzb2NrLm9uKCdjb25uZWN0Jywgb25Db25uZWN0KVxuICAgICAgICAub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ3RpbWVvdXQnKTtcbiAgICB9KS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICBkZWJ1ZyAmJiBkZWJ1ZyhgU29ja2V0IGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlYWR5VGltZW91dCk7XG4gICAgICBlcnIubGV2ZWwgPSAnY2xpZW50LXNvY2tldCc7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9KS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgZGVidWcgJiYgZGVidWcoJ1NvY2tldCBlbmRlZCcpO1xuICAgICAgb25Eb25lKCk7XG4gICAgICBwcm90by5jbGVhbnVwKCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVhZHlUaW1lb3V0KTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoa2F0aW1lcik7XG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgIH0pLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGRlYnVnICYmIGRlYnVnKCdTb2NrZXQgY2xvc2VkJyk7XG4gICAgICBvbkRvbmUoKTtcbiAgICAgIHByb3RvLmNsZWFudXAoKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWFkeVRpbWVvdXQpO1xuICAgICAgY2xlYXJJbnRlcnZhbChrYXRpbWVyKTtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcblxuICAgICAgLy8gTm90aWZ5IG91dHN0YW5kaW5nIGNoYW5uZWwgcmVxdWVzdHMgb2YgZGlzY29ubmVjdGlvbiAuLi5cbiAgICAgIGNvbnN0IGNhbGxiYWNrc18gPSBjYWxsYmFja3M7XG4gICAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgZnJvbSBzZXJ2ZXInKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzXy5sZW5ndGg7ICsraSlcbiAgICAgICAgY2FsbGJhY2tzX1tpXShlcnIpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBlcnJvciBmb3IgYW55IGNoYW5uZWxzIHdhaXRpbmcgdG8gYmUgb3BlbmVkXG4gICAgICB0aGlzLl9jaGFuTWdyLmNsZWFudXAoZXJyKTtcbiAgICB9KTtcblxuICAgIC8vIEJlZ2luIGF1dGhlbnRpY2F0aW9uIGhhbmRsaW5nID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBsZXQgY3VyQXV0aDtcbiAgICBsZXQgY3VyUGFydGlhbCA9IG51bGw7XG4gICAgbGV0IGN1ckF1dGhzTGVmdCA9IG51bGw7XG4gICAgY29uc3QgYXV0aHNBbGxvd2VkID0gWydub25lJ107XG4gICAgaWYgKHRoaXMuY29uZmlnLnBhc3N3b3JkICE9PSB1bmRlZmluZWQpXG4gICAgICBhdXRoc0FsbG93ZWQucHVzaCgncGFzc3dvcmQnKTtcbiAgICBpZiAocHJpdmF0ZUtleSAhPT0gdW5kZWZpbmVkKVxuICAgICAgYXV0aHNBbGxvd2VkLnB1c2goJ3B1YmxpY2tleScpO1xuICAgIGlmICh0aGlzLl9hZ2VudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgYXV0aHNBbGxvd2VkLnB1c2goJ2FnZW50Jyk7XG4gICAgaWYgKHRoaXMuY29uZmlnLnRyeUtleWJvYXJkKVxuICAgICAgYXV0aHNBbGxvd2VkLnB1c2goJ2tleWJvYXJkLWludGVyYWN0aXZlJyk7XG4gICAgaWYgKHByaXZhdGVLZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAmJiB0aGlzLmNvbmZpZy5sb2NhbEhvc3RuYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgJiYgdGhpcy5jb25maWcubG9jYWxVc2VybmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdXRoc0FsbG93ZWQucHVzaCgnaG9zdGJhc2VkJyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXV0aEhhbmRsZXIpKVxuICAgICAgYXV0aEhhbmRsZXIgPSBtYWtlU2ltcGxlQXV0aEhhbmRsZXIoYXV0aEhhbmRsZXIpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBhdXRoSGFuZGxlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIGF1dGhIYW5kbGVyID0gbWFrZVNpbXBsZUF1dGhIYW5kbGVyKGF1dGhzQWxsb3dlZCk7XG5cbiAgICBsZXQgaGFzU2VudEF1dGggPSBmYWxzZTtcbiAgICBjb25zdCBkb05leHRBdXRoID0gKG5leHRBdXRoKSA9PiB7XG4gICAgICBpZiAoaGFzU2VudEF1dGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGhhc1NlbnRBdXRoID0gdHJ1ZTtcblxuICAgICAgaWYgKG5leHRBdXRoID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0FsbCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMgZmFpbGVkJyk7XG4gICAgICAgIGVyci5sZXZlbCA9ICdjbGllbnQtYXV0aGVudGljYXRpb24nO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG5leHRBdXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBSZW1haW4gYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aCBvcmlnaW5hbCBgYXV0aEhhbmRsZXIoKWAgdXNhZ2UsXG4gICAgICAgIC8vIHdoaWNoIG9ubHkgc3VwcG9ydGVkIHBhc3NpbmcgbmFtZXMgb2YgbmV4dCBtZXRob2QgdG8gdHJ5IHVzaW5nIGRhdGFcbiAgICAgICAgLy8gZnJvbSB0aGUgYGNvbm5lY3QoKWAgY29uZmlnIG9iamVjdFxuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBuZXh0QXV0aDtcbiAgICAgICAgaWYgKGF1dGhzQWxsb3dlZC5pbmRleE9mKHR5cGUpID09PSAtMSlcbiAgICAgICAgICByZXR1cm4gc2tpcEF1dGgoYEF1dGhlbnRpY2F0aW9uIG1ldGhvZCBub3QgYWxsb3dlZDogJHt0eXBlfWApO1xuXG4gICAgICAgIGNvbnN0IHVzZXJuYW1lID0gdGhpcy5jb25maWcudXNlcm5hbWU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3Bhc3N3b3JkJzpcbiAgICAgICAgICAgIG5leHRBdXRoID0geyB0eXBlLCB1c2VybmFtZSwgcGFzc3dvcmQ6IHRoaXMuY29uZmlnLnBhc3N3b3JkIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwdWJsaWNrZXknOlxuICAgICAgICAgICAgbmV4dEF1dGggPSB7IHR5cGUsIHVzZXJuYW1lLCBrZXk6IHByaXZhdGVLZXkgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2hvc3RiYXNlZCc6XG4gICAgICAgICAgICBuZXh0QXV0aCA9IHtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgdXNlcm5hbWUsXG4gICAgICAgICAgICAgIGtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgbG9jYWxIb3N0bmFtZTogdGhpcy5jb25maWcubG9jYWxIb3N0bmFtZSxcbiAgICAgICAgICAgICAgbG9jYWxVc2VybmFtZTogdGhpcy5jb25maWcubG9jYWxVc2VybmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhZ2VudCc6XG4gICAgICAgICAgICBuZXh0QXV0aCA9IHtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgdXNlcm5hbWUsXG4gICAgICAgICAgICAgIGFnZW50Q3R4OiBuZXcgQWdlbnRDb250ZXh0KHRoaXMuX2FnZW50KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdrZXlib2FyZC1pbnRlcmFjdGl2ZSc6XG4gICAgICAgICAgICBuZXh0QXV0aCA9IHtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgdXNlcm5hbWUsXG4gICAgICAgICAgICAgIHByb21wdDogKC4uLmFyZ3MpID0+IHRoaXMuZW1pdCgna2V5Ym9hcmQtaW50ZXJhY3RpdmUnLCAuLi5hcmdzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgIG5leHRBdXRoID0geyB0eXBlLCB1c2VybmFtZSB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBza2lwQXV0aChcbiAgICAgICAgICAgICAgYFNraXBwaW5nIHVuc3VwcG9ydGVkIGF1dGhlbnRpY2F0aW9uIG1ldGhvZDogJHtuZXh0QXV0aH1gXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0QXV0aCAhPT0gJ29iamVjdCcgfHwgbmV4dEF1dGggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdXRoKFxuICAgICAgICAgIGBTa2lwcGluZyBpbnZhbGlkIGF1dGhlbnRpY2F0aW9uIGF0dGVtcHQ6ICR7bmV4dEF1dGh9YFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBuZXh0QXV0aC51c2VybmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VybmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gc2tpcEF1dGgoXG4gICAgICAgICAgICBgU2tpcHBpbmcgaW52YWxpZCBhdXRoZW50aWNhdGlvbiBhdHRlbXB0OiAke25leHRBdXRofWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBuZXh0QXV0aC50eXBlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdwYXNzd29yZCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFzc3dvcmQgfSA9IG5leHRBdXRoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpXG4gICAgICAgICAgICAgIHJldHVybiBza2lwQXV0aCgnU2tpcHBpbmcgaW52YWxpZCBwYXNzd29yZCBhdXRoIGF0dGVtcHQnKTtcbiAgICAgICAgICAgIG5leHRBdXRoID0geyB0eXBlLCB1c2VybmFtZSwgcGFzc3dvcmQgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdwdWJsaWNrZXknOiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwYXJzZUtleShuZXh0QXV0aC5rZXksIG5leHRBdXRoLnBhc3NwaHJhc2UpO1xuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gc2tpcEF1dGgoJ1NraXBwaW5nIGludmFsaWQga2V5IGF1dGggYXR0ZW1wdCcpO1xuICAgICAgICAgICAgaWYgKCFrZXkuaXNQcml2YXRlS2V5KCkpXG4gICAgICAgICAgICAgIHJldHVybiBza2lwQXV0aCgnU2tpcHBpbmcgbm9uLXByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgICBuZXh0QXV0aCA9IHsgdHlwZSwgdXNlcm5hbWUsIGtleSB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2hvc3RiYXNlZCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbG9jYWxIb3N0bmFtZSwgbG9jYWxVc2VybmFtZSB9ID0gbmV4dEF1dGg7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwYXJzZUtleShuZXh0QXV0aC5rZXksIG5leHRBdXRoLnBhc3NwaHJhc2UpO1xuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICAgICAgfHwgdHlwZW9mIGxvY2FsSG9zdG5hbWUgIT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfHwgdHlwZW9mIGxvY2FsVXNlcm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBza2lwQXV0aCgnU2tpcHBpbmcgaW52YWxpZCBob3N0YmFzZWQgYXV0aCBhdHRlbXB0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtleS5pc1ByaXZhdGVLZXkoKSlcbiAgICAgICAgICAgICAgcmV0dXJuIHNraXBBdXRoKCdTa2lwcGluZyBub24tcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIG5leHRBdXRoID0geyB0eXBlLCB1c2VybmFtZSwga2V5LCBsb2NhbEhvc3RuYW1lLCBsb2NhbFVzZXJuYW1lIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnYWdlbnQnOiB7XG4gICAgICAgICAgICBsZXQgYWdlbnQgPSBuZXh0QXV0aC5hZ2VudDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWdlbnQgPT09ICdzdHJpbmcnICYmIGFnZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBhZ2VudCA9IGNyZWF0ZUFnZW50KGFnZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzQWdlbnQoYWdlbnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBza2lwQXV0aChcbiAgICAgICAgICAgICAgICBgU2tpcHBpbmcgaW52YWxpZCBhZ2VudDogJHtuZXh0QXV0aC5hZ2VudH1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0QXV0aCA9IHsgdHlwZSwgdXNlcm5hbWUsIGFnZW50Q3R4OiBuZXcgQWdlbnRDb250ZXh0KGFnZW50KSB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2tleWJvYXJkLWludGVyYWN0aXZlJzoge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9tcHQgfSA9IG5leHRBdXRoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9tcHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNraXBBdXRoKFxuICAgICAgICAgICAgICAgICdTa2lwcGluZyBpbnZhbGlkIGtleWJvYXJkLWludGVyYWN0aXZlIGF1dGggYXR0ZW1wdCdcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRBdXRoID0geyB0eXBlLCB1c2VybmFtZSwgcHJvbXB0IH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICBuZXh0QXV0aCA9IHsgdHlwZSwgdXNlcm5hbWUgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc2tpcEF1dGgoXG4gICAgICAgICAgICAgIGBTa2lwcGluZyB1bnN1cHBvcnRlZCBhdXRoZW50aWNhdGlvbiBtZXRob2Q6ICR7bmV4dEF1dGh9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VyQXV0aCA9IG5leHRBdXRoO1xuXG4gICAgICAvLyBCZWdpbiBhdXRoZW50aWNhdGlvbiBtZXRob2QncyBwcm9jZXNzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1c2VybmFtZSA9IGN1ckF1dGgudXNlcm5hbWU7XG4gICAgICAgIHN3aXRjaCAoY3VyQXV0aC50eXBlKSB7XG4gICAgICAgICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgICAgICAgcHJvdG8uYXV0aFBhc3N3b3JkKHVzZXJuYW1lLCBjdXJBdXRoLnBhc3N3b3JkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3B1YmxpY2tleSc6IHtcbiAgICAgICAgICAgIGxldCBrZXlBbGdvO1xuICAgICAgICAgICAgY3VyQXV0aC5rZXlBbGdvcyA9IGdldEtleUFsZ29zKHRoaXMsIGN1ckF1dGgua2V5LCBzZXJ2ZXJTaWdBbGdzKTtcbiAgICAgICAgICAgIGlmIChjdXJBdXRoLmtleUFsZ29zKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJBdXRoLmtleUFsZ29zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGtleUFsZ28gPSBjdXJBdXRoLmtleUFsZ29zWzBdWzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBza2lwQXV0aChcbiAgICAgICAgICAgICAgICAgICdTa2lwcGluZyBrZXkgYXV0aGVudGljYXRpb24gKG5vIG11dHVhbCBoYXNoIGFsZ29yaXRobSknXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvdG8uYXV0aFBLKHVzZXJuYW1lLCBjdXJBdXRoLmtleSwga2V5QWxnbyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnaG9zdGJhc2VkJzoge1xuICAgICAgICAgICAgbGV0IGtleUFsZ287XG4gICAgICAgICAgICBsZXQgaGFzaEFsZ287XG4gICAgICAgICAgICBjdXJBdXRoLmtleUFsZ29zID0gZ2V0S2V5QWxnb3ModGhpcywgY3VyQXV0aC5rZXksIHNlcnZlclNpZ0FsZ3MpO1xuICAgICAgICAgICAgaWYgKGN1ckF1dGgua2V5QWxnb3MpIHtcbiAgICAgICAgICAgICAgaWYgKGN1ckF1dGgua2V5QWxnb3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgW2tleUFsZ28sIGhhc2hBbGdvXSA9IGN1ckF1dGgua2V5QWxnb3NbMF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNraXBBdXRoKFxuICAgICAgICAgICAgICAgICAgJ1NraXBwaW5nIGhvc3RiYXNlZCBhdXRoZW50aWNhdGlvbiAobm8gbXV0dWFsIGhhc2ggYWxnb3JpdGhtKSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3RvLmF1dGhIb3N0YmFzZWQodXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckF1dGgua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJBdXRoLmxvY2FsSG9zdG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckF1dGgubG9jYWxVc2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5QWxnbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZiwgY2IpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gY3VyQXV0aC5rZXkuc2lnbihidWYsIGhhc2hBbGdvKTtcbiAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLm1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgYEVycm9yIHdoaWxlIHNpZ25pbmcgd2l0aCBrZXk6ICR7c2lnbmF0dXJlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUubGV2ZWwgPSAnY2xpZW50LWF1dGhlbnRpY2F0aW9uJztcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5TmV4dEF1dGgoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNiKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdhZ2VudCc6XG4gICAgICAgICAgICBjdXJBdXRoLmFnZW50Q3R4LmluaXQoKGVycikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyLmxldmVsID0gJ2FnZW50JztcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5TmV4dEF1dGgoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnlOZXh0QWdlbnRLZXkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAna2V5Ym9hcmQtaW50ZXJhY3RpdmUnOlxuICAgICAgICAgICAgcHJvdG8uYXV0aEtleWJvYXJkKHVzZXJuYW1lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgcHJvdG8uYXV0aE5vbmUodXNlcm5hbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGhhc1NlbnRBdXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNraXBBdXRoKG1zZykge1xuICAgICAgZGVidWcgJiYgZGVidWcobXNnKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2sodHJ5TmV4dEF1dGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyeU5leHRBdXRoKCkge1xuICAgICAgaGFzU2VudEF1dGggPSBmYWxzZTtcbiAgICAgIGNvbnN0IGF1dGggPSBhdXRoSGFuZGxlcihjdXJBdXRoc0xlZnQsIGN1clBhcnRpYWwsIGRvTmV4dEF1dGgpO1xuICAgICAgaWYgKGhhc1NlbnRBdXRoIHx8IGF1dGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZG9OZXh0QXV0aChhdXRoKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cnlOZXh0QWdlbnRLZXkgPSAoKSA9PiB7XG4gICAgICBpZiAoY3VyQXV0aC50eXBlID09PSAnYWdlbnQnKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGN1ckF1dGguYWdlbnRDdHgubmV4dEtleSgpO1xuICAgICAgICBpZiAoa2V5ID09PSBmYWxzZSkge1xuICAgICAgICAgIGRlYnVnICYmIGRlYnVnKCdBZ2VudDogTm8gbW9yZSBrZXlzIGxlZnQgdG8gdHJ5Jyk7XG4gICAgICAgICAgZGVidWcgJiYgZGVidWcoJ0NsaWVudDogYWdlbnQgYXV0aCBmYWlsZWQnKTtcbiAgICAgICAgICB0cnlOZXh0QXV0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBvcyA9IGN1ckF1dGguYWdlbnRDdHgucG9zKCk7XG4gICAgICAgICAgbGV0IGtleUFsZ287XG4gICAgICAgICAgY3VyQXV0aC5rZXlBbGdvcyA9IGdldEtleUFsZ29zKHRoaXMsIGtleSwgc2VydmVyU2lnQWxncyk7XG4gICAgICAgICAgaWYgKGN1ckF1dGgua2V5QWxnb3MpIHtcbiAgICAgICAgICAgIGlmIChjdXJBdXRoLmtleUFsZ29zLmxlbmd0aCkge1xuICAgICAgICAgICAgICBrZXlBbGdvID0gY3VyQXV0aC5rZXlBbGdvc1swXVswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlYnVnICYmIGRlYnVnKFxuICAgICAgICAgICAgICAgIGBBZ2VudDogU2tpcHBpbmcga2V5ICMke3BvcyArIDF9IChubyBtdXR1YWwgaGFzaCBhbGdvcml0aG0pYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0cnlOZXh0QWdlbnRLZXkoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZWJ1ZyAmJiBkZWJ1ZyhgQWdlbnQ6IFRyeWluZyBrZXkgIyR7cG9zICsgMX1gKTtcbiAgICAgICAgICBwcm90by5hdXRoUEsoY3VyQXV0aC51c2VybmFtZSwga2V5LCBrZXlBbGdvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBzdGFydFRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25maWcucmVhZHlUaW1lb3V0ID4gMCkge1xuICAgICAgICB0aGlzLl9yZWFkeVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1RpbWVkIG91dCB3aGlsZSB3YWl0aW5nIGZvciBoYW5kc2hha2UnKTtcbiAgICAgICAgICBlcnIubGV2ZWwgPSAnY2xpZW50LXRpbWVvdXQnO1xuICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgIHNvY2suZGVzdHJveSgpO1xuICAgICAgICB9LCB0aGlzLmNvbmZpZy5yZWFkeVRpbWVvdXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWNmZy5zb2NrKSB7XG4gICAgICBsZXQgaG9zdCA9IHRoaXMuY29uZmlnLmhvc3Q7XG4gICAgICBjb25zdCBmb3JjZUlQdjQgPSB0aGlzLmNvbmZpZy5mb3JjZUlQdjQ7XG4gICAgICBjb25zdCBmb3JjZUlQdjYgPSB0aGlzLmNvbmZpZy5mb3JjZUlQdjY7XG5cbiAgICAgIGRlYnVnICYmIGRlYnVnKGBDbGllbnQ6IFRyeWluZyAke2hvc3R9IG9uIHBvcnQgJHt0aGlzLmNvbmZpZy5wb3J0fSAuLi5gKTtcblxuICAgICAgY29uc3QgZG9Db25uZWN0ID0gKCkgPT4ge1xuICAgICAgICBzdGFydFRpbWVvdXQoKTtcbiAgICAgICAgc29jay5jb25uZWN0KHtcbiAgICAgICAgICBob3N0LFxuICAgICAgICAgIHBvcnQ6IHRoaXMuY29uZmlnLnBvcnQsXG4gICAgICAgICAgbG9jYWxBZGRyZXNzOiB0aGlzLmNvbmZpZy5sb2NhbEFkZHJlc3MsXG4gICAgICAgICAgbG9jYWxQb3J0OiB0aGlzLmNvbmZpZy5sb2NhbFBvcnRcbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2suc2V0TWF4TGlzdGVuZXJzKDApO1xuICAgICAgICBzb2NrLnNldFRpbWVvdXQodHlwZW9mIGNmZy50aW1lb3V0ID09PSAnbnVtYmVyJyA/IGNmZy50aW1lb3V0IDogMCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoKCFmb3JjZUlQdjQgJiYgIWZvcmNlSVB2NikgfHwgKGZvcmNlSVB2NCAmJiBmb3JjZUlQdjYpKSB7XG4gICAgICAgIGRvQ29ubmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG5zTG9va3VwKGhvc3QsIChmb3JjZUlQdjQgPyA0IDogNiksIChlcnIsIGFkZHJlc3MsIGZhbWlseSkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSAoZm9yY2VJUHY0ID8gJ0lQdjQnIDogJ0lQdjYnKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgRXJyb3Igd2hpbGUgbG9va2luZyB1cCAke3R5cGV9IGFkZHJlc3MgZm9yICcke2hvc3R9JzogJHtlcnJ9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWFkeVRpbWVvdXQpO1xuICAgICAgICAgICAgZXJyb3IubGV2ZWwgPSAnY2xpZW50LWRucyc7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBob3N0ID0gYWRkcmVzcztcbiAgICAgICAgICBkb0Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN1c3RvbSBzb2NrZXQgcGFzc2VkIGluXG4gICAgICBzdGFydFRpbWVvdXQoKTtcbiAgICAgIGlmICh0eXBlb2Ygc29jay5jb25uZWN0aW5nID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgLy8gbmV0LlNvY2tldFxuXG4gICAgICAgIGlmICghc29jay5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgLy8gQWxyZWFkeSBjb25uZWN0ZWRcbiAgICAgICAgICBvbkNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXNzdW1lIHNvY2tldC9zdHJlYW0gaXMgYWxyZWFkeSBcImNvbm5lY3RlZFwiXG4gICAgICAgIG9uQ29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZW5kKCkge1xuICAgIGlmICh0aGlzLl9zb2NrICYmIGlzV3JpdGFibGUodGhpcy5fc29jaykpIHtcbiAgICAgIHRoaXMuX3Byb3RvY29sLmRpc2Nvbm5lY3QoRElTQ09OTkVDVF9SRUFTT04uQllfQVBQTElDQVRJT04pO1xuICAgICAgdGhpcy5fc29jay5lbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3NvY2sgJiYgaXNXcml0YWJsZSh0aGlzLl9zb2NrKSAmJiB0aGlzLl9zb2NrLmRlc3Ryb3koKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGV4ZWMoY21kLCBvcHRzLCBjYikge1xuICAgIGlmICghdGhpcy5fc29jayB8fCAhaXNXcml0YWJsZSh0aGlzLl9zb2NrKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdHM7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgY29uc3QgZXh0cmFPcHRzID0geyBhbGxvd0hhbGZPcGVuOiAob3B0cy5hbGxvd0hhbGZPcGVuICE9PSBmYWxzZSkgfTtcblxuICAgIG9wZW5DaGFubmVsKHRoaXMsICdzZXNzaW9uJywgZXh0cmFPcHRzLCAoZXJyLCBjaGFuKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9kbyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiByZXFDYihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNoYW4uY2xvc2UoKTtcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9kby5sZW5ndGgpXG4gICAgICAgICAgdG9kby5zaGlmdCgpKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5hbGxvd0FnZW50RndkID09PSB0cnVlXG4gICAgICAgICAgfHwgKG9wdHNcbiAgICAgICAgICAgICAgJiYgb3B0cy5hZ2VudEZvcndhcmQgPT09IHRydWVcbiAgICAgICAgICAgICAgJiYgdGhpcy5fYWdlbnQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdG9kby5wdXNoKCgpID0+IHJlcUFnZW50RndkKGNoYW4sIHJlcUNiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgb3B0cyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMuZW52ID09PSAnb2JqZWN0JyAmJiBvcHRzLmVudiAhPT0gbnVsbClcbiAgICAgICAgICByZXFFbnYoY2hhbiwgb3B0cy5lbnYpO1xuICAgICAgICBpZiAoKHR5cGVvZiBvcHRzLnB0eSA9PT0gJ29iamVjdCcgJiYgb3B0cy5wdHkgIT09IG51bGwpXG4gICAgICAgICAgICB8fCBvcHRzLnB0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRvZG8ucHVzaCgoKSA9PiByZXFQdHkoY2hhbiwgb3B0cy5wdHksIHJlcUNiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlb2Ygb3B0cy54MTEgPT09ICdvYmplY3QnICYmIG9wdHMueDExICE9PSBudWxsKVxuICAgICAgICAgICAgfHwgb3B0cy54MTEgPT09ICdudW1iZXInXG4gICAgICAgICAgICB8fCBvcHRzLngxMSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRvZG8ucHVzaCgoKSA9PiByZXFYMTEoY2hhbiwgb3B0cy54MTEsIHJlcUNiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9kby5wdXNoKCgpID0+IHJlcUV4ZWMoY2hhbiwgY21kLCBvcHRzLCBjYikpO1xuICAgICAgdG9kby5zaGlmdCgpKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNoZWxsKHduZG9wdHMsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrIHx8ICFpc1dyaXRhYmxlKHRoaXMuX3NvY2spKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJyk7XG5cbiAgICBpZiAodHlwZW9mIHduZG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gd25kb3B0cztcbiAgICAgIHduZG9wdHMgPSBvcHRzID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0cztcbiAgICAgIG9wdHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh3bmRvcHRzICYmICh3bmRvcHRzLngxMSAhPT0gdW5kZWZpbmVkIHx8IHduZG9wdHMuZW52ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICBvcHRzID0gd25kb3B0cztcbiAgICAgIHduZG9wdHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgb3BlbkNoYW5uZWwodGhpcywgJ3Nlc3Npb24nLCAoZXJyLCBjaGFuKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9kbyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiByZXFDYihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNoYW4uY2xvc2UoKTtcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9kby5sZW5ndGgpXG4gICAgICAgICAgdG9kby5zaGlmdCgpKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5hbGxvd0FnZW50RndkID09PSB0cnVlXG4gICAgICAgICAgfHwgKG9wdHNcbiAgICAgICAgICAgICAgJiYgb3B0cy5hZ2VudEZvcndhcmQgPT09IHRydWVcbiAgICAgICAgICAgICAgJiYgdGhpcy5fYWdlbnQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdG9kby5wdXNoKCgpID0+IHJlcUFnZW50RndkKGNoYW4sIHJlcUNiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3bmRvcHRzICE9PSBmYWxzZSlcbiAgICAgICAgdG9kby5wdXNoKCgpID0+IHJlcVB0eShjaGFuLCB3bmRvcHRzLCByZXFDYikpO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmIG9wdHMgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmVudiA9PT0gJ29iamVjdCcgJiYgb3B0cy5lbnYgIT09IG51bGwpXG4gICAgICAgICAgcmVxRW52KGNoYW4sIG9wdHMuZW52KTtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb3B0cy54MTEgPT09ICdvYmplY3QnICYmIG9wdHMueDExICE9PSBudWxsKVxuICAgICAgICAgICAgfHwgb3B0cy54MTEgPT09ICdudW1iZXInXG4gICAgICAgICAgICB8fCBvcHRzLngxMSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRvZG8ucHVzaCgoKSA9PiByZXFYMTEoY2hhbiwgb3B0cy54MTEsIHJlcUNiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9kby5wdXNoKCgpID0+IHJlcVNoZWxsKGNoYW4sIGNiKSk7XG4gICAgICB0b2RvLnNoaWZ0KCkoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3Vic3lzKG5hbWUsIGNiKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrIHx8ICFpc1dyaXRhYmxlKHRoaXMuX3NvY2spKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJyk7XG5cbiAgICBvcGVuQ2hhbm5lbCh0aGlzLCAnc2Vzc2lvbicsIChlcnIsIGNoYW4pID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXFTdWJzeXN0ZW0oY2hhbiwgbmFtZSwgKGVyciwgc3RyZWFtKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNiKHVuZGVmaW5lZCwgc3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3J3YXJkSW4oYmluZEFkZHIsIGJpbmRQb3J0LCBjYikge1xuICAgIGlmICghdGhpcy5fc29jayB8fCAhaXNXcml0YWJsZSh0aGlzLl9zb2NrKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpO1xuXG4gICAgLy8gU2VuZCBhIHJlcXVlc3QgZm9yIHRoZSBzZXJ2ZXIgdG8gc3RhcnQgZm9yd2FyZGluZyBUQ1AgY29ubmVjdGlvbnMgdG8gdXNcbiAgICAvLyBvbiBhIHBhcnRpY3VsYXIgYWRkcmVzcyBhbmQgcG9ydFxuXG4gICAgY29uc3Qgd2FudFJlcGx5ID0gKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyk7XG5cbiAgICBpZiAod2FudFJlcGx5KSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MucHVzaCgoaGFkX2VyciwgZGF0YSkgPT4ge1xuICAgICAgICBpZiAoaGFkX2Vycikge1xuICAgICAgICAgIGNiKGhhZF9lcnIgIT09IHRydWVcbiAgICAgICAgICAgICA/IGhhZF9lcnJcbiAgICAgICAgICAgICA6IG5ldyBFcnJvcihgVW5hYmxlIHRvIGJpbmQgdG8gJHtiaW5kQWRkcn06JHtiaW5kUG9ydH1gKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlYWxQb3J0ID0gYmluZFBvcnQ7XG4gICAgICAgIGlmIChiaW5kUG9ydCA9PT0gMCAmJiBkYXRhICYmIGRhdGEubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICByZWFsUG9ydCA9IHJlYWRVSW50MzJCRShkYXRhLCAwKTtcbiAgICAgICAgICBpZiAoISh0aGlzLl9wcm90b2NvbC5fY29tcGF0RmxhZ3MgJiBDT01QQVQuRFlOX1JQT1JUX0JVRykpXG4gICAgICAgICAgICBiaW5kUG9ydCA9IHJlYWxQb3J0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZm9yd2FyZGluZ1tgJHtiaW5kQWRkcn06JHtiaW5kUG9ydH1gXSA9IHJlYWxQb3J0O1xuXG4gICAgICAgIGNiKHVuZGVmaW5lZCwgcmVhbFBvcnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJvdG9jb2wudGNwaXBGb3J3YXJkKGJpbmRBZGRyLCBiaW5kUG9ydCwgd2FudFJlcGx5KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdW5mb3J3YXJkSW4oYmluZEFkZHIsIGJpbmRQb3J0LCBjYikge1xuICAgIGlmICghdGhpcy5fc29jayB8fCAhaXNXcml0YWJsZSh0aGlzLl9zb2NrKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpO1xuXG4gICAgLy8gU2VuZCBhIHJlcXVlc3QgdG8gc3RvcCBmb3J3YXJkaW5nIHVzIG5ldyBjb25uZWN0aW9ucyBmb3IgYSBwYXJ0aWN1bGFyXG4gICAgLy8gYWRkcmVzcyBhbmQgcG9ydFxuXG4gICAgY29uc3Qgd2FudFJlcGx5ID0gKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyk7XG5cbiAgICBpZiAod2FudFJlcGx5KSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MucHVzaCgoaGFkX2VycikgPT4ge1xuICAgICAgICBpZiAoaGFkX2Vycikge1xuICAgICAgICAgIGNiKGhhZF9lcnIgIT09IHRydWVcbiAgICAgICAgICAgICA/IGhhZF9lcnJcbiAgICAgICAgICAgICA6IG5ldyBFcnJvcihgVW5hYmxlIHRvIHVuYmluZCBmcm9tICR7YmluZEFkZHJ9OiR7YmluZFBvcnR9YCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9mb3J3YXJkaW5nW2Ake2JpbmRBZGRyfToke2JpbmRQb3J0fWBdO1xuXG4gICAgICAgIGNiKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm90b2NvbC5jYW5jZWxUY3BpcEZvcndhcmQoYmluZEFkZHIsIGJpbmRQb3J0LCB3YW50UmVwbHkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3J3YXJkT3V0KHNyY0lQLCBzcmNQb3J0LCBkc3RJUCwgZHN0UG9ydCwgY2IpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2sgfHwgIWlzV3JpdGFibGUodGhpcy5fc29jaykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKTtcblxuICAgIC8vIFNlbmQgYSByZXF1ZXN0IHRvIGZvcndhcmQgYSBUQ1AgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyXG5cbiAgICBjb25zdCBjZmcgPSB7XG4gICAgICBzcmNJUDogc3JjSVAsXG4gICAgICBzcmNQb3J0OiBzcmNQb3J0LFxuICAgICAgZHN0SVA6IGRzdElQLFxuICAgICAgZHN0UG9ydDogZHN0UG9ydFxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBub29wO1xuXG4gICAgb3BlbkNoYW5uZWwodGhpcywgJ2RpcmVjdC10Y3BpcCcsIGNmZywgY2IpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvcGVuc3NoX25vTW9yZVNlc3Npb25zKGNiKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrIHx8ICFpc1dyaXRhYmxlKHRoaXMuX3NvY2spKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJyk7XG5cbiAgICBjb25zdCB3YW50UmVwbHkgPSAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKTtcblxuICAgIGlmICghdGhpcy5jb25maWcuc3RyaWN0VmVuZG9yXG4gICAgICAgIHx8ICh0aGlzLmNvbmZpZy5zdHJpY3RWZW5kb3IgJiYgUkVfT1BFTlNTSC50ZXN0KHRoaXMuX3JlbW90ZVZlcikpKSB7XG4gICAgICBpZiAod2FudFJlcGx5KSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKChoYWRfZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGhhZF9lcnIpIHtcbiAgICAgICAgICAgIGNiKGhhZF9lcnIgIT09IHRydWVcbiAgICAgICAgICAgICAgID8gaGFkX2VyclxuICAgICAgICAgICAgICAgOiBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkaXNhYmxlIGZ1dHVyZSBzZXNzaW9ucycpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJvdG9jb2wub3BlbnNzaF9ub01vcmVTZXNzaW9ucyh3YW50UmVwbHkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCF3YW50UmVwbHkpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIHByb2Nlc3MubmV4dFRpY2soXG4gICAgICBjYixcbiAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgJ3N0cmljdFZlbmRvciBlbmFibGVkIGFuZCBzZXJ2ZXIgaXMgbm90IE9wZW5TU0ggb3IgY29tcGF0aWJsZSB2ZXJzaW9uJ1xuICAgICAgKVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9wZW5zc2hfZm9yd2FyZEluU3RyZWFtTG9jYWwoc29ja2V0UGF0aCwgY2IpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2sgfHwgIWlzV3JpdGFibGUodGhpcy5fc29jaykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKTtcblxuICAgIGNvbnN0IHdhbnRSZXBseSA9ICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpO1xuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5zdHJpY3RWZW5kb3JcbiAgICAgICAgfHwgKHRoaXMuY29uZmlnLnN0cmljdFZlbmRvciAmJiBSRV9PUEVOU1NILnRlc3QodGhpcy5fcmVtb3RlVmVyKSkpIHtcbiAgICAgIGlmICh3YW50UmVwbHkpIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goKGhhZF9lcnIpID0+IHtcbiAgICAgICAgICBpZiAoaGFkX2Vycikge1xuICAgICAgICAgICAgY2IoaGFkX2VyciAhPT0gdHJ1ZVxuICAgICAgICAgICAgICAgPyBoYWRfZXJyXG4gICAgICAgICAgICAgICA6IG5ldyBFcnJvcihgVW5hYmxlIHRvIGJpbmQgdG8gJHtzb2NrZXRQYXRofWApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZm9yd2FyZGluZ1VuaXhbc29ja2V0UGF0aF0gPSB0cnVlO1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcm90b2NvbC5vcGVuc3NoX3N0cmVhbUxvY2FsRm9yd2FyZChzb2NrZXRQYXRoLCB3YW50UmVwbHkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCF3YW50UmVwbHkpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIHByb2Nlc3MubmV4dFRpY2soXG4gICAgICBjYixcbiAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgJ3N0cmljdFZlbmRvciBlbmFibGVkIGFuZCBzZXJ2ZXIgaXMgbm90IE9wZW5TU0ggb3IgY29tcGF0aWJsZSB2ZXJzaW9uJ1xuICAgICAgKVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9wZW5zc2hfdW5mb3J3YXJkSW5TdHJlYW1Mb2NhbChzb2NrZXRQYXRoLCBjYikge1xuICAgIGlmICghdGhpcy5fc29jayB8fCAhaXNXcml0YWJsZSh0aGlzLl9zb2NrKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpO1xuXG4gICAgY29uc3Qgd2FudFJlcGx5ID0gKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyk7XG5cbiAgICBpZiAoIXRoaXMuY29uZmlnLnN0cmljdFZlbmRvclxuICAgICAgICB8fCAodGhpcy5jb25maWcuc3RyaWN0VmVuZG9yICYmIFJFX09QRU5TU0gudGVzdCh0aGlzLl9yZW1vdGVWZXIpKSkge1xuICAgICAgaWYgKHdhbnRSZXBseSkge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaCgoaGFkX2VycikgPT4ge1xuICAgICAgICAgIGlmIChoYWRfZXJyKSB7XG4gICAgICAgICAgICBjYihoYWRfZXJyICE9PSB0cnVlXG4gICAgICAgICAgICAgICA/IGhhZF9lcnJcbiAgICAgICAgICAgICAgIDogbmV3IEVycm9yKGBVbmFibGUgdG8gdW5iaW5kIGZyb20gJHtzb2NrZXRQYXRofWApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2ZvcndhcmRpbmdVbml4W3NvY2tldFBhdGhdO1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcm90b2NvbC5vcGVuc3NoX2NhbmNlbFN0cmVhbUxvY2FsRm9yd2FyZChzb2NrZXRQYXRoLCB3YW50UmVwbHkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCF3YW50UmVwbHkpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIHByb2Nlc3MubmV4dFRpY2soXG4gICAgICBjYixcbiAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgJ3N0cmljdFZlbmRvciBlbmFibGVkIGFuZCBzZXJ2ZXIgaXMgbm90IE9wZW5TU0ggb3IgY29tcGF0aWJsZSB2ZXJzaW9uJ1xuICAgICAgKVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9wZW5zc2hfZm9yd2FyZE91dFN0cmVhbUxvY2FsKHNvY2tldFBhdGgsIGNiKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrIHx8ICFpc1dyaXRhYmxlKHRoaXMuX3NvY2spKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJyk7XG5cbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBub29wO1xuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5zdHJpY3RWZW5kb3JcbiAgICAgICAgfHwgKHRoaXMuY29uZmlnLnN0cmljdFZlbmRvciAmJiBSRV9PUEVOU1NILnRlc3QodGhpcy5fcmVtb3RlVmVyKSkpIHtcbiAgICAgIG9wZW5DaGFubmVsKHRoaXMsICdkaXJlY3Qtc3RyZWFtbG9jYWxAb3BlbnNzaC5jb20nLCB7IHNvY2tldFBhdGggfSwgY2IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHByb2Nlc3MubmV4dFRpY2soXG4gICAgICBjYixcbiAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgJ3N0cmljdFZlbmRvciBlbmFibGVkIGFuZCBzZXJ2ZXIgaXMgbm90IE9wZW5TU0ggb3IgY29tcGF0aWJsZSB2ZXJzaW9uJ1xuICAgICAgKVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNmdHAoY2IpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2sgfHwgIWlzV3JpdGFibGUodGhpcy5fc29jaykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKTtcblxuICAgIG9wZW5DaGFubmVsKHRoaXMsICdzZnRwJywgKGVyciwgc2Z0cCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcVN1YnN5c3RlbShzZnRwLCAnc2Z0cCcsIChlcnIsIHNmdHBfKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICAgICAgICBzZnRwLnJlbW92ZUxpc3RlbmVyKCdyZWFkeScsIG9uUmVhZHkpO1xuICAgICAgICAgIHNmdHAucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgc2Z0cC5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIG9uRXhpdCk7XG4gICAgICAgICAgc2Z0cC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkV4aXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25SZWFkeSgpIHtcbiAgICAgICAgICAvLyBUT0RPOiBkbyBub3QgcmVtb3ZlIGV4aXQvY2xvc2UgaW4gY2FzZSByZW1vdGUgZW5kIGNsb3NlcyB0aGVcbiAgICAgICAgICAvLyBjaGFubmVsIGFicnVwdGx5IGFuZCB3ZSBuZWVkIHRvIG5vdGlmeSBvdXRzdGFuZGluZyBjYWxsYmFja3NcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICBjYih1bmRlZmluZWQsIHNmdHApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25FeGl0KGNvZGUsIHNpZ25hbCkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIGxldCBtc2c7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIG1zZyA9IGBSZWNlaXZlZCBleGl0IGNvZGUgJHtjb2RlfSB3aGlsZSBlc3RhYmxpc2hpbmcgU0ZUUCBzZXNzaW9uYDtcbiAgICAgICAgICBlbHNlIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG1zZyA9IGBSZWNlaXZlZCBzaWduYWwgJHtzaWduYWx9IHdoaWxlIGVzdGFibGlzaGluZyBTRlRQIHNlc3Npb25gO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1zZyA9ICdSZWNlaXZlZCB1bmV4cGVjdGVkIFNGVFAgc2Vzc2lvbiB0ZXJtaW5hdGlvbic7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgZXJyLmNvZGUgPSBjb2RlO1xuICAgICAgICAgIGVyci5zaWduYWwgPSBzaWduYWw7XG4gICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNmdHAub24oJ3JlYWR5Jywgb25SZWFkeSlcbiAgICAgICAgICAgIC5vbignZXJyb3InLCBvbkVycm9yKVxuICAgICAgICAgICAgLm9uKCdleGl0Jywgb25FeGl0KVxuICAgICAgICAgICAgLm9uKCdjbG9zZScsIG9uRXhpdCk7XG5cbiAgICAgICAgc2Z0cC5faW5pdCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE5vRGVsYXkobm9EZWxheSkge1xuICAgIGlmICh0aGlzLl9zb2NrICYmIHR5cGVvZiB0aGlzLl9zb2NrLnNldE5vRGVsYXkgPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLl9zb2NrLnNldE5vRGVsYXkobm9EZWxheSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5mdW5jdGlvbiBvcGVuQ2hhbm5lbChzZWxmLCB0eXBlLCBvcHRzLCBjYikge1xuICAvLyBBc2sgdGhlIHNlcnZlciB0byBvcGVuIGEgY2hhbm5lbCBmb3Igc29tZSBwdXJwb3NlXG4gIC8vIChlLmcuIHNlc3Npb24gKHNmdHAsIGV4ZWMsIHNoZWxsKSwgb3IgZm9yd2FyZGluZyBhIFRDUCBjb25uZWN0aW9uXG4gIGNvbnN0IGluaXRXaW5kb3cgPSBNQVhfV0lORE9XO1xuICBjb25zdCBtYXhQYWNrZXQgPSBQQUNLRVRfU0laRTtcblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY29uc3Qgd3JhcHBlciA9IChlcnIsIHN0cmVhbSkgPT4ge1xuICAgIGNiKGVyciwgc3RyZWFtKTtcbiAgfTtcbiAgd3JhcHBlci50eXBlID0gdHlwZTtcblxuICBjb25zdCBsb2NhbENoYW4gPSBzZWxmLl9jaGFuTWdyLmFkZCh3cmFwcGVyKTtcblxuICBpZiAobG9jYWxDaGFuID09PSAtMSkge1xuICAgIGNiKG5ldyBFcnJvcignTm8gZnJlZSBjaGFubmVscyBhdmFpbGFibGUnKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc2Vzc2lvbic6XG4gICAgY2FzZSAnc2Z0cCc6XG4gICAgICBzZWxmLl9wcm90b2NvbC5zZXNzaW9uKGxvY2FsQ2hhbiwgaW5pdFdpbmRvdywgbWF4UGFja2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RpcmVjdC10Y3BpcCc6XG4gICAgICBzZWxmLl9wcm90b2NvbC5kaXJlY3RUY3BpcChsb2NhbENoYW4sIGluaXRXaW5kb3csIG1heFBhY2tldCwgb3B0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkaXJlY3Qtc3RyZWFtbG9jYWxAb3BlbnNzaC5jb20nOlxuICAgICAgc2VsZi5fcHJvdG9jb2wub3BlbnNzaF9kaXJlY3RTdHJlYW1Mb2NhbChcbiAgICAgICAgbG9jYWxDaGFuLCBpbml0V2luZG93LCBtYXhQYWNrZXQsIG9wdHNcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaGFubmVsIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXFYMTEoY2hhbiwgc2NyZWVuLCBjYikge1xuICAvLyBBc2tzIHNlcnZlciB0byBzdGFydCBzZW5kaW5nIHVzIFgxMSBjb25uZWN0aW9uc1xuICBjb25zdCBjZmcgPSB7XG4gICAgc2luZ2xlOiBmYWxzZSxcbiAgICBwcm90b2NvbDogJ01JVC1NQUdJQy1DT09LSUUtMScsXG4gICAgY29va2llOiB1bmRlZmluZWQsXG4gICAgc2NyZWVuOiAwXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBzY3JlZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IHNjcmVlbjtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2NyZWVuID09PSAnb2JqZWN0JyAmJiBzY3JlZW4gIT09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHNjcmVlbi5zaW5nbGUgPT09ICdib29sZWFuJylcbiAgICAgIGNmZy5zaW5nbGUgPSBzY3JlZW4uc2luZ2xlO1xuICAgIGlmICh0eXBlb2Ygc2NyZWVuLnNjcmVlbiA9PT0gJ251bWJlcicpXG4gICAgICBjZmcuc2NyZWVuID0gc2NyZWVuLnNjcmVlbjtcbiAgICBpZiAodHlwZW9mIHNjcmVlbi5wcm90b2NvbCA9PT0gJ3N0cmluZycpXG4gICAgICBjZmcucHJvdG9jb2wgPSBzY3JlZW4ucHJvdG9jb2w7XG4gICAgaWYgKHR5cGVvZiBzY3JlZW4uY29va2llID09PSAnc3RyaW5nJylcbiAgICAgIGNmZy5jb29raWUgPSBzY3JlZW4uY29va2llO1xuICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzY3JlZW4uY29va2llKSlcbiAgICAgIGNmZy5jb29raWUgPSBzY3JlZW4uY29va2llLmhleFNsaWNlKDAsIHNjcmVlbi5jb29raWUubGVuZ3RoKTtcbiAgfVxuICBpZiAoY2ZnLmNvb2tpZSA9PT0gdW5kZWZpbmVkKVxuICAgIGNmZy5jb29raWUgPSByYW5kb21Db29raWUoKTtcblxuICBjb25zdCB3YW50UmVwbHkgPSAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKTtcblxuICBpZiAoY2hhbi5vdXRnb2luZy5zdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgaWYgKHdhbnRSZXBseSlcbiAgICAgIGNiKG5ldyBFcnJvcignQ2hhbm5lbCBpcyBub3Qgb3BlbicpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAod2FudFJlcGx5KSB7XG4gICAgY2hhbi5fY2FsbGJhY2tzLnB1c2goKGhhZF9lcnIpID0+IHtcbiAgICAgIGlmIChoYWRfZXJyKSB7XG4gICAgICAgIGNiKGhhZF9lcnIgIT09IHRydWUgPyBoYWRfZXJyIDogbmV3IEVycm9yKCdVbmFibGUgdG8gcmVxdWVzdCBYMTEnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2hhbi5faGFzWDExID0gdHJ1ZTtcbiAgICAgICsrY2hhbi5fY2xpZW50Ll9hY2NlcHRYMTE7XG4gICAgICBjaGFuLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBpZiAoY2hhbi5fY2xpZW50Ll9hY2NlcHRYMTEpXG4gICAgICAgICAgLS1jaGFuLl9jbGllbnQuX2FjY2VwdFgxMTtcbiAgICAgIH0pO1xuXG4gICAgICBjYigpO1xuICAgIH0pO1xuICB9XG5cbiAgY2hhbi5fY2xpZW50Ll9wcm90b2NvbC54MTFGb3J3YXJkKGNoYW4ub3V0Z29pbmcuaWQsIGNmZywgd2FudFJlcGx5KTtcbn1cblxuZnVuY3Rpb24gcmVxUHR5KGNoYW4sIG9wdHMsIGNiKSB7XG4gIGxldCByb3dzID0gMjQ7XG4gIGxldCBjb2xzID0gODA7XG4gIGxldCB3aWR0aCA9IDY0MDtcbiAgbGV0IGhlaWdodCA9IDQ4MDtcbiAgbGV0IHRlcm0gPSAndnQxMDAnO1xuICBsZXQgbW9kZXMgPSBudWxsO1xuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0cztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgb3B0cyAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2Ygb3B0cy5yb3dzID09PSAnbnVtYmVyJylcbiAgICAgIHJvd3MgPSBvcHRzLnJvd3M7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNvbHMgPT09ICdudW1iZXInKVxuICAgICAgY29scyA9IG9wdHMuY29scztcbiAgICBpZiAodHlwZW9mIG9wdHMud2lkdGggPT09ICdudW1iZXInKVxuICAgICAgd2lkdGggPSBvcHRzLndpZHRoO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5oZWlnaHQgPT09ICdudW1iZXInKVxuICAgICAgaGVpZ2h0ID0gb3B0cy5oZWlnaHQ7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnRlcm0gPT09ICdzdHJpbmcnKVxuICAgICAgdGVybSA9IG9wdHMudGVybTtcbiAgICBpZiAodHlwZW9mIG9wdHMubW9kZXMgPT09ICdvYmplY3QnKVxuICAgICAgbW9kZXMgPSBvcHRzLm1vZGVzO1xuICB9XG5cbiAgY29uc3Qgd2FudFJlcGx5ID0gKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyk7XG5cbiAgaWYgKGNoYW4ub3V0Z29pbmcuc3RhdGUgIT09ICdvcGVuJykge1xuICAgIGlmICh3YW50UmVwbHkpXG4gICAgICBjYihuZXcgRXJyb3IoJ0NoYW5uZWwgaXMgbm90IG9wZW4nKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHdhbnRSZXBseSkge1xuICAgIGNoYW4uX2NhbGxiYWNrcy5wdXNoKChoYWRfZXJyKSA9PiB7XG4gICAgICBpZiAoaGFkX2Vycikge1xuICAgICAgICBjYihoYWRfZXJyICE9PSB0cnVlXG4gICAgICAgICAgID8gaGFkX2VyclxuICAgICAgICAgICA6IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlcXVlc3QgYSBwc2V1ZG8tdGVybWluYWwnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNiKCk7XG4gICAgfSk7XG4gIH1cblxuICBjaGFuLl9jbGllbnQuX3Byb3RvY29sLnB0eShjaGFuLm91dGdvaW5nLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FudFJlcGx5KTtcbn1cblxuZnVuY3Rpb24gcmVxQWdlbnRGd2QoY2hhbiwgY2IpIHtcbiAgY29uc3Qgd2FudFJlcGx5ID0gKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyk7XG5cbiAgaWYgKGNoYW4ub3V0Z29pbmcuc3RhdGUgIT09ICdvcGVuJykge1xuICAgIHdhbnRSZXBseSAmJiBjYihuZXcgRXJyb3IoJ0NoYW5uZWwgaXMgbm90IG9wZW4nKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjaGFuLl9jbGllbnQuX2FnZW50RndkRW5hYmxlZCkge1xuICAgIHdhbnRSZXBseSAmJiBjYihmYWxzZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY2hhbi5fY2xpZW50Ll9hZ2VudEZ3ZEVuYWJsZWQgPSB0cnVlO1xuXG4gIGNoYW4uX2NhbGxiYWNrcy5wdXNoKChoYWRfZXJyKSA9PiB7XG4gICAgaWYgKGhhZF9lcnIpIHtcbiAgICAgIGNoYW4uX2NsaWVudC5fYWdlbnRGd2RFbmFibGVkID0gZmFsc2U7XG4gICAgICBpZiAod2FudFJlcGx5KSB7XG4gICAgICAgIGNiKGhhZF9lcnIgIT09IHRydWVcbiAgICAgICAgICAgPyBoYWRfZXJyXG4gICAgICAgICAgIDogbmV3IEVycm9yKCdVbmFibGUgdG8gcmVxdWVzdCBhZ2VudCBmb3J3YXJkaW5nJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh3YW50UmVwbHkpXG4gICAgICBjYigpO1xuICB9KTtcblxuICBjaGFuLl9jbGllbnQuX3Byb3RvY29sLm9wZW5zc2hfYWdlbnRGb3J3YXJkKGNoYW4ub3V0Z29pbmcuaWQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiByZXFTaGVsbChjaGFuLCBjYikge1xuICBpZiAoY2hhbi5vdXRnb2luZy5zdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgY2IobmV3IEVycm9yKCdDaGFubmVsIGlzIG5vdCBvcGVuJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNoYW4uX2NhbGxiYWNrcy5wdXNoKChoYWRfZXJyKSA9PiB7XG4gICAgaWYgKGhhZF9lcnIpIHtcbiAgICAgIGNiKGhhZF9lcnIgIT09IHRydWUgPyBoYWRfZXJyIDogbmV3IEVycm9yKCdVbmFibGUgdG8gb3BlbiBzaGVsbCcpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2hhbi5zdWJ0eXBlID0gJ3NoZWxsJztcbiAgICBjYih1bmRlZmluZWQsIGNoYW4pO1xuICB9KTtcblxuICBjaGFuLl9jbGllbnQuX3Byb3RvY29sLnNoZWxsKGNoYW4ub3V0Z29pbmcuaWQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiByZXFFeGVjKGNoYW4sIGNtZCwgb3B0cywgY2IpIHtcbiAgaWYgKGNoYW4ub3V0Z29pbmcuc3RhdGUgIT09ICdvcGVuJykge1xuICAgIGNiKG5ldyBFcnJvcignQ2hhbm5lbCBpcyBub3Qgb3BlbicpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjaGFuLl9jYWxsYmFja3MucHVzaCgoaGFkX2VycikgPT4ge1xuICAgIGlmIChoYWRfZXJyKSB7XG4gICAgICBjYihoYWRfZXJyICE9PSB0cnVlID8gaGFkX2VyciA6IG5ldyBFcnJvcignVW5hYmxlIHRvIGV4ZWMnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNoYW4uc3VidHlwZSA9ICdleGVjJztcbiAgICBjaGFuLmFsbG93SGFsZk9wZW4gPSAob3B0cy5hbGxvd0hhbGZPcGVuICE9PSBmYWxzZSk7XG4gICAgY2IodW5kZWZpbmVkLCBjaGFuKTtcbiAgfSk7XG5cbiAgY2hhbi5fY2xpZW50Ll9wcm90b2NvbC5leGVjKGNoYW4ub3V0Z29pbmcuaWQsIGNtZCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlcUVudihjaGFuLCBlbnYpIHtcbiAgaWYgKGNoYW4ub3V0Z29pbmcuc3RhdGUgIT09ICdvcGVuJylcbiAgICByZXR1cm47XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVudiB8fCB7fSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWwgPSBlbnZba2V5XTtcbiAgICBjaGFuLl9jbGllbnQuX3Byb3RvY29sLmVudihjaGFuLm91dGdvaW5nLmlkLCBrZXksIHZhbCwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcVN1YnN5c3RlbShjaGFuLCBuYW1lLCBjYikge1xuICBpZiAoY2hhbi5vdXRnb2luZy5zdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgY2IobmV3IEVycm9yKCdDaGFubmVsIGlzIG5vdCBvcGVuJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNoYW4uX2NhbGxiYWNrcy5wdXNoKChoYWRfZXJyKSA9PiB7XG4gICAgaWYgKGhhZF9lcnIpIHtcbiAgICAgIGNiKGhhZF9lcnIgIT09IHRydWVcbiAgICAgICAgID8gaGFkX2VyclxuICAgICAgICAgOiBuZXcgRXJyb3IoYFVuYWJsZSB0byBzdGFydCBzdWJzeXN0ZW06ICR7bmFtZX1gKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNoYW4uc3VidHlwZSA9ICdzdWJzeXN0ZW0nO1xuICAgIGNiKHVuZGVmaW5lZCwgY2hhbik7XG4gIH0pO1xuXG4gIGNoYW4uX2NsaWVudC5fcHJvdG9jb2wuc3Vic3lzdGVtKGNoYW4ub3V0Z29pbmcuaWQsIG5hbWUsIHRydWUpO1xufVxuXG4vLyBUT0RPOiBpbmxpbmUgaW1wbGVtZW50YXRpb24gaW50byBzaW5nbGUgY2FsbCBzaXRlXG5mdW5jdGlvbiBvbkNIQU5ORUxfT1BFTihzZWxmLCBpbmZvKSB7XG4gIC8vIFRoZSBzZXJ2ZXIgaXMgdHJ5aW5nIHRvIG9wZW4gYSBjaGFubmVsIHdpdGggdXMsIHRoaXMgaXMgdXN1YWxseSB3aGVuXG4gIC8vIHdlIGFza2VkIHRoZSBzZXJ2ZXIgdG8gZm9yd2FyZCB1cyBjb25uZWN0aW9ucyBvbiBzb21lIHBvcnQgYW5kIG5vdyB0aGV5XG4gIC8vIGFyZSBhc2tpbmcgdXMgdG8gYWNjZXB0L2RlbnkgYW4gaW5jb21pbmcgY29ubmVjdGlvbiBvbiB0aGVpciBzaWRlXG5cbiAgbGV0IGxvY2FsQ2hhbiA9IC0xO1xuICBsZXQgcmVhc29uO1xuXG4gIGNvbnN0IGFjY2VwdCA9ICgpID0+IHtcbiAgICBjb25zdCBjaGFuSW5mbyA9IHtcbiAgICAgIHR5cGU6IGluZm8udHlwZSxcbiAgICAgIGluY29taW5nOiB7XG4gICAgICAgIGlkOiBsb2NhbENoYW4sXG4gICAgICAgIHdpbmRvdzogTUFYX1dJTkRPVyxcbiAgICAgICAgcGFja2V0U2l6ZTogUEFDS0VUX1NJWkUsXG4gICAgICAgIHN0YXRlOiAnb3BlbidcbiAgICAgIH0sXG4gICAgICBvdXRnb2luZzoge1xuICAgICAgICBpZDogaW5mby5zZW5kZXIsXG4gICAgICAgIHdpbmRvdzogaW5mby53aW5kb3csXG4gICAgICAgIHBhY2tldFNpemU6IGluZm8ucGFja2V0U2l6ZSxcbiAgICAgICAgc3RhdGU6ICdvcGVuJ1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IENoYW5uZWwoc2VsZiwgY2hhbkluZm8pO1xuICAgIHNlbGYuX2NoYW5NZ3IudXBkYXRlKGxvY2FsQ2hhbiwgc3RyZWFtKTtcblxuICAgIHNlbGYuX3Byb3RvY29sLmNoYW5uZWxPcGVuQ29uZmlybShpbmZvLnNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDaGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNQVhfV0lORE9XLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQQUNLRVRfU0laRSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfTtcbiAgY29uc3QgcmVqZWN0ID0gKCkgPT4ge1xuICAgIGlmIChyZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGxvY2FsQ2hhbiA9PT0gLTEpXG4gICAgICAgIHJlYXNvbiA9IENIQU5ORUxfT1BFTl9GQUlMVVJFLlJFU09VUkNFX1NIT1JUQUdFO1xuICAgICAgZWxzZVxuICAgICAgICByZWFzb24gPSBDSEFOTkVMX09QRU5fRkFJTFVSRS5DT05ORUNUX0ZBSUxFRDtcbiAgICB9XG5cbiAgICBpZiAobG9jYWxDaGFuICE9PSAtMSlcbiAgICAgIHNlbGYuX2NoYW5NZ3IucmVtb3ZlKGxvY2FsQ2hhbik7XG5cbiAgICBzZWxmLl9wcm90b2NvbC5jaGFubmVsT3BlbkZhaWwoaW5mby5zZW5kZXIsIHJlYXNvbiwgJycpO1xuICB9O1xuICBjb25zdCByZXNlcnZlQ2hhbm5lbCA9ICgpID0+IHtcbiAgICBsb2NhbENoYW4gPSBzZWxmLl9jaGFuTWdyLmFkZCgpO1xuXG4gICAgaWYgKGxvY2FsQ2hhbiA9PT0gLTEpIHtcbiAgICAgIHJlYXNvbiA9IENIQU5ORUxfT1BFTl9GQUlMVVJFLlJFU09VUkNFX1NIT1JUQUdFO1xuICAgICAgaWYgKHNlbGYuY29uZmlnLmRlYnVnKSB7XG4gICAgICAgIHNlbGYuY29uZmlnLmRlYnVnKFxuICAgICAgICAgICdDbGllbnQ6IEF1dG9tYXRpYyByZWplY3Rpb24gb2YgaW5jb21pbmcgY2hhbm5lbCBvcGVuOiAnXG4gICAgICAgICAgICArICdubyBjaGFubmVscyBhdmFpbGFibGUnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChsb2NhbENoYW4gIT09IC0xKTtcbiAgfTtcblxuICBjb25zdCBkYXRhID0gaW5mby5kYXRhO1xuICBzd2l0Y2ggKGluZm8udHlwZSkge1xuICAgIGNhc2UgJ2ZvcndhcmRlZC10Y3BpcCc6IHtcbiAgICAgIGNvbnN0IHZhbCA9IHNlbGYuX2ZvcndhcmRpbmdbYCR7ZGF0YS5kZXN0SVB9OiR7ZGF0YS5kZXN0UG9ydH1gXTtcbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiByZXNlcnZlQ2hhbm5lbCgpKSB7XG4gICAgICAgIGlmIChkYXRhLmRlc3RQb3J0ID09PSAwKVxuICAgICAgICAgIGRhdGEuZGVzdFBvcnQgPSB2YWw7XG4gICAgICAgIHNlbGYuZW1pdCgndGNwIGNvbm5lY3Rpb24nLCBkYXRhLCBhY2NlcHQsIHJlamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdmb3J3YXJkZWQtc3RyZWFtbG9jYWxAb3BlbnNzaC5jb20nOlxuICAgICAgaWYgKHNlbGYuX2ZvcndhcmRpbmdVbml4W2RhdGEuc29ja2V0UGF0aF0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICYmIHJlc2VydmVDaGFubmVsKCkpIHtcbiAgICAgICAgc2VsZi5lbWl0KCd1bml4IGNvbm5lY3Rpb24nLCBkYXRhLCBhY2NlcHQsIHJlamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2F1dGgtYWdlbnRAb3BlbnNzaC5jb20nOlxuICAgICAgaWYgKHNlbGYuX2FnZW50RndkRW5hYmxlZFxuICAgICAgICAgICYmIHR5cGVvZiBzZWxmLl9hZ2VudC5nZXRTdHJlYW0gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAmJiByZXNlcnZlQ2hhbm5lbCgpKSB7XG4gICAgICAgIHNlbGYuX2FnZW50LmdldFN0cmVhbSgoZXJyLCBzdHJlYW0pID0+IHtcbiAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xuXG4gICAgICAgICAgY29uc3QgdXBzdHJlYW0gPSBhY2NlcHQoKTtcbiAgICAgICAgICB1cHN0cmVhbS5waXBlKHN0cmVhbSkucGlwZSh1cHN0cmVhbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd4MTEnOlxuICAgICAgaWYgKHNlbGYuX2FjY2VwdFgxMSAhPT0gMCAmJiByZXNlcnZlQ2hhbm5lbCgpKSB7XG4gICAgICAgIHNlbGYuZW1pdCgneDExJywgZGF0YSwgYWNjZXB0LCByZWplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gQXV0b21hdGljYWxseSByZWplY3QgYW55IHVuc3VwcG9ydGVkIGNoYW5uZWwgb3BlbiByZXF1ZXN0c1xuICAgICAgcmVhc29uID0gQ0hBTk5FTF9PUEVOX0ZBSUxVUkUuVU5LTk9XTl9DSEFOTkVMX1RZUEU7XG4gICAgICBpZiAoc2VsZi5jb25maWcuZGVidWcpIHtcbiAgICAgICAgc2VsZi5jb25maWcuZGVidWcoXG4gICAgICAgICAgJ0NsaWVudDogQXV0b21hdGljIHJlamVjdGlvbiBvZiB1bnN1cHBvcnRlZCBpbmNvbWluZyBjaGFubmVsIG9wZW4gJ1xuICAgICAgICAgICAgKyBgdHlwZTogJHtpbmZvLnR5cGV9YFxuICAgICAgICApO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHJlYXNvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVhc29uID0gQ0hBTk5FTF9PUEVOX0ZBSUxVUkUuQURNSU5JU1RSQVRJVkVMWV9QUk9ISUJJVEVEO1xuICAgIGlmIChzZWxmLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgIHNlbGYuY29uZmlnLmRlYnVnKFxuICAgICAgICAnQ2xpZW50OiBBdXRvbWF0aWMgcmVqZWN0aW9uIG9mIHVuZXhwZWN0ZWQgaW5jb21pbmcgY2hhbm5lbCBvcGVuIGZvcjogJ1xuICAgICAgICAgICsgaW5mby50eXBlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlamVjdCgpO1xufVxuXG5jb25zdCByYW5kb21Db29raWUgPSAoKCkgPT4ge1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJhbmRvbUZpbGxTeW5jKGJ1ZmZlciwgMCwgMTYpO1xuICAgIHJldHVybiBidWZmZXIuaGV4U2xpY2UoMCwgMTYpO1xuICB9O1xufSkoKTtcblxuZnVuY3Rpb24gbWFrZVNpbXBsZUF1dGhIYW5kbGVyKGF1dGhMaXN0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhdXRoTGlzdCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoTGlzdCBtdXN0IGJlIGFuIGFycmF5Jyk7XG5cbiAgbGV0IGEgPSAwO1xuICByZXR1cm4gKGF1dGhzTGVmdCwgcGFydGlhbFN1Y2Nlc3MsIGNiKSA9PiB7XG4gICAgaWYgKGEgPT09IGF1dGhMaXN0Lmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYXV0aExpc3RbYSsrXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaG9zdEtleXNQcm92ZShjbGllbnQsIGtleXNfLCBjYikge1xuICBpZiAoIWNsaWVudC5fc29jayB8fCAhaXNXcml0YWJsZShjbGllbnQuX3NvY2spKVxuICAgIHJldHVybjtcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gbm9vcDtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5c18pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQga2V5cyBhcmd1bWVudCB0eXBlJyk7XG5cbiAgY29uc3Qga2V5cyA9IFtdO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzXykge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlS2V5KGtleSk7XG4gICAgaWYgKHBhcnNlZCBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgdGhyb3cgcGFyc2VkO1xuICAgIGtleXMucHVzaChwYXJzZWQpO1xuICB9XG5cbiAgaWYgKCFjbGllbnQuY29uZmlnLnN0cmljdFZlbmRvclxuICAgICAgfHwgKGNsaWVudC5jb25maWcuc3RyaWN0VmVuZG9yICYmIFJFX09QRU5TU0gudGVzdChjbGllbnQuX3JlbW90ZVZlcikpKSB7XG4gICAgY2xpZW50Ll9jYWxsYmFja3MucHVzaCgoaGFkX2VyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGhhZF9lcnIpIHtcbiAgICAgICAgY2IoaGFkX2VyciAhPT0gdHJ1ZVxuICAgICAgICAgICA/IGhhZF9lcnJcbiAgICAgICAgICAgOiBuZXcgRXJyb3IoJ1NlcnZlciBmYWlsZWQgdG8gcHJvdmUgc3VwcGxpZWQga2V5cycpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBtb3ZlIGFsbCBvZiB0aGlzIHBhcnNpbmcvdmVyaWZ5aW5nIGxvZ2ljIG91dCBvZiB0aGUgY2xpZW50P1xuICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICBsZXQga2V5SWR4ID0gMDtcbiAgICAgIGJ1ZmZlclBhcnNlci5pbml0KGRhdGEsIDApO1xuICAgICAgd2hpbGUgKGJ1ZmZlclBhcnNlci5hdmFpbCgpKSB7XG4gICAgICAgIGlmIChrZXlJZHggPT09IGtleXMubGVuZ3RoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2tleUlkeCsrXTtcbiAgICAgICAgY29uc3Qga2V5UHVibGljID0ga2V5LmdldFB1YmxpY1NTSCgpO1xuXG4gICAgICAgIGNvbnN0IHNpZ0VudHJ5ID0gYnVmZmVyUGFyc2VyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgc2lnUGFyc2VyLmluaXQoc2lnRW50cnksIDApO1xuICAgICAgICBjb25zdCB0eXBlID0gc2lnUGFyc2VyLnJlYWRTdHJpbmcodHJ1ZSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHNpZ1BhcnNlci5yZWFkU3RyaW5nKCk7XG5cbiAgICAgICAgbGV0IGFsZ287XG4gICAgICAgIGlmICh0eXBlICE9PSBrZXkudHlwZSkge1xuICAgICAgICAgIGlmIChrZXkudHlwZSA9PT0gJ3NzaC1yc2EnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAncnNhLXNoYTItMjU2JzpcbiAgICAgICAgICAgICAgICBhbGdvID0gJ3NoYTI1Nic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3JzYS1zaGEyLTUxMic6XG4gICAgICAgICAgICAgICAgYWxnbyA9ICdzaGE1MTInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXNzaW9uSUQgPSBjbGllbnQuX3Byb3RvY29sLl9rZXguc2Vzc2lvbklEO1xuICAgICAgICBjb25zdCB2ZXJpZnlEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgICAgICAgIDQgKyAyOSArIDQgKyBzZXNzaW9uSUQubGVuZ3RoICsgNCArIGtleVB1YmxpYy5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHAgPSAwO1xuICAgICAgICB3cml0ZVVJbnQzMkJFKHZlcmlmeURhdGEsIDI5LCBwKTtcbiAgICAgICAgdmVyaWZ5RGF0YS51dGY4V3JpdGUoJ2hvc3RrZXlzLXByb3ZlLTAwQG9wZW5zc2guY29tJywgcCArPSA0LCAyOSk7XG4gICAgICAgIHdyaXRlVUludDMyQkUodmVyaWZ5RGF0YSwgc2Vzc2lvbklELmxlbmd0aCwgcCArPSAyOSk7XG4gICAgICAgIGJ1ZmZlckNvcHkoc2Vzc2lvbklELCB2ZXJpZnlEYXRhLCAwLCBzZXNzaW9uSUQubGVuZ3RoLCBwICs9IDQpO1xuICAgICAgICB3cml0ZVVJbnQzMkJFKHZlcmlmeURhdGEsIGtleVB1YmxpYy5sZW5ndGgsIHAgKz0gc2Vzc2lvbklELmxlbmd0aCk7XG4gICAgICAgIGJ1ZmZlckNvcHkoa2V5UHVibGljLCB2ZXJpZnlEYXRhLCAwLCBrZXlQdWJsaWMubGVuZ3RoLCBwICs9IDQpO1xuXG4gICAgICAgIGlmICghKHZhbHVlID0gc2lnU1NIVG9BU04xKHZhbHVlLCB0eXBlKSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChrZXkudmVyaWZ5KHZlcmlmeURhdGEsIHZhbHVlLCBhbGdvKSA9PT0gdHJ1ZSlcbiAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgc2lnUGFyc2VyLmNsZWFyKCk7XG4gICAgICBidWZmZXJQYXJzZXIuY2xlYXIoKTtcblxuICAgICAgY2IobnVsbCwgcmV0KTtcbiAgICB9KTtcblxuICAgIGNsaWVudC5fcHJvdG9jb2wub3BlbnNzaF9ob3N0S2V5c1Byb3ZlKGtleXMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb2Nlc3MubmV4dFRpY2soXG4gICAgY2IsXG4gICAgbmV3IEVycm9yKFxuICAgICAgJ3N0cmljdFZlbmRvciBlbmFibGVkIGFuZCBzZXJ2ZXIgaXMgbm90IE9wZW5TU0ggb3IgY29tcGF0aWJsZSB2ZXJzaW9uJ1xuICAgIClcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5QWxnb3MoY2xpZW50LCBrZXksIHNlcnZlclNpZ0FsZ3MpIHtcbiAgc3dpdGNoIChrZXkudHlwZSkge1xuICAgIGNhc2UgJ3NzaC1yc2EnOlxuICAgICAgaWYgKGNsaWVudC5fcHJvdG9jb2wuX2NvbXBhdEZsYWdzICYgQ09NUEFULklNUExZX1JTQV9TSEEyX1NJR0FMR1MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNlcnZlclNpZ0FsZ3MpKVxuICAgICAgICAgIHNlcnZlclNpZ0FsZ3MgPSBbJ3JzYS1zaGEyLTI1NicsICdyc2Etc2hhMi01MTInXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNlcnZlclNpZ0FsZ3MgPSBbJ3JzYS1zaGEyLTI1NicsICdyc2Etc2hhMi01MTInLCAuLi5zZXJ2ZXJTaWdBbGdzXTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlcnZlclNpZ0FsZ3MpKSB7XG4gICAgICAgIGlmIChzZXJ2ZXJTaWdBbGdzLmluZGV4T2YoJ3JzYS1zaGEyLTI1NicpICE9PSAtMSlcbiAgICAgICAgICByZXR1cm4gW1sncnNhLXNoYTItMjU2JywgJ3NoYTI1NiddXTtcbiAgICAgICAgaWYgKHNlcnZlclNpZ0FsZ3MuaW5kZXhPZigncnNhLXNoYTItNTEyJykgIT09IC0xKVxuICAgICAgICAgIHJldHVybiBbWydyc2Etc2hhMi01MTInLCAnc2hhNTEyJ11dO1xuICAgICAgICBpZiAoc2VydmVyU2lnQWxncy5pbmRleE9mKCdzc2gtcnNhJykgPT09IC0xKVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbWydzc2gtcnNhJywgJ3NoYTEnXV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnQ7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEFnZW50OiBIdHRwQWdlbnQgfSA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHsgQWdlbnQ6IEh0dHBzQWdlbnQgfSA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCB7IGNvbm5lY3Q6IHRsc0Nvbm5lY3QgfSA9IHJlcXVpcmUoJ3RscycpO1xuXG5sZXQgQ2xpZW50O1xuXG5mb3IgKGNvbnN0IGN0b3Igb2YgW0h0dHBBZ2VudCwgSHR0cHNBZ2VudF0pIHtcbiAgY2xhc3MgU1NIQWdlbnQgZXh0ZW5kcyBjdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0Q2ZnLCBhZ2VudE9wdGlvbnMpIHtcbiAgICAgIHN1cGVyKGFnZW50T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3RDZmcgPSBjb25uZWN0Q2ZnO1xuICAgICAgdGhpcy5fZGVmYXVsdFNyY0lQID0gKGFnZW50T3B0aW9ucyAmJiBhZ2VudE9wdGlvbnMuc3JjSVApIHx8ICdsb2NhbGhvc3QnO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgY2IpIHtcbiAgICAgIGNvbnN0IHNyY0lQID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5sb2NhbEFkZHJlc3MpIHx8IHRoaXMuX2RlZmF1bHRTcmNJUDtcbiAgICAgIGNvbnN0IHNyY1BvcnQgPSAob3B0aW9ucyAmJiBvcHRpb25zLmxvY2FsUG9ydCkgfHwgMDtcbiAgICAgIGNvbnN0IGRzdElQID0gb3B0aW9ucy5ob3N0O1xuICAgICAgY29uc3QgZHN0UG9ydCA9IG9wdGlvbnMucG9ydDtcblxuICAgICAgaWYgKENsaWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudC5qcycpO1xuXG4gICAgICBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gICAgICBsZXQgdHJpZWRGb3J3YXJkID0gZmFsc2U7XG4gICAgICBjbGllbnQub24oJ3JlYWR5JywgKCkgPT4ge1xuICAgICAgICBjbGllbnQuZm9yd2FyZE91dChzcmNJUCwgc3JjUG9ydCwgZHN0SVAsIGRzdFBvcnQsIChlcnIsIHN0cmVhbSkgPT4ge1xuICAgICAgICAgIHRyaWVkRm9yd2FyZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2xpZW50LmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IGNsaWVudC5lbmQoKSk7XG4gICAgICAgICAgY2IobnVsbCwgZGVjb3JhdGVTdHJlYW0oc3RyZWFtLCBjdG9yLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkub24oJ2Vycm9yJywgY2IpLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgaWYgKCF0cmllZEZvcndhcmQpXG4gICAgICAgICAgY2IobmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbm5lY3Rpb24gY2xvc2UnKSk7XG4gICAgICB9KS5jb25uZWN0KHRoaXMuX2Nvbm5lY3RDZmcpO1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydHNbY3RvciA9PT0gSHR0cEFnZW50ID8gJ1NTSFRUUEFnZW50JyA6ICdTU0hUVFBTQWdlbnQnXSA9IFNTSEFnZW50O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZGVjb3JhdGVTdHJlYW0oc3RyZWFtLCBjdG9yLCBvcHRpb25zKSB7XG4gIGlmIChjdG9yID09PSBIdHRwQWdlbnQpIHtcbiAgICAvLyBIVFRQXG4gICAgc3RyZWFtLnNldEtlZXBBbGl2ZSA9IG5vb3A7XG4gICAgc3RyZWFtLnNldE5vRGVsYXkgPSBub29wO1xuICAgIHN0cmVhbS5zZXRUaW1lb3V0ID0gbm9vcDtcbiAgICBzdHJlYW0ucmVmID0gbm9vcDtcbiAgICBzdHJlYW0udW5yZWYgPSBub29wO1xuICAgIHN0cmVhbS5kZXN0cm95U29vbiA9IHN0cmVhbS5kZXN0cm95O1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvLyBIVFRQU1xuICBvcHRpb25zLnNvY2tldCA9IHN0cmVhbTtcbiAgY29uc3Qgd3JhcHBlZCA9IHRsc0Nvbm5lY3Qob3B0aW9ucyk7XG5cbiAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGEgcmVncmVzc2lvbiBpbiBub2RlIHYxMi4xNi4zK1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzM1OTA0XG4gIGNvbnN0IG9uQ2xvc2UgPSAoKCkgPT4ge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGlmIChzdHJlYW0uaXNQYXVzZWQoKSlcbiAgICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH07XG4gIH0pKCk7XG4gIC8vICdlbmQnIGxpc3RlbmVyIGlzIG5lZWRlZCBiZWNhdXNlICdjbG9zZScgaXMgbm90IGVtaXR0ZWQgaW4gc29tZSBzY2VuYXJpb3NcbiAgLy8gaW4gbm9kZSB2MTIueCBmb3Igc29tZSB1bmtub3duIHJlYXNvblxuICB3cmFwcGVkLm9uKCdlbmQnLCBvbkNsb3NlKS5vbignY2xvc2UnLCBvbkNsb3NlKTtcblxuICByZXR1cm4gd3JhcHBlZDtcbn1cbiIsICIvLyBUT0RPOlxuLy8gICAqIGNvbnZlcnQgbGlzdGVuZXJDb3VudCgpIHVzYWdlIHRvIGVtaXQoKSByZXR1cm4gdmFsdWUgY2hlY2tpbmc/XG4vLyAgICogZW1pdCBlcnJvciB3aGVuIGNvbm5lY3Rpb24gc2V2ZXJlZCBlYXJseSAoZS5nLiBiZWZvcmUgaGFuZHNoYWtlKVxuLy8gICAqIGFkZCAnLmNvbm5lY3RlZCcgb3Igc2ltaWxhciBwcm9wZXJ0eSB0byBjb25uZWN0aW9uIG9iamVjdHMgdG8gYWxsb3dcbi8vICAgICBpbW1lZGlhdGUgY29ubmVjdGlvbiBzdGF0dXMgY2hlY2tpbmdcbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBTZXJ2ZXI6IG5ldFNlcnZlciB9ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IHsgbGlzdGVuZXJDb3VudCB9ID0gRXZlbnRFbWl0dGVyO1xuXG5jb25zdCB7XG4gIENIQU5ORUxfT1BFTl9GQUlMVVJFLFxuICBERUZBVUxUX0NJUEhFUixcbiAgREVGQVVMVF9DT01QUkVTU0lPTixcbiAgREVGQVVMVF9LRVgsXG4gIERFRkFVTFRfTUFDLFxuICBERUZBVUxUX1NFUlZFUl9IT1NUX0tFWSxcbiAgRElTQ09OTkVDVF9SRUFTT04sXG4gIERJU0NPTk5FQ1RfUkVBU09OX0JZX1ZBTFVFLFxuICBTVVBQT1JURURfQ0lQSEVSLFxuICBTVVBQT1JURURfQ09NUFJFU1NJT04sXG4gIFNVUFBPUlRFRF9LRVgsXG4gIFNVUFBPUlRFRF9NQUMsXG4gIFNVUFBPUlRFRF9TRVJWRVJfSE9TVF9LRVksXG59ID0gcmVxdWlyZSgnLi9wcm90b2NvbC9jb25zdGFudHMuanMnKTtcbmNvbnN0IHsgaW5pdDogY3J5cHRvSW5pdCB9ID0gcmVxdWlyZSgnLi9wcm90b2NvbC9jcnlwdG8uanMnKTtcbmNvbnN0IHsgS2V4SW5pdCB9ID0gcmVxdWlyZSgnLi9wcm90b2NvbC9rZXguanMnKTtcbmNvbnN0IHsgcGFyc2VLZXkgfSA9IHJlcXVpcmUoJy4vcHJvdG9jb2wva2V5UGFyc2VyLmpzJyk7XG5jb25zdCBQcm90b2NvbCA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvUHJvdG9jb2wuanMnKTtcbmNvbnN0IHsgU0ZUUCB9ID0gcmVxdWlyZSgnLi9wcm90b2NvbC9TRlRQLmpzJyk7XG5jb25zdCB7IHdyaXRlVUludDMyQkUgfSA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvdXRpbHMuanMnKTtcblxuY29uc3Qge1xuICBDaGFubmVsLFxuICBNQVhfV0lORE9XLFxuICBQQUNLRVRfU0laRSxcbiAgd2luZG93QWRqdXN0LFxuICBXSU5ET1dfVEhSRVNIT0xELFxufSA9IHJlcXVpcmUoJy4vQ2hhbm5lbC5qcycpO1xuXG5jb25zdCB7XG4gIENoYW5uZWxNYW5hZ2VyLFxuICBnZW5lcmF0ZUFsZ29yaXRobUxpc3QsXG4gIGlzV3JpdGFibGUsXG4gIG9uQ2hhbm5lbE9wZW5GYWlsdXJlLFxuICBvbkNIQU5ORUxfQ0xPU0UsXG59ID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuXG5jb25zdCBNQVhfUEVORElOR19BVVRIUyA9IDEwO1xuXG5jbGFzcyBBdXRoQ29udGV4dCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHByb3RvY29sLCB1c2VybmFtZSwgc2VydmljZSwgbWV0aG9kLCBjYikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnVzZXJuYW1lID0gdGhpcy51c2VyID0gdXNlcm5hbWU7XG4gICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLl9pbml0aWFsUmVzcG9uc2UgPSBmYWxzZTtcbiAgICB0aGlzLl9maW5hbFJlc3BvbnNlID0gZmFsc2U7XG4gICAgdGhpcy5fbXVsdGlzdGVwID0gZmFsc2U7XG4gICAgdGhpcy5fY2JmaW5hbCA9IChhbGxvd2VkLCBtZXRob2RzTGVmdCwgaXNQYXJ0aWFsKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2ZpbmFsUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5fZmluYWxSZXNwb25zZSA9IHRydWU7XG4gICAgICAgIGNiKHRoaXMsIGFsbG93ZWQsIG1ldGhvZHNMZWZ0LCBpc1BhcnRpYWwpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgfVxuXG4gIGFjY2VwdCgpIHtcbiAgICB0aGlzLl9jbGVhbnVwICYmIHRoaXMuX2NsZWFudXAoKTtcbiAgICB0aGlzLl9pbml0aWFsUmVzcG9uc2UgPSB0cnVlO1xuICAgIHRoaXMuX2NiZmluYWwodHJ1ZSk7XG4gIH1cbiAgcmVqZWN0KG1ldGhvZHNMZWZ0LCBpc1BhcnRpYWwpIHtcbiAgICB0aGlzLl9jbGVhbnVwICYmIHRoaXMuX2NsZWFudXAoKTtcbiAgICB0aGlzLl9pbml0aWFsUmVzcG9uc2UgPSB0cnVlO1xuICAgIHRoaXMuX2NiZmluYWwoZmFsc2UsIG1ldGhvZHNMZWZ0LCBpc1BhcnRpYWwpO1xuICB9XG59XG5cblxuY2xhc3MgS2V5Ym9hcmRBdXRoQ29udGV4dCBleHRlbmRzIEF1dGhDb250ZXh0IHtcbiAgY29uc3RydWN0b3IocHJvdG9jb2wsIHVzZXJuYW1lLCBzZXJ2aWNlLCBtZXRob2QsIHN1Ym1ldGhvZHMsIGNiKSB7XG4gICAgc3VwZXIocHJvdG9jb2wsIHVzZXJuYW1lLCBzZXJ2aWNlLCBtZXRob2QsIGNiKTtcblxuICAgIHRoaXMuX211bHRpc3RlcCA9IHRydWU7XG5cbiAgICB0aGlzLl9jYiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vbkluZm9SZXNwb25zZSA9IChyZXNwb25zZXMpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fY2I7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnN1Ym1ldGhvZHMgPSBzdWJtZXRob2RzO1xuICAgIHRoaXMub24oJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgdGhpcy5fY2IgJiYgdGhpcy5fY2IobmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiByZXF1ZXN0IGFib3J0ZWQnKSk7XG4gICAgfSk7XG4gIH1cblxuICBwcm9tcHQocHJvbXB0cywgdGl0bGUsIGluc3RydWN0aW9ucywgY2IpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvbXB0cykpXG4gICAgICBwcm9tcHRzID0gWyBwcm9tcHRzIF07XG5cbiAgICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IHRpdGxlO1xuICAgICAgdGl0bGUgPSBpbnN0cnVjdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGluc3RydWN0aW9ucztcbiAgICAgIGluc3RydWN0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9tcHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodHlwZW9mIHByb21wdHNbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHByb21wdHNbaV0gPSB7XG4gICAgICAgICAgcHJvbXB0OiBwcm9tcHRzW2ldLFxuICAgICAgICAgIGVjaG86IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jYiA9IGNiO1xuICAgIHRoaXMuX2luaXRpYWxSZXNwb25zZSA9IHRydWU7XG5cbiAgICB0aGlzLl9wcm90b2NvbC5hdXRoSW5mb1JlcSh0aXRsZSwgaW5zdHJ1Y3Rpb25zLCBwcm9tcHRzKTtcbiAgfVxufVxuXG5jbGFzcyBQS0F1dGhDb250ZXh0IGV4dGVuZHMgQXV0aENvbnRleHQge1xuICBjb25zdHJ1Y3Rvcihwcm90b2NvbCwgdXNlcm5hbWUsIHNlcnZpY2UsIG1ldGhvZCwgcGtJbmZvLCBjYikge1xuICAgIHN1cGVyKHByb3RvY29sLCB1c2VybmFtZSwgc2VydmljZSwgbWV0aG9kLCBjYik7XG5cbiAgICB0aGlzLmtleSA9IHsgYWxnbzogcGtJbmZvLmtleUFsZ28sIGRhdGE6IHBrSW5mby5rZXkgfTtcbiAgICB0aGlzLmhhc2hBbGdvID0gcGtJbmZvLmhhc2hBbGdvO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gcGtJbmZvLnNpZ25hdHVyZTtcbiAgICB0aGlzLmJsb2IgPSBwa0luZm8uYmxvYjtcbiAgfVxuXG4gIGFjY2VwdCgpIHtcbiAgICBpZiAoIXRoaXMuc2lnbmF0dXJlKSB7XG4gICAgICB0aGlzLl9pbml0aWFsUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgdGhpcy5fcHJvdG9jb2wuYXV0aFBLT0sodGhpcy5rZXkuYWxnbywgdGhpcy5rZXkuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEF1dGhDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgSG9zdGJhc2VkQXV0aENvbnRleHQgZXh0ZW5kcyBBdXRoQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKHByb3RvY29sLCB1c2VybmFtZSwgc2VydmljZSwgbWV0aG9kLCBwa0luZm8sIGNiKSB7XG4gICAgc3VwZXIocHJvdG9jb2wsIHVzZXJuYW1lLCBzZXJ2aWNlLCBtZXRob2QsIGNiKTtcblxuICAgIHRoaXMua2V5ID0geyBhbGdvOiBwa0luZm8ua2V5QWxnbywgZGF0YTogcGtJbmZvLmtleSB9O1xuICAgIHRoaXMuaGFzaEFsZ28gPSBwa0luZm8uaGFzaEFsZ287XG4gICAgdGhpcy5zaWduYXR1cmUgPSBwa0luZm8uc2lnbmF0dXJlO1xuICAgIHRoaXMuYmxvYiA9IHBrSW5mby5ibG9iO1xuICAgIHRoaXMubG9jYWxIb3N0bmFtZSA9IHBrSW5mby5sb2NhbEhvc3RuYW1lO1xuICAgIHRoaXMubG9jYWxVc2VybmFtZSA9IHBrSW5mby5sb2NhbFVzZXJuYW1lO1xuICB9XG59XG5cbmNsYXNzIFB3ZEF1dGhDb250ZXh0IGV4dGVuZHMgQXV0aENvbnRleHQge1xuICBjb25zdHJ1Y3Rvcihwcm90b2NvbCwgdXNlcm5hbWUsIHNlcnZpY2UsIG1ldGhvZCwgcGFzc3dvcmQsIGNiKSB7XG4gICAgc3VwZXIocHJvdG9jb2wsIHVzZXJuYW1lLCBzZXJ2aWNlLCBtZXRob2QsIGNiKTtcblxuICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICB0aGlzLl9jaGFuZ2VDYiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJlcXVlc3RDaGFuZ2UocHJvbXB0LCBjYikge1xuICAgIGlmICh0aGlzLl9jaGFuZ2VDYilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhbmdlIHJlcXVlc3QgYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgIGlmICh0eXBlb2YgcHJvbXB0ICE9PSAnc3RyaW5nJylcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJvbXB0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB0aGlzLl9jaGFuZ2VDYiA9IGNiO1xuICAgIHRoaXMuX3Byb3RvY29sLmF1dGhQYXNzd2RDaGcocHJvbXB0KTtcbiAgfVxufVxuXG5cbmNsYXNzIFNlc3Npb24gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGluZm8sIGxvY2FsQ2hhbikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnR5cGUgPSAnc2Vzc2lvbic7XG4gICAgdGhpcy5zdWJ0eXBlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2VydmVyID0gdHJ1ZTtcbiAgICB0aGlzLl9lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jaGFubmVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoYW5JbmZvID0ge1xuICAgICAgdHlwZTogJ3Nlc3Npb24nLFxuICAgICAgaW5jb21pbmc6IHtcbiAgICAgICAgaWQ6IGxvY2FsQ2hhbixcbiAgICAgICAgd2luZG93OiBNQVhfV0lORE9XLFxuICAgICAgICBwYWNrZXRTaXplOiBQQUNLRVRfU0laRSxcbiAgICAgICAgc3RhdGU6ICdvcGVuJ1xuICAgICAgfSxcbiAgICAgIG91dGdvaW5nOiB7XG4gICAgICAgIGlkOiBpbmZvLnNlbmRlcixcbiAgICAgICAgd2luZG93OiBpbmZvLndpbmRvdyxcbiAgICAgICAgcGFja2V0U2l6ZTogaW5mby5wYWNrZXRTaXplLFxuICAgICAgICBzdGF0ZTogJ29wZW4nXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5cbmNsYXNzIFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGNmZywgbGlzdGVuZXIpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKHR5cGVvZiBjZmcgIT09ICdvYmplY3QnIHx8IGNmZyA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjb25maWd1cmF0aW9uIG9iamVjdCcpO1xuXG4gICAgY29uc3QgaG9zdEtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGhvc3RLZXlBbGdvT3JkZXIgPSBbXTtcblxuICAgIGNvbnN0IGhvc3RLZXlzXyA9IGNmZy5ob3N0S2V5cztcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaG9zdEtleXNfKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignaG9zdEtleXMgbXVzdCBiZSBhbiBhcnJheScpO1xuXG4gICAgY29uc3QgY2ZnQWxnb3MgPSAoXG4gICAgICB0eXBlb2YgY2ZnLmFsZ29yaXRobXMgPT09ICdvYmplY3QnICYmIGNmZy5hbGdvcml0aG1zICE9PSBudWxsXG4gICAgICA/IGNmZy5hbGdvcml0aG1zXG4gICAgICA6IHt9XG4gICAgKTtcblxuICAgIGNvbnN0IGhvc3RLZXlBbGdvcyA9IGdlbmVyYXRlQWxnb3JpdGhtTGlzdChcbiAgICAgIGNmZ0FsZ29zLnNlcnZlckhvc3RLZXksXG4gICAgICBERUZBVUxUX1NFUlZFUl9IT1NUX0tFWSxcbiAgICAgIFNVUFBPUlRFRF9TRVJWRVJfSE9TVF9LRVlcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9zdEtleXNfLmxlbmd0aDsgKytpKSB7XG4gICAgICBsZXQgcHJpdmF0ZUtleTtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoaG9zdEtleXNfW2ldKSB8fCB0eXBlb2YgaG9zdEtleXNfW2ldID09PSAnc3RyaW5nJylcbiAgICAgICAgcHJpdmF0ZUtleSA9IHBhcnNlS2V5KGhvc3RLZXlzX1tpXSk7XG4gICAgICBlbHNlXG4gICAgICAgIHByaXZhdGVLZXkgPSBwYXJzZUtleShob3N0S2V5c19baV0ua2V5LCBob3N0S2V5c19baV0ucGFzc3BocmFzZSk7XG5cbiAgICAgIGlmIChwcml2YXRlS2V5IGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIHByaXZhdGVLZXk6ICR7cHJpdmF0ZUtleS5tZXNzYWdlfWApO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcml2YXRlS2V5KSkge1xuICAgICAgICAvLyBPcGVuU1NIJ3MgbmV3ZXIgZm9ybWF0IG9ubHkgc3RvcmVzIDEga2V5IGZvciBub3dcbiAgICAgICAgcHJpdmF0ZUtleSA9IHByaXZhdGVLZXlbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcml2YXRlS2V5LmdldFByaXZhdGVQRU0oKSA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlS2V5IHZhbHVlIGNvbnRhaW5zIGFuIGludmFsaWQgcHJpdmF0ZSBrZXknKTtcblxuICAgICAgLy8gRGlzY2FyZCBrZXkgaWYgd2UgYWxyZWFkeSBmb3VuZCBhIGtleSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICBpZiAoaG9zdEtleUFsZ29PcmRlci5pbmNsdWRlcyhwcml2YXRlS2V5LnR5cGUpKVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgaWYgKHByaXZhdGVLZXkudHlwZSA9PT0gJ3NzaC1yc2EnKSB7XG4gICAgICAgIC8vIFNTSCBzdXBwb3J0cyBtdWx0aXBsZSBzaWduYXR1cmUgaGFzaGluZyBhbGdvcml0aG1zIGZvciBSU0EsIHNvIHdlIGFkZFxuICAgICAgICAvLyB0aGUgYWxnb3JpdGhtcyBpbiB0aGUgZGVzaXJlZCBvcmRlclxuICAgICAgICBsZXQgc2hhMVBvcyA9IGhvc3RLZXlBbGdvcy5pbmRleE9mKCdzc2gtcnNhJyk7XG4gICAgICAgIGNvbnN0IHNoYTI1NlBvcyA9IGhvc3RLZXlBbGdvcy5pbmRleE9mKCdyc2Etc2hhMi0yNTYnKTtcbiAgICAgICAgY29uc3Qgc2hhNTEyUG9zID0gaG9zdEtleUFsZ29zLmluZGV4T2YoJ3JzYS1zaGEyLTUxMicpO1xuICAgICAgICBpZiAoc2hhMVBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gZ2l2aW5nIFNIQTEgdGhlIGxvd2VzdCBwcmlvcml0eVxuICAgICAgICAgIHNoYTFQb3MgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICBbc2hhMVBvcywgc2hhMjU2UG9zLCBzaGE1MTJQb3NdLnNvcnQoY29tcGFyZU51bWJlcnMpLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgICAgIGlmIChwb3MgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgICAgIGNhc2Ugc2hhMVBvczogdHlwZSA9ICdzc2gtcnNhJzsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNoYTI1NlBvczogdHlwZSA9ICdyc2Etc2hhMi0yNTYnOyBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2hhNTEyUG9zOiB0eXBlID0gJ3JzYS1zaGEyLTUxMic7IGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN0b3JlIHNhbWUgUlNBIGtleSB1bmRlciBlYWNoIGhhc2ggYWxnb3JpdGhtIG5hbWUgZm9yIGNvbnZlbmllbmNlXG4gICAgICAgICAgaG9zdEtleXNbdHlwZV0gPSBwcml2YXRlS2V5O1xuXG4gICAgICAgICAgaG9zdEtleUFsZ29PcmRlci5wdXNoKHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvc3RLZXlzW3ByaXZhdGVLZXkudHlwZV0gPSBwcml2YXRlS2V5O1xuICAgICAgICBob3N0S2V5QWxnb09yZGVyLnB1c2gocHJpdmF0ZUtleS50eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhbGdvcml0aG1zID0ge1xuICAgICAga2V4OiBnZW5lcmF0ZUFsZ29yaXRobUxpc3QoY2ZnQWxnb3Mua2V4LCBERUZBVUxUX0tFWCwgU1VQUE9SVEVEX0tFWCksXG4gICAgICBzZXJ2ZXJIb3N0S2V5OiBob3N0S2V5QWxnb09yZGVyLFxuICAgICAgY3M6IHtcbiAgICAgICAgY2lwaGVyOiBnZW5lcmF0ZUFsZ29yaXRobUxpc3QoXG4gICAgICAgICAgICAgICAgICBjZmdBbGdvcy5jaXBoZXIsXG4gICAgICAgICAgICAgICAgICBERUZBVUxUX0NJUEhFUixcbiAgICAgICAgICAgICAgICAgIFNVUFBPUlRFRF9DSVBIRVJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICBtYWM6IGdlbmVyYXRlQWxnb3JpdGhtTGlzdChjZmdBbGdvcy5obWFjLCBERUZBVUxUX01BQywgU1VQUE9SVEVEX01BQyksXG4gICAgICAgIGNvbXByZXNzOiBnZW5lcmF0ZUFsZ29yaXRobUxpc3QoXG4gICAgICAgICAgICAgICAgICAgIGNmZ0FsZ29zLmNvbXByZXNzLFxuICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgICAgICAgICAgICAgICAgICBTVVBQT1JURURfQ09NUFJFU1NJT05cbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgIGxhbmc6IFtdLFxuICAgICAgfSxcbiAgICAgIHNjOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBhbGdvcml0aG1zLnNjID0gYWxnb3JpdGhtcy5jcztcblxuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLm9uKCdjb25uZWN0aW9uJywgbGlzdGVuZXIpO1xuXG4gICAgY29uc3Qgb3JpZ0RlYnVnID0gKHR5cGVvZiBjZmcuZGVidWcgPT09ICdmdW5jdGlvbicgPyBjZmcuZGVidWcgOiB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGlkZW50ID0gKGNmZy5pZGVudCA/IEJ1ZmZlci5mcm9tKGNmZy5pZGVudCkgOiB1bmRlZmluZWQpO1xuICAgIGNvbnN0IG9mZmVyID0gbmV3IEtleEluaXQoYWxnb3JpdGhtcyk7XG5cbiAgICB0aGlzLl9zcnYgPSBuZXcgbmV0U2VydmVyKChzb2NrZXQpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9ucyA+PSB0aGlzLm1heENvbm5lY3Rpb25zKSB7XG4gICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgICsrdGhpcy5fY29ubmVjdGlvbnM7XG4gICAgICBzb2NrZXQub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIC0tdGhpcy5fY29ubmVjdGlvbnM7XG4gICAgICB9KTtcblxuICAgICAgbGV0IGRlYnVnO1xuICAgICAgaWYgKG9yaWdEZWJ1Zykge1xuICAgICAgICAvLyBQcmVwZW5kIGRlYnVnIG91dHB1dCB3aXRoIGEgdW5pcXVlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGVyZSBhcmVcbiAgICAgICAgLy8gbXVsdGlwbGUgY2xpZW50cyBjb25uZWN0ZWQgYXQgdGhlIHNhbWUgdGltZVxuICAgICAgICBjb25zdCBkZWJ1Z1ByZWZpeCA9IGBbJHtwcm9jZXNzLmhydGltZSgpLmpvaW4oJy4nKX1dIGA7XG4gICAgICAgIGRlYnVnID0gKG1zZykgPT4ge1xuICAgICAgICAgIG9yaWdEZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0ke21zZ31gKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICBuZXcgQ2xpZW50KHNvY2tldCwgaG9zdEtleXMsIGlkZW50LCBvZmZlciwgZGVidWcsIHRoaXMsIGNmZyk7XG4gICAgfSkub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSkub24oJ2xpc3RlbmluZycsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnbGlzdGVuaW5nJyk7XG4gICAgfSkub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gMDtcbiAgICB0aGlzLm1heENvbm5lY3Rpb25zID0gSW5maW5pdHk7XG4gIH1cblxuICBpbmplY3RTb2NrZXQoc29ja2V0KSB7XG4gICAgdGhpcy5fc3J2LmVtaXQoJ2Nvbm5lY3Rpb24nLCBzb2NrZXQpO1xuICB9XG5cbiAgbGlzdGVuKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9zcnYubGlzdGVuKC4uLmFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkcmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3J2LmFkZHJlc3MoKTtcbiAgfVxuXG4gIGdldENvbm5lY3Rpb25zKGNiKSB7XG4gICAgdGhpcy5fc3J2LmdldENvbm5lY3Rpb25zKGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNsb3NlKGNiKSB7XG4gICAgdGhpcy5fc3J2LmNsb3NlKGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlZigpIHtcbiAgICB0aGlzLl9zcnYucmVmKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1bnJlZigpIHtcbiAgICB0aGlzLl9zcnYudW5yZWYoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuU2VydmVyLktFRVBBTElWRV9DTElFTlRfSU5URVJWQUwgPSAxNTAwMDtcblNlcnZlci5LRUVQQUxJVkVfQ0xJRU5UX0NPVU5UX01BWCA9IDM7XG5cblxuY2xhc3MgQ2xpZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Ioc29ja2V0LCBob3N0S2V5cywgaWRlbnQsIG9mZmVyLCBkZWJ1Zywgc2VydmVyLCBzcnZDZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgbGV0IGV4Y2hhbmdlcyA9IDA7XG4gICAgbGV0IGFjY2VwdGVkQXV0aFN2YyA9IGZhbHNlO1xuICAgIGxldCBwZW5kaW5nQXV0aHMgPSBbXTtcbiAgICBsZXQgYXV0aEN0eDtcbiAgICBsZXQga2FUaW1lcjtcbiAgICBsZXQgb25QYWNrZXQ7XG4gICAgY29uc3QgdW5zZW50R2xvYmFsUmVxdWVzdHNSZXBsaWVzID0gW107XG4gICAgdGhpcy5fc29jayA9IHNvY2tldDtcbiAgICB0aGlzLl9jaGFuTWdyID0gbmV3IENoYW5uZWxNYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMuX2RlYnVnID0gZGVidWc7XG4gICAgdGhpcy5ub01vcmVTZXNzaW9ucyA9IGZhbHNlO1xuICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IGZhbHNlO1xuXG4gICAgLy8gU2lsZW5jZSBwcmUtaGVhZGVyIGVycm9yc1xuICAgIGZ1bmN0aW9uIG9uQ2xpZW50UHJlSGVhZGVyRXJyb3IoZXJyKSB7fVxuICAgIHRoaXMub24oJ2Vycm9yJywgb25DbGllbnRQcmVIZWFkZXJFcnJvcik7XG5cbiAgICBjb25zdCBERUJVR19IQU5ETEVSID0gKCFkZWJ1ZyA/IHVuZGVmaW5lZCA6IChwLCBkaXNwbGF5LCBtc2cpID0+IHtcbiAgICAgIGRlYnVnKGBEZWJ1ZyBvdXRwdXQgZnJvbSBjbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkobXNnKX1gKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGthSW50dmwgPSAoXG4gICAgICB0eXBlb2Ygc3J2Q2ZnLmtlZXBhbGl2ZUludGVydmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAmJiBpc0Zpbml0ZShzcnZDZmcua2VlcGFsaXZlSW50ZXJ2YWwpXG4gICAgICAgICYmIHNydkNmZy5rZWVwYWxpdmVJbnRlcnZhbCA+IDBcbiAgICAgID8gc3J2Q2ZnLmtlZXBhbGl2ZUludGVydmFsXG4gICAgICA6IChcbiAgICAgICAgdHlwZW9mIFNlcnZlci5LRUVQQUxJVkVfQ0xJRU5UX0lOVEVSVkFMID09PSAnbnVtYmVyJ1xuICAgICAgICAgICYmIGlzRmluaXRlKFNlcnZlci5LRUVQQUxJVkVfQ0xJRU5UX0lOVEVSVkFMKVxuICAgICAgICAgICYmIFNlcnZlci5LRUVQQUxJVkVfQ0xJRU5UX0lOVEVSVkFMID4gMFxuICAgICAgICA/IFNlcnZlci5LRUVQQUxJVkVfQ0xJRU5UX0lOVEVSVkFMXG4gICAgICAgIDogLTFcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnN0IGthQ291bnRNYXggPSAoXG4gICAgICB0eXBlb2Ygc3J2Q2ZnLmtlZXBhbGl2ZUNvdW50TWF4ID09PSAnbnVtYmVyJ1xuICAgICAgICAmJiBpc0Zpbml0ZShzcnZDZmcua2VlcGFsaXZlQ291bnRNYXgpXG4gICAgICAgICYmIHNydkNmZy5rZWVwYWxpdmVDb3VudE1heCA+PSAwXG4gICAgICA/IHNydkNmZy5rZWVwYWxpdmVDb3VudE1heFxuICAgICAgOiAoXG4gICAgICAgIHR5cGVvZiBTZXJ2ZXIuS0VFUEFMSVZFX0NMSUVOVF9DT1VOVF9NQVggPT09ICdudW1iZXInXG4gICAgICAgICAgJiYgaXNGaW5pdGUoU2VydmVyLktFRVBBTElWRV9DTElFTlRfQ09VTlRfTUFYKVxuICAgICAgICAgICYmIFNlcnZlci5LRUVQQUxJVkVfQ0xJRU5UX0NPVU5UX01BWCA+PSAwXG4gICAgICAgID8gU2VydmVyLktFRVBBTElWRV9DTElFTlRfQ09VTlRfTUFYXG4gICAgICAgIDogLTFcbiAgICAgIClcbiAgICApO1xuICAgIGxldCBrYUN1ckNvdW50ID0gMDtcbiAgICBpZiAoa2FJbnR2bCAhPT0gLTEgJiYga2FDb3VudE1heCAhPT0gLTEpIHtcbiAgICAgIHRoaXMub25jZSgncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChrYVRpbWVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbignY2xvc2UnLCBvbkNsb3NlKS5vbignZW5kJywgb25DbG9zZSk7XG4gICAgICAgIGthVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCsra2FDdXJDb3VudCA+IGthQ291bnRNYXgpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoa2FUaW1lcik7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0tlZXBhbGl2ZSB0aW1lb3V0Jyk7XG4gICAgICAgICAgICBlcnIubGV2ZWwgPSAnY2xpZW50LXRpbWVvdXQnO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBYWFg6IGlmIHRoZSBzZXJ2ZXIgZXZlciBzdGFydHMgc2VuZGluZyByZWFsIGdsb2JhbCByZXF1ZXN0cyB0b1xuICAgICAgICAgICAgLy8gICAgICB0aGUgY2xpZW50LCB3ZSB3aWxsIG5lZWQgdG8gYWRkIGEgZHVtbXkgY2FsbGJhY2sgaGVyZSB0b1xuICAgICAgICAgICAgLy8gICAgICBrZWVwIHRoZSBjb3JyZWN0IHJlcGx5IG9yZGVyXG4gICAgICAgICAgICBwcm90by5waW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBrYUludHZsKTtcbiAgICAgIH0pO1xuICAgICAgLy8gVE9ETzogcmUtdmVyaWZ5IGtlZXBhbGl2ZSBiZWhhdmlvciB3aXRoIE9wZW5TU0hcbiAgICAgIG9uUGFja2V0ID0gKCkgPT4ge1xuICAgICAgICBrYVRpbWVyICYmIGthVGltZXIucmVmcmVzaCgpO1xuICAgICAgICBrYUN1ckNvdW50ID0gMDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG8gPSB0aGlzLl9wcm90b2NvbCA9IG5ldyBQcm90b2NvbCh7XG4gICAgICBzZXJ2ZXI6IHRydWUsXG4gICAgICBob3N0S2V5cyxcbiAgICAgIGlkZW50LFxuICAgICAgb2ZmZXIsXG4gICAgICBvblBhY2tldCxcbiAgICAgIGdyZWV0aW5nOiBzcnZDZmcuZ3JlZXRpbmcsXG4gICAgICBiYW5uZXI6IHNydkNmZy5iYW5uZXIsXG4gICAgICBvbldyaXRlOiAoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoaXNXcml0YWJsZShzb2NrZXQpKVxuICAgICAgICAgIHNvY2tldC53cml0ZShkYXRhKTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAoZXJyKSA9PiB7XG4gICAgICAgIGlmICghcHJvdG8uX2Rlc3RydWN0KVxuICAgICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc29ja2V0LmVuZCgpO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9LFxuICAgICAgb25IZWFkZXI6IChoZWFkZXIpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkNsaWVudFByZUhlYWRlckVycm9yKTtcblxuICAgICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICAgIGlwOiBzb2NrZXQucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICBmYW1pbHk6IHNvY2tldC5yZW1vdGVGYW1pbHksXG4gICAgICAgICAgcG9ydDogc29ja2V0LnJlbW90ZVBvcnQsXG4gICAgICAgICAgaGVhZGVyLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXNlcnZlci5lbWl0KCdjb25uZWN0aW9uJywgdGhpcywgaW5mbykpIHtcbiAgICAgICAgICAvLyBhdXRvIHJlamVjdFxuICAgICAgICAgIHByb3RvLmRpc2Nvbm5lY3QoRElTQ09OTkVDVF9SRUFTT04uQllfQVBQTElDQVRJT04pO1xuICAgICAgICAgIHNvY2tldC5lbmQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVhZGVyLmdyZWV0aW5nKVxuICAgICAgICAgIHRoaXMuZW1pdCgnZ3JlZXRpbmcnLCBoZWFkZXIuZ3JlZXRpbmcpO1xuICAgICAgfSxcbiAgICAgIG9uSGFuZHNoYWtlQ29tcGxldGU6IChuZWdvdGlhdGVkKSA9PiB7XG4gICAgICAgIGlmICgrK2V4Y2hhbmdlcyA+IDEpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZWtleScpO1xuICAgICAgICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIG5lZ290aWF0ZWQpO1xuICAgICAgfSxcbiAgICAgIGRlYnVnLFxuICAgICAgbWVzc2FnZUhhbmRsZXJzOiB7XG4gICAgICAgIERFQlVHOiBERUJVR19IQU5ETEVSLFxuICAgICAgICBESVNDT05ORUNUOiAocCwgcmVhc29uLCBkZXNjKSA9PiB7XG4gICAgICAgICAgaWYgKHJlYXNvbiAhPT0gRElTQ09OTkVDVF9SRUFTT04uQllfQVBQTElDQVRJT04pIHtcbiAgICAgICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgICBkZXNjID0gRElTQ09OTkVDVF9SRUFTT05fQllfVkFMVUVbcmVhc29uXTtcbiAgICAgICAgICAgICAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBkZXNjID0gYFVuZXhwZWN0ZWQgZGlzY29ubmVjdGlvbiByZWFzb246ICR7cmVhc29ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZGVzYyk7XG4gICAgICAgICAgICBlcnIuY29kZSA9IHJlYXNvbjtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIENIQU5ORUxfT1BFTjogKHAsIGluZm8pID0+IHtcbiAgICAgICAgICAvLyBIYW5kbGUgaW5jb21pbmcgcmVxdWVzdHMgZnJvbSBjbGllbnRcblxuICAgICAgICAgIC8vIERvIGVhcmx5IHJlamVjdCBpbiBzb21lIGNhc2VzIHRvIHByZXZlbnQgd2FzdGVmdWwgY2hhbm5lbFxuICAgICAgICAgIC8vIGFsbG9jYXRpb25cbiAgICAgICAgICBpZiAoKGluZm8udHlwZSA9PT0gJ3Nlc3Npb24nICYmIHRoaXMubm9Nb3JlU2Vzc2lvbnMpXG4gICAgICAgICAgICAgIHx8ICF0aGlzLmF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYXNvbkNvZGUgPSBDSEFOTkVMX09QRU5fRkFJTFVSRS5BRE1JTklTVFJBVElWRUxZX1BST0hJQklURUQ7XG4gICAgICAgICAgICByZXR1cm4gcHJvdG8uY2hhbm5lbE9wZW5GYWlsKGluZm8uc2VuZGVyLCByZWFzb25Db2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgbG9jYWxDaGFuID0gLTE7XG4gICAgICAgICAgbGV0IHJlYXNvbjtcbiAgICAgICAgICBsZXQgcmVwbGllZCA9IGZhbHNlO1xuXG4gICAgICAgICAgbGV0IGFjY2VwdDtcbiAgICAgICAgICBjb25zdCByZWplY3QgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVwbGllZClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmVwbGllZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChyZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAobG9jYWxDaGFuID09PSAtMSlcbiAgICAgICAgICAgICAgICByZWFzb24gPSBDSEFOTkVMX09QRU5fRkFJTFVSRS5SRVNPVVJDRV9TSE9SVEFHRTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlYXNvbiA9IENIQU5ORUxfT1BFTl9GQUlMVVJFLkNPTk5FQ1RfRkFJTEVEO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9jYWxDaGFuICE9PSAtMSlcbiAgICAgICAgICAgICAgdGhpcy5fY2hhbk1nci5yZW1vdmUobG9jYWxDaGFuKTtcbiAgICAgICAgICAgIHByb3RvLmNoYW5uZWxPcGVuRmFpbChpbmZvLnNlbmRlciwgcmVhc29uLCAnJyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCByZXNlcnZlQ2hhbm5lbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGxvY2FsQ2hhbiA9IHRoaXMuX2NoYW5NZ3IuYWRkKCk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbENoYW4gPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlYXNvbiA9IENIQU5ORUxfT1BFTl9GQUlMVVJFLlJFU09VUkNFX1NIT1JUQUdFO1xuICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnQXV0b21hdGljIHJlamVjdGlvbiBvZiBpbmNvbWluZyBjaGFubmVsIG9wZW46ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ25vIGNoYW5uZWxzIGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAobG9jYWxDaGFuICE9PSAtMSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBpbmZvLmRhdGE7XG4gICAgICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Nlc3Npb24nOlxuICAgICAgICAgICAgICBpZiAobGlzdGVuZXJDb3VudCh0aGlzLCAnc2Vzc2lvbicpICYmIHJlc2VydmVDaGFubmVsKCkpIHtcbiAgICAgICAgICAgICAgICBhY2NlcHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwbGllZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgcmVwbGllZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFNlc3Npb24odGhpcywgaW5mbywgbG9jYWxDaGFuKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5NZ3IudXBkYXRlKGxvY2FsQ2hhbiwgaW5zdGFuY2UpO1xuXG4gICAgICAgICAgICAgICAgICBwcm90by5jaGFubmVsT3BlbkNvbmZpcm0oaW5mby5zZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDaGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1BWF9XSU5ET1csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUEFDS0VUX1NJWkUpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc2Vzc2lvbicsIGFjY2VwdCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaXJlY3QtdGNwaXAnOlxuICAgICAgICAgICAgICBpZiAobGlzdGVuZXJDb3VudCh0aGlzLCAndGNwaXAnKSAmJiByZXNlcnZlQ2hhbm5lbCgpKSB7XG4gICAgICAgICAgICAgICAgYWNjZXB0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcGxpZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIHJlcGxpZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICBjb25zdCBjaGFuSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBpbmNvbWluZzoge1xuICAgICAgICAgICAgICAgICAgICAgIGlkOiBsb2NhbENoYW4sXG4gICAgICAgICAgICAgICAgICAgICAgd2luZG93OiBNQVhfV0lORE9XLFxuICAgICAgICAgICAgICAgICAgICAgIHBhY2tldFNpemU6IFBBQ0tFVF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiAnb3BlbidcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb3V0Z29pbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZDogaW5mby5zZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgd2luZG93OiBpbmZvLndpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRTaXplOiBpbmZvLnBhY2tldFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdvcGVuJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgQ2hhbm5lbCh0aGlzLCBjaGFuSW5mbywgeyBzZXJ2ZXI6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuTWdyLnVwZGF0ZShsb2NhbENoYW4sIHN0cmVhbSk7XG5cbiAgICAgICAgICAgICAgICAgIHByb3RvLmNoYW5uZWxPcGVuQ29uZmlybShpbmZvLnNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbENoYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTUFYX1dJTkRPVyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQQUNLRVRfU0laRSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndGNwaXAnLCBhY2NlcHQsIHJlamVjdCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGlyZWN0LXN0cmVhbWxvY2FsQG9wZW5zc2guY29tJzpcbiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyQ291bnQodGhpcywgJ29wZW5zc2guc3RyZWFtbG9jYWwnKVxuICAgICAgICAgICAgICAgICAgJiYgcmVzZXJ2ZUNoYW5uZWwoKSkge1xuICAgICAgICAgICAgICAgIGFjY2VwdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXBsaWVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICByZXBsaWVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbkluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgaW5jb21pbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZDogbG9jYWxDaGFuLFxuICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdzogTUFYX1dJTkRPVyxcbiAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRTaXplOiBQQUNLRVRfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ29wZW4nXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG91dGdvaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGluZm8uc2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdzogaW5mby53aW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAgcGFja2V0U2l6ZTogaW5mby5wYWNrZXRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiAnb3BlbidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IENoYW5uZWwodGhpcywgY2hhbkluZm8sIHsgc2VydmVyOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbk1nci51cGRhdGUobG9jYWxDaGFuLCBzdHJlYW0pO1xuXG4gICAgICAgICAgICAgICAgICBwcm90by5jaGFubmVsT3BlbkNvbmZpcm0oaW5mby5zZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDaGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1BWF9XSU5ET1csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUEFDS0VUX1NJWkUpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ29wZW5zc2guc3RyZWFtbG9jYWwnLCBhY2NlcHQsIHJlamVjdCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gQXV0b21hdGljYWxseSByZWplY3QgYW55IHVuc3VwcG9ydGVkIGNoYW5uZWwgb3BlbiByZXF1ZXN0c1xuICAgICAgICAgICAgICByZWFzb24gPSBDSEFOTkVMX09QRU5fRkFJTFVSRS5VTktOT1dOX0NIQU5ORUxfVFlQRTtcbiAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ0F1dG9tYXRpYyByZWplY3Rpb24gb2YgdW5zdXBwb3J0ZWQgaW5jb21pbmcgY2hhbm5lbCBvcGVuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyBgIHR5cGU6ICR7aW5mby50eXBlfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlYXNvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWFzb24gPSBDSEFOTkVMX09QRU5fRkFJTFVSRS5BRE1JTklTVFJBVElWRUxZX1BST0hJQklURUQ7XG4gICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ0F1dG9tYXRpYyByZWplY3Rpb24gb2YgdW5leHBlY3RlZCBpbmNvbWluZyBjaGFubmVsIG9wZW4nXG4gICAgICAgICAgICAgICAgICAgICAgKyBgIGZvcjogJHtpbmZvLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIENIQU5ORUxfT1BFTl9DT05GSVJNQVRJT046IChwLCBpbmZvKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuX2NoYW5NZ3IuZ2V0KGluZm8ucmVjaXBpZW50KTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICBjb25zdCBjaGFuSW5mbyA9IHtcbiAgICAgICAgICAgIHR5cGU6IGNoYW5uZWwudHlwZSxcbiAgICAgICAgICAgIGluY29taW5nOiB7XG4gICAgICAgICAgICAgIGlkOiBpbmZvLnJlY2lwaWVudCxcbiAgICAgICAgICAgICAgd2luZG93OiBNQVhfV0lORE9XLFxuICAgICAgICAgICAgICBwYWNrZXRTaXplOiBQQUNLRVRfU0laRSxcbiAgICAgICAgICAgICAgc3RhdGU6ICdvcGVuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG91dGdvaW5nOiB7XG4gICAgICAgICAgICAgIGlkOiBpbmZvLnNlbmRlcixcbiAgICAgICAgICAgICAgd2luZG93OiBpbmZvLndpbmRvdyxcbiAgICAgICAgICAgICAgcGFja2V0U2l6ZTogaW5mby5wYWNrZXRTaXplLFxuICAgICAgICAgICAgICBzdGF0ZTogJ29wZW4nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IENoYW5uZWwodGhpcywgY2hhbkluZm8sIHsgc2VydmVyOiB0cnVlIH0pO1xuICAgICAgICAgIHRoaXMuX2NoYW5NZ3IudXBkYXRlKGluZm8ucmVjaXBpZW50LCBpbnN0YW5jZSk7XG4gICAgICAgICAgY2hhbm5lbCh1bmRlZmluZWQsIGluc3RhbmNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgQ0hBTk5FTF9PUEVOX0ZBSUxVUkU6IChwLCByZWNpcGllbnQsIHJlYXNvbiwgZGVzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5fY2hhbk1nci5nZXQocmVjaXBpZW50KTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICBjb25zdCBpbmZvID0geyByZWFzb24sIGRlc2NyaXB0aW9uIH07XG4gICAgICAgICAgb25DaGFubmVsT3BlbkZhaWx1cmUodGhpcywgcmVjaXBpZW50LCBpbmZvLCBjaGFubmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgQ0hBTk5FTF9EQVRBOiAocCwgcmVjaXBpZW50LCBkYXRhKSA9PiB7XG4gICAgICAgICAgbGV0IGNoYW5uZWwgPSB0aGlzLl9jaGFuTWdyLmdldChyZWNpcGllbnQpO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2hhbm5lbCAhPT0gJ29iamVjdCcgfHwgY2hhbm5lbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIGlmIChjaGFubmVsLmNvbnN0cnVjdG9yID09PSBTZXNzaW9uKSB7XG4gICAgICAgICAgICBjaGFubmVsID0gY2hhbm5lbC5fY2hhbm5lbDtcbiAgICAgICAgICAgIGlmICghY2hhbm5lbClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSByZW1vdGUgcGFydHkgc2hvdWxkIG5vdCBiZSBzZW5kaW5nIHVzIGRhdGEgaWYgdGhlcmUgaXMgbm9cbiAgICAgICAgICAvLyB3aW5kb3cgc3BhY2UgYXZhaWxhYmxlIC4uLlxuICAgICAgICAgIC8vIFRPRE86IHJhaXNlIGVycm9yIG9uIGRhdGEgd2l0aCBub3QgZW5vdWdoIHdpbmRvdz9cbiAgICAgICAgICBpZiAoY2hhbm5lbC5pbmNvbWluZy53aW5kb3cgPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICBjaGFubmVsLmluY29taW5nLndpbmRvdyAtPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChjaGFubmVsLnB1c2goZGF0YSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjaGFubmVsLl93YWl0Q2hhbkRyYWluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhbm5lbC5pbmNvbWluZy53aW5kb3cgPD0gV0lORE9XX1RIUkVTSE9MRClcbiAgICAgICAgICAgIHdpbmRvd0FkanVzdChjaGFubmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgQ0hBTk5FTF9FWFRFTkRFRF9EQVRBOiAocCwgcmVjaXBpZW50LCBkYXRhLCB0eXBlKSA9PiB7XG4gICAgICAgICAgLy8gTk9PUCAtLSBzaG91bGQgbm90IGJlIHNlbnQgYnkgY2xpZW50XG4gICAgICAgIH0sXG4gICAgICAgIENIQU5ORUxfV0lORE9XX0FESlVTVDogKHAsIHJlY2lwaWVudCwgYW1vdW50KSA9PiB7XG4gICAgICAgICAgbGV0IGNoYW5uZWwgPSB0aGlzLl9jaGFuTWdyLmdldChyZWNpcGllbnQpO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2hhbm5lbCAhPT0gJ29iamVjdCcgfHwgY2hhbm5lbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIGlmIChjaGFubmVsLmNvbnN0cnVjdG9yID09PSBTZXNzaW9uKSB7XG4gICAgICAgICAgICBjaGFubmVsID0gY2hhbm5lbC5fY2hhbm5lbDtcbiAgICAgICAgICAgIGlmICghY2hhbm5lbClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBvdGhlciBzaWRlIGlzIGFsbG93aW5nIHVzIHRvIHNlbmQgYGFtb3VudGAgbW9yZSBieXRlcyBvZiBkYXRhXG4gICAgICAgICAgY2hhbm5lbC5vdXRnb2luZy53aW5kb3cgKz0gYW1vdW50O1xuXG4gICAgICAgICAgaWYgKGNoYW5uZWwuX3dhaXRXaW5kb3cpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuX3dhaXRXaW5kb3cgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGNoYW5uZWwuX2NodW5rKSB7XG4gICAgICAgICAgICAgIGNoYW5uZWwuX3dyaXRlKGNoYW5uZWwuX2NodW5rLCBudWxsLCBjaGFubmVsLl9jaHVua2NiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5fY2h1bmtjYikge1xuICAgICAgICAgICAgICBjaGFubmVsLl9jaHVua2NiKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWwuX2NodW5rRXJyKSB7XG4gICAgICAgICAgICAgIGNoYW5uZWwuc3RkZXJyLl93cml0ZShjaGFubmVsLl9jaHVua0VycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLl9jaHVua2NiRXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5fY2h1bmtjYkVycikge1xuICAgICAgICAgICAgICBjaGFubmVsLl9jaHVua2NiRXJyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBDSEFOTkVMX1NVQ0NFU1M6IChwLCByZWNpcGllbnQpID0+IHtcbiAgICAgICAgICBsZXQgY2hhbm5lbCA9IHRoaXMuX2NoYW5NZ3IuZ2V0KHJlY2lwaWVudCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9PSAnb2JqZWN0JyB8fCBjaGFubmVsID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgaWYgKGNoYW5uZWwuY29uc3RydWN0b3IgPT09IFNlc3Npb24pIHtcbiAgICAgICAgICAgIGNoYW5uZWwgPSBjaGFubmVsLl9jaGFubmVsO1xuICAgICAgICAgICAgaWYgKCFjaGFubmVsKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoYW5uZWwuX2NhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBjaGFubmVsLl9jYWxsYmFja3Muc2hpZnQoKShmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIENIQU5ORUxfRkFJTFVSRTogKHAsIHJlY2lwaWVudCkgPT4ge1xuICAgICAgICAgIGxldCBjaGFubmVsID0gdGhpcy5fY2hhbk1nci5nZXQocmVjaXBpZW50KTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT09ICdvYmplY3QnIHx8IGNoYW5uZWwgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICBpZiAoY2hhbm5lbC5jb25zdHJ1Y3RvciA9PT0gU2Vzc2lvbikge1xuICAgICAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwuX2NoYW5uZWw7XG4gICAgICAgICAgICBpZiAoIWNoYW5uZWwpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhbm5lbC5fY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgIGNoYW5uZWwuX2NhbGxiYWNrcy5zaGlmdCgpKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBDSEFOTkVMX1JFUVVFU1Q6IChwLCByZWNpcGllbnQsIHR5cGUsIHdhbnRSZXBseSwgZGF0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLl9jaGFuTWdyLmdldChyZWNpcGllbnQpO1xuICAgICAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbiAhPT0gJ29iamVjdCcgfHwgc2Vzc2lvbiA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIGxldCByZXBsaWVkID0gZmFsc2U7XG4gICAgICAgICAgbGV0IGFjY2VwdDtcbiAgICAgICAgICBsZXQgcmVqZWN0O1xuXG4gICAgICAgICAgaWYgKHNlc3Npb24uY29uc3RydWN0b3IgIT09IFNlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbCBDaGFubmVsIGluc3RhbmNlXG4gICAgICAgICAgICBpZiAod2FudFJlcGx5KVxuICAgICAgICAgICAgICBwcm90by5jaGFubmVsRmFpbHVyZShzZXNzaW9uLm91dGdvaW5nLmlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod2FudFJlcGx5KSB7XG4gICAgICAgICAgICAvLyBcInJlYWwgc2Vzc2lvblwiIHJlcXVlc3RzIHdpbGwgaGF2ZSBjdXN0b20gYWNjZXB0IGJlaGF2aW9yc1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdzaGVsbCdcbiAgICAgICAgICAgICAgICAmJiB0eXBlICE9PSAnZXhlYydcbiAgICAgICAgICAgICAgICAmJiB0eXBlICE9PSAnc3Vic3lzdGVtJykge1xuICAgICAgICAgICAgICBhY2NlcHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxpZWQgfHwgc2Vzc2lvbi5fZW5kaW5nIHx8IHNlc3Npb24uX2NoYW5uZWwpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgcmVwbGllZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBwcm90by5jaGFubmVsU3VjY2VzcyhzZXNzaW9uLl9jaGFuSW5mby5vdXRnb2luZy5pZCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlamVjdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlcGxpZWQgfHwgc2Vzc2lvbi5fZW5kaW5nIHx8IHNlc3Npb24uX2NoYW5uZWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICByZXBsaWVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBwcm90by5jaGFubmVsRmFpbHVyZShzZXNzaW9uLl9jaGFuSW5mby5vdXRnb2luZy5pZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZXNzaW9uLl9lbmRpbmcpIHtcbiAgICAgICAgICAgIHJlamVjdCAmJiByZWplY3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFwicHJlLXJlYWwgc2Vzc2lvbiBzdGFydFwiIHJlcXVlc3RzXG4gICAgICAgICAgICBjYXNlICdlbnYnOlxuICAgICAgICAgICAgICBpZiAobGlzdGVuZXJDb3VudChzZXNzaW9uLCAnZW52JykpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ2VudicsIGFjY2VwdCwgcmVqZWN0LCB7XG4gICAgICAgICAgICAgICAgICBrZXk6IGRhdGEubmFtZSxcbiAgICAgICAgICAgICAgICAgIHZhbDogZGF0YS52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B0eS1yZXEnOlxuICAgICAgICAgICAgICBpZiAobGlzdGVuZXJDb3VudChzZXNzaW9uLCAncHR5JykpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ3B0eScsIGFjY2VwdCwgcmVqZWN0LCBkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3aW5kb3ctY2hhbmdlJzpcbiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyQ291bnQoc2Vzc2lvbiwgJ3dpbmRvdy1jaGFuZ2UnKSlcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ3dpbmRvdy1jaGFuZ2UnLCBhY2NlcHQsIHJlamVjdCwgZGF0YSk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZWplY3QgJiYgcmVqZWN0KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneDExLXJlcSc6XG4gICAgICAgICAgICAgIGlmIChsaXN0ZW5lckNvdW50KHNlc3Npb24sICd4MTEnKSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgneDExJywgYWNjZXB0LCByZWplY3QsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFwicG9zdC1yZWFsIHNlc3Npb24gc3RhcnRcIiByZXF1ZXN0c1xuICAgICAgICAgICAgY2FzZSAnc2lnbmFsJzpcbiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyQ291bnQoc2Vzc2lvbiwgJ3NpZ25hbCcpKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5lbWl0KCdzaWduYWwnLCBhY2NlcHQsIHJlamVjdCwge1xuICAgICAgICAgICAgICAgICAgbmFtZTogZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFhYWDogaXMgYGF1dGgtYWdlbnQtcmVxQG9wZW5zc2guY29tYCByZWFsbHkgXCJwb3N0LXJlYWwgc2Vzc2lvblxuICAgICAgICAgICAgLy8gc3RhcnRcIj9cbiAgICAgICAgICAgIGNhc2UgJ2F1dGgtYWdlbnQtcmVxQG9wZW5zc2guY29tJzpcbiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyQ291bnQoc2Vzc2lvbiwgJ2F1dGgtYWdlbnQnKSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgnYXV0aC1hZ2VudCcsIGFjY2VwdCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBcInJlYWwgc2Vzc2lvbiBzdGFydFwiIHJlcXVlc3RzXG4gICAgICAgICAgICBjYXNlICdzaGVsbCc6XG4gICAgICAgICAgICAgIGlmIChsaXN0ZW5lckNvdW50KHNlc3Npb24sICdzaGVsbCcpKSB7XG4gICAgICAgICAgICAgICAgYWNjZXB0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcGxpZWQgfHwgc2Vzc2lvbi5fZW5kaW5nIHx8IHNlc3Npb24uX2NoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIHJlcGxpZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAod2FudFJlcGx5KVxuICAgICAgICAgICAgICAgICAgICBwcm90by5jaGFubmVsU3VjY2VzcyhzZXNzaW9uLl9jaGFuSW5mby5vdXRnb2luZy5pZCk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgQ2hhbm5lbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgc2Vzc2lvbi5fY2hhbkluZm8sIHsgc2VydmVyOiB0cnVlIH1cbiAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3VidHlwZSA9IHNlc3Npb24uc3VidHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICBzZXNzaW9uLl9jaGFubmVsID0gY2hhbm5lbDtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgnc2hlbGwnLCBhY2NlcHQsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXhlYyc6XG4gICAgICAgICAgICAgIGlmIChsaXN0ZW5lckNvdW50KHNlc3Npb24sICdleGVjJykpIHtcbiAgICAgICAgICAgICAgICBhY2NlcHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwbGllZCB8fCBzZXNzaW9uLl9lbmRpbmcgfHwgc2Vzc2lvbi5fY2hhbm5lbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgcmVwbGllZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh3YW50UmVwbHkpXG4gICAgICAgICAgICAgICAgICAgIHByb3RvLmNoYW5uZWxTdWNjZXNzKHNlc3Npb24uX2NoYW5JbmZvLm91dGdvaW5nLmlkKTtcblxuICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IG5ldyBDaGFubmVsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLCBzZXNzaW9uLl9jaGFuSW5mbywgeyBzZXJ2ZXI6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zdWJ0eXBlID0gc2Vzc2lvbi5zdWJ0eXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgIHNlc3Npb24uX2NoYW5uZWwgPSBjaGFubmVsO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5lbWl0KCdleGVjJywgYWNjZXB0LCByZWplY3QsIHtcbiAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdWJzeXN0ZW0nOiB7XG4gICAgICAgICAgICAgIGxldCB1c2VTRlRQID0gKGRhdGEgPT09ICdzZnRwJyk7XG4gICAgICAgICAgICAgIGFjY2VwdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGllZCB8fCBzZXNzaW9uLl9lbmRpbmcgfHwgc2Vzc2lvbi5fY2hhbm5lbClcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICByZXBsaWVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmICh3YW50UmVwbHkpXG4gICAgICAgICAgICAgICAgICBwcm90by5jaGFubmVsU3VjY2VzcyhzZXNzaW9uLl9jaGFuSW5mby5vdXRnb2luZy5pZCk7XG5cbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgaWYgKHVzZVNGVFApIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gbmV3IFNGVFAodGhpcywgc2Vzc2lvbi5fY2hhbkluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IG5ldyBDaGFubmVsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLCBzZXNzaW9uLl9jaGFuSW5mbywgeyBzZXJ2ZXI6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnN1YnR5cGUgPVxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnN1YnR5cGUgPSBgJHt0eXBlfToke2RhdGF9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5fY2hhbm5lbCA9IGluc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChkYXRhID09PSAnc2Z0cCcpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJDb3VudChzZXNzaW9uLCAnc2Z0cCcpKSB7XG4gICAgICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ3NmdHAnLCBhY2NlcHQsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVzZVNGVFAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGlzdGVuZXJDb3VudChzZXNzaW9uLCAnc3Vic3lzdGVtJykpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ3N1YnN5c3RlbScsIGFjY2VwdCwgcmVqZWN0LCB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZWJ1ZyAmJiBkZWJ1ZyhcbiAgICAgICAgICAgIGBBdXRvbWF0aWMgcmVqZWN0aW9uIG9mIGluY29taW5nIGNoYW5uZWwgcmVxdWVzdDogJHt0eXBlfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlamVjdCAmJiByZWplY3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAgQ0hBTk5FTF9FT0Y6IChwLCByZWNpcGllbnQpID0+IHtcbiAgICAgICAgICBsZXQgY2hhbm5lbCA9IHRoaXMuX2NoYW5NZ3IuZ2V0KHJlY2lwaWVudCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9PSAnb2JqZWN0JyB8fCBjaGFubmVsID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgaWYgKGNoYW5uZWwuY29uc3RydWN0b3IgPT09IFNlc3Npb24pIHtcbiAgICAgICAgICAgIGlmICghY2hhbm5lbC5fZW5kaW5nKSB7XG4gICAgICAgICAgICAgIGNoYW5uZWwuX2VuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGNoYW5uZWwuZW1pdCgnZW9mJyk7XG4gICAgICAgICAgICAgIGNoYW5uZWwuZW1pdCgnZW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFubmVsID0gY2hhbm5lbC5fY2hhbm5lbDtcbiAgICAgICAgICAgIGlmICghY2hhbm5lbClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGFubmVsLmluY29taW5nLnN0YXRlICE9PSAnb3BlbicpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2hhbm5lbC5pbmNvbWluZy5zdGF0ZSA9ICdlb2YnO1xuXG4gICAgICAgICAgaWYgKGNoYW5uZWwucmVhZGFibGUpXG4gICAgICAgICAgICBjaGFubmVsLnB1c2gobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIENIQU5ORUxfQ0xPU0U6IChwLCByZWNpcGllbnQpID0+IHtcbiAgICAgICAgICBsZXQgY2hhbm5lbCA9IHRoaXMuX2NoYW5NZ3IuZ2V0KHJlY2lwaWVudCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9PSAnb2JqZWN0JyB8fCBjaGFubmVsID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgaWYgKGNoYW5uZWwuY29uc3RydWN0b3IgPT09IFNlc3Npb24pIHtcbiAgICAgICAgICAgIGNoYW5uZWwuX2VuZGluZyA9IHRydWU7XG4gICAgICAgICAgICBjaGFubmVsLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgICAgICBjaGFubmVsID0gY2hhbm5lbC5fY2hhbm5lbDtcbiAgICAgICAgICAgIGlmICghY2hhbm5lbClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9uQ0hBTk5FTF9DTE9TRSh0aGlzLCByZWNpcGllbnQsIGNoYW5uZWwpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBCZWdpbiBzZXJ2aWNlL2F1dGgtcmVsYXRlZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgU0VSVklDRV9SRVFVRVNUOiAocCwgc2VydmljZSkgPT4ge1xuICAgICAgICAgIGlmIChleGNoYW5nZXMgPT09IDBcbiAgICAgICAgICAgICAgfHwgYWNjZXB0ZWRBdXRoU3ZjXG4gICAgICAgICAgICAgIHx8IHRoaXMuYXV0aGVudGljYXRlZFxuICAgICAgICAgICAgICB8fCBzZXJ2aWNlICE9PSAnc3NoLXVzZXJhdXRoJykge1xuICAgICAgICAgICAgcHJvdG8uZGlzY29ubmVjdChESVNDT05ORUNUX1JFQVNPTi5TRVJWSUNFX05PVF9BVkFJTEFCTEUpO1xuICAgICAgICAgICAgc29ja2V0LmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFjY2VwdGVkQXV0aFN2YyA9IHRydWU7XG4gICAgICAgICAgcHJvdG8uc2VydmljZUFjY2VwdChzZXJ2aWNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgVVNFUkFVVEhfUkVRVUVTVDogKHAsIHVzZXJuYW1lLCBzZXJ2aWNlLCBtZXRob2QsIG1ldGhvZERhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZXhjaGFuZ2VzID09PSAwXG4gICAgICAgICAgICAgIHx8IHRoaXMuYXV0aGVudGljYXRlZFxuICAgICAgICAgICAgICB8fCAoYXV0aEN0eFxuICAgICAgICAgICAgICAgICAgJiYgKGF1dGhDdHgudXNlcm5hbWUgIT09IHVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgfHwgYXV0aEN0eC5zZXJ2aWNlICE9PSBzZXJ2aWNlKSlcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGhvc3RiYXNlZCBhdXRoXG4gICAgICAgICAgICAgIHx8IChtZXRob2QgIT09ICdwYXNzd29yZCdcbiAgICAgICAgICAgICAgICAgICYmIG1ldGhvZCAhPT0gJ3B1YmxpY2tleSdcbiAgICAgICAgICAgICAgICAgICYmIG1ldGhvZCAhPT0gJ2hvc3RiYXNlZCdcbiAgICAgICAgICAgICAgICAgICYmIG1ldGhvZCAhPT0gJ2tleWJvYXJkLWludGVyYWN0aXZlJ1xuICAgICAgICAgICAgICAgICAgJiYgbWV0aG9kICE9PSAnbm9uZScpXG4gICAgICAgICAgICAgIHx8IHBlbmRpbmdBdXRocy5sZW5ndGggPT09IE1BWF9QRU5ESU5HX0FVVEhTKSB7XG4gICAgICAgICAgICBwcm90by5kaXNjb25uZWN0KERJU0NPTk5FQ1RfUkVBU09OLlBST1RPQ09MX0VSUk9SKTtcbiAgICAgICAgICAgIHNvY2tldC5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZpY2UgIT09ICdzc2gtY29ubmVjdGlvbicpIHtcbiAgICAgICAgICAgIHByb3RvLmRpc2Nvbm5lY3QoRElTQ09OTkVDVF9SRUFTT04uU0VSVklDRV9OT1RfQVZBSUxBQkxFKTtcbiAgICAgICAgICAgIHNvY2tldC5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgY3R4O1xuICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlICdrZXlib2FyZC1pbnRlcmFjdGl2ZSc6XG4gICAgICAgICAgICAgIGN0eCA9IG5ldyBLZXlib2FyZEF1dGhDb250ZXh0KHByb3RvLCB1c2VybmFtZSwgc2VydmljZSwgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2REYXRhLCBvbkF1dGhEZWNpZGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B1YmxpY2tleSc6XG4gICAgICAgICAgICAgIGN0eCA9IG5ldyBQS0F1dGhDb250ZXh0KHByb3RvLCB1c2VybmFtZSwgc2VydmljZSwgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2REYXRhLCBvbkF1dGhEZWNpZGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvc3RiYXNlZCc6XG4gICAgICAgICAgICAgIGN0eCA9IG5ldyBIb3N0YmFzZWRBdXRoQ29udGV4dChwcm90bywgdXNlcm5hbWUsIHNlcnZpY2UsIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZERhdGEsIG9uQXV0aERlY2lkZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgICAgICAgICBpZiAoYXV0aEN0eFxuICAgICAgICAgICAgICAgICAgJiYgYXV0aEN0eCBpbnN0YW5jZW9mIFB3ZEF1dGhDb250ZXh0XG4gICAgICAgICAgICAgICAgICAmJiBhdXRoQ3R4Ll9jaGFuZ2VDYikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gYXV0aEN0eC5fY2hhbmdlQ2I7XG4gICAgICAgICAgICAgICAgYXV0aEN0eC5fY2hhbmdlQ2IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY2IobWV0aG9kRGF0YS5uZXdQYXNzd29yZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN0eCA9IG5ldyBQd2RBdXRoQ29udGV4dChwcm90bywgdXNlcm5hbWUsIHNlcnZpY2UsIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZERhdGEsIG9uQXV0aERlY2lkZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgIGN0eCA9IG5ldyBBdXRoQ29udGV4dChwcm90bywgdXNlcm5hbWUsIHNlcnZpY2UsIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQXV0aERlY2lkZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdXRoQ3R4KSB7XG4gICAgICAgICAgICBpZiAoIWF1dGhDdHguX2luaXRpYWxSZXNwb25zZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcGVuZGluZ0F1dGhzLnB1c2goY3R4KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXV0aEN0eC5fbXVsdGlzdGVwICYmICFhdXRoQ3R4Ll9maW5hbFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIC8vIFJGQyA0MjUyIHNheXMgdG8gc2lsZW50bHkgYWJvcnQgdGhlIGN1cnJlbnQgYXV0aCByZXF1ZXN0IGlmIGFcbiAgICAgICAgICAgICAgLy8gbmV3IGF1dGggcmVxdWVzdCBjb21lcyBpbiBiZWZvcmUgdGhlIGZpbmFsIHJlc3BvbnNlIGZyb20gYW5cbiAgICAgICAgICAgICAgLy8gYXV0aCBtZXRob2QgdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIHJlcXVlc3QvcmVzcG9uc2UgZXhjaGFuZ2VzXG4gICAgICAgICAgICAgIC8vIC0tIHRoaXMgbWVhbnMga2V5Ym9hcmQtaW50ZXJhY3RpdmUgZm9yIG5vdyAuLi5cbiAgICAgICAgICAgICAgYXV0aEN0eC5fY2xlYW51cCAmJiBhdXRoQ3R4Ll9jbGVhbnVwKCk7XG4gICAgICAgICAgICAgIGF1dGhDdHguZW1pdCgnYWJvcnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdXRoQ3R4ID0gY3R4O1xuXG4gICAgICAgICAgaWYgKGxpc3RlbmVyQ291bnQodGhpcywgJ2F1dGhlbnRpY2F0aW9uJykpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2F1dGhlbnRpY2F0aW9uJywgYXV0aEN0eCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXV0aEN0eC5yZWplY3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAgVVNFUkFVVEhfSU5GT19SRVNQT05TRTogKHAsIHJlc3BvbnNlcykgPT4ge1xuICAgICAgICAgIGlmIChhdXRoQ3R4ICYmIGF1dGhDdHggaW5zdGFuY2VvZiBLZXlib2FyZEF1dGhDb250ZXh0KVxuICAgICAgICAgICAgYXV0aEN0eC5fb25JbmZvUmVzcG9uc2UocmVzcG9uc2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5kIHNlcnZpY2UvYXV0aC1yZWxhdGVkID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIEdMT0JBTF9SRVFVRVNUOiAocCwgbmFtZSwgd2FudFJlcGx5LCBkYXRhKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVwbHkgPSB7XG4gICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgYnVmOiBudWxsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHNldFJlcGx5KHR5cGUsIGJ1Zikge1xuICAgICAgICAgICAgcmVwbHkudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICByZXBseS5idWYgPSBidWY7XG4gICAgICAgICAgICBzZW5kUmVwbGllcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3YW50UmVwbHkpXG4gICAgICAgICAgICB1bnNlbnRHbG9iYWxSZXF1ZXN0c1JlcGxpZXMucHVzaChyZXBseSk7XG5cbiAgICAgICAgICBpZiAoKG5hbWUgPT09ICd0Y3BpcC1mb3J3YXJkJ1xuICAgICAgICAgICAgICAgfHwgbmFtZSA9PT0gJ2NhbmNlbC10Y3BpcC1mb3J3YXJkJ1xuICAgICAgICAgICAgICAgfHwgbmFtZSA9PT0gJ25vLW1vcmUtc2Vzc2lvbnNAb3BlbnNzaC5jb20nXG4gICAgICAgICAgICAgICB8fCBuYW1lID09PSAnc3RyZWFtbG9jYWwtZm9yd2FyZEBvcGVuc3NoLmNvbSdcbiAgICAgICAgICAgICAgIHx8IG5hbWUgPT09ICdjYW5jZWwtc3RyZWFtbG9jYWwtZm9yd2FyZEBvcGVuc3NoLmNvbScpXG4gICAgICAgICAgICAgICYmIGxpc3RlbmVyQ291bnQodGhpcywgJ3JlcXVlc3QnKVxuICAgICAgICAgICAgICAmJiB0aGlzLmF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgICAgIGxldCBhY2NlcHQ7XG4gICAgICAgICAgICBsZXQgcmVqZWN0O1xuXG4gICAgICAgICAgICBpZiAod2FudFJlcGx5KSB7XG4gICAgICAgICAgICAgIGxldCByZXBsaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGFjY2VwdCA9IChjaG9zZW5Qb3J0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxpZWQpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgcmVwbGllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZlBvcnQ7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd0Y3BpcC1mb3J3YXJkJ1xuICAgICAgICAgICAgICAgICAgICAmJiBkYXRhLmJpbmRQb3J0ID09PSAwXG4gICAgICAgICAgICAgICAgICAgICYmIHR5cGVvZiBjaG9zZW5Qb3J0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgYnVmUG9ydCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KTtcbiAgICAgICAgICAgICAgICAgIHdyaXRlVUludDMyQkUoYnVmUG9ydCwgY2hvc2VuUG9ydCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFJlcGx5KCdTVUNDRVNTJywgYnVmUG9ydCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJlamVjdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGllZClcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICByZXBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZXRSZXBseSgnRkFJTFVSRScpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ25vLW1vcmUtc2Vzc2lvbnNAb3BlbnNzaC5jb20nKSB7XG4gICAgICAgICAgICAgIHRoaXMubm9Nb3JlU2Vzc2lvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICBhY2NlcHQgJiYgYWNjZXB0KCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgYWNjZXB0LCByZWplY3QsIG5hbWUsIGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2FudFJlcGx5KSB7XG4gICAgICAgICAgICBzZXRSZXBseSgnRkFJTFVSRScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBzb2NrZXQucGF1c2UoKTtcbiAgICBjcnlwdG9Jbml0LnRoZW4oKCkgPT4ge1xuICAgICAgcHJvdG8uc3RhcnQoKTtcbiAgICAgIHNvY2tldC5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvdG8ucGFyc2UoZGF0YSwgMCwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBleCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc1dyaXRhYmxlKHNvY2tldCkpXG4gICAgICAgICAgICAgIHNvY2tldC5lbmQoKTtcbiAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc29ja2V0LnJlc3VtZSgpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzV3JpdGFibGUoc29ja2V0KSlcbiAgICAgICAgICBzb2NrZXQuZW5kKCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfSk7XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIGVyci5sZXZlbCA9ICdzb2NrZXQnO1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSkub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgZGVidWcgJiYgZGVidWcoJ1NvY2tldCBlbmRlZCcpO1xuICAgICAgcHJvdG8uY2xlYW51cCgpO1xuICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICB9KS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGRlYnVnICYmIGRlYnVnKCdTb2NrZXQgY2xvc2VkJyk7XG4gICAgICBwcm90by5jbGVhbnVwKCk7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG5cbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgZnJvbSBzZXJ2ZXInKTtcblxuICAgICAgLy8gU2ltdWxhdGUgZXJyb3IgZm9yIHBlbmRpbmcgY2hhbm5lbHMgYW5kIGNsb3NlIGFueSBvcGVuIGNoYW5uZWxzXG4gICAgICB0aGlzLl9jaGFuTWdyLmNsZWFudXAoZXJyKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uQXV0aERlY2lkZSA9IChjdHgsIGFsbG93ZWQsIG1ldGhvZHNMZWZ0LCBpc1BhcnRpYWwpID0+IHtcbiAgICAgIGlmIChhdXRoQ3R4ID09PSBjdHggJiYgIXRoaXMuYXV0aGVudGljYXRlZCkge1xuICAgICAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgICAgIGF1dGhDdHggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5hdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICBwcm90by5hdXRoU3VjY2VzcygpO1xuICAgICAgICAgIHBlbmRpbmdBdXRocyA9IFtdO1xuICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90by5hdXRoRmFpbHVyZShtZXRob2RzTGVmdCwgaXNQYXJ0aWFsKTtcbiAgICAgICAgICBpZiAocGVuZGluZ0F1dGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXV0aEN0eCA9IHBlbmRpbmdBdXRocy5wb3AoKTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lckNvdW50KHRoaXMsICdhdXRoZW50aWNhdGlvbicpKVxuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2F1dGhlbnRpY2F0aW9uJywgYXV0aEN0eCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGF1dGhDdHgucmVqZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNlbmRSZXBsaWVzKCkge1xuICAgICAgd2hpbGUgKHVuc2VudEdsb2JhbFJlcXVlc3RzUmVwbGllcy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgJiYgdW5zZW50R2xvYmFsUmVxdWVzdHNSZXBsaWVzWzBdLnR5cGUpIHtcbiAgICAgICAgY29uc3QgcmVwbHkgPSB1bnNlbnRHbG9iYWxSZXF1ZXN0c1JlcGxpZXMuc2hpZnQoKTtcbiAgICAgICAgaWYgKHJlcGx5LnR5cGUgPT09ICdTVUNDRVNTJylcbiAgICAgICAgICBwcm90by5yZXF1ZXN0U3VjY2VzcyhyZXBseS5idWYpO1xuICAgICAgICBpZiAocmVwbHkudHlwZSA9PT0gJ0ZBSUxVUkUnKVxuICAgICAgICAgIHByb3RvLnJlcXVlc3RGYWlsdXJlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZW5kKCkge1xuICAgIGlmICh0aGlzLl9zb2NrICYmIGlzV3JpdGFibGUodGhpcy5fc29jaykpIHtcbiAgICAgIHRoaXMuX3Byb3RvY29sLmRpc2Nvbm5lY3QoRElTQ09OTkVDVF9SRUFTT04uQllfQVBQTElDQVRJT04pO1xuICAgICAgdGhpcy5fc29jay5lbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB4MTEob3JpZ2luQWRkciwgb3JpZ2luUG9ydCwgY2IpIHtcbiAgICBjb25zdCBvcHRzID0geyBvcmlnaW5BZGRyLCBvcmlnaW5Qb3J0IH07XG4gICAgb3BlbkNoYW5uZWwodGhpcywgJ3gxMScsIG9wdHMsIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvcndhcmRPdXQoYm91bmRBZGRyLCBib3VuZFBvcnQsIHJlbW90ZUFkZHIsIHJlbW90ZVBvcnQsIGNiKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgYm91bmRBZGRyLCBib3VuZFBvcnQsIHJlbW90ZUFkZHIsIHJlbW90ZVBvcnQgfTtcbiAgICBvcGVuQ2hhbm5lbCh0aGlzLCAnZm9yd2FyZGVkLXRjcGlwJywgb3B0cywgY2IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb3BlbnNzaF9mb3J3YXJkT3V0U3RyZWFtTG9jYWwoc29ja2V0UGF0aCwgY2IpIHtcbiAgICBjb25zdCBvcHRzID0geyBzb2NrZXRQYXRoIH07XG4gICAgb3BlbkNoYW5uZWwodGhpcywgJ2ZvcndhcmRlZC1zdHJlYW1sb2NhbEBvcGVuc3NoLmNvbScsIG9wdHMsIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJla2V5KGNiKSB7XG4gICAgbGV0IGVycm9yO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3Byb3RvY29sLnJla2V5KCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGVycm9yID0gZXg7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmUtdGhyb3cgZXJyb3IgaWYgbm8gY2FsbGJhY2s/XG5cbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZXJyb3IpXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVycm9yKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5vbmNlKCdyZWtleScsIGNiKTtcbiAgICB9XG4gIH1cblxuICBzZXROb0RlbGF5KG5vRGVsYXkpIHtcbiAgICBpZiAodGhpcy5fc29jayAmJiB0eXBlb2YgdGhpcy5fc29jay5zZXROb0RlbGF5ID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5fc29jay5zZXROb0RlbGF5KG5vRGVsYXkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBvcGVuQ2hhbm5lbChzZWxmLCB0eXBlLCBvcHRzLCBjYikge1xuICAvLyBBc2sgdGhlIGNsaWVudCB0byBvcGVuIGEgY2hhbm5lbCBmb3Igc29tZSBwdXJwb3NlIChlLmcuIGEgZm9yd2FyZGVkIFRDUFxuICAvLyBjb25uZWN0aW9uKVxuICBjb25zdCBpbml0V2luZG93ID0gTUFYX1dJTkRPVztcbiAgY29uc3QgbWF4UGFja2V0ID0gUEFDS0VUX1NJWkU7XG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHdyYXBwZXIgPSAoZXJyLCBzdHJlYW0pID0+IHtcbiAgICBjYihlcnIsIHN0cmVhbSk7XG4gIH07XG4gIHdyYXBwZXIudHlwZSA9IHR5cGU7XG5cbiAgY29uc3QgbG9jYWxDaGFuID0gc2VsZi5fY2hhbk1nci5hZGQod3JhcHBlcik7XG5cbiAgaWYgKGxvY2FsQ2hhbiA9PT0gLTEpIHtcbiAgICBjYihuZXcgRXJyb3IoJ05vIGZyZWUgY2hhbm5lbHMgYXZhaWxhYmxlJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2ZvcndhcmRlZC10Y3BpcCc6XG4gICAgICBzZWxmLl9wcm90b2NvbC5mb3J3YXJkZWRUY3BpcChsb2NhbENoYW4sIGluaXRXaW5kb3csIG1heFBhY2tldCwgb3B0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd4MTEnOlxuICAgICAgc2VsZi5fcHJvdG9jb2wueDExKGxvY2FsQ2hhbiwgaW5pdFdpbmRvdywgbWF4UGFja2V0LCBvcHRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZvcndhcmRlZC1zdHJlYW1sb2NhbEBvcGVuc3NoLmNvbSc6XG4gICAgICBzZWxmLl9wcm90b2NvbC5vcGVuc3NoX2ZvcndhcmRlZFN0cmVhbUxvY2FsKFxuICAgICAgICBsb2NhbENoYW4sIGluaXRXaW5kb3csIG1heFBhY2tldCwgb3B0c1xuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNoYW5uZWwgdHlwZTogJHt0eXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZlcjtcbm1vZHVsZS5leHBvcnRzLkluY29taW5nQ2xpZW50ID0gQ2xpZW50O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuICBjcmVhdGVDaXBoZXJpdixcbiAgZ2VuZXJhdGVLZXlQYWlyOiBnZW5lcmF0ZUtleVBhaXJfLFxuICBnZW5lcmF0ZUtleVBhaXJTeW5jOiBnZW5lcmF0ZUtleVBhaXJTeW5jXyxcbiAgZ2V0Q3VydmVzLFxuICByYW5kb21CeXRlcyxcbn0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgeyBCZXIgfSA9IHJlcXVpcmUoJ2FzbjEnKTtcbmNvbnN0IGJjcnlwdF9wYmtkZiA9IHJlcXVpcmUoJ2JjcnlwdC1wYmtkZicpLnBia2RmO1xuXG5jb25zdCB7IENJUEhFUl9JTkZPIH0gPSByZXF1aXJlKCcuL3Byb3RvY29sL2NyeXB0by5qcycpO1xuXG5jb25zdCBTQUxUX0xFTiA9IDE2O1xuY29uc3QgREVGQVVMVF9ST1VORFMgPSAxNjtcblxuY29uc3QgY3VydmVzID0gZ2V0Q3VydmVzKCk7XG5jb25zdCBjaXBoZXJzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhDSVBIRVJfSU5GTykpO1xuXG5mdW5jdGlvbiBtYWtlQXJncyh0eXBlLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2V5IHR5cGUgbXVzdCBiZSBhIHN0cmluZycpO1xuXG4gIGNvbnN0IHB1YmxpY0tleUVuY29kaW5nID0geyB0eXBlOiAnc3BraScsIGZvcm1hdDogJ2RlcicgfTtcbiAgY29uc3QgcHJpdmF0ZUtleUVuY29kaW5nID0geyB0eXBlOiAncGtjczgnLCBmb3JtYXQ6ICdkZXInIH07XG5cbiAgc3dpdGNoICh0eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdyc2EnOiB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8IG9wdHMgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3Npbmcgb3B0aW9ucyBvYmplY3QgZm9yIFJTQSBrZXknKTtcbiAgICAgIGNvbnN0IG1vZHVsdXNMZW5ndGggPSBvcHRzLmJpdHM7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobW9kdWx1c0xlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JTQSBiaXRzIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgaWYgKG1vZHVsdXNMZW5ndGggPD0gMCB8fCBtb2R1bHVzTGVuZ3RoID4gMTYzODQpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdSU0EgYml0cyBtdXN0IGJlIG5vbi16ZXJvIGFuZCA8PSAxNjM4NCcpO1xuICAgICAgcmV0dXJuIFsncnNhJywgeyBtb2R1bHVzTGVuZ3RoLCBwdWJsaWNLZXlFbmNvZGluZywgcHJpdmF0ZUtleUVuY29kaW5nIH1dO1xuICAgIH1cbiAgICBjYXNlICdlY2RzYSc6IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgb3B0cyA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBvcHRpb25zIG9iamVjdCBmb3IgRUNEU0Ega2V5Jyk7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob3B0cy5iaXRzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRUNEU0EgYml0cyBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgIGxldCBuYW1lZEN1cnZlO1xuICAgICAgc3dpdGNoIChvcHRzLmJpdHMpIHtcbiAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgICAgbmFtZWRDdXJ2ZSA9ICdwcmltZTI1NnYxJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODQ6XG4gICAgICAgICAgbmFtZWRDdXJ2ZSA9ICdzZWNwMzg0cjEnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDUyMTpcbiAgICAgICAgICBuYW1lZEN1cnZlID0gJ3NlY3A1MjFyMSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFQ0RTQSBiaXRzIG11c3QgYmUgMjU2LCAzODQsIG9yIDUyMScpO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJ2ZXMuaW5jbHVkZXMobmFtZWRDdXJ2ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgRUNEU0EgYml0cyB2YWx1ZScpO1xuICAgICAgcmV0dXJuIFsnZWMnLCB7IG5hbWVkQ3VydmUsIHB1YmxpY0tleUVuY29kaW5nLCBwcml2YXRlS2V5RW5jb2RpbmcgfV07XG4gICAgfVxuICAgIGNhc2UgJ2VkMjU1MTknOlxuICAgICAgcmV0dXJuIFsnZWQyNTUxOScsIHsgcHVibGljS2V5RW5jb2RpbmcsIHByaXZhdGVLZXlFbmNvZGluZyB9XTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBrZXkgdHlwZTogJHt0eXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlREVScyhrZXlUeXBlLCBwdWIsIHByaXYpIHtcbiAgc3dpdGNoIChrZXlUeXBlKSB7XG4gICAgY2FzZSAncnNhJzoge1xuICAgICAgLy8gTm90ZTogd2UgZG9uJ3QgbmVlZCB0byBwYXJzZSB0aGUgcHVibGljIGtleSBzaW5jZSB0aGUgUEtDUzggcHJpdmF0ZSBrZXlcbiAgICAgIC8vIGFscmVhZHkgaW5jbHVkZXMgdGhlIHB1YmxpYyBrZXkgcGFyYW1ldGVyc1xuXG4gICAgICAvLyBQYXJzZSBwcml2YXRlIGtleVxuICAgICAgbGV0IHJlYWRlciA9IG5ldyBCZXIuUmVhZGVyKHByaXYpO1xuICAgICAgcmVhZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG4gICAgICAvLyAtIFZlcnNpb25cbiAgICAgIGlmIChyZWFkZXIucmVhZEludCgpICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb24gaW4gUlNBIHByaXZhdGUga2V5Jyk7XG5cbiAgICAgIC8vIC0gQWxnb3JpdGhtXG4gICAgICByZWFkZXIucmVhZFNlcXVlbmNlKCk7XG4gICAgICBpZiAocmVhZGVyLnJlYWRPSUQoKSAhPT0gJzEuMi44NDAuMTEzNTQ5LjEuMS4xJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgUlNBIHByaXZhdGUgT0lEJyk7XG4gICAgICAvLyAtIEFsZ29yaXRobSBwYXJhbWV0ZXJzIChSU0EgaGFzIG5vbmUpXG4gICAgICBpZiAocmVhZGVyLnJlYWRCeXRlKCkgIT09IEJlci5OdWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBSU0EgcHJpdmF0ZSBrZXkgKGV4cGVjdGVkIG51bGwpJyk7XG4gICAgICBpZiAocmVhZGVyLnJlYWRCeXRlKCkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdNYWxmb3JtZWQgUlNBIHByaXZhdGUga2V5IChleHBlY3RlZCB6ZXJvLWxlbmd0aCBudWxsKSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmVhZGVyID0gbmV3IEJlci5SZWFkZXIocmVhZGVyLnJlYWRTdHJpbmcoQmVyLk9jdGV0U3RyaW5nLCB0cnVlKSk7XG4gICAgICByZWFkZXIucmVhZFNlcXVlbmNlKCk7XG4gICAgICBpZiAocmVhZGVyLnJlYWRJbnQoKSAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uIGluIFJTQSBwcml2YXRlIGtleScpO1xuICAgICAgY29uc3QgbiA9IHJlYWRlci5yZWFkU3RyaW5nKEJlci5JbnRlZ2VyLCB0cnVlKTtcbiAgICAgIGNvbnN0IGUgPSByZWFkZXIucmVhZFN0cmluZyhCZXIuSW50ZWdlciwgdHJ1ZSk7XG4gICAgICBjb25zdCBkID0gcmVhZGVyLnJlYWRTdHJpbmcoQmVyLkludGVnZXIsIHRydWUpO1xuICAgICAgY29uc3QgcCA9IHJlYWRlci5yZWFkU3RyaW5nKEJlci5JbnRlZ2VyLCB0cnVlKTtcbiAgICAgIGNvbnN0IHEgPSByZWFkZXIucmVhZFN0cmluZyhCZXIuSW50ZWdlciwgdHJ1ZSk7XG4gICAgICByZWFkZXIucmVhZFN0cmluZyhCZXIuSW50ZWdlciwgdHJ1ZSk7IC8vIGRtcDFcbiAgICAgIHJlYWRlci5yZWFkU3RyaW5nKEJlci5JbnRlZ2VyLCB0cnVlKTsgLy8gZG1xMVxuICAgICAgY29uc3QgaXFtcCA9IHJlYWRlci5yZWFkU3RyaW5nKEJlci5JbnRlZ2VyLCB0cnVlKTtcblxuICAgICAgLypcbiAgICAgICAgT3BlblNTSCBSU0EgcHJpdmF0ZSBrZXk6XG4gICAgICAgICAgc3RyaW5nICBcInNzaC1yc2FcIlxuICAgICAgICAgIHN0cmluZyAgbiAtLSBwdWJsaWNcbiAgICAgICAgICBzdHJpbmcgIGUgLS0gcHVibGljXG4gICAgICAgICAgc3RyaW5nICBkIC0tIHByaXZhdGVcbiAgICAgICAgICBzdHJpbmcgIGlxbXAgLS0gcHJpdmF0ZVxuICAgICAgICAgIHN0cmluZyAgcCAtLSBwcml2YXRlXG4gICAgICAgICAgc3RyaW5nICBxIC0tIHByaXZhdGVcbiAgICAgICovXG4gICAgICBjb25zdCBrZXlOYW1lID0gQnVmZmVyLmZyb20oJ3NzaC1yc2EnKTtcbiAgICAgIGNvbnN0IHByaXZCdWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoXG4gICAgICAgIDQgKyBrZXlOYW1lLmxlbmd0aFxuICAgICAgICArIDQgKyBuLmxlbmd0aFxuICAgICAgICArIDQgKyBlLmxlbmd0aFxuICAgICAgICArIDQgKyBkLmxlbmd0aFxuICAgICAgICArIDQgKyBpcW1wLmxlbmd0aFxuICAgICAgICArIDQgKyBwLmxlbmd0aFxuICAgICAgICArIDQgKyBxLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIGxldCBwb3MgPSAwO1xuXG4gICAgICBwcml2QnVmLndyaXRlVUludDMyQkUoa2V5TmFtZS5sZW5ndGgsIHBvcyArPSAwKTtcbiAgICAgIHByaXZCdWYuc2V0KGtleU5hbWUsIHBvcyArPSA0KTtcbiAgICAgIHByaXZCdWYud3JpdGVVSW50MzJCRShuLmxlbmd0aCwgcG9zICs9IGtleU5hbWUubGVuZ3RoKTtcbiAgICAgIHByaXZCdWYuc2V0KG4sIHBvcyArPSA0KTtcbiAgICAgIHByaXZCdWYud3JpdGVVSW50MzJCRShlLmxlbmd0aCwgcG9zICs9IG4ubGVuZ3RoKTtcbiAgICAgIHByaXZCdWYuc2V0KGUsIHBvcyArPSA0KTtcbiAgICAgIHByaXZCdWYud3JpdGVVSW50MzJCRShkLmxlbmd0aCwgcG9zICs9IGUubGVuZ3RoKTtcbiAgICAgIHByaXZCdWYuc2V0KGQsIHBvcyArPSA0KTtcbiAgICAgIHByaXZCdWYud3JpdGVVSW50MzJCRShpcW1wLmxlbmd0aCwgcG9zICs9IGQubGVuZ3RoKTtcbiAgICAgIHByaXZCdWYuc2V0KGlxbXAsIHBvcyArPSA0KTtcbiAgICAgIHByaXZCdWYud3JpdGVVSW50MzJCRShwLmxlbmd0aCwgcG9zICs9IGlxbXAubGVuZ3RoKTtcbiAgICAgIHByaXZCdWYuc2V0KHAsIHBvcyArPSA0KTtcbiAgICAgIHByaXZCdWYud3JpdGVVSW50MzJCRShxLmxlbmd0aCwgcG9zICs9IHAubGVuZ3RoKTtcbiAgICAgIHByaXZCdWYuc2V0KHEsIHBvcyArPSA0KTtcblxuICAgICAgLypcbiAgICAgICAgT3BlblNTSCBSU0EgcHVibGljIGtleTpcbiAgICAgICAgICBzdHJpbmcgIFwic3NoLXJzYVwiXG4gICAgICAgICAgc3RyaW5nICBlIC0tIHB1YmxpY1xuICAgICAgICAgIHN0cmluZyAgbiAtLSBwdWJsaWNcbiAgICAgICovXG4gICAgICBjb25zdCBwdWJCdWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoXG4gICAgICAgIDQgKyBrZXlOYW1lLmxlbmd0aFxuICAgICAgICArIDQgKyBlLmxlbmd0aFxuICAgICAgICArIDQgKyBuLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIHBvcyA9IDA7XG5cbiAgICAgIHB1YkJ1Zi53cml0ZVVJbnQzMkJFKGtleU5hbWUubGVuZ3RoLCBwb3MgKz0gMCk7XG4gICAgICBwdWJCdWYuc2V0KGtleU5hbWUsIHBvcyArPSA0KTtcbiAgICAgIHB1YkJ1Zi53cml0ZVVJbnQzMkJFKGUubGVuZ3RoLCBwb3MgKz0ga2V5TmFtZS5sZW5ndGgpO1xuICAgICAgcHViQnVmLnNldChlLCBwb3MgKz0gNCk7XG4gICAgICBwdWJCdWYud3JpdGVVSW50MzJCRShuLmxlbmd0aCwgcG9zICs9IGUubGVuZ3RoKTtcbiAgICAgIHB1YkJ1Zi5zZXQobiwgcG9zICs9IDQpO1xuXG4gICAgICByZXR1cm4geyBzc2hOYW1lOiBrZXlOYW1lLnRvU3RyaW5nKCksIHByaXY6IHByaXZCdWYsIHB1YjogcHViQnVmIH07XG4gICAgfVxuICAgIGNhc2UgJ2VjJzoge1xuICAgICAgLy8gUGFyc2UgcHVibGljIGtleVxuICAgICAgbGV0IHJlYWRlciA9IG5ldyBCZXIuUmVhZGVyKHB1Yik7XG4gICAgICByZWFkZXIucmVhZFNlcXVlbmNlKCk7XG5cbiAgICAgIHJlYWRlci5yZWFkU2VxdWVuY2UoKTtcbiAgICAgIGlmIChyZWFkZXIucmVhZE9JRCgpICE9PSAnMS4yLjg0MC4xMDA0NS4yLjEnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBFQ0RTQSBwdWJsaWMgT0lEJyk7XG4gICAgICAvLyBTa2lwIGN1cnZlIE9JRCwgd2UnbGwgZ2V0IGl0IGZyb20gdGhlIHByaXZhdGUga2V5XG4gICAgICByZWFkZXIucmVhZE9JRCgpO1xuICAgICAgbGV0IHB1YkJpbiA9IHJlYWRlci5yZWFkU3RyaW5nKEJlci5CaXRTdHJpbmcsIHRydWUpO1xuICAgICAge1xuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvIGJ5dGVzXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBwdWJCaW4ubGVuZ3RoICYmIHB1YkJpbltpXSA9PT0gMHgwMDsgKytpKTtcbiAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgIHB1YkJpbiA9IHB1YkJpbi5zbGljZShpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUGFyc2UgcHJpdmF0ZSBrZXlcbiAgICAgIHJlYWRlciA9IG5ldyBCZXIuUmVhZGVyKHByaXYpO1xuICAgICAgcmVhZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG4gICAgICAvLyAtIFZlcnNpb25cbiAgICAgIGlmIChyZWFkZXIucmVhZEludCgpICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb24gaW4gRUNEU0EgcHJpdmF0ZSBrZXknKTtcblxuICAgICAgcmVhZGVyLnJlYWRTZXF1ZW5jZSgpO1xuICAgICAgaWYgKHJlYWRlci5yZWFkT0lEKCkgIT09ICcxLjIuODQwLjEwMDQ1LjIuMScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIEVDRFNBIHByaXZhdGUgT0lEJyk7XG4gICAgICBjb25zdCBjdXJ2ZU9JRCA9IHJlYWRlci5yZWFkT0lEKCk7XG4gICAgICBsZXQgc3NoQ3VydmVOYW1lO1xuICAgICAgc3dpdGNoIChjdXJ2ZU9JRCkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjMuMS43JzpcbiAgICAgICAgICAvLyBwcmltZTI1NnYxL3NlY3AyNTZyMVxuICAgICAgICAgIHNzaEN1cnZlTmFtZSA9ICduaXN0cDI1Nic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzEuMy4xMzIuMC4zNCc6XG4gICAgICAgICAgLy8gc2VjcDM4NHIxXG4gICAgICAgICAgc3NoQ3VydmVOYW1lID0gJ25pc3RwMzg0JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMS4zLjEzMi4wLjM1JzpcbiAgICAgICAgICAvLyBzZWNwNTIxcjFcbiAgICAgICAgICBzc2hDdXJ2ZU5hbWUgPSAnbmlzdHA1MjEnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY3VydmUgaW4gRUNEU0EgcHJpdmF0ZSBrZXknKTtcbiAgICAgIH1cblxuICAgICAgcmVhZGVyID0gbmV3IEJlci5SZWFkZXIocmVhZGVyLnJlYWRTdHJpbmcoQmVyLk9jdGV0U3RyaW5nLCB0cnVlKSk7XG4gICAgICByZWFkZXIucmVhZFNlcXVlbmNlKCk7XG5cbiAgICAgIC8vIC0gVmVyc2lvblxuICAgICAgaWYgKHJlYWRlci5yZWFkSW50KCkgIT09IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbiBpbiBFQ0RTQSBwcml2YXRlIGtleScpO1xuXG4gICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvIGJ5dGUgdG8gcHJldmVudCBuZWdhdGl2ZSBiaWdudW0gaW4gcHJpdmF0ZSBrZXlcbiAgICAgIGNvbnN0IHByaXZCaW4gPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgQnVmZmVyLmZyb20oWzB4MDBdKSxcbiAgICAgICAgcmVhZGVyLnJlYWRTdHJpbmcoQmVyLk9jdGV0U3RyaW5nLCB0cnVlKVxuICAgICAgXSk7XG5cbiAgICAgIC8qXG4gICAgICAgIE9wZW5TU0ggRUNEU0EgcHJpdmF0ZSBrZXk6XG4gICAgICAgICAgc3RyaW5nICBcImVjZHNhLXNoYTItPHNzaEN1cnZlTmFtZT5cIlxuICAgICAgICAgIHN0cmluZyAgY3VydmUgbmFtZVxuICAgICAgICAgIHN0cmluZyAgUSAtLSBwdWJsaWNcbiAgICAgICAgICBzdHJpbmcgIGQgLS0gcHJpdmF0ZVxuICAgICAgKi9cbiAgICAgIGNvbnN0IGtleU5hbWUgPSBCdWZmZXIuZnJvbShgZWNkc2Etc2hhMi0ke3NzaEN1cnZlTmFtZX1gKTtcbiAgICAgIHNzaEN1cnZlTmFtZSA9IEJ1ZmZlci5mcm9tKHNzaEN1cnZlTmFtZSk7XG4gICAgICBjb25zdCBwcml2QnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgICAgICA0ICsga2V5TmFtZS5sZW5ndGhcbiAgICAgICAgKyA0ICsgc3NoQ3VydmVOYW1lLmxlbmd0aFxuICAgICAgICArIDQgKyBwdWJCaW4ubGVuZ3RoXG4gICAgICAgICsgNCArIHByaXZCaW4ubGVuZ3RoXG4gICAgICApO1xuICAgICAgbGV0IHBvcyA9IDA7XG5cbiAgICAgIHByaXZCdWYud3JpdGVVSW50MzJCRShrZXlOYW1lLmxlbmd0aCwgcG9zICs9IDApO1xuICAgICAgcHJpdkJ1Zi5zZXQoa2V5TmFtZSwgcG9zICs9IDQpO1xuICAgICAgcHJpdkJ1Zi53cml0ZVVJbnQzMkJFKHNzaEN1cnZlTmFtZS5sZW5ndGgsIHBvcyArPSBrZXlOYW1lLmxlbmd0aCk7XG4gICAgICBwcml2QnVmLnNldChzc2hDdXJ2ZU5hbWUsIHBvcyArPSA0KTtcbiAgICAgIHByaXZCdWYud3JpdGVVSW50MzJCRShwdWJCaW4ubGVuZ3RoLCBwb3MgKz0gc3NoQ3VydmVOYW1lLmxlbmd0aCk7XG4gICAgICBwcml2QnVmLnNldChwdWJCaW4sIHBvcyArPSA0KTtcbiAgICAgIHByaXZCdWYud3JpdGVVSW50MzJCRShwcml2QmluLmxlbmd0aCwgcG9zICs9IHB1YkJpbi5sZW5ndGgpO1xuICAgICAgcHJpdkJ1Zi5zZXQocHJpdkJpbiwgcG9zICs9IDQpO1xuXG4gICAgICAvKlxuICAgICAgICBPcGVuU1NIIEVDRFNBIHB1YmxpYyBrZXk6XG4gICAgICAgICAgc3RyaW5nICBcImVjZHNhLXNoYTItPHNzaEN1cnZlTmFtZT5cIlxuICAgICAgICAgIHN0cmluZyAgY3VydmUgbmFtZVxuICAgICAgICAgIHN0cmluZyAgUSAtLSBwdWJsaWNcbiAgICAgICovXG4gICAgICBjb25zdCBwdWJCdWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoXG4gICAgICAgIDQgKyBrZXlOYW1lLmxlbmd0aFxuICAgICAgICArIDQgKyBzc2hDdXJ2ZU5hbWUubGVuZ3RoXG4gICAgICAgICsgNCArIHB1YkJpbi5sZW5ndGhcbiAgICAgICk7XG4gICAgICBwb3MgPSAwO1xuXG4gICAgICBwdWJCdWYud3JpdGVVSW50MzJCRShrZXlOYW1lLmxlbmd0aCwgcG9zICs9IDApO1xuICAgICAgcHViQnVmLnNldChrZXlOYW1lLCBwb3MgKz0gNCk7XG4gICAgICBwdWJCdWYud3JpdGVVSW50MzJCRShzc2hDdXJ2ZU5hbWUubGVuZ3RoLCBwb3MgKz0ga2V5TmFtZS5sZW5ndGgpO1xuICAgICAgcHViQnVmLnNldChzc2hDdXJ2ZU5hbWUsIHBvcyArPSA0KTtcbiAgICAgIHB1YkJ1Zi53cml0ZVVJbnQzMkJFKHB1YkJpbi5sZW5ndGgsIHBvcyArPSBzc2hDdXJ2ZU5hbWUubGVuZ3RoKTtcbiAgICAgIHB1YkJ1Zi5zZXQocHViQmluLCBwb3MgKz0gNCk7XG5cbiAgICAgIHJldHVybiB7IHNzaE5hbWU6IGtleU5hbWUudG9TdHJpbmcoKSwgcHJpdjogcHJpdkJ1ZiwgcHViOiBwdWJCdWYgfTtcbiAgICB9XG4gICAgY2FzZSAnZWQyNTUxOSc6IHtcbiAgICAgIC8vIFBhcnNlIHB1YmxpYyBrZXlcbiAgICAgIGxldCByZWFkZXIgPSBuZXcgQmVyLlJlYWRlcihwdWIpO1xuICAgICAgcmVhZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG4gICAgICAvLyAtIEFsZ29yaXRobVxuICAgICAgcmVhZGVyLnJlYWRTZXF1ZW5jZSgpO1xuICAgICAgaWYgKHJlYWRlci5yZWFkT0lEKCkgIT09ICcxLjMuMTAxLjExMicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIEVEMjU1MTkgcHVibGljIE9JRCcpO1xuICAgICAgLy8gLSBBdHRyaWJ1dGVzIChhYnNlbnQgZm9yIEVEMjU1MTkpXG5cbiAgICAgIGxldCBwdWJCaW4gPSByZWFkZXIucmVhZFN0cmluZyhCZXIuQml0U3RyaW5nLCB0cnVlKTtcbiAgICAgIHtcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVybyBieXRlc1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgcHViQmluLmxlbmd0aCAmJiBwdWJCaW5baV0gPT09IDB4MDA7ICsraSk7XG4gICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICBwdWJCaW4gPSBwdWJCaW4uc2xpY2UoaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhcnNlIHByaXZhdGUga2V5XG4gICAgICByZWFkZXIgPSBuZXcgQmVyLlJlYWRlcihwcml2KTtcbiAgICAgIHJlYWRlci5yZWFkU2VxdWVuY2UoKTtcblxuICAgICAgLy8gLSBWZXJzaW9uXG4gICAgICBpZiAocmVhZGVyLnJlYWRJbnQoKSAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uIGluIEVEMjU1MTkgcHJpdmF0ZSBrZXknKTtcblxuICAgICAgLy8gLSBBbGdvcml0aG1cbiAgICAgIHJlYWRlci5yZWFkU2VxdWVuY2UoKTtcbiAgICAgIGlmIChyZWFkZXIucmVhZE9JRCgpICE9PSAnMS4zLjEwMS4xMTInKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBFRDI1NTE5IHByaXZhdGUgT0lEJyk7XG4gICAgICAvLyAtIEF0dHJpYnV0ZXMgKGFic2VudClcblxuICAgICAgcmVhZGVyID0gbmV3IEJlci5SZWFkZXIocmVhZGVyLnJlYWRTdHJpbmcoQmVyLk9jdGV0U3RyaW5nLCB0cnVlKSk7XG4gICAgICBjb25zdCBwcml2QmluID0gcmVhZGVyLnJlYWRTdHJpbmcoQmVyLk9jdGV0U3RyaW5nLCB0cnVlKTtcblxuICAgICAgLypcbiAgICAgICAgT3BlblNTSCBlZDI1NTE5IHByaXZhdGUga2V5OlxuICAgICAgICAgIHN0cmluZyAgXCJzc2gtZWQyNTUxOVwiXG4gICAgICAgICAgc3RyaW5nICBwdWJsaWMga2V5XG4gICAgICAgICAgc3RyaW5nICBwcml2YXRlIGtleSArIHB1YmxpYyBrZXlcbiAgICAgICovXG4gICAgICBjb25zdCBrZXlOYW1lID0gQnVmZmVyLmZyb20oJ3NzaC1lZDI1NTE5Jyk7XG4gICAgICBjb25zdCBwcml2QnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgICAgICA0ICsga2V5TmFtZS5sZW5ndGhcbiAgICAgICAgKyA0ICsgcHViQmluLmxlbmd0aFxuICAgICAgICArIDQgKyAocHJpdkJpbi5sZW5ndGggKyBwdWJCaW4ubGVuZ3RoKVxuICAgICAgKTtcbiAgICAgIGxldCBwb3MgPSAwO1xuXG4gICAgICBwcml2QnVmLndyaXRlVUludDMyQkUoa2V5TmFtZS5sZW5ndGgsIHBvcyArPSAwKTtcbiAgICAgIHByaXZCdWYuc2V0KGtleU5hbWUsIHBvcyArPSA0KTtcbiAgICAgIHByaXZCdWYud3JpdGVVSW50MzJCRShwdWJCaW4ubGVuZ3RoLCBwb3MgKz0ga2V5TmFtZS5sZW5ndGgpO1xuICAgICAgcHJpdkJ1Zi5zZXQocHViQmluLCBwb3MgKz0gNCk7XG4gICAgICBwcml2QnVmLndyaXRlVUludDMyQkUoXG4gICAgICAgIHByaXZCaW4ubGVuZ3RoICsgcHViQmluLmxlbmd0aCxcbiAgICAgICAgcG9zICs9IHB1YkJpbi5sZW5ndGhcbiAgICAgICk7XG4gICAgICBwcml2QnVmLnNldChwcml2QmluLCBwb3MgKz0gNCk7XG4gICAgICBwcml2QnVmLnNldChwdWJCaW4sIHBvcyArPSBwcml2QmluLmxlbmd0aCk7XG5cbiAgICAgIC8qXG4gICAgICAgIE9wZW5TU0ggZWQyNTUxOSBwdWJsaWMga2V5OlxuICAgICAgICAgIHN0cmluZyAgXCJzc2gtZWQyNTUxOVwiXG4gICAgICAgICAgc3RyaW5nICBwdWJsaWMga2V5XG4gICAgICAqL1xuICAgICAgY29uc3QgcHViQnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgICAgICA0ICsga2V5TmFtZS5sZW5ndGhcbiAgICAgICAgKyA0ICsgcHViQmluLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIHBvcyA9IDA7XG5cbiAgICAgIHB1YkJ1Zi53cml0ZVVJbnQzMkJFKGtleU5hbWUubGVuZ3RoLCBwb3MgKz0gMCk7XG4gICAgICBwdWJCdWYuc2V0KGtleU5hbWUsIHBvcyArPSA0KTtcbiAgICAgIHB1YkJ1Zi53cml0ZVVJbnQzMkJFKHB1YkJpbi5sZW5ndGgsIHBvcyArPSBrZXlOYW1lLmxlbmd0aCk7XG4gICAgICBwdWJCdWYuc2V0KHB1YkJpbiwgcG9zICs9IDQpO1xuXG4gICAgICByZXR1cm4geyBzc2hOYW1lOiBrZXlOYW1lLnRvU3RyaW5nKCksIHByaXY6IHByaXZCdWYsIHB1YjogcHViQnVmIH07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRLZXlzKGtleVR5cGUsIHB1YiwgcHJpdiwgb3B0cykge1xuICBsZXQgZm9ybWF0ID0gJ25ldyc7XG4gIGxldCBlbmNyeXB0ZWQ7XG4gIGxldCBjb21tZW50ID0gJyc7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgb3B0cyAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2Ygb3B0cy5jb21tZW50ID09PSAnc3RyaW5nJyAmJiBvcHRzLmNvbW1lbnQpXG4gICAgICBjb21tZW50ID0gb3B0cy5jb21tZW50O1xuICAgIGlmICh0eXBlb2Ygb3B0cy5mb3JtYXQgPT09ICdzdHJpbmcnICYmIG9wdHMuZm9ybWF0KVxuICAgICAgZm9ybWF0ID0gb3B0cy5mb3JtYXQ7XG4gICAgaWYgKG9wdHMucGFzc3BocmFzZSkge1xuICAgICAgbGV0IHBhc3NwaHJhc2U7XG4gICAgICBpZiAodHlwZW9mIG9wdHMucGFzc3BocmFzZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHBhc3NwaHJhc2UgPSBCdWZmZXIuZnJvbShvcHRzLnBhc3NwaHJhc2UpO1xuICAgICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG9wdHMucGFzc3BocmFzZSkpXG4gICAgICAgIHBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXNzcGhyYXNlJyk7XG5cbiAgICAgIGlmIChvcHRzLmNpcGhlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2lwaGVyIG5hbWUnKTtcbiAgICAgIGNvbnN0IGNpcGhlciA9IGNpcGhlcnMuZ2V0KG9wdHMuY2lwaGVyKTtcbiAgICAgIGlmIChjaXBoZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNpcGhlciBuYW1lJyk7XG5cbiAgICAgIGlmIChmb3JtYXQgPT09ICduZXcnKSB7XG4gICAgICAgIGxldCByb3VuZHMgPSBERUZBVUxUX1JPVU5EUztcbiAgICAgICAgaWYgKG9wdHMucm91bmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob3B0cy5yb3VuZHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncm91bmRzIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgICAgIGlmIChvcHRzLnJvdW5kcyA+IDApXG4gICAgICAgICAgICByb3VuZHMgPSBvcHRzLnJvdW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdlbiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShjaXBoZXIua2V5TGVuICsgY2lwaGVyLml2TGVuKTtcbiAgICAgICAgY29uc3Qgc2FsdCA9IHJhbmRvbUJ5dGVzKFNBTFRfTEVOKTtcbiAgICAgICAgY29uc3QgciA9IGJjcnlwdF9wYmtkZihcbiAgICAgICAgICBwYXNzcGhyYXNlLFxuICAgICAgICAgIHBhc3NwaHJhc2UubGVuZ3RoLFxuICAgICAgICAgIHNhbHQsXG4gICAgICAgICAgc2FsdC5sZW5ndGgsXG4gICAgICAgICAgZ2VuLFxuICAgICAgICAgIGdlbi5sZW5ndGgsXG4gICAgICAgICAgcm91bmRzXG4gICAgICAgICk7XG4gICAgICAgIGlmIChyICE9PSAwKVxuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSBpbmZvcm1hdGlvbiB0byBlbmNyeXB0IGtleScpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgc3RyaW5nIHNhbHRcbiAgICAgICAgICB1aW50MzIgcm91bmRzXG4gICAgICAgICovXG4gICAgICAgIGNvbnN0IGtkZk9wdGlvbnMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCArIHNhbHQubGVuZ3RoICsgNCk7XG4gICAgICAgIHtcbiAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICBrZGZPcHRpb25zLndyaXRlVUludDMyQkUoc2FsdC5sZW5ndGgsIHBvcyArPSAwKTtcbiAgICAgICAgICBrZGZPcHRpb25zLnNldChzYWx0LCBwb3MgKz0gNCk7XG4gICAgICAgICAga2RmT3B0aW9ucy53cml0ZVVJbnQzMkJFKHJvdW5kcywgcG9zICs9IHNhbHQubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuY3J5cHRlZCA9IHtcbiAgICAgICAgICBjaXBoZXIsXG4gICAgICAgICAgY2lwaGVyTmFtZTogb3B0cy5jaXBoZXIsXG4gICAgICAgICAga2RmTmFtZTogJ2JjcnlwdCcsXG4gICAgICAgICAga2RmT3B0aW9ucyxcbiAgICAgICAgICBrZXk6IGdlbi5zbGljZSgwLCBjaXBoZXIua2V5TGVuKSxcbiAgICAgICAgICBpdjogZ2VuLnNsaWNlKGNpcGhlci5rZXlMZW4pLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSAnbmV3Jzoge1xuICAgICAgbGV0IHByaXZhdGVCNjQgPSAnLS0tLS1CRUdJTiBPUEVOU1NIIFBSSVZBVEUgS0VZLS0tLS1cXG4nO1xuICAgICAgbGV0IHB1YmxpY0I2NDtcbiAgICAgIC8qXG4gICAgICAgIGJ5dGVbXSAgXCJvcGVuc3NoLWtleS12MVxcMFwiXG4gICAgICAgIHN0cmluZyAgY2lwaGVybmFtZVxuICAgICAgICBzdHJpbmcgIGtkZm5hbWVcbiAgICAgICAgc3RyaW5nICBrZGZvcHRpb25zXG4gICAgICAgIHVpbnQzMiAgbnVtYmVyIG9mIGtleXMgTlxuICAgICAgICBzdHJpbmcgIHB1YmxpY2tleTFcbiAgICAgICAgc3RyaW5nICBlbmNyeXB0ZWQsIHBhZGRlZCBsaXN0IG9mIHByaXZhdGUga2V5c1xuICAgICAgICAgIHVpbnQzMiAgY2hlY2tpbnRcbiAgICAgICAgICB1aW50MzIgIGNoZWNraW50XG4gICAgICAgICAgYnl0ZVtdICBwcml2YXRla2V5MVxuICAgICAgICAgIHN0cmluZyAgY29tbWVudDFcbiAgICAgICAgICBieXRlICAxXG4gICAgICAgICAgYnl0ZSAgMlxuICAgICAgICAgIGJ5dGUgIDNcbiAgICAgICAgICAuLi5cbiAgICAgICAgICBieXRlICBwYWRsZW4gJSAyNTVcbiAgICAgICovXG4gICAgICBjb25zdCBjaXBoZXJOYW1lID0gQnVmZmVyLmZyb20oZW5jcnlwdGVkID8gZW5jcnlwdGVkLmNpcGhlck5hbWUgOiAnbm9uZScpO1xuICAgICAgY29uc3Qga2RmTmFtZSA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZCA/IGVuY3J5cHRlZC5rZGZOYW1lIDogJ25vbmUnKTtcbiAgICAgIGNvbnN0IGtkZk9wdGlvbnMgPSAoZW5jcnlwdGVkID8gZW5jcnlwdGVkLmtkZk9wdGlvbnMgOiBCdWZmZXIuYWxsb2MoMCkpO1xuICAgICAgY29uc3QgYmxvY2tMZW4gPSAoZW5jcnlwdGVkID8gZW5jcnlwdGVkLmNpcGhlci5ibG9ja0xlbiA6IDgpO1xuXG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZURFUnMoa2V5VHlwZSwgcHViLCBwcml2KTtcblxuICAgICAgY29uc3QgY2hlY2tJbnQgPSByYW5kb21CeXRlcyg0KTtcbiAgICAgIGNvbnN0IGNvbW1lbnRCaW4gPSBCdWZmZXIuZnJvbShjb21tZW50KTtcbiAgICAgIGNvbnN0IHByaXZCbG9iTGVuID0gKDQgKyA0ICsgcGFyc2VkLnByaXYubGVuZ3RoICsgNCArIGNvbW1lbnRCaW4ubGVuZ3RoKTtcbiAgICAgIGxldCBwYWRkaW5nID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMTsgKChwcml2QmxvYkxlbiArIHBhZGRpbmcubGVuZ3RoKSAlIGJsb2NrTGVuKTsgKytpKVxuICAgICAgICBwYWRkaW5nLnB1c2goaSAmIDB4RkYpO1xuICAgICAgcGFkZGluZyA9IEJ1ZmZlci5mcm9tKHBhZGRpbmcpO1xuXG4gICAgICBsZXQgcHJpdkJsb2IgPSBCdWZmZXIuYWxsb2NVbnNhZmUocHJpdkJsb2JMZW4gKyBwYWRkaW5nLmxlbmd0aCk7XG4gICAgICBsZXQgZXh0cmE7XG4gICAgICB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBwcml2QmxvYi5zZXQoY2hlY2tJbnQsIHBvcyArPSAwKTtcbiAgICAgICAgcHJpdkJsb2Iuc2V0KGNoZWNrSW50LCBwb3MgKz0gNCk7XG4gICAgICAgIHByaXZCbG9iLnNldChwYXJzZWQucHJpdiwgcG9zICs9IDQpO1xuICAgICAgICBwcml2QmxvYi53cml0ZVVJbnQzMkJFKGNvbW1lbnRCaW4ubGVuZ3RoLCBwb3MgKz0gcGFyc2VkLnByaXYubGVuZ3RoKTtcbiAgICAgICAgcHJpdkJsb2Iuc2V0KGNvbW1lbnRCaW4sIHBvcyArPSA0KTtcbiAgICAgICAgcHJpdkJsb2Iuc2V0KHBhZGRpbmcsIHBvcyArPSBjb21tZW50QmluLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmNyeXB0ZWQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgYXV0aFRhZ0xlbmd0aDogZW5jcnlwdGVkLmNpcGhlci5hdXRoTGVuIH07XG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyZWF0ZUNpcGhlcml2KFxuICAgICAgICAgIGVuY3J5cHRlZC5jaXBoZXIuc3NsTmFtZSxcbiAgICAgICAgICBlbmNyeXB0ZWQua2V5LFxuICAgICAgICAgIGVuY3J5cHRlZC5pdixcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIGNpcGhlci5zZXRBdXRvUGFkZGluZyhmYWxzZSk7XG4gICAgICAgIHByaXZCbG9iID0gQnVmZmVyLmNvbmNhdChbIGNpcGhlci51cGRhdGUocHJpdkJsb2IpLCBjaXBoZXIuZmluYWwoKSBdKTtcbiAgICAgICAgaWYgKGVuY3J5cHRlZC5jaXBoZXIuYXV0aExlbiA+IDApXG4gICAgICAgICAgZXh0cmEgPSBjaXBoZXIuZ2V0QXV0aFRhZygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZXh0cmEgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIGVuY3J5cHRlZC5rZXkuZmlsbCgwKTtcbiAgICAgICAgZW5jcnlwdGVkLml2LmZpbGwoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRyYSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWFnaWNCeXRlcyA9IEJ1ZmZlci5mcm9tKCdvcGVuc3NoLWtleS12MVxcMCcpO1xuICAgICAgY29uc3QgcHJpdkJpbiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShcbiAgICAgICAgbWFnaWNCeXRlcy5sZW5ndGhcbiAgICAgICAgICArIDQgKyBjaXBoZXJOYW1lLmxlbmd0aFxuICAgICAgICAgICsgNCArIGtkZk5hbWUubGVuZ3RoXG4gICAgICAgICAgKyA0ICsga2RmT3B0aW9ucy5sZW5ndGhcbiAgICAgICAgICArIDRcbiAgICAgICAgICArIDQgKyBwYXJzZWQucHViLmxlbmd0aFxuICAgICAgICAgICsgNCArIHByaXZCbG9iLmxlbmd0aFxuICAgICAgICAgICsgZXh0cmEubGVuZ3RoXG4gICAgICApO1xuICAgICAge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgcHJpdkJpbi5zZXQobWFnaWNCeXRlcywgcG9zICs9IDApO1xuICAgICAgICBwcml2QmluLndyaXRlVUludDMyQkUoY2lwaGVyTmFtZS5sZW5ndGgsIHBvcyArPSBtYWdpY0J5dGVzLmxlbmd0aCk7XG4gICAgICAgIHByaXZCaW4uc2V0KGNpcGhlck5hbWUsIHBvcyArPSA0KTtcbiAgICAgICAgcHJpdkJpbi53cml0ZVVJbnQzMkJFKGtkZk5hbWUubGVuZ3RoLCBwb3MgKz0gY2lwaGVyTmFtZS5sZW5ndGgpO1xuICAgICAgICBwcml2QmluLnNldChrZGZOYW1lLCBwb3MgKz0gNCk7XG4gICAgICAgIHByaXZCaW4ud3JpdGVVSW50MzJCRShrZGZPcHRpb25zLmxlbmd0aCwgcG9zICs9IGtkZk5hbWUubGVuZ3RoKTtcbiAgICAgICAgcHJpdkJpbi5zZXQoa2RmT3B0aW9ucywgcG9zICs9IDQpO1xuICAgICAgICBwcml2QmluLndyaXRlVUludDMyQkUoMSwgcG9zICs9IGtkZk9wdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgcHJpdkJpbi53cml0ZVVJbnQzMkJFKHBhcnNlZC5wdWIubGVuZ3RoLCBwb3MgKz0gNCk7XG4gICAgICAgIHByaXZCaW4uc2V0KHBhcnNlZC5wdWIsIHBvcyArPSA0KTtcbiAgICAgICAgcHJpdkJpbi53cml0ZVVJbnQzMkJFKHByaXZCbG9iLmxlbmd0aCwgcG9zICs9IHBhcnNlZC5wdWIubGVuZ3RoKTtcbiAgICAgICAgcHJpdkJpbi5zZXQocHJpdkJsb2IsIHBvcyArPSA0KTtcbiAgICAgICAgcHJpdkJpbi5zZXQoZXh0cmEsIHBvcyArPSBwcml2QmxvYi5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGNvbnN0IGI2NCA9IHByaXZCaW4uYmFzZTY0U2xpY2UoMCwgcHJpdkJpbi5sZW5ndGgpO1xuICAgICAgICBsZXQgZm9ybWF0dGVkID0gYjY0LnJlcGxhY2UoLy57NjR9L2csICckJlxcbicpO1xuICAgICAgICBpZiAoYjY0Lmxlbmd0aCAmIDYzKVxuICAgICAgICAgIGZvcm1hdHRlZCArPSAnXFxuJztcbiAgICAgICAgcHJpdmF0ZUI2NCArPSBmb3JtYXR0ZWQ7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgY29uc3QgYjY0ID0gcGFyc2VkLnB1Yi5iYXNlNjRTbGljZSgwLCBwYXJzZWQucHViLmxlbmd0aCk7XG4gICAgICAgIHB1YmxpY0I2NCA9IGAke3BhcnNlZC5zc2hOYW1lfSAke2I2NH0ke2NvbW1lbnQgPyBgICR7Y29tbWVudH1gIDogJyd9YDtcbiAgICAgIH1cblxuICAgICAgcHJpdmF0ZUI2NCArPSAnLS0tLS1FTkQgT1BFTlNTSCBQUklWQVRFIEtFWS0tLS0tXFxuJztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByaXZhdGU6IHByaXZhdGVCNjQsXG4gICAgICAgIHB1YmxpYzogcHVibGljQjY0LFxuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvdXRwdXQga2V5IGZvcm1hdCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2VuZXJhdGVLZXlQYWlyOiAoa2V5VHlwZSwgb3B0cywgY2IpID0+IHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0cztcbiAgICAgIG9wdHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG5vb3A7XG4gICAgY29uc3QgYXJncyA9IG1ha2VBcmdzKGtleVR5cGUsIG9wdHMpO1xuICAgIGdlbmVyYXRlS2V5UGFpcl8oLi4uYXJncywgKGVyciwgcHViLCBwcml2KSA9PiB7XG4gICAgICBpZiAoZXJyKVxuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgIGxldCByZXQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBjb252ZXJ0S2V5cyhhcmdzWzBdLCBwdWIsIHByaXYsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIGNiKGV4KTtcbiAgICAgIH1cbiAgICAgIGNiKG51bGwsIHJldCk7XG4gICAgfSk7XG4gIH0sXG4gIGdlbmVyYXRlS2V5UGFpclN5bmM6IChrZXlUeXBlLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgYXJncyA9IG1ha2VBcmdzKGtleVR5cGUsIG9wdHMpO1xuICAgIGNvbnN0IHsgcHVibGljS2V5OiBwdWIsIHByaXZhdGVLZXk6IHByaXYgfSA9IGdlbmVyYXRlS2V5UGFpclN5bmNfKC4uLmFyZ3MpO1xuICAgIHJldHVybiBjb252ZXJ0S2V5cyhhcmdzWzBdLCBwdWIsIHByaXYsIG9wdHMpO1xuICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuICBBZ2VudFByb3RvY29sLFxuICBCYXNlQWdlbnQsXG4gIGNyZWF0ZUFnZW50LFxuICBDeWd3aW5BZ2VudCxcbiAgT3BlblNTSEFnZW50LFxuICBQYWdlYW50QWdlbnQsXG59ID0gcmVxdWlyZSgnLi9hZ2VudC5qcycpO1xuY29uc3Qge1xuICBTU0hUVFBBZ2VudDogSFRUUEFnZW50LFxuICBTU0hUVFBTQWdlbnQ6IEhUVFBTQWdlbnQsXG59ID0gcmVxdWlyZSgnLi9odHRwLWFnZW50cy5qcycpO1xuY29uc3QgeyBwYXJzZUtleSB9ID0gcmVxdWlyZSgnLi9wcm90b2NvbC9rZXlQYXJzZXIuanMnKTtcbmNvbnN0IHtcbiAgZmxhZ3NUb1N0cmluZyxcbiAgT1BFTl9NT0RFLFxuICBTVEFUVVNfQ09ERSxcbiAgc3RyaW5nVG9GbGFncyxcbn0gPSByZXF1aXJlKCcuL3Byb3RvY29sL1NGVFAuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFnZW50UHJvdG9jb2wsXG4gIEJhc2VBZ2VudCxcbiAgY3JlYXRlQWdlbnQsXG4gIENsaWVudDogcmVxdWlyZSgnLi9jbGllbnQuanMnKSxcbiAgQ3lnd2luQWdlbnQsXG4gIEhUVFBBZ2VudCxcbiAgSFRUUFNBZ2VudCxcbiAgT3BlblNTSEFnZW50LFxuICBQYWdlYW50QWdlbnQsXG4gIFNlcnZlcjogcmVxdWlyZSgnLi9zZXJ2ZXIuanMnKSxcbiAgdXRpbHM6IHtcbiAgICBwYXJzZUtleSxcbiAgICAuLi5yZXF1aXJlKCcuL2tleWdlbi5qcycpLFxuICAgIHNmdHA6IHtcbiAgICAgIGZsYWdzVG9TdHJpbmcsXG4gICAgICBPUEVOX01PREUsXG4gICAgICBTVEFUVVNfQ09ERSxcbiAgICAgIHN0cmluZ1RvRmxhZ3MsXG4gICAgfSxcbiAgfSxcbn07XG4iLCAibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J1ZmZlcicpLFxuICBCdWZmZXIgPSBfcmVxdWlyZS5CdWZmZXI7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbCcpLFxuICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoc3JjLCB0YXJnZXQsIG9mZnNldCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihzKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAocCkge1xuICAgICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICB9LCB7XG4gICAga2V5OiBcImNvbnN1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShuLCBoYXNTdHJpbmdzKSB7XG4gICAgICB2YXIgcmV0O1xuICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuaGVhZC5kYXRhID0gdGhpcy5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgICAgIG4gLT0gbmI7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgKytjO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QnVmZmVyKG4pIHtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHAuZGF0YS5jb3B5KHJldCk7XG4gICAgICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgICAgIG4gLT0gbmI7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgKytjO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cbiAgfSwge1xuICAgIGtleTogY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiLCAiJ3VzZSBzdHJpY3QnO1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwgIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjb2RlcyA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5vZGVFcnJvciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgcmV0dXJuIF9CYXNlLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUVycm9yO1xuICB9KEJhc2UpO1xuXG4gIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IEJhc2UubmFtZTtcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZTtcbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX09QVF9WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gJ1RoZSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCInICsgbmFtZSArICdcIic7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9XG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2YgYWN0dWFsKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YnLCAnc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ1RoZSAnICsgbmFtZSArICcgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnLCAnUHJlbWF0dXJlIGNsb3NlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fREVTVFJPWUVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdDYW5ub3QgY2FsbCAnICsgbmFtZSArICcgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0NBTk5PVF9QSVBFJywgJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fTlVMTF9WQUxVRVMnLCAnTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfVU5LTk9XTl9FTkNPRElORycsIGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuICdVbmtub3duIGVuY29kaW5nOiAnICsgYXJnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCcsICdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlcztcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfSU5WQUxJRF9PUFRfVkFMVUUgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfSU5WQUxJRF9PUFRfVkFMVUU7XG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpO1xuICBpZiAoaHdtICE9IG51bGwpIHtcbiAgICBpZiAoIShpc0Zpbml0ZShod20pICYmIE1hdGguZmxvb3IoaHdtKSA9PT0gaHdtKSB8fCBod20gPCAwKSB7XG4gICAgICB2YXIgbmFtZSA9IGlzRHVwbGV4ID8gZHVwbGV4S2V5IDogJ2hpZ2hXYXRlck1hcmsnO1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX09QVF9WQUxVRShuYW1lLCBod20pO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB2YWx1ZVxuICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEhpZ2hXYXRlck1hcms6IGdldEhpZ2hXYXRlck1hcmtcbn07IiwgImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsICJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCAiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5mdW5jdGlvbiBub3AoKSB7fVxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlO1xuXG4gIC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95O1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cblxuICAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCAiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsICIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7XG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHt9XG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCBvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGU7XG4gIHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgb3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlO1xuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgIHdyaXRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gIH07XG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICB9O1xuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBlb3M7IiwgIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xudmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgnbGFzdFJlc29sdmUnKTtcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xudmFyIGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbnZhciBrRW5kZWQgPSBTeW1ib2woJ2VuZGVkJyk7XG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xudmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKCdoYW5kbGVQcm9taXNlJyk7XG52YXIga1N0cmVhbSA9IFN5bWJvbCgnc3RyZWFtJyk7XG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG4gIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTtcbiAgICAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xuICAgIH0sIHJlamVjdCk7XG4gIH07XG59XG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBpZiB3ZSBoYXZlIGRldGVjdGVkIGFuIGVycm9yIGluIHRoZSBtZWFud2hpbGVcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxuICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcbiAgICAgIC8vIGNhbGxlZCwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCB2aWEgbmV4dFRpY2ssIGFuZFxuICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG5vIGVycm9yIGxpbmdlcmluZyBhcm91bmRcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICByZWplY3QoX3RoaXNba0Vycm9yXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xuICAgIH1cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9KTtcbiAgfSk7XG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX09iamVjdCRjcmVhdGUpKTtcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07XG4gICAgICAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cbiAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTtcbiAgfSk7XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlLmJpbmQobnVsbCwgaXRlcmF0b3IpKTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsICJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZS5mcm9tIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXInKVxufTtcbiIsICIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fSkuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZztcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7XG5cbi8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXG4gIC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlO1xuXG4gIC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95O1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyO1xuICAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn07XG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgICAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG5cbiAgICAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0aGlzO1xufTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7XG5cbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCAiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gIEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HLFxuICBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzA7XG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xucmVxdWlyZSgnaW5oZXJpdHMnKShUcmFuc2Zvcm0sIER1cGxleCk7XG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG4gIGlmIChkYXRhICE9IG51bGwpXG4gICAgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIGlmIChkYXRhICE9IG51bGwpXG4gICAgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wKCk7XG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcoKTtcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsICIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5yZXF1aXJlKCdpbmhlcml0cycpKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCAiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlb3M7XG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2RlcyxcbiAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1MsXG4gIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XG5mdW5jdGlvbiBub29wKGVycikge1xuICAvLyBSZXRocm93IHRoZSBlcnJvciBpZiBpdCBleGlzdHMgdG8gYXZvaWQgc3dhbGxvd2luZyBpdFxuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChlb3MgPT09IHVuZGVmaW5lZCkgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICB3cml0YWJsZTogd3JpdGluZ1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgIC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCk7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm4oKTtcbn1cbmZ1bmN0aW9uIHBpcGUoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0byk7XG59XG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XG4gIGlmICghc3RyZWFtcy5sZW5ndGgpIHJldHVybiBub29wO1xuICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5vb3A7XG4gIHJldHVybiBzdHJlYW1zLnBvcCgpO1xufVxuZnVuY3Rpb24gcGlwZWxpbmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXTtcbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJyk7XG4gIH1cbiAgdmFyIGVycm9yO1xuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgIHZhciB3cml0aW5nID0gaSA+IDA7XG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZTsiLCAiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbmV4cG9ydHMuZmluaXNoZWQgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMnKTtcbmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJyk7XG4iLCAiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbnZhciBpc01vZGVybiA9IChcbiAgdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuKVxuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChpbnB1dCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpbnB1dCkuc2xpY2UoOCwgLTEpID09PSAnQXJyYXlCdWZmZXInXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAob2JqLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYnl0ZU9mZnNldCA+Pj49IDBcblxuICB2YXIgbWF4TGVuZ3RoID0gb2JqLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0XG5cbiAgaWYgKG1heExlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidvZmZzZXQnIGlzIG91dCBvZiBib3VuZHNcIilcbiAgfVxuXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IG1heExlbmd0aFxuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA+Pj49IDBcblxuICAgIGlmIChsZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2xlbmd0aCcgaXMgb3V0IG9mIGJvdW5kc1wiKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc01vZGVyblxuICAgID8gQnVmZmVyLmZyb20ob2JqLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBsZW5ndGgpKVxuICAgIDogbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShvYmouc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGxlbmd0aCkpKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHJldHVybiBpc01vZGVyblxuICAgID8gQnVmZmVyLmZyb20oc3RyaW5nLCBlbmNvZGluZylcbiAgICA6IG5ldyBCdWZmZXIoc3RyaW5nLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYnVmZmVyRnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGlzTW9kZXJuXG4gICAgPyBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICA6IG5ldyBCdWZmZXIodmFsdWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVmZmVyRnJvbVxuIiwgInZhciB1bmRlZmluZWQgPSAodm9pZCAwKTsgLy8gUGFyYW5vaWFcblxuLy8gQmV5b25kIHRoaXMgdmFsdWUsIGluZGV4IGdldHRlcnMvc2V0dGVycyAoaS5lLiBhcnJheVswXSwgYXJyYXlbMV0pIGFyZSBzbyBzbG93IHRvXG4vLyBjcmVhdGUsIGFuZCBjb25zdW1lIHNvIG11Y2ggbWVtb3J5LCB0aGF0IHRoZSBicm93c2VyIGFwcGVhcnMgZnJvemVuLlxudmFyIE1BWF9BUlJBWV9MRU5HVEggPSAxZTU7XG5cbi8vIEFwcHJveGltYXRpb25zIG9mIGludGVybmFsIEVDTUFTY3JpcHQgY29udmVyc2lvbiBmdW5jdGlvbnNcbnZhciBFQ01BU2NyaXB0ID0gKGZ1bmN0aW9uKCkge1xuICAvLyBTdGFzaCBhIGNvcHkgaW4gY2FzZSBvdGhlciBzY3JpcHRzIG1vZGlmeSB0aGVzZVxuICB2YXIgb3B0cyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICBvcGhvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBDbGFzcyByZXR1cm5zIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSwgdXNlZCB0byBhdm9pZCBjcm9zcy1mcmFtZSBpbnN0YW5jZW9mIGlzc3VlczpcbiAgICBDbGFzczogZnVuY3Rpb24odikgeyByZXR1cm4gb3B0cy5jYWxsKHYpLnJlcGxhY2UoL15cXFtvYmplY3QgKnxcXF0kL2csICcnKTsgfSxcbiAgICBIYXNQcm9wZXJ0eTogZnVuY3Rpb24obywgcCkgeyByZXR1cm4gcCBpbiBvOyB9LFxuICAgIEhhc093blByb3BlcnR5OiBmdW5jdGlvbihvLCBwKSB7IHJldHVybiBvcGhvcC5jYWxsKG8sIHApOyB9LFxuICAgIElzQ2FsbGFibGU6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIHR5cGVvZiBvID09PSAnZnVuY3Rpb24nOyB9LFxuICAgIFRvSW50MzI6IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgPj4gMDsgfSxcbiAgICBUb1VpbnQzMjogZnVuY3Rpb24odikgeyByZXR1cm4gdiA+Pj4gMDsgfVxuICB9O1xufSgpKTtcblxuLy8gU25hcHNob3QgaW50cmluc2ljc1xudmFyIExOMiA9IE1hdGguTE4yLFxuICAgIGFicyA9IE1hdGguYWJzLFxuICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICBsb2cgPSBNYXRoLmxvZyxcbiAgICBtaW4gPSBNYXRoLm1pbixcbiAgICBwb3cgPSBNYXRoLnBvdyxcbiAgICByb3VuZCA9IE1hdGgucm91bmQ7XG5cbi8vIEVTNTogbG9jayBkb3duIG9iamVjdCBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBjb25maWd1cmVQcm9wZXJ0aWVzKG9iaikge1xuICBpZiAoZ2V0T3duUHJvcE5hbWVzICYmIGRlZmluZVByb3ApIHtcbiAgICB2YXIgcHJvcHMgPSBnZXRPd25Qcm9wTmFtZXMob2JqKSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGRlZmluZVByb3Aob2JqLCBwcm9wc1tpXSwge1xuICAgICAgICB2YWx1ZTogb2JqW3Byb3BzW2ldXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIGVtdWxhdGUgRVM1IGdldHRlci9zZXR0ZXIgQVBJIHVzaW5nIGxlZ2FjeSBBUElzXG4vLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZS9hcmNoaXZlLzIwMTAvMDkvMDcvdHJhbnNpdGlvbmluZy1leGlzdGluZy1jb2RlLXRvLXRoZS1lczUtZ2V0dGVyLXNldHRlci1hcGlzLmFzcHhcbi8vIChzZWNvbmQgY2xhdXNlIHRlc3RzIGZvciBPYmplY3QuZGVmaW5lUHJvcGVydHkoKSBpbiBJRTw5IHRoYXQgb25seSBzdXBwb3J0cyBleHRlbmRpbmcgRE9NIHByb3RvdHlwZXMsIGJ1dFxuLy8gbm90ZSB0aGF0IElFPDkgZG9lcyBub3Qgc3VwcG9ydCBfX2RlZmluZUdldHRlcl9fIG9yIF9fZGVmaW5lU2V0dGVyX18gc28gaXQganVzdCByZW5kZXJzIHRoZSBtZXRob2QgaGFybWxlc3MpXG52YXIgZGVmaW5lUHJvcFxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pKCkpIHtcbiAgZGVmaW5lUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbn0gZWxzZSB7XG4gIGRlZmluZVByb3AgPSBmdW5jdGlvbihvLCBwLCBkZXNjKSB7XG4gICAgaWYgKCFvID09PSBPYmplY3QobykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbGVkIG9uIG5vbi1vYmplY3RcIik7XG4gICAgaWYgKEVDTUFTY3JpcHQuSGFzUHJvcGVydHkoZGVzYywgJ2dldCcpICYmIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXykgeyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18uY2FsbChvLCBwLCBkZXNjLmdldCk7IH1cbiAgICBpZiAoRUNNQVNjcmlwdC5IYXNQcm9wZXJ0eShkZXNjLCAnc2V0JykgJiYgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKSB7IE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG8sIHAsIGRlc2Muc2V0KTsgfVxuICAgIGlmIChFQ01BU2NyaXB0Lkhhc1Byb3BlcnR5KGRlc2MsICd2YWx1ZScpKSB7IG9bcF0gPSBkZXNjLnZhbHVlOyB9XG4gICAgcmV0dXJuIG87XG4gIH07XG59XG5cbnZhciBnZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICBpZiAobyAhPT0gT2JqZWN0KG8pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgY2FsbGVkIG9uIG5vbi1vYmplY3RcIik7XG4gIHZhciBwcm9wcyA9IFtdLCBwO1xuICBmb3IgKHAgaW4gbykge1xuICAgIGlmIChFQ01BU2NyaXB0Lkhhc093blByb3BlcnR5KG8sIHApKSB7XG4gICAgICBwcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59O1xuXG4vLyBFUzU6IE1ha2Ugb2JqW2luZGV4XSBhbiBhbGlhcyBmb3Igb2JqLl9nZXR0ZXIoaW5kZXgpL29iai5fc2V0dGVyKGluZGV4LCB2YWx1ZSlcbi8vIGZvciBpbmRleCBpbiAwIC4uLiBvYmoubGVuZ3RoXG5mdW5jdGlvbiBtYWtlQXJyYXlBY2Nlc3NvcnMob2JqKSB7XG4gIGlmICghZGVmaW5lUHJvcCkgeyByZXR1cm47IH1cblxuICBpZiAob2JqLmxlbmd0aCA+IE1BWF9BUlJBWV9MRU5HVEgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXJyYXkgdG9vIGxhcmdlIGZvciBwb2x5ZmlsbFwiKTtcblxuICBmdW5jdGlvbiBtYWtlQXJyYXlBY2Nlc3NvcihpbmRleCkge1xuICAgIGRlZmluZVByb3Aob2JqLCBpbmRleCwge1xuICAgICAgJ2dldCc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gb2JqLl9nZXR0ZXIoaW5kZXgpOyB9LFxuICAgICAgJ3NldCc6IGZ1bmN0aW9uKHYpIHsgb2JqLl9zZXR0ZXIoaW5kZXgsIHYpOyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgbWFrZUFycmF5QWNjZXNzb3IoaSk7XG4gIH1cbn1cblxuLy8gSW50ZXJuYWwgY29udmVyc2lvbiBmdW5jdGlvbnM6XG4vLyAgICBwYWNrPFR5cGU+KCkgICAtIHRha2UgYSBudW1iZXIgKGludGVycHJldGVkIGFzIFR5cGUpLCBvdXRwdXQgYSBieXRlIGFycmF5XG4vLyAgICB1bnBhY2s8VHlwZT4oKSAtIHRha2UgYSBieXRlIGFycmF5LCBvdXRwdXQgYSBUeXBlLWxpa2UgbnVtYmVyXG5cbmZ1bmN0aW9uIGFzX3NpZ25lZCh2YWx1ZSwgYml0cykgeyB2YXIgcyA9IDMyIC0gYml0czsgcmV0dXJuICh2YWx1ZSA8PCBzKSA+PiBzOyB9XG5mdW5jdGlvbiBhc191bnNpZ25lZCh2YWx1ZSwgYml0cykgeyB2YXIgcyA9IDMyIC0gYml0czsgcmV0dXJuICh2YWx1ZSA8PCBzKSA+Pj4gczsgfVxuXG5mdW5jdGlvbiBwYWNrSTgobikgeyByZXR1cm4gW24gJiAweGZmXTsgfVxuZnVuY3Rpb24gdW5wYWNrSTgoYnl0ZXMpIHsgcmV0dXJuIGFzX3NpZ25lZChieXRlc1swXSwgOCk7IH1cblxuZnVuY3Rpb24gcGFja1U4KG4pIHsgcmV0dXJuIFtuICYgMHhmZl07IH1cbmZ1bmN0aW9uIHVucGFja1U4KGJ5dGVzKSB7IHJldHVybiBhc191bnNpZ25lZChieXRlc1swXSwgOCk7IH1cblxuZnVuY3Rpb24gcGFja1U4Q2xhbXBlZChuKSB7IG4gPSByb3VuZChOdW1iZXIobikpOyByZXR1cm4gW24gPCAwID8gMCA6IG4gPiAweGZmID8gMHhmZiA6IG4gJiAweGZmXTsgfVxuXG5mdW5jdGlvbiBwYWNrSTE2KG4pIHsgcmV0dXJuIFsobiA+PiA4KSAmIDB4ZmYsIG4gJiAweGZmXTsgfVxuZnVuY3Rpb24gdW5wYWNrSTE2KGJ5dGVzKSB7IHJldHVybiBhc19zaWduZWQoYnl0ZXNbMF0gPDwgOCB8IGJ5dGVzWzFdLCAxNik7IH1cblxuZnVuY3Rpb24gcGFja1UxNihuKSB7IHJldHVybiBbKG4gPj4gOCkgJiAweGZmLCBuICYgMHhmZl07IH1cbmZ1bmN0aW9uIHVucGFja1UxNihieXRlcykgeyByZXR1cm4gYXNfdW5zaWduZWQoYnl0ZXNbMF0gPDwgOCB8IGJ5dGVzWzFdLCAxNik7IH1cblxuZnVuY3Rpb24gcGFja0kzMihuKSB7IHJldHVybiBbKG4gPj4gMjQpICYgMHhmZiwgKG4gPj4gMTYpICYgMHhmZiwgKG4gPj4gOCkgJiAweGZmLCBuICYgMHhmZl07IH1cbmZ1bmN0aW9uIHVucGFja0kzMihieXRlcykgeyByZXR1cm4gYXNfc2lnbmVkKGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIDMyKTsgfVxuXG5mdW5jdGlvbiBwYWNrVTMyKG4pIHsgcmV0dXJuIFsobiA+PiAyNCkgJiAweGZmLCAobiA+PiAxNikgJiAweGZmLCAobiA+PiA4KSAmIDB4ZmYsIG4gJiAweGZmXTsgfVxuZnVuY3Rpb24gdW5wYWNrVTMyKGJ5dGVzKSB7IHJldHVybiBhc191bnNpZ25lZChieXRlc1swXSA8PCAyNCB8IGJ5dGVzWzFdIDw8IDE2IHwgYnl0ZXNbMl0gPDwgOCB8IGJ5dGVzWzNdLCAzMik7IH1cblxuZnVuY3Rpb24gcGFja0lFRUU3NTQodiwgZWJpdHMsIGZiaXRzKSB7XG5cbiAgdmFyIGJpYXMgPSAoMSA8PCAoZWJpdHMgLSAxKSkgLSAxLFxuICAgICAgcywgZSwgZiwgbG4sXG4gICAgICBpLCBiaXRzLCBzdHIsIGJ5dGVzO1xuXG4gIGZ1bmN0aW9uIHJvdW5kVG9FdmVuKG4pIHtcbiAgICB2YXIgdyA9IGZsb29yKG4pLCBmID0gbiAtIHc7XG4gICAgaWYgKGYgPCAwLjUpXG4gICAgICByZXR1cm4gdztcbiAgICBpZiAoZiA+IDAuNSlcbiAgICAgIHJldHVybiB3ICsgMTtcbiAgICByZXR1cm4gdyAlIDIgPyB3ICsgMSA6IHc7XG4gIH1cblxuICAvLyBDb21wdXRlIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxuICBpZiAodiAhPT0gdikge1xuICAgIC8vIE5hTlxuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnLzIwMDYvd2ViYXBpL1dlYklETC8jZXMtdHlwZS1tYXBwaW5nXG4gICAgZSA9ICgxIDw8IGViaXRzKSAtIDE7IGYgPSBwb3coMiwgZmJpdHMgLSAxKTsgcyA9IDA7XG4gIH0gZWxzZSBpZiAodiA9PT0gSW5maW5pdHkgfHwgdiA9PT0gLUluZmluaXR5KSB7XG4gICAgZSA9ICgxIDw8IGViaXRzKSAtIDE7IGYgPSAwOyBzID0gKHYgPCAwKSA/IDEgOiAwO1xuICB9IGVsc2UgaWYgKHYgPT09IDApIHtcbiAgICBlID0gMDsgZiA9IDA7IHMgPSAoMSAvIHYgPT09IC1JbmZpbml0eSkgPyAxIDogMDtcbiAgfSBlbHNlIHtcbiAgICBzID0gdiA8IDA7XG4gICAgdiA9IGFicyh2KTtcblxuICAgIGlmICh2ID49IHBvdygyLCAxIC0gYmlhcykpIHtcbiAgICAgIGUgPSBtaW4oZmxvb3IobG9nKHYpIC8gTE4yKSwgMTAyMyk7XG4gICAgICBmID0gcm91bmRUb0V2ZW4odiAvIHBvdygyLCBlKSAqIHBvdygyLCBmYml0cykpO1xuICAgICAgaWYgKGYgLyBwb3coMiwgZmJpdHMpID49IDIpIHtcbiAgICAgICAgZSA9IGUgKyAxO1xuICAgICAgICBmID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChlID4gYmlhcykge1xuICAgICAgICAvLyBPdmVyZmxvd1xuICAgICAgICBlID0gKDEgPDwgZWJpdHMpIC0gMTtcbiAgICAgICAgZiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWxpemVkXG4gICAgICAgIGUgPSBlICsgYmlhcztcbiAgICAgICAgZiA9IGYgLSBwb3coMiwgZmJpdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZW5vcm1hbGl6ZWRcbiAgICAgIGUgPSAwO1xuICAgICAgZiA9IHJvdW5kVG9FdmVuKHYgLyBwb3coMiwgMSAtIGJpYXMgLSBmYml0cykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBhY2sgc2lnbiwgZXhwb25lbnQsIGZyYWN0aW9uXG4gIGJpdHMgPSBbXTtcbiAgZm9yIChpID0gZmJpdHM7IGk7IGkgLT0gMSkgeyBiaXRzLnB1c2goZiAlIDIgPyAxIDogMCk7IGYgPSBmbG9vcihmIC8gMik7IH1cbiAgZm9yIChpID0gZWJpdHM7IGk7IGkgLT0gMSkgeyBiaXRzLnB1c2goZSAlIDIgPyAxIDogMCk7IGUgPSBmbG9vcihlIC8gMik7IH1cbiAgYml0cy5wdXNoKHMgPyAxIDogMCk7XG4gIGJpdHMucmV2ZXJzZSgpO1xuICBzdHIgPSBiaXRzLmpvaW4oJycpO1xuXG4gIC8vIEJpdHMgdG8gYnl0ZXNcbiAgYnl0ZXMgPSBbXTtcbiAgd2hpbGUgKHN0ci5sZW5ndGgpIHtcbiAgICBieXRlcy5wdXNoKHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMCwgOCksIDIpKTtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDgpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cblxuZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChieXRlcywgZWJpdHMsIGZiaXRzKSB7XG5cbiAgLy8gQnl0ZXMgdG8gYml0c1xuICB2YXIgYml0cyA9IFtdLCBpLCBqLCBiLCBzdHIsXG4gICAgICBiaWFzLCBzLCBlLCBmO1xuXG4gIGZvciAoaSA9IGJ5dGVzLmxlbmd0aDsgaTsgaSAtPSAxKSB7XG4gICAgYiA9IGJ5dGVzW2kgLSAxXTtcbiAgICBmb3IgKGogPSA4OyBqOyBqIC09IDEpIHtcbiAgICAgIGJpdHMucHVzaChiICUgMiA/IDEgOiAwKTsgYiA9IGIgPj4gMTtcbiAgICB9XG4gIH1cbiAgYml0cy5yZXZlcnNlKCk7XG4gIHN0ciA9IGJpdHMuam9pbignJyk7XG5cbiAgLy8gVW5wYWNrIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxuICBiaWFzID0gKDEgPDwgKGViaXRzIC0gMSkpIC0gMTtcbiAgcyA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMCwgMSksIDIpID8gLTEgOiAxO1xuICBlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZygxLCAxICsgZWJpdHMpLCAyKTtcbiAgZiA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMSArIGViaXRzKSwgMik7XG5cbiAgLy8gUHJvZHVjZSBudW1iZXJcbiAgaWYgKGUgPT09ICgxIDw8IGViaXRzKSAtIDEpIHtcbiAgICByZXR1cm4gZiAhPT0gMCA/IE5hTiA6IHMgKiBJbmZpbml0eTtcbiAgfSBlbHNlIGlmIChlID4gMCkge1xuICAgIC8vIE5vcm1hbGl6ZWRcbiAgICByZXR1cm4gcyAqIHBvdygyLCBlIC0gYmlhcykgKiAoMSArIGYgLyBwb3coMiwgZmJpdHMpKTtcbiAgfSBlbHNlIGlmIChmICE9PSAwKSB7XG4gICAgLy8gRGVub3JtYWxpemVkXG4gICAgcmV0dXJuIHMgKiBwb3coMiwgLShiaWFzIC0gMSkpICogKGYgLyBwb3coMiwgZmJpdHMpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcyA8IDAgPyAtMCA6IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5wYWNrRjY0KGIpIHsgcmV0dXJuIHVucGFja0lFRUU3NTQoYiwgMTEsIDUyKTsgfVxuZnVuY3Rpb24gcGFja0Y2NCh2KSB7IHJldHVybiBwYWNrSUVFRTc1NCh2LCAxMSwgNTIpOyB9XG5mdW5jdGlvbiB1bnBhY2tGMzIoYikgeyByZXR1cm4gdW5wYWNrSUVFRTc1NChiLCA4LCAyMyk7IH1cbmZ1bmN0aW9uIHBhY2tGMzIodikgeyByZXR1cm4gcGFja0lFRUU3NTQodiwgOCwgMjMpOyB9XG5cblxuLy9cbi8vIDMgVGhlIEFycmF5QnVmZmVyIFR5cGVcbi8vXG5cbihmdW5jdGlvbigpIHtcblxuICAvKiogQGNvbnN0cnVjdG9yICovXG4gIHZhciBBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGxlbmd0aCA9IEVDTUFTY3JpcHQuVG9JbnQzMihsZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXJyYXlCdWZmZXIgc2l6ZSBpcyBub3QgYSBzbWFsbCBlbm91Z2ggcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2J5dGVzID0gW107XG4gICAgdGhpcy5fYnl0ZXMubGVuZ3RoID0gbGVuZ3RoO1xuXG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYnl0ZUxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB0aGlzLl9ieXRlc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgY29uZmlndXJlUHJvcGVydGllcyh0aGlzKTtcbiAgfTtcblxuICBleHBvcnRzLkFycmF5QnVmZmVyID0gZXhwb3J0cy5BcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlcjtcblxuICAvL1xuICAvLyA0IFRoZSBBcnJheUJ1ZmZlclZpZXcgVHlwZVxuICAvL1xuXG4gIC8vIE5PVEU6IHRoaXMgY29uc3RydWN0b3IgaXMgbm90IGV4cG9ydGVkXG4gIC8qKiBAY29uc3RydWN0b3IgKi9cbiAgdmFyIEFycmF5QnVmZmVyVmlldyA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyVmlldygpIHtcbiAgICAvL3RoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAvL3RoaXMuYnl0ZU9mZnNldCA9IDA7XG4gICAgLy90aGlzLmJ5dGVMZW5ndGggPSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIDUgVGhlIFR5cGVkIEFycmF5IFZpZXcgVHlwZXNcbiAgLy9cblxuICBmdW5jdGlvbiBtYWtlQ29uc3RydWN0b3IoYnl0ZXNQZXJFbGVtZW50LCBwYWNrLCB1bnBhY2spIHtcbiAgICAvLyBFYWNoIFR5cGVkQXJyYXkgdHlwZSByZXF1aXJlcyBhIGRpc3RpbmN0IGNvbnN0cnVjdG9yIGluc3RhbmNlIHdpdGhcbiAgICAvLyBpZGVudGljYWwgbG9naWMsIHdoaWNoIHRoaXMgcHJvZHVjZXMuXG5cbiAgICB2YXIgY3RvcjtcbiAgICBjdG9yID0gZnVuY3Rpb24oYnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIHZhciBhcnJheSwgc2VxdWVuY2UsIGksIHM7XG5cbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBDb25zdHJ1Y3Rvcih1bnNpZ25lZCBsb25nIGxlbmd0aClcbiAgICAgICAgdGhpcy5sZW5ndGggPSBFQ01BU2NyaXB0LlRvSW50MzIoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdBcnJheUJ1ZmZlclZpZXcgc2l6ZSBpcyBub3QgYSBzbWFsbCBlbm91Z2ggcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IHRoaXMubGVuZ3RoICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiYgYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yID09PSBjdG9yKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdG9yKFR5cGVkQXJyYXkgYXJyYXkpXG4gICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSB0aGlzLmxlbmd0aCAqIHRoaXMuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9zZXR0ZXIoaSwgYXJyYXkuX2dldHRlcihpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgIShhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBFQ01BU2NyaXB0LkNsYXNzKGFyZ3VtZW50c1swXSkgPT09ICdBcnJheUJ1ZmZlcicpKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdG9yKHNlcXVlbmNlPHR5cGU+IGFycmF5KVxuICAgICAgICBzZXF1ZW5jZSA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB0aGlzLmxlbmd0aCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoc2VxdWVuY2UubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gdGhpcy5sZW5ndGggKiB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgcyA9IHNlcXVlbmNlW2ldO1xuICAgICAgICAgIHRoaXMuX3NldHRlcihpLCBOdW1iZXIocykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBFQ01BU2NyaXB0LkNsYXNzKGFyZ3VtZW50c1swXSkgPT09ICdBcnJheUJ1ZmZlcicpKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdG9yKEFycmF5QnVmZmVyIGJ1ZmZlcixcbiAgICAgICAgLy8gICAgICAgICAgICAgb3B0aW9uYWwgdW5zaWduZWQgbG9uZyBieXRlT2Zmc2V0LCBvcHRpb25hbCB1bnNpZ25lZCBsb25nIGxlbmd0aClcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG5cbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihieXRlT2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuYnl0ZU9mZnNldCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImJ5dGVPZmZzZXQgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYnl0ZU9mZnNldCAlIHRoaXMuQllURVNfUEVSX0VMRU1FTlQpIHtcbiAgICAgICAgICAvLyBUaGUgZ2l2ZW4gYnl0ZU9mZnNldCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICAvLyBzaXplIG9mIHRoZSBzcGVjaWZpYyB0eXBlLCBvdGhlcndpc2UgYW4gZXhjZXB0aW9uIGlzIHJhaXNlZC5cbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFycmF5QnVmZmVyIGxlbmd0aCBtaW51cyB0aGUgYnl0ZU9mZnNldCBpcyBub3QgYSBtdWx0aXBsZSBvZiB0aGUgZWxlbWVudCBzaXplLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggLSB0aGlzLmJ5dGVPZmZzZXQ7XG5cbiAgICAgICAgICBpZiAodGhpcy5ieXRlTGVuZ3RoICUgdGhpcy5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJsZW5ndGggb2YgYnVmZmVyIG1pbnVzIGJ5dGVPZmZzZXQgbm90IGEgbXVsdGlwbGUgb2YgdGhlIGVsZW1lbnQgc2l6ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGggLyB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihsZW5ndGgpO1xuICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IHRoaXMubGVuZ3RoICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5ieXRlTGVuZ3RoKSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImJ5dGVPZmZzZXQgYW5kIGxlbmd0aCByZWZlcmVuY2UgYW4gYXJlYSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudCB0eXBlKHMpXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY3RvcjtcblxuICAgICAgY29uZmlndXJlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgIG1ha2VBcnJheUFjY2Vzc29ycyh0aGlzKTtcbiAgICB9O1xuXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgQXJyYXlCdWZmZXJWaWV3KCk7XG4gICAgY3Rvci5wcm90b3R5cGUuQllURVNfUEVSX0VMRU1FTlQgPSBieXRlc1BlckVsZW1lbnQ7XG4gICAgY3Rvci5wcm90b3R5cGUuX3BhY2sgPSBwYWNrO1xuICAgIGN0b3IucHJvdG90eXBlLl91bnBhY2sgPSB1bnBhY2s7XG4gICAgY3Rvci5CWVRFU19QRVJfRUxFTUVOVCA9IGJ5dGVzUGVyRWxlbWVudDtcblxuICAgIC8vIGdldHRlciB0eXBlICh1bnNpZ25lZCBsb25nIGluZGV4KTtcbiAgICBjdG9yLnByb3RvdHlwZS5fZ2V0dGVyID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm90IGVub3VnaCBhcmd1bWVudHNcIik7XG5cbiAgICAgIGluZGV4ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihpbmRleCk7XG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ5dGVzID0gW10sIGksIG87XG4gICAgICBmb3IgKGkgPSAwLCBvID0gdGhpcy5ieXRlT2Zmc2V0ICsgaW5kZXggKiB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICAgICBpIDwgdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgICAgaSArPSAxLCBvICs9IDEpIHtcbiAgICAgICAgYnl0ZXMucHVzaCh0aGlzLmJ1ZmZlci5fYnl0ZXNbb10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3VucGFjayhieXRlcyk7XG4gICAgfTtcblxuICAgIC8vIE5PTlNUQU5EQVJEOiBjb252ZW5pZW5jZSBhbGlhcyBmb3IgZ2V0dGVyOiB0eXBlIGdldCh1bnNpZ25lZCBsb25nIGluZGV4KTtcbiAgICBjdG9yLnByb3RvdHlwZS5nZXQgPSBjdG9yLnByb3RvdHlwZS5fZ2V0dGVyO1xuXG4gICAgLy8gc2V0dGVyIHZvaWQgKHVuc2lnbmVkIGxvbmcgaW5kZXgsIHR5cGUgdmFsdWUpO1xuICAgIGN0b3IucHJvdG90eXBlLl9zZXR0ZXIgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm90IGVub3VnaCBhcmd1bWVudHNcIik7XG5cbiAgICAgIGluZGV4ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihpbmRleCk7XG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ5dGVzID0gdGhpcy5fcGFjayh2YWx1ZSksIGksIG87XG4gICAgICBmb3IgKGkgPSAwLCBvID0gdGhpcy5ieXRlT2Zmc2V0ICsgaW5kZXggKiB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICAgICBpIDwgdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgICAgaSArPSAxLCBvICs9IDEpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuX2J5dGVzW29dID0gYnl0ZXNbaV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHZvaWQgc2V0KFR5cGVkQXJyYXkgYXJyYXksIG9wdGlvbmFsIHVuc2lnbmVkIGxvbmcgb2Zmc2V0KTtcbiAgICAvLyB2b2lkIHNldChzZXF1ZW5jZTx0eXBlPiBhcnJheSwgb3B0aW9uYWwgdW5zaWduZWQgbG9uZyBvZmZzZXQpO1xuICAgIGN0b3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiKTtcbiAgICAgIHZhciBhcnJheSwgc2VxdWVuY2UsIG9mZnNldCwgbGVuLFxuICAgICAgICAgIGksIHMsIGQsXG4gICAgICAgICAgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCwgdG1wO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiYgYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yID09PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIC8vIHZvaWQgc2V0KFR5cGVkQXJyYXkgYXJyYXksIG9wdGlvbmFsIHVuc2lnbmVkIGxvbmcgb2Zmc2V0KTtcbiAgICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIG9mZnNldCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoYXJndW1lbnRzWzFdKTtcblxuICAgICAgICBpZiAob2Zmc2V0ICsgYXJyYXkubGVuZ3RoID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk9mZnNldCBwbHVzIGxlbmd0aCBvZiBhcnJheSBpcyBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIH1cblxuICAgICAgICBieXRlT2Zmc2V0ID0gdGhpcy5ieXRlT2Zmc2V0ICsgb2Zmc2V0ICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgYnl0ZUxlbmd0aCA9IGFycmF5Lmxlbmd0aCAqIHRoaXMuQllURVNfUEVSX0VMRU1FTlQ7XG5cbiAgICAgICAgaWYgKGFycmF5LmJ1ZmZlciA9PT0gdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICB0bXAgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzID0gYXJyYXkuYnl0ZU9mZnNldDsgaSA8IGJ5dGVMZW5ndGg7IGkgKz0gMSwgcyArPSAxKSB7XG4gICAgICAgICAgICB0bXBbaV0gPSBhcnJheS5idWZmZXIuX2J5dGVzW3NdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGkgPSAwLCBkID0gYnl0ZU9mZnNldDsgaSA8IGJ5dGVMZW5ndGg7IGkgKz0gMSwgZCArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5fYnl0ZXNbZF0gPSB0bXBbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaSA9IDAsIHMgPSBhcnJheS5ieXRlT2Zmc2V0LCBkID0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgICAgIGkgPCBieXRlTGVuZ3RoOyBpICs9IDEsIHMgKz0gMSwgZCArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5fYnl0ZXNbZF0gPSBhcnJheS5idWZmZXIuX2J5dGVzW3NdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYXJndW1lbnRzWzBdLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gdm9pZCBzZXQoc2VxdWVuY2U8dHlwZT4gYXJyYXksIG9wdGlvbmFsIHVuc2lnbmVkIGxvbmcgb2Zmc2V0KTtcbiAgICAgICAgc2VxdWVuY2UgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGxlbiA9IEVDTUFTY3JpcHQuVG9VaW50MzIoc2VxdWVuY2UubGVuZ3RoKTtcbiAgICAgICAgb2Zmc2V0ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihhcmd1bWVudHNbMV0pO1xuXG4gICAgICAgIGlmIChvZmZzZXQgKyBsZW4gPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiT2Zmc2V0IHBsdXMgbGVuZ3RoIG9mIGFycmF5IGlzIG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHMgPSBzZXF1ZW5jZVtpXTtcbiAgICAgICAgICB0aGlzLl9zZXR0ZXIob2Zmc2V0ICsgaSwgTnVtYmVyKHMpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnQgdHlwZShzKVwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVHlwZWRBcnJheSBzdWJhcnJheShsb25nIGJlZ2luLCBvcHRpb25hbCBsb25nIGVuZCk7XG4gICAgY3Rvci5wcm90b3R5cGUuc3ViYXJyYXkgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkgeyByZXR1cm4gdiA8IG1pbiA/IG1pbiA6IHYgPiBtYXggPyBtYXggOiB2OyB9XG5cbiAgICAgIHN0YXJ0ID0gRUNNQVNjcmlwdC5Ub0ludDMyKHN0YXJ0KTtcbiAgICAgIGVuZCA9IEVDTUFTY3JpcHQuVG9JbnQzMihlbmQpO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHsgc3RhcnQgPSAwOyB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHsgZW5kID0gdGhpcy5sZW5ndGg7IH1cblxuICAgICAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQ7IH1cbiAgICAgIGlmIChlbmQgPCAwKSB7IGVuZCA9IHRoaXMubGVuZ3RoICsgZW5kOyB9XG5cbiAgICAgIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIGVuZCA9IGNsYW1wKGVuZCwgMCwgdGhpcy5sZW5ndGgpO1xuXG4gICAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgICBpZiAobGVuIDwgMCkge1xuICAgICAgICBsZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoXG4gICAgICAgIHRoaXMuYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQgKyBzdGFydCAqIHRoaXMuQllURVNfUEVSX0VMRU1FTlQsIGxlbik7XG4gICAgfTtcblxuICAgIHJldHVybiBjdG9yO1xuICB9XG5cbiAgdmFyIEludDhBcnJheSA9IG1ha2VDb25zdHJ1Y3RvcigxLCBwYWNrSTgsIHVucGFja0k4KTtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBtYWtlQ29uc3RydWN0b3IoMSwgcGFja1U4LCB1bnBhY2tVOCk7XG4gIHZhciBVaW50OENsYW1wZWRBcnJheSA9IG1ha2VDb25zdHJ1Y3RvcigxLCBwYWNrVThDbGFtcGVkLCB1bnBhY2tVOCk7XG4gIHZhciBJbnQxNkFycmF5ID0gbWFrZUNvbnN0cnVjdG9yKDIsIHBhY2tJMTYsIHVucGFja0kxNik7XG4gIHZhciBVaW50MTZBcnJheSA9IG1ha2VDb25zdHJ1Y3RvcigyLCBwYWNrVTE2LCB1bnBhY2tVMTYpO1xuICB2YXIgSW50MzJBcnJheSA9IG1ha2VDb25zdHJ1Y3Rvcig0LCBwYWNrSTMyLCB1bnBhY2tJMzIpO1xuICB2YXIgVWludDMyQXJyYXkgPSBtYWtlQ29uc3RydWN0b3IoNCwgcGFja1UzMiwgdW5wYWNrVTMyKTtcbiAgdmFyIEZsb2F0MzJBcnJheSA9IG1ha2VDb25zdHJ1Y3Rvcig0LCBwYWNrRjMyLCB1bnBhY2tGMzIpO1xuICB2YXIgRmxvYXQ2NEFycmF5ID0gbWFrZUNvbnN0cnVjdG9yKDgsIHBhY2tGNjQsIHVucGFja0Y2NCk7XG5cbiAgZXhwb3J0cy5JbnQ4QXJyYXkgPSBleHBvcnRzLkludDhBcnJheSB8fCBJbnQ4QXJyYXk7XG4gIGV4cG9ydHMuVWludDhBcnJheSA9IGV4cG9ydHMuVWludDhBcnJheSB8fCBVaW50OEFycmF5O1xuICBleHBvcnRzLlVpbnQ4Q2xhbXBlZEFycmF5ID0gZXhwb3J0cy5VaW50OENsYW1wZWRBcnJheSB8fCBVaW50OENsYW1wZWRBcnJheTtcbiAgZXhwb3J0cy5JbnQxNkFycmF5ID0gZXhwb3J0cy5JbnQxNkFycmF5IHx8IEludDE2QXJyYXk7XG4gIGV4cG9ydHMuVWludDE2QXJyYXkgPSBleHBvcnRzLlVpbnQxNkFycmF5IHx8IFVpbnQxNkFycmF5O1xuICBleHBvcnRzLkludDMyQXJyYXkgPSBleHBvcnRzLkludDMyQXJyYXkgfHwgSW50MzJBcnJheTtcbiAgZXhwb3J0cy5VaW50MzJBcnJheSA9IGV4cG9ydHMuVWludDMyQXJyYXkgfHwgVWludDMyQXJyYXk7XG4gIGV4cG9ydHMuRmxvYXQzMkFycmF5ID0gZXhwb3J0cy5GbG9hdDMyQXJyYXkgfHwgRmxvYXQzMkFycmF5O1xuICBleHBvcnRzLkZsb2F0NjRBcnJheSA9IGV4cG9ydHMuRmxvYXQ2NEFycmF5IHx8IEZsb2F0NjRBcnJheTtcbn0oKSk7XG5cbi8vXG4vLyA2IFRoZSBEYXRhVmlldyBWaWV3IFR5cGVcbi8vXG5cbihmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gcihhcnJheSwgaW5kZXgpIHtcbiAgICByZXR1cm4gRUNNQVNjcmlwdC5Jc0NhbGxhYmxlKGFycmF5LmdldCkgPyBhcnJheS5nZXQoaW5kZXgpIDogYXJyYXlbaW5kZXhdO1xuICB9XG5cbiAgdmFyIElTX0JJR19FTkRJQU4gPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHUxNmFycmF5ID0gbmV3KGV4cG9ydHMuVWludDE2QXJyYXkpKFsweDEyMzRdKSxcbiAgICAgICAgdThhcnJheSA9IG5ldyhleHBvcnRzLlVpbnQ4QXJyYXkpKHUxNmFycmF5LmJ1ZmZlcik7XG4gICAgcmV0dXJuIHIodThhcnJheSwgMCkgPT09IDB4MTI7XG4gIH0oKSk7XG5cbiAgLy8gQ29uc3RydWN0b3IoQXJyYXlCdWZmZXIgYnVmZmVyLFxuICAvLyAgICAgICAgICAgICBvcHRpb25hbCB1bnNpZ25lZCBsb25nIGJ5dGVPZmZzZXQsXG4gIC8vICAgICAgICAgICAgIG9wdGlvbmFsIHVuc2lnbmVkIGxvbmcgYnl0ZUxlbmd0aClcbiAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICB2YXIgRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnVmZmVyID0gbmV3IGV4cG9ydHMuQXJyYXlCdWZmZXIoMCk7XG4gICAgfSBlbHNlIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIGV4cG9ydHMuQXJyYXlCdWZmZXIgfHwgRUNNQVNjcmlwdC5DbGFzcyhidWZmZXIpID09PSAnQXJyYXlCdWZmZXInKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlR5cGVFcnJvclwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciB8fCBuZXcgZXhwb3J0cy5BcnJheUJ1ZmZlcigwKTtcblxuICAgIHRoaXMuYnl0ZU9mZnNldCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKHRoaXMuYnl0ZU9mZnNldCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYnl0ZU9mZnNldCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICB0aGlzLmJ5dGVMZW5ndGggPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoIC0gdGhpcy5ieXRlT2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ5dGVMZW5ndGggPSBFQ01BU2NyaXB0LlRvVWludDMyKGJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIGlmICgodGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5ieXRlTGVuZ3RoKSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYnl0ZU9mZnNldCBhbmQgbGVuZ3RoIHJlZmVyZW5jZSBhbiBhcmVhIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgY29uZmlndXJlUHJvcGVydGllcyh0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlR2V0dGVyKGFycmF5VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcblxuICAgICAgYnl0ZU9mZnNldCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoYnl0ZU9mZnNldCk7XG5cbiAgICAgIGlmIChieXRlT2Zmc2V0ICsgYXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UID4gdGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXJyYXkgaW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgfVxuICAgICAgYnl0ZU9mZnNldCArPSB0aGlzLmJ5dGVPZmZzZXQ7XG5cbiAgICAgIHZhciB1aW50OEFycmF5ID0gbmV3IGV4cG9ydHMuVWludDhBcnJheSh0aGlzLmJ1ZmZlciwgYnl0ZU9mZnNldCwgYXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UKSxcbiAgICAgICAgICBieXRlcyA9IFtdLCBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVzLnB1c2gocih1aW50OEFycmF5LCBpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChCb29sZWFuKGxpdHRsZUVuZGlhbikgPT09IEJvb2xlYW4oSVNfQklHX0VORElBTikpIHtcbiAgICAgICAgYnl0ZXMucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcihuZXcgYXJyYXlUeXBlKG5ldyBleHBvcnRzLlVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlciksIDApO1xuICAgIH07XG4gIH1cblxuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDggPSBtYWtlR2V0dGVyKGV4cG9ydHMuVWludDhBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQ4ID0gbWFrZUdldHRlcihleHBvcnRzLkludDhBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MTYgPSBtYWtlR2V0dGVyKGV4cG9ydHMuVWludDE2QXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MTYgPSBtYWtlR2V0dGVyKGV4cG9ydHMuSW50MTZBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MzIgPSBtYWtlR2V0dGVyKGV4cG9ydHMuVWludDMyQXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MzIgPSBtYWtlR2V0dGVyKGV4cG9ydHMuSW50MzJBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDMyID0gbWFrZUdldHRlcihleHBvcnRzLkZsb2F0MzJBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDY0ID0gbWFrZUdldHRlcihleHBvcnRzLkZsb2F0NjRBcnJheSk7XG5cbiAgZnVuY3Rpb24gbWFrZVNldHRlcihhcnJheVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuXG4gICAgICBieXRlT2Zmc2V0ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihieXRlT2Zmc2V0KTtcbiAgICAgIGlmIChieXRlT2Zmc2V0ICsgYXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UID4gdGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXJyYXkgaW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgYnl0ZXNcbiAgICAgIHZhciB0eXBlQXJyYXkgPSBuZXcgYXJyYXlUeXBlKFt2YWx1ZV0pLFxuICAgICAgICAgIGJ5dGVBcnJheSA9IG5ldyBleHBvcnRzLlVpbnQ4QXJyYXkodHlwZUFycmF5LmJ1ZmZlciksXG4gICAgICAgICAgYnl0ZXMgPSBbXSwgaSwgYnl0ZVZpZXc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7IGkgKz0gMSkge1xuICAgICAgICBieXRlcy5wdXNoKHIoYnl0ZUFycmF5LCBpKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZsaXAgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoQm9vbGVhbihsaXR0bGVFbmRpYW4pID09PSBCb29sZWFuKElTX0JJR19FTkRJQU4pKSB7XG4gICAgICAgIGJ5dGVzLnJldmVyc2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gV3JpdGUgdGhlbVxuICAgICAgYnl0ZVZpZXcgPSBuZXcgZXhwb3J0cy5VaW50OEFycmF5KHRoaXMuYnVmZmVyLCBieXRlT2Zmc2V0LCBhcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgICAgYnl0ZVZpZXcuc2V0KGJ5dGVzKTtcbiAgICB9O1xuICB9XG5cbiAgRGF0YVZpZXcucHJvdG90eXBlLnNldFVpbnQ4ID0gbWFrZVNldHRlcihleHBvcnRzLlVpbnQ4QXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0SW50OCA9IG1ha2VTZXR0ZXIoZXhwb3J0cy5JbnQ4QXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0VWludDE2ID0gbWFrZVNldHRlcihleHBvcnRzLlVpbnQxNkFycmF5KTtcbiAgRGF0YVZpZXcucHJvdG90eXBlLnNldEludDE2ID0gbWFrZVNldHRlcihleHBvcnRzLkludDE2QXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0VWludDMyID0gbWFrZVNldHRlcihleHBvcnRzLlVpbnQzMkFycmF5KTtcbiAgRGF0YVZpZXcucHJvdG90eXBlLnNldEludDMyID0gbWFrZVNldHRlcihleHBvcnRzLkludDMyQXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0RmxvYXQzMiA9IG1ha2VTZXR0ZXIoZXhwb3J0cy5GbG9hdDMyQXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0RmxvYXQ2NCA9IG1ha2VTZXR0ZXIoZXhwb3J0cy5GbG9hdDY0QXJyYXkpO1xuXG4gIGV4cG9ydHMuRGF0YVZpZXcgPSBleHBvcnRzLkRhdGFWaWV3IHx8IERhdGFWaWV3O1xuXG59KCkpO1xuIiwgInZhciBXcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLldyaXRhYmxlXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgYnVmZmVyRnJvbSA9IHJlcXVpcmUoJ2J1ZmZlci1mcm9tJylcblxuaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgVTggPSByZXF1aXJlKCd0eXBlZGFycmF5JykuVWludDhBcnJheVxufSBlbHNlIHtcbiAgdmFyIFU4ID0gVWludDhBcnJheVxufVxuXG5mdW5jdGlvbiBDb25jYXRTdHJlYW0ob3B0cywgY2IpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbmNhdFN0cmVhbSkpIHJldHVybiBuZXcgQ29uY2F0U3RyZWFtKG9wdHMsIGNiKVxuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgdmFyIGVuY29kaW5nID0gb3B0cy5lbmNvZGluZ1xuICB2YXIgc2hvdWxkSW5mZXJFbmNvZGluZyA9IGZhbHNlXG5cbiAgaWYgKCFlbmNvZGluZykge1xuICAgIHNob3VsZEluZmVyRW5jb2RpbmcgPSB0cnVlXG4gIH0gZWxzZSB7XG4gICAgZW5jb2RpbmcgPSAgU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndTgnIHx8IGVuY29kaW5nID09PSAndWludDgnKSB7XG4gICAgICBlbmNvZGluZyA9ICd1aW50OGFycmF5J1xuICAgIH1cbiAgfVxuXG4gIFdyaXRhYmxlLmNhbGwodGhpcywgeyBvYmplY3RNb2RlOiB0cnVlIH0pXG5cbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nXG4gIHRoaXMuc2hvdWxkSW5mZXJFbmNvZGluZyA9IHNob3VsZEluZmVyRW5jb2RpbmdcblxuICBpZiAoY2IpIHRoaXMub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHsgY2IodGhpcy5nZXRCb2R5KCkpIH0pXG4gIHRoaXMuYm9keSA9IFtdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29uY2F0U3RyZWFtXG5pbmhlcml0cyhDb25jYXRTdHJlYW0sIFdyaXRhYmxlKVxuXG5Db25jYXRTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmMsIG5leHQpIHtcbiAgdGhpcy5ib2R5LnB1c2goY2h1bmspXG4gIG5leHQoKVxufVxuXG5Db25jYXRTdHJlYW0ucHJvdG90eXBlLmluZmVyRW5jb2RpbmcgPSBmdW5jdGlvbiAoYnVmZikge1xuICB2YXIgZmlyc3RCdWZmZXIgPSBidWZmID09PSB1bmRlZmluZWQgPyB0aGlzLmJvZHlbMF0gOiBidWZmO1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGZpcnN0QnVmZmVyKSkgcmV0dXJuICdidWZmZXInXG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlyc3RCdWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gJ3VpbnQ4YXJyYXknXG4gIGlmIChBcnJheS5pc0FycmF5KGZpcnN0QnVmZmVyKSkgcmV0dXJuICdhcnJheSdcbiAgaWYgKHR5cGVvZiBmaXJzdEJ1ZmZlciA9PT0gJ3N0cmluZycpIHJldHVybiAnc3RyaW5nJ1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZpcnN0QnVmZmVyKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikgcmV0dXJuICdvYmplY3QnXG4gIHJldHVybiAnYnVmZmVyJ1xufVxuXG5Db25jYXRTdHJlYW0ucHJvdG90eXBlLmdldEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5lbmNvZGluZyAmJiB0aGlzLmJvZHkubGVuZ3RoID09PSAwKSByZXR1cm4gW11cbiAgaWYgKHRoaXMuc2hvdWxkSW5mZXJFbmNvZGluZykgdGhpcy5lbmNvZGluZyA9IHRoaXMuaW5mZXJFbmNvZGluZygpXG4gIGlmICh0aGlzLmVuY29kaW5nID09PSAnYXJyYXknKSByZXR1cm4gYXJyYXlDb25jYXQodGhpcy5ib2R5KVxuICBpZiAodGhpcy5lbmNvZGluZyA9PT0gJ3N0cmluZycpIHJldHVybiBzdHJpbmdDb25jYXQodGhpcy5ib2R5KVxuICBpZiAodGhpcy5lbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHJldHVybiBidWZmZXJDb25jYXQodGhpcy5ib2R5KVxuICBpZiAodGhpcy5lbmNvZGluZyA9PT0gJ3VpbnQ4YXJyYXknKSByZXR1cm4gdThDb25jYXQodGhpcy5ib2R5KVxuICByZXR1cm4gdGhpcy5ib2R5XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKGFycikge1xuICByZXR1cm4gL0FycmF5XFxdJC8udGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSlcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXJpc2ggKHApIHtcbiAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJyB8fCBpc0FycmF5aXNoKHApIHx8IChwICYmIHR5cGVvZiBwLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdDb25jYXQgKHBhcnRzKSB7XG4gIHZhciBzdHJpbmdzID0gW11cbiAgdmFyIG5lZWRzVG9TdHJpbmcgPSBmYWxzZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBwYXJ0c1tpXVxuICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN0cmluZ3MucHVzaChwKVxuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHApKSB7XG4gICAgICBzdHJpbmdzLnB1c2gocClcbiAgICB9IGVsc2UgaWYgKGlzQnVmZmVyaXNoKHApKSB7XG4gICAgICBzdHJpbmdzLnB1c2goYnVmZmVyRnJvbShwKSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyaW5ncy5wdXNoKGJ1ZmZlckZyb20oU3RyaW5nKHApKSlcbiAgICB9XG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwYXJ0c1swXSkpIHtcbiAgICBzdHJpbmdzID0gQnVmZmVyLmNvbmNhdChzdHJpbmdzKVxuICAgIHN0cmluZ3MgPSBzdHJpbmdzLnRvU3RyaW5nKCd1dGY4JylcbiAgfSBlbHNlIHtcbiAgICBzdHJpbmdzID0gc3RyaW5ncy5qb2luKCcnKVxuICB9XG4gIHJldHVybiBzdHJpbmdzXG59XG5cbmZ1bmN0aW9uIGJ1ZmZlckNvbmNhdCAocGFydHMpIHtcbiAgdmFyIGJ1ZnMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBwYXJ0c1tpXVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocCkpIHtcbiAgICAgIGJ1ZnMucHVzaChwKVxuICAgIH0gZWxzZSBpZiAoaXNCdWZmZXJpc2gocCkpIHtcbiAgICAgIGJ1ZnMucHVzaChidWZmZXJGcm9tKHApKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZzLnB1c2goYnVmZmVyRnJvbShTdHJpbmcocCkpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChidWZzKVxufVxuXG5mdW5jdGlvbiBhcnJheUNvbmNhdCAocGFydHMpIHtcbiAgdmFyIHJlcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaC5hcHBseShyZXMsIHBhcnRzW2ldKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gdThDb25jYXQgKHBhcnRzKSB7XG4gIHZhciBsZW4gPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHBhcnRzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgcGFydHNbaV0gPSBidWZmZXJGcm9tKHBhcnRzW2ldKVxuICAgIH1cbiAgICBsZW4gKz0gcGFydHNbaV0ubGVuZ3RoXG4gIH1cbiAgdmFyIHU4ID0gbmV3IFU4KGxlbilcbiAgZm9yICh2YXIgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcGFydHNbaV1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnQubGVuZ3RoOyBqKyspIHtcbiAgICAgIHU4W29mZnNldCsrXSA9IHBhcnRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHU4XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJvcihlcnIsIGNvZGUsIHByb3BzKSB7XG4gICAgaWYgKCFlcnIgfHwgdHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHBhc3MgYW4gRXJyb3IgdG8gZXJyLWNvZGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb2RlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBwcm9wcyA9IGNvZGU7XG4gICAgICAgIGNvZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICBwcm9wcy5jb2RlID0gY29kZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXNzaWduKGVyciwgcHJvcHMpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgcHJvcHMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICBwcm9wcy5zdGFjayA9IGVyci5zdGFjaztcblxuICAgICAgICBjb25zdCBFcnJDbGFzcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgIEVyckNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGVycikpO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ24obmV3IEVyckNsYXNzKCksIHByb3BzKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRXJyb3I7XG4iLCAiZnVuY3Rpb24gUmV0cnlPcGVyYXRpb24odGltZW91dHMsIG9wdGlvbnMpIHtcbiAgLy8gQ29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCAodGltZW91dHMsIHJldHJ5Rm9yZXZlcikgc2lnbmF0dXJlXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHsgZm9yZXZlcjogb3B0aW9ucyB9O1xuICB9XG5cbiAgdGhpcy5fb3JpZ2luYWxUaW1lb3V0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGltZW91dHMpKTtcbiAgdGhpcy5fdGltZW91dHMgPSB0aW1lb3V0cztcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX21heFJldHJ5VGltZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyeVRpbWUgfHwgSW5maW5pdHk7XG4gIHRoaXMuX2ZuID0gbnVsbDtcbiAgdGhpcy5fZXJyb3JzID0gW107XG4gIHRoaXMuX2F0dGVtcHRzID0gMTtcbiAgdGhpcy5fb3BlcmF0aW9uVGltZW91dCA9IG51bGw7XG4gIHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYiA9IG51bGw7XG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICB0aGlzLl9vcGVyYXRpb25TdGFydCA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZm9yZXZlcikge1xuICAgIHRoaXMuX2NhY2hlZFRpbWVvdXRzID0gdGhpcy5fdGltZW91dHMuc2xpY2UoMCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmV0cnlPcGVyYXRpb247XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9hdHRlbXB0cyA9IDE7XG4gIHRoaXMuX3RpbWVvdXRzID0gdGhpcy5fb3JpZ2luYWxUaW1lb3V0cztcbn1cblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gIH1cblxuICB0aGlzLl90aW1lb3V0cyAgICAgICA9IFtdO1xuICB0aGlzLl9jYWNoZWRUaW1lb3V0cyA9IG51bGw7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUucmV0cnkgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gIH1cblxuICBpZiAoIWVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgaWYgKGVyciAmJiBjdXJyZW50VGltZSAtIHRoaXMuX29wZXJhdGlvblN0YXJ0ID49IHRoaXMuX21heFJldHJ5VGltZSkge1xuICAgIHRoaXMuX2Vycm9ycy51bnNoaWZ0KG5ldyBFcnJvcignUmV0cnlPcGVyYXRpb24gdGltZW91dCBvY2N1cnJlZCcpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGlzLl9lcnJvcnMucHVzaChlcnIpO1xuXG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dHMuc2hpZnQoKTtcbiAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRUaW1lb3V0cykge1xuICAgICAgLy8gcmV0cnkgZm9yZXZlciwgb25seSBrZWVwIGxhc3QgZXJyb3JcbiAgICAgIHRoaXMuX2Vycm9ycy5zcGxpY2UodGhpcy5fZXJyb3JzLmxlbmd0aCAtIDEsIHRoaXMuX2Vycm9ycy5sZW5ndGgpO1xuICAgICAgdGhpcy5fdGltZW91dHMgPSB0aGlzLl9jYWNoZWRUaW1lb3V0cy5zbGljZSgwKTtcbiAgICAgIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0cy5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2F0dGVtcHRzKys7XG5cbiAgICBpZiAoc2VsZi5fb3BlcmF0aW9uVGltZW91dENiKSB7XG4gICAgICBzZWxmLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fb3BlcmF0aW9uVGltZW91dENiKHNlbGYuX2F0dGVtcHRzKTtcbiAgICAgIH0sIHNlbGYuX29wZXJhdGlvblRpbWVvdXQpO1xuXG4gICAgICBpZiAoc2VsZi5fb3B0aW9ucy51bnJlZikge1xuICAgICAgICAgIHNlbGYuX3RpbWVvdXQudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLl9mbihzZWxmLl9hdHRlbXB0cyk7XG4gIH0sIHRpbWVvdXQpO1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLnVucmVmKSB7XG4gICAgICB0aW1lci51bnJlZigpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuYXR0ZW1wdCA9IGZ1bmN0aW9uKGZuLCB0aW1lb3V0T3BzKSB7XG4gIHRoaXMuX2ZuID0gZm47XG5cbiAgaWYgKHRpbWVvdXRPcHMpIHtcbiAgICBpZiAodGltZW91dE9wcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0ID0gdGltZW91dE9wcy50aW1lb3V0O1xuICAgIH1cbiAgICBpZiAodGltZW91dE9wcy5jYikge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uVGltZW91dENiID0gdGltZW91dE9wcy5jYjtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX29wZXJhdGlvblRpbWVvdXRDYigpO1xuICAgIH0sIHNlbGYuX29wZXJhdGlvblRpbWVvdXQpO1xuICB9XG5cbiAgdGhpcy5fb3BlcmF0aW9uU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICB0aGlzLl9mbih0aGlzLl9hdHRlbXB0cyk7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5ID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc29sZS5sb2coJ1VzaW5nIFJldHJ5T3BlcmF0aW9uLnRyeSgpIGlzIGRlcHJlY2F0ZWQnKTtcbiAgdGhpcy5hdHRlbXB0KGZuKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnNvbGUubG9nKCdVc2luZyBSZXRyeU9wZXJhdGlvbi5zdGFydCgpIGlzIGRlcHJlY2F0ZWQnKTtcbiAgdGhpcy5hdHRlbXB0KGZuKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS50cnk7XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Vycm9ycztcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5hdHRlbXB0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXR0ZW1wdHM7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUubWFpbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY291bnRzID0ge307XG4gIHZhciBtYWluRXJyb3IgPSBudWxsO1xuICB2YXIgbWFpbkVycm9yQ291bnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5fZXJyb3JzW2ldO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB2YXIgY291bnQgPSAoY291bnRzW21lc3NhZ2VdIHx8IDApICsgMTtcblxuICAgIGNvdW50c1ttZXNzYWdlXSA9IGNvdW50O1xuXG4gICAgaWYgKGNvdW50ID49IG1haW5FcnJvckNvdW50KSB7XG4gICAgICBtYWluRXJyb3IgPSBlcnJvcjtcbiAgICAgIG1haW5FcnJvckNvdW50ID0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1haW5FcnJvcjtcbn07XG4iLCAidmFyIFJldHJ5T3BlcmF0aW9uID0gcmVxdWlyZSgnLi9yZXRyeV9vcGVyYXRpb24nKTtcblxuZXhwb3J0cy5vcGVyYXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciB0aW1lb3V0cyA9IGV4cG9ydHMudGltZW91dHMob3B0aW9ucyk7XG4gIHJldHVybiBuZXcgUmV0cnlPcGVyYXRpb24odGltZW91dHMsIHtcbiAgICAgIGZvcmV2ZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JldmVyLFxuICAgICAgdW5yZWY6IG9wdGlvbnMgJiYgb3B0aW9ucy51bnJlZixcbiAgICAgIG1heFJldHJ5VGltZTogb3B0aW9ucyAmJiBvcHRpb25zLm1heFJldHJ5VGltZVxuICB9KTtcbn07XG5cbmV4cG9ydHMudGltZW91dHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIG9wdHMgPSB7XG4gICAgcmV0cmllczogMTAsXG4gICAgZmFjdG9yOiAyLFxuICAgIG1pblRpbWVvdXQ6IDEgKiAxMDAwLFxuICAgIG1heFRpbWVvdXQ6IEluZmluaXR5LFxuICAgIHJhbmRvbWl6ZTogZmFsc2VcbiAgfTtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICBvcHRzW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cblxuICBpZiAob3B0cy5taW5UaW1lb3V0ID4gb3B0cy5tYXhUaW1lb3V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaW5UaW1lb3V0IGlzIGdyZWF0ZXIgdGhhbiBtYXhUaW1lb3V0Jyk7XG4gIH1cblxuICB2YXIgdGltZW91dHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLnJldHJpZXM7IGkrKykge1xuICAgIHRpbWVvdXRzLnB1c2godGhpcy5jcmVhdGVUaW1lb3V0KGksIG9wdHMpKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9yZXZlciAmJiAhdGltZW91dHMubGVuZ3RoKSB7XG4gICAgdGltZW91dHMucHVzaCh0aGlzLmNyZWF0ZVRpbWVvdXQoaSwgb3B0cykpO1xuICB9XG5cbiAgLy8gc29ydCB0aGUgYXJyYXkgbnVtZXJpY2FsbHkgYXNjZW5kaW5nXG4gIHRpbWVvdXRzLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9KTtcblxuICByZXR1cm4gdGltZW91dHM7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVRpbWVvdXQgPSBmdW5jdGlvbihhdHRlbXB0LCBvcHRzKSB7XG4gIHZhciByYW5kb20gPSAob3B0cy5yYW5kb21pemUpXG4gICAgPyAoTWF0aC5yYW5kb20oKSArIDEpXG4gICAgOiAxO1xuXG4gIHZhciB0aW1lb3V0ID0gTWF0aC5yb3VuZChyYW5kb20gKiBvcHRzLm1pblRpbWVvdXQgKiBNYXRoLnBvdyhvcHRzLmZhY3RvciwgYXR0ZW1wdCkpO1xuICB0aW1lb3V0ID0gTWF0aC5taW4odGltZW91dCwgb3B0cy5tYXhUaW1lb3V0KTtcblxuICByZXR1cm4gdGltZW91dDtcbn07XG5cbmV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucywgbWV0aG9kcykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgbWV0aG9kcyA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoIW1ldGhvZHMpIHtcbiAgICBtZXRob2RzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtZXRob2RzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWV0aG9kICAgPSBtZXRob2RzW2ldO1xuICAgIHZhciBvcmlnaW5hbCA9IG9ialttZXRob2RdO1xuXG4gICAgb2JqW21ldGhvZF0gPSBmdW5jdGlvbiByZXRyeVdyYXBwZXIob3JpZ2luYWwpIHtcbiAgICAgIHZhciBvcCAgICAgICA9IGV4cG9ydHMub3BlcmF0aW9uKG9wdGlvbnMpO1xuICAgICAgdmFyIGFyZ3MgICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG5cbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKG9wLnJldHJ5KGVycikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG9wLm1haW5FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgICAgb3AuYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgb3JpZ2luYWwuYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0uYmluZChvYmosIG9yaWdpbmFsKTtcbiAgICBvYmpbbWV0aG9kXS5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxufTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3JldHJ5Jyk7IiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGVycmNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpO1xudmFyIHJldHJ5ID0gcmVxdWlyZSgncmV0cnknKTtcblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGlzUmV0cnlFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZXJyICYmIGVyci5jb2RlID09PSAnRVBST01JU0VSRVRSWScgJiYgaGFzT3duLmNhbGwoZXJyLCAncmV0cmllZCcpO1xufVxuXG5mdW5jdGlvbiBwcm9taXNlUmV0cnkoZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgdGVtcDtcbiAgICB2YXIgb3BlcmF0aW9uO1xuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gU3dhcCBvcHRpb25zIGFuZCBmbiB3aGVuIHVzaW5nIGFsdGVybmF0ZSBzaWduYXR1cmUgKG9wdGlvbnMsIGZuKVxuICAgICAgICB0ZW1wID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IGZuO1xuICAgICAgICBmbiA9IHRlbXA7XG4gICAgfVxuXG4gICAgb3BlcmF0aW9uID0gcmV0cnkub3BlcmF0aW9uKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgb3BlcmF0aW9uLmF0dGVtcHQoZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXRyeUVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IGVyci5yZXRyaWVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyY29kZShuZXcgRXJyb3IoJ1JldHJ5aW5nJyksICdFUFJPTUlTRVJFVFJZJywgeyByZXRyaWVkOiBlcnIgfSk7XG4gICAgICAgICAgICAgICAgfSwgbnVtYmVyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihyZXNvbHZlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmV0cnlFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyci5yZXRyaWVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ucmV0cnkoZXJyIHx8IG5ldyBFcnJvcigpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvbWlzZVJldHJ5O1xuIiwgImNvbnN0IGVycm9yQ29kZSA9IHtcbiAgZ2VuZXJpYzogJ0VSUl9HRU5FUklDX0NMSUVOVCcsXG4gIGNvbm5lY3Q6ICdFUlJfTk9UX0NPTk5FQ1RFRCcsXG4gIGJhZFBhdGg6ICdFUlJfQkFEX1BBVEgnLFxuICBwZXJtaXNzaW9uOiAnRUFDQ0VTJyxcbiAgbm90ZXhpc3Q6ICdFTk9FTlQnLFxuICBub3RkaXI6ICdFTk9URElSJyxcbn07XG5cbmNvbnN0IHRhcmdldFR5cGUgPSB7XG4gIHdyaXRlRmlsZTogMSxcbiAgcmVhZEZpbGU6IDIsXG4gIHdyaXRlRGlyOiAzLFxuICByZWFkRGlyOiA0LFxuICByZWFkT2JqOiA1LFxuICB3cml0ZU9iajogNixcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlcnJvckNvZGUsXG4gIHRhcmdldFR5cGUsXG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuY29uc3QgeyBlcnJvckNvZGUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBuZXcgRXJyb3Igb2JqZWN0IHdpdGggYSByZWZvcm1hdHRlZCBlcnJvciBtZXNzYWdlIHdoaWNoXG4gKiBpcyBhIGxpdHRsZSBtb3JlIGluZm9ybWF0aXZlIGFuZCB1c2VmdWwgdG8gdXNlcnMuXG4gKlxuICogQHBhcmFtIHtFcnJvcnxzdHJpbmd9IGVyciAtIFRoZSBFcnJvciBvYmplY3QgdGhlIG5ldyBlcnJvciB3aWxsIGJlIGJhc2VkIG9uXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cnlDb3VudCAtIEZvciB0aG9zZSBmdW5jdGlvbnMgd2hpY2ggdXNlIHJldHJ5LiBOdW1iZXIgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHMgdG8gY29tcGxldGUgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybnMge0Vycm9yfSBOZXcgZXJyb3Igd2l0aCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICovXG5mdW5jdGlvbiBmbXRFcnJvcihlcnIsIG5hbWUgPSAnc2Z0cCcsIGVDb2RlLCByZXRyeUNvdW50KSB7XG4gIGxldCBtc2cgPSAnJztcbiAgbGV0IGNvZGUgPSAnJztcbiAgbGV0IHJldHJ5ID0gcmV0cnlDb3VudFxuICAgID8gYCBhZnRlciAke3JldHJ5Q291bnR9ICR7cmV0cnlDb3VudCA+IDEgPyAnYXR0ZW1wdHMnIDogJ2F0dGVtcHQnfWBcbiAgICA6ICcnO1xuXG4gIGlmIChlcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIG1zZyA9IGAke25hbWV9OiBVbmRlZmluZWQgZXJyb3IgLSBwcm9iYWJseSBhIGJ1ZyFgO1xuICAgIGNvZGUgPSBlcnJvckNvZGUuZ2VuZXJpYztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgIG1zZyA9IGAke25hbWV9OiAke2Vycn0ke3JldHJ5fWA7XG4gICAgY29kZSA9IGVDb2RlID8gZUNvZGUgOiBlcnJvckNvZGUuZ2VuZXJpYztcbiAgfSBlbHNlIGlmIChlcnIuY3VzdG9tKSB7XG4gICAgbXNnID0gYCR7bmFtZX0tPiR7ZXJyLm1lc3NhZ2V9JHtyZXRyeX1gO1xuICAgIGNvZGUgPSBlcnIuY29kZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICBjYXNlICdFTk9URk9VTkQnOlxuICAgICAgICBtc2cgPVxuICAgICAgICAgIGAke25hbWV9OiAke2Vyci5sZXZlbH0gZXJyb3IuIGAgK1xuICAgICAgICAgIGBBZGRyZXNzIGxvb2t1cCBmYWlsZWQgZm9yIGhvc3QgJHtlcnIuaG9zdG5hbWV9JHtyZXRyeX1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0VDT05OUkVGVVNFRCc6XG4gICAgICAgIG1zZyA9XG4gICAgICAgICAgYCR7bmFtZX06ICR7ZXJyLmxldmVsfSBlcnJvci4gUmVtb3RlIGhvc3QgYXQgYCArXG4gICAgICAgICAgYCR7ZXJyLmFkZHJlc3N9IHJlZnVzZWQgY29ubmVjdGlvbiR7cmV0cnl9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFQ09OTlJFU0VUJzpcbiAgICAgICAgbXNnID1cbiAgICAgICAgICBgJHtuYW1lfTogUmVtb3RlIGhvc3QgaGFzIHJlc2V0IHRoZSBjb25uZWN0aW9uOiBgICtcbiAgICAgICAgICBgJHtlcnIubWVzc2FnZX0ke3JldHJ5fWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbXNnID0gYCR7bmFtZX06ICR7ZXJyLm1lc3NhZ2V9JHtyZXRyeX1gO1xuICAgIH1cbiAgICBjb2RlID0gZXJyLmNvZGUgPyBlcnIuY29kZSA6IGVycm9yQ29kZS5nZW5lcmljO1xuICB9XG4gIGxldCBuZXdFcnJvciA9IG5ldyBFcnJvcihtc2cpO1xuICBuZXdFcnJvci5jb2RlID0gY29kZTtcbiAgbmV3RXJyb3IuY3VzdG9tID0gdHJ1ZTtcbiAgcmV0dXJuIG5ld0Vycm9yO1xufVxuXG4vKipcbiAqIFNpbXBsZSBkZWZhdWx0IGVycm9yIGxpc3RlbmVyLiBXaWxsIHJlZm9ybWF0IHRoZSBlcnJvciBtZXNzYWdlIGFuZFxuICogdGhyb3cgYSBuZXcgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gc291cmNlIGZvciBkZWZpbmluZyBuZXcgZXJyb3JcbiAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgbmV3IGVycm9yXG4gKi9cbmZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoY2xpZW50LCBuYW1lLCByZWplY3QpIHtcbiAgbGV0IGZuID0gKGVycikgPT4ge1xuICAgIGlmIChjbGllbnQuZW5kQ2FsbGVkIHx8IGNsaWVudC5lcnJvckhhbmRsZWQpIHtcbiAgICAgIGNsaWVudC5kZWJ1Z01zZyhgJHtuYW1lfSBFcnJvcjogSWdub3JpbmcgaGFuZGxlZCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpZW50LmRlYnVnTXNnKGAke25hbWV9IEVycm9yOiBIYW5kbGluZyBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIGNsaWVudC5lcnJvckhhbmRsZWQgPSB0cnVlO1xuICAgICAgaWYgKHJlamVjdCkge1xuICAgICAgICBjbGllbnQuZGVidWdNc2coYCR7bmFtZX0gRXJyb3I6IGhhbmRsZWQgZXJyb3Igd2l0aCByZWplY3RgKTtcbiAgICAgICAgcmVqZWN0KGZtdEVycm9yKGVyciwgbmFtZSwgZXJyLmNvZGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudC5kZWJ1Z01zZyhgJHtuYW1lfSBFcnJvcjogaGFuZGxpbmcgZXJyb3Igd2l0aCB0aHJvd2ApO1xuICAgICAgICB0aHJvdyBmbXRFcnJvcihlcnIsIG5hbWUsIGVyci5jb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gZW5kTGlzdGVuZXIoY2xpZW50LCBuYW1lLCByZWplY3QpIHtcbiAgbGV0IGZuID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjbGllbnQuZW5kQ2FsbGVkIHx8IGNsaWVudC5lbmRIYW5kbGVkKSB7XG4gICAgICBjbGllbnQuZGVidWdNc2coYCR7bmFtZX0gRW5kOiBJZ25vcmluZyBleHBlY3RlZCBlbmQgZXZlbnRgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpZW50LmRlYnVnTXNnKGAke25hbWV9IEVuZDogSGFuZGxpbmcgZW5kIGV2ZW50YCk7XG4gICAgICBjbGllbnQuc2Z0cCA9IHVuZGVmaW5lZDtcbiAgICAgIGNsaWVudC5lbmRIYW5kbGVkID0gdHJ1ZTtcbiAgICAgIGlmIChyZWplY3QpIHtcbiAgICAgICAgY2xpZW50LmRlYnVnTXNnKGAke25hbWV9IEVuZDogaGFuZGxpbmcgZW5kIGV2ZW50IHdpdGggcmVqZWN0J2ApO1xuICAgICAgICByZWplY3QoZm10RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIGV2ZW50IHJhaXNlZCcsIG5hbWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudC5kZWJ1Z01zZyhgJHtuYW1lfSBFbmQ6IGhhbmRsaW5nIGVuZCBldmVudCB3aXRoIHRocm93YCk7XG4gICAgICAgIHRocm93IGZtdEVycm9yKCdVbmV4cGVjdGVkIGVuZCBldmVudCByYWlzZWQnLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY2xvc2VMaXN0ZW5lcihjbGllbnQsIG5hbWUsIHJlamVjdCkge1xuICBsZXQgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNsaWVudC5lbmRDYWxsZWQgfHwgY2xpZW50LmNsb3NlSGFuZGxlZCkge1xuICAgICAgY2xpZW50LmRlYnVnTXNnKGAke25hbWV9IENsb3NlOiBpZ25vcmluZyBleHBlY3RlZCBjbG9zZSBldmVudGApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnQuZGVidWdNc2coYCR7bmFtZX0gQ2xvc2U6IGhhbmRsaW5nIHVuZXhwZWN0ZWQgY2xvc2UgZXZlbnRgKTtcbiAgICAgIGNsaWVudC5zZnRwID0gdW5kZWZpbmVkO1xuICAgICAgY2xpZW50LmNsb3NlSGFuZGxlZCA9IHRydWU7XG4gICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgIGNsaWVudC5kZWJ1Z01zZyhgJHtuYW1lfSBDbG9zZTogaGFuZGxpbmcgY2xvc2UgZXZlbnQgd2l0aCByZWplY3RgKTtcbiAgICAgICAgcmVqZWN0KGZtdEVycm9yKCdVbmV4cGVjdGVkIGNsb3NlIGV2ZW50IHJhaXNlZCcsIG5hbWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudC5kZWJ1Z01zZyhgJHtuYW1lfSBDbG9zZTogaGFuZGxpbmcgY2xvc2UgZXZlbnQgd2l0aCB0aHJvd2ApO1xuICAgICAgICB0aHJvdyBmbXRFcnJvcignVW5leHBlY3RlZCBjbG9zZSBldmVudCByYWlzZWQnLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gYWRkVGVtcExpc3RlbmVycyhjbGllbnQsIG5hbWUsIHJlamVjdCkge1xuICBsZXQgbGlzdGVuZXJzID0ge1xuICAgIGVuZDogZW5kTGlzdGVuZXIoY2xpZW50LCBuYW1lLCByZWplY3QpLFxuICAgIGNsb3NlOiBjbG9zZUxpc3RlbmVyKGNsaWVudCwgbmFtZSwgcmVqZWN0KSxcbiAgICBlcnJvcjogZXJyb3JMaXN0ZW5lcihjbGllbnQsIG5hbWUsIHJlamVjdCksXG4gIH07XG4gIGNsaWVudC5kZWJ1Z01zZyhgJHtuYW1lfTogQWRkaW5nIHRlbXAgZXZlbnQgbGlzdGVuZXJzYCk7XG4gIGNsaWVudC5vbignZW5kJywgbGlzdGVuZXJzLmVuZCk7XG4gIGNsaWVudC5vbignY2xvc2UnLCBsaXN0ZW5lcnMuY2xvc2UpO1xuICBjbGllbnQub24oJ2Vycm9yJywgbGlzdGVuZXJzLmVycm9yKTtcbiAgcmV0dXJuIGxpc3RlbmVycztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGVtcExpc3RlbmVycyhjbGllbnQsIGxpc3RlbmVycywgbmFtZSkge1xuICBjbGllbnQuZGVidWdNc2coYCR7bmFtZX06IFJlbW92aW5nIHRlbXAgZXZlbnQgbGlzdGVuZXJzYCk7XG4gIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZW5kJywgbGlzdGVuZXJzLmVuZCk7XG4gIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcnMuY2xvc2UpO1xuICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXJzLmVycm9yKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gdmVyaWZ5IGxvY2FsIG9iamVjdCBleGlzdHMuIFJldHVybnMgYSBjaGFyYWN0ZXIgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdHlwZVxuICogdHlwZSBvZiBsb2NhbCBvYmplY3QgaWYgaXQgZXhpc3RzLCBmYWxzZSBpZiBpdCBkb2Vzbid0LlxuICpcbiAqIFJldHVybiBjb2RlczogbCA9IHN5bWJvbGljIGxpbmtcbiAqICAgICAgICAgICAgICAgLSA9IHJlZ3VsYXIgZmlsZVxuICogICAgICAgICAgICAgICBkID0gZGlyZWN0b3J5XG4gKiAgICAgICAgICAgICAgIHMgPSBzb2NrZXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggLSBwYXRoIHRvIGxvY2FsIG9iamVjdFxuICogQHJldHVybnMge3N0cmluZyB8IGJvb2xlYW59IHJldHVybnMgYSBzdHJpbmcgZm9yIG9iamVjdCB0eXBlIGlmIGl0IGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGxvY2FsRXhpc3RzKGZpbGVQYXRoKSB7XG4gIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgsIHsgdGhyb3dJZk5vRW50cnk6IGZhbHNlIH0pO1xuICBpZiAoIXN0YXRzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICByZXR1cm4gJ2QnO1xuICB9IGVsc2UgaWYgKHN0YXRzLmlzRmlsZSgpKSB7XG4gICAgcmV0dXJuICctJztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBmbXRFcnJvcihcbiAgICAgIGBCYWQgcGF0aDogJHtmaWxlUGF0aH06IHRhcmdldCBtdXN0IGJlIGEgZmlsZSBvciBkaXJlY3RvcnlgLFxuICAgICAgJ2xvY2FsRXhpc3RzJyxcbiAgICAgIGVycm9yQ29kZS5iYWRQYXRoXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcmlmeSBhY2Nlc3MgdG8gbG9jYWwgb2JqZWN0LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZm9yIHN0YXR1cywgdHlwZSxcbiAqIGRldGFpbHMgYW5kIGNvZGUuXG4gKlxuICogcmV0dXJuIG9iamVjdCB7XG4gKiAgICAgICAgICAgICAgICAgc3RhdHVzOiB0cnVlIGlmIGV4aXN0cyBhbmQgY2FuIGJlIGFjY2Vzc2VkLCBmYWxzZSBvdGhlcndpc2VcbiAqICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlIG9mIG9iamVjdCAnLScgPSBmaWxlLCAnZCcgPSBkaXIsICdsJyA9IGxpbmssICdzJyA9IHNvY2tldFxuICogICAgICAgICAgICAgICAgIGRldGFpbHM6ICdhY2Nlc3Mgb2snIGlmIG9iamVjdCBjYW4gYmUgYWNjZXNzZWQsICdub3QgZm91bmQnIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IGRvZXMgbm90IGV4aXN0LCAncGVybWlzc2lvbiBkZW5pZWQnIGlmIGFjY2VzcyBkZW5pZWRcbiAqICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvciBjb2RlIGlmIG9iamVjdCBkb2VzIG5vdCBleGlzdCBvciBwZXJtaXNzaW9uIGRlbmllZFxuICogICAgICAgICAgICAgIH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggPSBwYXRoIHRvIGxvY2FsIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgPSBhY2Nlc3MgbW9kZSAtIGVpdGhlciAncicgb3IgJ3cnLiBEZWZhdWx0cyB0byAncidcbiAqIEByZXR1cm5zIHtPYmplY3R9IHdpdGggcHJvcGVydGllcyBzdGF0dXMsIHR5cGUsIGRldGFpbHMgYW5kIGNvZGVcbiAqL1xuZnVuY3Rpb24gaGF2ZUxvY2FsQWNjZXNzKGZpbGVQYXRoLCBtb2RlID0gJ3InKSB7XG4gIGNvbnN0IGFjY2Vzc01vZGUgPVxuICAgIGZzLmNvbnN0YW50cy5GX09LIHwgKG1vZGUgPT09ICd3JykgPyBmcy5jb25zdGFudHMuV19PSyA6IGZzLmNvbnN0YW50cy5SX09LO1xuXG4gIHRyeSB7XG4gICAgZnMuYWNjZXNzU3luYyhmaWxlUGF0aCwgYWNjZXNzTW9kZSk7XG4gICAgY29uc3QgdHlwZSA9IGxvY2FsRXhpc3RzKGZpbGVQYXRoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiB0cnVlLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGRldGFpbHM6ICdhY2Nlc3MgT0snLFxuICAgICAgY29kZTogMCxcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzd2l0Y2ggKGVyci5lcnJubykge1xuICAgICAgY2FzZSAtMjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IGZhbHNlLFxuICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgZGV0YWlsczogJ25vdCBleGlzdCcsXG4gICAgICAgICAgY29kZTogLTIsXG4gICAgICAgIH07XG4gICAgICBjYXNlIC0xMzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IGZhbHNlLFxuICAgICAgICAgIHR5cGU6IGxvY2FsRXhpc3RzKGZpbGVQYXRoKSxcbiAgICAgICAgICBkZXRhaWxzOiAncGVybWlzc2lvbiBkZW5pZWQnLFxuICAgICAgICAgIGNvZGU6IC0xMyxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgLTIwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogZmFsc2UsXG4gICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICBkZXRhaWxzOiAncGFyZW50IG5vdCBhIGRpcmVjdG9yeScsXG4gICAgICAgIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogZmFsc2UsXG4gICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICBkZXRhaWxzOiBlcnIubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gdmVyaWZ5IHRoZSBvYmplY3Qgc3BlY2lmaWVkIGJ5IGZpbGVQYXRoIGNhbiBlaXRoZXIgYmUgd3JpdHRlbiB0byBvciBjcmVhdGVkXG4gKiBpZiBpdCBkb2Vucyd0IGFscmVhZHkgZXhpc3QuIElmIGl0IGRvZXMgbm90IGV4aXN0LCBjaGVja3MgdG8gc2VlIGlmIHRoZSBwYXJlbnQgZW50cnkgaW4gdGhlXG4gKiBwYXRoIGlzIGEgZGlyZWN0b3J5IGFuZCBjYW4gYmUgd3JpdHRlbiB0by4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIG9iamVjdFxuICogcmV0dXJuZWQgYnkgJ2hhdmVMb2NhbEFjY2VzcycuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVQYXRoIC0gcGF0aCB0byBvYmplY3QgdG8gYmUgY3JlYXRlZCBvciB3cml0dGVuIHRcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB3aXRoIHByb3BlcnRpZXMgc3RhdHVzLCB0eXBlLCBkZXN0aWxzIGFuZCBjb2RlXG4gKi9cbmZ1bmN0aW9uIGhhdmVMb2NhbENyZWF0ZShmaWxlUGF0aCkge1xuICBjb25zdCB7IHN0YXR1cywgZGV0YWlscywgdHlwZSB9ID0gaGF2ZUxvY2FsQWNjZXNzKGZpbGVQYXRoLCAndycpO1xuICBpZiAoIXN0YXR1cyAmJiBkZXRhaWxzID09PSAncGVybWlzc2lvbiBkZW5pZWQnKSB7XG4gICAgLy90aHJvdyBuZXcgRXJyb3IoYEJhZCBwYXRoOiAke2ZpbGVQYXRofTogcGVybWlzc2lvbiBkZW5pZWRgKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzLFxuICAgICAgZGV0YWlscyxcbiAgICAgIHR5cGUsXG4gICAgfTtcbiAgfSBlbHNlIGlmICghc3RhdHVzKSB7XG4gICAgY29uc3QgZGlyUGF0aCA9IHBhdGguZGlybmFtZShmaWxlUGF0aCk7XG4gICAgY29uc3QgbG9jYWxDaGVjayA9IGhhdmVMb2NhbEFjY2VzcyhkaXJQYXRoLCAndycpO1xuICAgIGlmIChsb2NhbENoZWNrLnN0YXR1cyAmJiBsb2NhbENoZWNrLnR5cGUgIT09ICdkJykge1xuICAgICAgLy90aHJvdyBuZXcgRXJyb3IoYEJhZCBwYXRoOiAke2RpclBhdGh9OiBub3QgYSBkaXJlY3RvcnlgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogZmFsc2UsXG4gICAgICAgIGRldGFpbHM6IGAke2RpclBhdGh9OiBub3QgYSBkaXJlY3RvcnlgLFxuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFsb2NhbENoZWNrLnN0YXR1cykge1xuICAgICAgLy90aHJvdyBuZXcgRXJyb3IoYEJhZCBwYXRoOiAke2RpclBhdGh9OiAke2xvY2FsQ2hlY2suZGV0YWlsc31gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogbG9jYWxDaGVjay5zdGF0dXMsXG4gICAgICAgIGRldGFpbHM6IGAke2RpclBhdGh9OiAke2xvY2FsQ2hlY2suZGV0YWlsc31gLFxuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiB0cnVlLFxuICAgICAgICBkZXRhaWxzOiAnYWNjZXNzIE9LJyxcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgY29kZTogMCxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHN0YXR1cywgZGV0YWlscywgdHlwZSB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBub3JtYWxpemVSZW1vdGVQYXRoKGNsaWVudCwgYVBhdGgpIHtcbiAgdHJ5IHtcbiAgICBpZiAoYVBhdGguc3RhcnRzV2l0aCgnLi4nKSkge1xuICAgICAgbGV0IHJvb3QgPSBhd2FpdCBjbGllbnQucmVhbFBhdGgoJy4uJyk7XG4gICAgICByZXR1cm4gcm9vdCArIGNsaWVudC5yZW1vdGVQYXRoU2VwICsgYVBhdGguc2xpY2UoMyk7XG4gICAgfSBlbHNlIGlmIChhUGF0aC5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgIGxldCByb290ID0gYXdhaXQgY2xpZW50LnJlYWxQYXRoKCcuJyk7XG4gICAgICByZXR1cm4gcm9vdCArIGNsaWVudC5yZW1vdGVQYXRoU2VwICsgYVBhdGguc2xpY2UoMik7XG4gICAgfVxuICAgIHJldHVybiBhUGF0aDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgZm10RXJyb3IoZXJyLCAnbm9ybWFsaXplUmVtb3RlUGF0aCcpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBzZnRwIGNvbm5lY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2xpZW50IC0gY3VycmVudCBzZnRwIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lIGdpdmVuIHRvIHRoaXMgY29ubmVjdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IC0gaWYgZGVmaW5lZCwgY2FsbCB0aGlzIHJhdGhlciB0aGFuIHRocm93XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBlcnJvclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgY29ubmVjdGlvbiBPS1xuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGhhdmVDb25uZWN0aW9uKGNsaWVudCwgbmFtZSwgcmVqZWN0KSB7XG4gIGlmICghY2xpZW50LnNmdHApIHtcbiAgICBsZXQgbmV3RXJyb3IgPSBmbXRFcnJvcihcbiAgICAgICdObyBTRlRQIGNvbm5lY3Rpb24gYXZhaWxhYmxlJyxcbiAgICAgIG5hbWUsXG4gICAgICBlcnJvckNvZGUuY29ubmVjdFxuICAgICk7XG4gICAgaWYgKHJlamVjdCkge1xuICAgICAgcmVqZWN0KG5ld0Vycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3RXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzbGVlcChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0sIG1zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmbXRFcnJvcixcbiAgZXJyb3JMaXN0ZW5lcixcbiAgZW5kTGlzdGVuZXIsXG4gIGNsb3NlTGlzdGVuZXIsXG4gIGFkZFRlbXBMaXN0ZW5lcnMsXG4gIHJlbW92ZVRlbXBMaXN0ZW5lcnMsXG4gIGhhdmVMb2NhbEFjY2VzcyxcbiAgaGF2ZUxvY2FsQ3JlYXRlLFxuICBub3JtYWxpemVSZW1vdGVQYXRoLFxuICBsb2NhbEV4aXN0cyxcbiAgaGF2ZUNvbm5lY3Rpb24sXG4gIHNsZWVwLFxufTtcbiIsICIvKipcbiAqIHNzaDIgc2Z0cCBjbGllbnQgZm9yIG5vZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgQ2xpZW50IH0gPSByZXF1aXJlKCdzc2gyJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBjb25jYXQgPSByZXF1aXJlKCdjb25jYXQtc3RyZWFtJyk7XG5jb25zdCBwcm9taXNlUmV0cnkgPSByZXF1aXJlKCdwcm9taXNlLXJldHJ5Jyk7XG5jb25zdCB7IGpvaW4sIHBhcnNlIH0gPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7XG4gIGZtdEVycm9yLFxuICBhZGRUZW1wTGlzdGVuZXJzLFxuICByZW1vdmVUZW1wTGlzdGVuZXJzLFxuICBoYXZlQ29ubmVjdGlvbixcbiAgbm9ybWFsaXplUmVtb3RlUGF0aCxcbiAgbG9jYWxFeGlzdHMsXG4gIGhhdmVMb2NhbEFjY2VzcyxcbiAgaGF2ZUxvY2FsQ3JlYXRlLFxuICBzbGVlcCxcbn0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7IGVycm9yQ29kZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY2xhc3MgU2Z0cENsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudE5hbWUpIHtcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAgICB0aGlzLnNmdHAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jbGllbnROYW1lID0gY2xpZW50TmFtZSA/IGNsaWVudE5hbWUgOiAnc2Z0cCc7XG4gICAgdGhpcy5lbmRDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVycm9ySGFuZGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xvc2VIYW5kbGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbmRIYW5kbGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZW1vdGVQYXRoU2VwID0gJy8nO1xuICAgIHRoaXMucmVtb3RlUGxhdGZvcm0gPSAndW5peCc7XG4gICAgdGhpcy5kZWJ1ZyA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuY2xpZW50Lm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmVuZENhbGxlZCB8fCB0aGlzLmNsb3NlSGFuZGxlZCkge1xuICAgICAgICAvLyB3ZSBhcmUgcHJvY2Vzc2luZyBhbiBleHBlY3RlZCBlbmQgZXZlbnQgb3IgY2xvc2UgZXZlbnQgaGFuZGxlZCBlbHNld2hlcmVcbiAgICAgICAgdGhpcy5kZWJ1Z01zZygnR2xvYmFsOiBJZ25vcmluZyBoYW5kbGVkIGNsb3NlIGV2ZW50Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlYnVnTXNnKCdHbG9iYWw6IEhhbmRsaW5nIHVuZXhwZWN0ZWQgY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgdGhpcy5zZnRwID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5jbGllbnQub24oJ2VuZCcsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmVuZENhbGxlZCB8fCB0aGlzLmVuZEhhbmRsZWQpIHtcbiAgICAgICAgLy8gZW5kIGV2ZW50IGV4cGVjdGVkIG9yIGhhbmRsZWQgZWxzZXdoZXJlXG4gICAgICAgIHRoaXMuZGVidWdNc2coJ0dsb2JhbDogSWdub3JpbmcgaGFubGRlZCBlbmQgZXZlbnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVidWdNc2coJ0dsb2JhbDogSGFuZGxpbmcgdW5leHBlY3RlZCBlbmQgZXZlbnQnKTtcbiAgICAgICAgdGhpcy5zZnRwID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5jbGllbnQub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgaWYgKHRoaXMuZW5kQ2FsbGVkIHx8IHRoaXMuZXJyb3JIYW5kbGVkKSB7XG4gICAgICAgIC8vIGVycm9yIGV2ZW50IGV4cGVjdGVkIG9yIGhhbmRsZWQgZWxzZXdoZXJlXG4gICAgICAgIHRoaXMuZGVidWdNc2coYEdsb2JhbDogSWdub3JpbmcgaGFuZGxlZCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVidWdNc2coYEdsb2JhbDsgSGFuZGxpbmcgdW5leHBlY3RlZCBlcnJvcjsgJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5zZnRwID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgc3NoMi1zZnRwLWNsaWVudDogVW5leHBlY3RlZCBlcnJvcjogJHtlcnIubWVzc2FnZX0uIEVycm9yIGNvZGU6ICR7ZXJyLmNvZGV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVidWdNc2cobXNnLCBvYmopIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgaWYgKG9iaikge1xuICAgICAgICB0aGlzLmRlYnVnKFxuICAgICAgICAgIGBDTElFTlRbJHt0aGlzLmNsaWVudE5hbWV9XTogJHttc2d9ICR7SlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAnICcpfWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVidWcoYENMSUVOVFske3RoaXMuY2xpZW50TmFtZX1dOiAke21zZ31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbGlzdG5lciB0byB0aGUgY2xpZW50IG9iamVjdC4gVGhpcyBpcyByYXJlbHkgbmVjZXNzYXJ5IGFuZCBjYW4gYmVcbiAgICogdGhlIHNvdXJjZSBvZiBlcnJvcnMuIEl0IGlzIHRoZSBjbGllbnQncyByZXNwb25zaWJpbGl0eSB0byByZW1vdmUgdGhlXG4gICAqIGxpc3RlbmVycyB3aGVuIG5vIGxvbmdlciByZXF1aXJlZC4gRmFpbHVyZSB0byBkbyBzbyBjYW4gcmVzdWx0IGluIG1lbW9yeVxuICAgKiBsZWFrcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGV2ZW50IHR5cGVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gY2FsbGVkIHdoZW4gZXZlbnQgdHJpZ2dlcnNcbiAgICovXG4gIG9uKGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmRlYnVnTXNnKGBBZGRpbmcgbGlzdGVuZXIgdG8gJHtldmVudFR5cGV9IGV2ZW50YCk7XG4gICAgdGhpcy5jbGllbnQucHJlcGVuZExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZGVidWdNc2coYFJlbW92aW5nIGxpc3RlbmVyIGZyb20gJHtldmVudFR5cGV9IGV2ZW50YCk7XG4gICAgdGhpcy5jbGllbnQucmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBfcmVzZXRFdmVudEZsYWdzKCkge1xuICAgIHRoaXMuY2xvc2VIYW5kbGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbmRIYW5kbGVkID0gZmFsc2U7XG4gICAgdGhpcy5lcnJvckhhbmRsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYXN5bmNcbiAgICpcbiAgICogQ3JlYXRlIGEgbmV3IFNGVFAgY29ubmVjdGlvbiB0byBhIHJlbW90ZSBTRlRQIHNlcnZlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gYW4gU0ZUUCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59IHdoaWNoIHdpbGwgcmVzb2x2ZSB0byBhbiBzZnRwIGNsaWVudCBvYmplY3RcbiAgICpcbiAgICovXG4gIGdldENvbm5lY3Rpb24oY29uZmlnKSB7XG4gICAgbGV0IGRvUmVhZHksIGxpc3RlbmVycztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGlzdGVuZXJzID0gYWRkVGVtcExpc3RlbmVycyh0aGlzLCAnZ2V0Q29ubmVjdGlvbicsIHJlamVjdCk7XG4gICAgICB0aGlzLmRlYnVnTXNnKCdnZXRDb25uZWN0aW9uOiBjcmVhdGVkIHByb21pc2UnKTtcbiAgICAgIGRvUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWdNc2coXG4gICAgICAgICAgJ2dldENvbm5lY3Rpb24gcmVhZHkgbGlzdGVuZXI6IGdvdCBjb25uZWN0aW9uIC0gcHJvbWlzZSByZXNvbHZlZCdcbiAgICAgICAgKTtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKCdyZWFkeScsIGRvUmVhZHkpO1xuICAgICAgdGhpcy5jbGllbnQuY29ubmVjdChjb25maWcpO1xuICAgIH0pLmZpbmFsbHkoYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5kZWJ1Z01zZygnZ2V0Q29ubmVjdGlvbjogZmluYWxseSBjbGF1c2UgZmlyZWQnKTtcbiAgICAgIGF3YWl0IHNsZWVwKDUwMCk7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkeScsIGRvUmVhZHkpO1xuICAgICAgcmVtb3ZlVGVtcExpc3RlbmVycyh0aGlzLCBsaXN0ZW5lcnMsICdnZXRDb25uZWN0aW9uJyk7XG4gICAgICB0aGlzLl9yZXNldEV2ZW50RmxhZ3MoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldFNmdHBDaGFubmVsKCkge1xuICAgIGxldCBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxpc3RlbmVycyA9IGFkZFRlbXBMaXN0ZW5lcnModGhpcywgJ2dldFNmdHBDaGFubmVsJywgcmVqZWN0KTtcbiAgICAgIHRoaXMuZGVidWdNc2coJ2dldFNmdHBDaGFubmVsOiBjcmVhdGVkIHByb21pc2UnKTtcbiAgICAgIHRoaXMuY2xpZW50LnNmdHAoKGVyciwgc2Z0cCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgZ2V0U2Z0cENoYW5uZWw6IFNGVFAgQ2hhbm5lbCBFcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICB0aGlzLmNsaWVudC5lbmQoKTtcbiAgICAgICAgICByZWplY3QoZm10RXJyb3IoZXJyLCAnZ2V0U2Z0cENoYW5uZWwnLCBlcnIuY29kZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVidWdNc2coJ2dldFNmdHBDaGFubmVsOiBTRlRQIGNoYW5uZWwgZXN0YWJsaXNoZWQnKTtcbiAgICAgICAgICB0aGlzLnNmdHAgPSBzZnRwO1xuICAgICAgICAgIHJlc29sdmUoc2Z0cCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5kZWJ1Z01zZygnZ2V0U2Z0cENoYW5uZWw6IGZpbmFsbHkgY2xhdXNlIGZpcmVkJyk7XG4gICAgICByZW1vdmVUZW1wTGlzdGVuZXJzKHRoaXMsIGxpc3RlbmVycywgJ2dldFNmdHBDaGFubmVsJyk7XG4gICAgICB0aGlzLl9yZXNldEV2ZW50RmxhZ3MoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYXN5bmNcbiAgICpcbiAgICogQ3JlYXRlIGEgbmV3IFNGVFAgY29ubmVjdGlvbiB0byBhIHJlbW90ZSBTRlRQIHNlcnZlci5cbiAgICogVGhlIGNvbm5lY3Rpb24gb3B0aW9ucyBhcmUgdGhlIHNhbWUgYXMgdGhvc2Ugb2ZmZXJlZFxuICAgKiBieSB0aGUgdW5kZXJseWluZyBTU0gyIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIGFuIFNGVFAgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSB3aGljaCB3aWxsIHJlc29sdmUgdG8gYW4gc2Z0cCBjbGllbnQgb2JqZWN0XG4gICAqXG4gICAqL1xuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICAgIHRoaXMuZGVidWcgPSBjb25maWcuZGVidWc7XG4gICAgICAgIHRoaXMuZGVidWdNc2coJ2Nvbm5lY3Q6IERlYnVnZ2luZyB0dXJuZWQgb24nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNmdHApIHtcbiAgICAgICAgdGhpcy5kZWJ1Z01zZygnY29ubmVjdDogQWxyZWFkeSBjb25uZWN0ZWQgLSByZWplY3QnKTtcbiAgICAgICAgdGhyb3cgZm10RXJyb3IoXG4gICAgICAgICAgJ0FuIGV4aXN0aW5nIFNGVFAgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGRlZmluZWQnLFxuICAgICAgICAgICdjb25uZWN0JyxcbiAgICAgICAgICBlcnJvckNvZGUuY29ubmVjdFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYXdhaXQgcHJvbWlzZVJldHJ5KFxuICAgICAgICAocmV0cnksIGF0dGVtcHQpID0+IHtcbiAgICAgICAgICB0aGlzLmRlYnVnTXNnKGBjb25uZWN0OiBDb25uZWN0IGF0dGVtcHQgJHthdHRlbXB0fWApO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbm5lY3Rpb24oY29uZmlnKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTXNnKFxuICAgICAgICAgICAgICBgZ2V0Q29ubmVjdGlvbiByZXRyeSBjYXRjaDogJHtlcnIubWVzc2FnZX0gQ29kZTogJHtlcnIuY29kZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICAgICAgICBjYXNlICdFTk9URk9VTkQnOlxuICAgICAgICAgICAgICBjYXNlICdFQ09OTlJFRlVTRUQnOlxuICAgICAgICAgICAgICBjYXNlICdFUlJfU09DS0VUX0JBRF9QT1JUJzpcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0cnkoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJldHJpZXM6IGNvbmZpZy5yZXRyaWVzIHx8IDEsXG4gICAgICAgICAgZmFjdG9yOiBjb25maWcucmV0cnlfZmFjdG9yIHx8IDIsXG4gICAgICAgICAgbWluVGltZW91dDogY29uZmlnLnJldHJ5X21pblRpbWVvdXQgfHwgMTAwMCxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFNmdHBDaGFubmVsKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlYnVnTXNnKGBjb25uZWN0OiBFcnJvciAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgdGhpcy5fcmVzZXRFdmVudEZsYWdzKCk7XG4gICAgICB0aHJvdyBmbXRFcnJvcihlcnIsICdjb25uZWN0Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBhc3luY1xuICAgKlxuICAgKiBSZXR1cm5zIHRoZSByZWFsIGFic29sdXRlIHBhdGggb24gdGhlIHJlbW90ZSBzZXJ2ZXIuIElzIGFibGUgdG8gaGFuZGxlXG4gICAqIGJvdGggJy4nIGFuZCAnLi4nIGluIHBhdGggbmFtZXMsIGJ1dCBub3QgJ34nLiBJZiB0aGUgcGF0aCBpcyByZWxhdGl2ZVxuICAgKiB0aGVuIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IGlzIHByZXBlbmRlZCB0byBjcmVhdGUgYW4gYWJzb2x1dGUgcGF0aC5cbiAgICogUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIHBhdGggZG9lcyBub3QgZXhpc3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVtb3RlUGF0aCAtIHJlbW90ZSBwYXRoLCBtYXkgYmUgcmVsYXRpdmVcbiAgICogQHJldHVybnMge1Byb21pc2U8U3RyaW5nPn0gLSByZW1vdGUgYWJzb2x1dGUgcGF0aCBvciAnJ1xuICAgKi9cbiAgcmVhbFBhdGgocmVtb3RlUGF0aCkge1xuICAgIGxldCBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxpc3RlbmVycyA9IGFkZFRlbXBMaXN0ZW5lcnModGhpcywgJ3JlYWxQYXRoJywgcmVqZWN0KTtcbiAgICAgIHRoaXMuZGVidWdNc2coYHJlYWxQYXRoIC0+ICR7cmVtb3RlUGF0aH1gKTtcbiAgICAgIGlmIChoYXZlQ29ubmVjdGlvbih0aGlzLCAncmVhbFBhdGgnLCByZWplY3QpKSB7XG4gICAgICAgIHRoaXMuc2Z0cC5yZWFscGF0aChyZW1vdGVQYXRoLCAoZXJyLCBhYnNQYXRoKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgcmVhbFBhdGggRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9IENvZGU6ICR7ZXJyLmNvZGV9YCk7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgZm10RXJyb3IoYCR7ZXJyLm1lc3NhZ2V9ICR7cmVtb3RlUGF0aH1gLCAncmVhbFBhdGgnLCBlcnIuY29kZSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgcmVhbFBhdGggPC0gJHthYnNQYXRofWApO1xuICAgICAgICAgIHJlc29sdmUoYWJzUGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgcmVtb3ZlVGVtcExpc3RlbmVycyh0aGlzLCBsaXN0ZW5lcnMsICdyZWFsUGF0aCcpO1xuICAgICAgdGhpcy5fcmVzZXRFdmVudEZsYWdzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGFzeW5jXG4gICAqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCB3b3JrZGluZyBkaXJlY3RvcnkgcGF0aFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdHJpbmc+fSAtIGN1cnJlbnQgcmVtb3RlIHdvcmtpbmcgZGlyZWN0b3J5XG4gICAqL1xuICBjd2QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhbFBhdGgoJy4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYXR0cmlidXRlcyBmb3IgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVtb3RlUGF0aCAtIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHBhdGggdG8gYSBmaWxlXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gc3RhdHMgLSBhdHRyaWJ1dGVzIGluZm9cbiAgICovXG4gIGFzeW5jIHN0YXQocmVtb3RlUGF0aCkge1xuICAgIGNvbnN0IF9zdGF0ID0gKGFQYXRoKSA9PiB7XG4gICAgICBsZXQgbGlzdGVuZXJzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGlzdGVuZXJzID0gYWRkVGVtcExpc3RlbmVycyh0aGlzLCAnX3N0YXQnLCByZWplY3QpO1xuICAgICAgICB0aGlzLmRlYnVnTXNnKGBfc3RhdDogJHthUGF0aH1gKTtcbiAgICAgICAgdGhpcy5zZnRwLnN0YXQoYVBhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgX3N0YXQ6IEVycm9yICR7ZXJyLm1lc3NhZ2V9IGNvZGU6ICR7ZXJyLmNvZGV9YCk7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDIgfHwgZXJyLmNvZGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIGZtdEVycm9yKFxuICAgICAgICAgICAgICAgICAgYE5vIHN1Y2ggZmlsZTogJHtyZW1vdGVQYXRofWAsXG4gICAgICAgICAgICAgICAgICAnX3N0YXQnLFxuICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlLm5vdGV4aXN0XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIGZtdEVycm9yKGAke2Vyci5tZXNzYWdlfSAke3JlbW90ZVBhdGh9YCwgJ19zdGF0JywgZXJyLmNvZGUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgIG1vZGU6IHN0YXRzLm1vZGUsXG4gICAgICAgICAgICAgIHVpZDogc3RhdHMudWlkLFxuICAgICAgICAgICAgICBnaWQ6IHN0YXRzLmdpZCxcbiAgICAgICAgICAgICAgc2l6ZTogc3RhdHMuc2l6ZSxcbiAgICAgICAgICAgICAgYWNjZXNzVGltZTogc3RhdHMuYXRpbWUgKiAxMDAwLFxuICAgICAgICAgICAgICBtb2RpZnlUaW1lOiBzdGF0cy5tdGltZSAqIDEwMDAsXG4gICAgICAgICAgICAgIGlzRGlyZWN0b3J5OiBzdGF0cy5pc0RpcmVjdG9yeSgpLFxuICAgICAgICAgICAgICBpc0ZpbGU6IHN0YXRzLmlzRmlsZSgpLFxuICAgICAgICAgICAgICBpc0Jsb2NrRGV2aWNlOiBzdGF0cy5pc0Jsb2NrRGV2aWNlKCksXG4gICAgICAgICAgICAgIGlzQ2hhcmFjdGVyRGV2aWNlOiBzdGF0cy5pc0NoYXJhY3RlckRldmljZSgpLFxuICAgICAgICAgICAgICBpc1N5bWJvbGljTGluazogc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSxcbiAgICAgICAgICAgICAgaXNGSUZPOiBzdGF0cy5pc0ZJRk8oKSxcbiAgICAgICAgICAgICAgaXNTb2NrZXQ6IHN0YXRzLmlzU29ja2V0KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZygnX3N0YXQ6IHN0YXRzIDwtICcsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICByZW1vdmVUZW1wTGlzdGVuZXJzKHRoaXMsIGxpc3RlbmVycywgJ19zdGF0Jyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGhhdmVDb25uZWN0aW9uKHRoaXMsICdzdGF0Jyk7XG4gICAgICBsZXQgYWJzUGF0aCA9IGF3YWl0IG5vcm1hbGl6ZVJlbW90ZVBhdGgodGhpcywgcmVtb3RlUGF0aCk7XG4gICAgICByZXR1cm4gX3N0YXQoYWJzUGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9yZXNldEV2ZW50RmxhZ3MoKTtcbiAgICAgIHRocm93IGVyci5jdXN0b20gPyBlcnIgOiBmbXRFcnJvcihlcnIsICdzdGF0JywgZXJyLmNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAYXN5bmNcbiAgICpcbiAgICogVGVzdHMgdG8gc2VlIGlmIGFuIG9iamVjdCBleGlzdHMuIElmIGl0IGRvZXMsIHJldHVybiB0aGUgdHlwZSBvZiB0aGF0IG9iamVjdFxuICAgKiAoaW4gdGhlIGZvcm1hdCByZXR1cm5lZCBieSBsaXN0KS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIHJldHVybiBmYWxzZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBwYXRoIHRvIHRoZSBvYmplY3Qgb24gdGhlIHNmdHAgc2VydmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJvb2xlYW58U3RyaW5nPn0gcmV0dXJucyBmYWxzZSBpZiBvYmplY3QgZG9lcyBub3QgZXhpc3QuIFJldHVybnMgdHlwZSBvZlxuICAgKiAgICAgICAgICAgICAgICAgICBvYmplY3QgaWYgaXQgZG9lc1xuICAgKi9cbiAgYXN5bmMgZXhpc3RzKHJlbW90ZVBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGhhdmVDb25uZWN0aW9uKHRoaXMsICdleGlzdHMnKSkge1xuICAgICAgICBpZiAocmVtb3RlUGF0aCA9PT0gJy4nKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZygnZXhpc3RzOiAuID0gZCcpO1xuICAgICAgICAgIHJldHVybiAnZCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFic1BhdGggPSBhd2FpdCBub3JtYWxpemVSZW1vdGVQYXRoKHRoaXMsIHJlbW90ZVBhdGgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuZGVidWdNc2coYGV4aXN0czogJHtyZW1vdGVQYXRofSAtPiAke2Fic1BhdGh9YCk7XG4gICAgICAgICAgbGV0IGluZm8gPSBhd2FpdCB0aGlzLnN0YXQoYWJzUGF0aCk7XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZygnZXhpc3RzOiA8LSAnLCBpbmZvKTtcbiAgICAgICAgICBpZiAoaW5mby5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgZXhpc3RzOiAke3JlbW90ZVBhdGh9ID0gZGApO1xuICAgICAgICAgICAgcmV0dXJuICdkJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZm8uaXNTeW1ib2xpY0xpbmspIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWdNc2coYGV4aXN0czogJHtyZW1vdGVQYXRofSA9IGxgKTtcbiAgICAgICAgICAgIHJldHVybiAnbCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmZvLmlzRmlsZSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgZXhpc3RzOiAke3JlbW90ZVBhdGh9ID0gLWApO1xuICAgICAgICAgICAgcmV0dXJuICctJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgZXhpc3RzOiAke3JlbW90ZVBhdGh9ID0gZmFsc2VgKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gZXJyb3JDb2RlLm5vdGV4aXN0KSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTXNnKFxuICAgICAgICAgICAgICBgZXhpc3RzOiAke3JlbW90ZVBhdGh9ID0gZmFsc2UgZXJyb3JDb2RlID0gJHtlcnIuY29kZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRlYnVnTXNnKGBleGlzdHM6IHRocm93IGVycm9yICR7ZXJyLm1lc3NhZ2V9ICR7ZXJyLmNvZGV9YCk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmRlYnVnTXNnKGBleGlzdHM6IGRlZmF1bHQgJHtyZW1vdGVQYXRofSA9IGZhbHNlYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9yZXNldEV2ZW50RmxhZ3MoKTtcbiAgICAgIHRocm93IGVyci5jdXN0b20gPyBlcnIgOiBmbXRFcnJvcihlcnIsICdleGlzdHMnLCBlcnIuY29kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBhc3luY1xuICAgKlxuICAgKiBMaXN0IGNvbnRlbnRzIG9mIGEgcmVtb3RlIGRpcmVjdG9yeS4gSWYgYSBwYXR0ZXJuIGlzIHByb3ZpZGVkLFxuICAgKiBmaWx0ZXIgdGhlIHJlc3VsdHMgdG8gb25seSBpbmNsdWRlIGZpbGVzIHdpdGggbmFtZXMgdGhhdCBtYXRjaFxuICAgKiB0aGUgc3VwcGxpZWQgcGF0dGVybi4gUmV0dXJuIHZhbHVlIGlzIGFuIGFycmF5IG9mIGZpbGUgZW50cnlcbiAgICogb2JqZWN0cyB0aGF0IGluY2x1ZGUgcHJvcGVydGllcyBmb3IgdHlwZSwgbmFtZSwgc2l6ZSwgbW9kaWZpeVRpbWUsXG4gICAqIGFjY2Vzc1RpbWUsIHJpZ2h0cyB7dXNlciwgZ3JvdXAgb3RoZXJ9LCBvd25lciBhbmQgZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZW1vdGVQYXRoIC0gcGF0aCB0byByZW1vdGUgZGlyZWN0b3J5XG4gICAqIEBwYXJhbSB7UmVnRXhwfSBwYXR0ZXJuIC0gcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGZpbGVuYW1lc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IGFycmF5IG9mIGZpbGUgZGVzY3JpcHRpb24gb2JqZWN0c1xuICAgKi9cbiAgbGlzdChyZW1vdGVQYXRoLCBwYXR0ZXJuID0gLy4qLykge1xuICAgIGxldCBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxpc3RlbmVycyA9IGFkZFRlbXBMaXN0ZW5lcnModGhpcywgJ2xpc3QnLCByZWplY3QpO1xuICAgICAgaWYgKGhhdmVDb25uZWN0aW9uKHRoaXMsICdsaXN0JywgcmVqZWN0KSkge1xuICAgICAgICBjb25zdCByZWcgPSAvLS9naTtcbiAgICAgICAgdGhpcy5kZWJ1Z01zZyhgbGlzdDogJHtyZW1vdGVQYXRofSBmaWx0ZXI6ICR7cGF0dGVybn1gKTtcbiAgICAgICAgdGhpcy5zZnRwLnJlYWRkaXIocmVtb3RlUGF0aCwgKGVyciwgZmlsZUxpc3QpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTXNnKGBsaXN0OiBFcnJvciAke2Vyci5tZXNzYWdlfSBjb2RlOiAke2Vyci5jb2RlfWApO1xuICAgICAgICAgICAgcmVqZWN0KGZtdEVycm9yKGAke2Vyci5tZXNzYWdlfSAke3JlbW90ZVBhdGh9YCwgJ2xpc3QnLCBlcnIuY29kZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3TGlzdCA9IFtdO1xuICAgICAgICAgICAgLy8gcmVzZXQgZmlsZSBpbmZvXG4gICAgICAgICAgICBpZiAoZmlsZUxpc3QpIHtcbiAgICAgICAgICAgICAgbmV3TGlzdCA9IGZpbGVMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBpdGVtLmxvbmduYW1lLnNsaWNlKDAsIDEpLFxuICAgICAgICAgICAgICAgICAgbmFtZTogaXRlbS5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgIHNpemU6IGl0ZW0uYXR0cnMuc2l6ZSxcbiAgICAgICAgICAgICAgICAgIG1vZGlmeVRpbWU6IGl0ZW0uYXR0cnMubXRpbWUgKiAxMDAwLFxuICAgICAgICAgICAgICAgICAgYWNjZXNzVGltZTogaXRlbS5hdHRycy5hdGltZSAqIDEwMDAsXG4gICAgICAgICAgICAgICAgICByaWdodHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdXNlcjogaXRlbS5sb25nbmFtZS5zbGljZSgxLCA0KS5yZXBsYWNlKHJlZywgJycpLFxuICAgICAgICAgICAgICAgICAgICBncm91cDogaXRlbS5sb25nbmFtZS5zbGljZSg0LCA3KS5yZXBsYWNlKHJlZywgJycpLFxuICAgICAgICAgICAgICAgICAgICBvdGhlcjogaXRlbS5sb25nbmFtZS5zbGljZSg3LCAxMCkucmVwbGFjZShyZWcsICcnKSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBvd25lcjogaXRlbS5hdHRycy51aWQsXG4gICAgICAgICAgICAgICAgICBncm91cDogaXRlbS5hdHRycy5naWQsXG4gICAgICAgICAgICAgICAgICBsb25nbmFtZTogaXRlbS5sb25nbmFtZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb3ZpZGUgc29tZSBjb21wYXRpYmlsaXR5IGZvciBhdXhMaXN0XG4gICAgICAgICAgICBsZXQgcmVnZXg7XG4gICAgICAgICAgICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICByZWdleCA9IHBhdHRlcm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQgbmV3UGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXFwqKFteKl0pKj8vZ2ksICcuKicpO1xuICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAobmV3UGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmlsdGVyZWRMaXN0ID0gbmV3TGlzdC5maWx0ZXIoKGl0ZW0pID0+IHJlZ2V4LnRlc3QoaXRlbS5uYW1lKSk7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTXNnKCdsaXN0OiByZXN1bHQ6ICcsIGZpbHRlcmVkTGlzdCk7XG4gICAgICAgICAgICByZXNvbHZlKGZpbHRlcmVkTGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHJlbW92ZVRlbXBMaXN0ZW5lcnModGhpcywgbGlzdGVuZXJzLCAnbGlzdCcpO1xuICAgICAgdGhpcy5fcmVzZXRFdmVudEZsYWdzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGZpbGVcbiAgICpcbiAgICogSWYgYSBkc3QgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGl0IG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nLCByZXByZXNlbnRpbmcgdGhlXG4gICAqIGxvY2FsIHBhdGggdG8gd2hlcmUgdGhlIGRhdGEgd2lsbCBiZSBwdXQsIGEgc3RyZWFtLCBpbiB3aGljaCBjYXNlIGRhdGEgaXNcbiAgICogcGlwZWQgaW50byB0aGUgc3RyZWFtIG9yIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSB0aGUgZGF0YSBpcyByZXR1cm5lZCBhc1xuICAgKiBhIEJ1ZmZlciBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZW1vdGVQYXRoIC0gcmVtb3RlIGZpbGUgcGF0aFxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJlYW18dW5kZWZpbmVkfSBkc3QgLSBkYXRhIGRlc3RpbmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBvYmplY3Qgd2l0aCBzdXBwb3J0ZWQgcHJvcGVydGllcyBvZiByZWFkU3RyZWFtT3B0aW9ucyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlU3RyZWFtT3B0aW9ucyBhbmQgcGlwZU9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nfFN0cmVhbXxCdWZmZXI+fVxuICAgKi9cbiAgZ2V0KFxuICAgIHJlbW90ZVBhdGgsXG4gICAgZHN0LFxuICAgIG9wdGlvbnMgPSB7IHJlYWRTdHJlYW1PcHRpb25zOiB7fSwgd3JpdGVTdHJlYW1PcHRpb25zOiB7fSwgcGlwZU9wdGlvbnM6IHt9IH1cbiAgKSB7XG4gICAgbGV0IHJkciwgd3RyLCBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxpc3RlbmVycyA9IGFkZFRlbXBMaXN0ZW5lcnModGhpcywgJ2dldCcsIHJlamVjdCk7XG4gICAgICBpZiAoaGF2ZUNvbm5lY3Rpb24odGhpcywgJ2dldCcsIHJlamVjdCkpIHtcbiAgICAgICAgdGhpcy5kZWJ1Z01zZyhgZ2V0IC0+ICR7cmVtb3RlUGF0aH0gYCwgb3B0aW9ucyk7XG4gICAgICAgIHJkciA9IHRoaXMuc2Z0cC5jcmVhdGVSZWFkU3RyZWFtKFxuICAgICAgICAgIHJlbW90ZVBhdGgsXG4gICAgICAgICAgb3B0aW9ucy5yZWFkU3RyZWFtT3B0aW9ucyA/IG9wdGlvbnMucmVhZFN0cmVhbU9wdGlvbnMgOiB7fVxuICAgICAgICApO1xuICAgICAgICByZHIub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGZtdEVycm9yKGAke2Vyci5tZXNzYWdlfSAke3JlbW90ZVBhdGh9YCwgJ2dldCcsIGVyci5jb2RlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZHN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBubyBkc3Qgc3BlY2lmaWVkLCByZXR1cm4gYnVmZmVyIG9mIGRhdGFcbiAgICAgICAgICB0aGlzLmRlYnVnTXNnKCdnZXQgcmV0dXJuaW5nIGJ1ZmZlciBvZiBkYXRhJyk7XG4gICAgICAgICAgd3RyID0gY29uY2F0KChidWZmKSA9PiB7XG4gICAgICAgICAgICAvL3Jkci5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJyk7XG4gICAgICAgICAgICByZXNvbHZlKGJ1ZmYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgZHN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gZHN0IGxvY2FsIGZpbGUgcGF0aFxuICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZygnZ2V0IHJldHVybmluZyBsb2NhbCBmaWxlJyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbENoZWNrID0gaGF2ZUxvY2FsQ3JlYXRlKGRzdCk7XG4gICAgICAgICAgICBpZiAoIWxvY2FsQ2hlY2suc3RhdHVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICAgICAgZm10RXJyb3IoXG4gICAgICAgICAgICAgICAgICBgQmFkIHBhdGg6ICR7ZHN0fTogJHtsb2NhbENoZWNrLmRldGFpbHN9YCxcbiAgICAgICAgICAgICAgICAgICdnZXQnLFxuICAgICAgICAgICAgICAgICAgbG9jYWxDaGVjay5jb2RlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3RyID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oXG4gICAgICAgICAgICAgIGRzdCxcbiAgICAgICAgICAgICAgb3B0aW9ucy53cml0ZVN0cmVhbU9wdGlvbnMgPyBvcHRpb25zLndyaXRlU3RyZWFtT3B0aW9ucyA6IHt9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTXNnKCdnZXQgcmV0dXJuaW5nIGRhdGEgaW50byBzdXBwbGllZCBzdHJlYW0nKTtcbiAgICAgICAgICAgIHd0ciA9IGRzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgd3RyLm9uY2UoJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBmbXRFcnJvcihcbiAgICAgICAgICAgICAgICBgJHtlcnIubWVzc2FnZX0gJHt0eXBlb2YgZHN0ID09PSAnc3RyaW5nJyA/IGRzdCA6ICcnfWAsXG4gICAgICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAgICAgZXJyLmNvZGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAncGlwZU9wdGlvbnMnKSAmJlxuICAgICAgICAgICAgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5waXBlT3B0aW9ucywgJ2VuZCcpICYmXG4gICAgICAgICAgICAhb3B0aW9ucy5waXBlT3B0aW9ucy5lbmRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJkci5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuZGVidWdNc2coJ2dldCByZXNvbHZlZCBvbiByZWFkZXIgZW5kIGV2ZW50Jyk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZHN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZHN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHd0cik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3dHIub25jZSgnZmluaXNoJywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmRlYnVnTXNnKCdnZXQgcmVzb2x2ZWQgb24gd3JpdGVyIGZpbmlzaCBldmVudCcpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGRzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRzdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh3dHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmRyLnBpcGUod3RyLCBvcHRpb25zLnBpcGVPcHRpb25zID8gb3B0aW9ucy5waXBlT3B0aW9ucyA6IHt9KTtcbiAgICAgIH1cbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHJlbW92ZVRlbXBMaXN0ZW5lcnModGhpcywgbGlzdGVuZXJzLCAnZ2V0Jyk7XG4gICAgICB0aGlzLl9yZXNldEV2ZW50RmxhZ3MoKTtcbiAgICAgIGlmIChcbiAgICAgICAgcmRyICYmXG4gICAgICAgIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdyZWFkU3RyZWFtT3B0aW9ucycpICYmXG4gICAgICAgIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucmVhZFN0cmVhbU9wdGlvbnMsICdhdXRvQ2xvc2UnKSAmJlxuICAgICAgICBvcHRpb25zLnJlYWRTdHJlYW1PcHRpb25zLmF1dG9DbG9zZSA9PT0gZmFsc2VcbiAgICAgICkge1xuICAgICAgICByZHIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICB3dHIgJiZcbiAgICAgICAgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3dyaXRlU3RyZWFtT3B0aW9ucycpICYmXG4gICAgICAgIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMud3JpdGVTdHJlYW1PcHRpb25zLCAnYXV0b0Nsb3NlJykgJiZcbiAgICAgICAgb3B0aW9ucy53cml0ZVN0cmVhbU9wdGlvbnMuYXV0b0Nsb3NlID09PSBmYWxzZSAmJlxuICAgICAgICB0eXBlb2YgZHN0ID09PSAnc3RyaW5nJ1xuICAgICAgKSB7XG4gICAgICAgIHd0ci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIFNTSDIgZmFzdEdldCBmb3IgZG93bmxvYWRpbmcgdGhlIGZpbGUuXG4gICAqIERvd25sb2FkcyBhIGZpbGUgYXQgcmVtb3RlUGF0aCB0byBsb2NhbFBhdGggdXNpbmcgcGFyYWxsZWwgcmVhZHNcbiAgICogZm9yIGZhc3RlciB0aHJvdWdocHV0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVtb3RlUGF0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jYWxQYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nPn0gdGhlIHJlc3VsdCBvZiBkb3dubG9hZGluZyB0aGUgZmlsZVxuICAgKi9cbiAgYXN5bmMgZmFzdEdldChyZW1vdGVQYXRoLCBsb2NhbFBhdGgsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnR5cGUgPSBhd2FpdCB0aGlzLmV4aXN0cyhyZW1vdGVQYXRoKTtcbiAgICAgIGlmIChmdHlwZSAhPT0gJy0nKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9XG4gICAgICAgICAgZnR5cGUgPT09IGZhbHNlXG4gICAgICAgICAgICA/IGBObyBzdWNoIGZpbGUgJHtyZW1vdGVQYXRofWBcbiAgICAgICAgICAgIDogYE5vdCBhIHJlZ3VsYXIgZmlsZSAke3JlbW90ZVBhdGh9YDtcbiAgICAgICAgbGV0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICBlcnIuY29kZSA9IGVycm9yQ29kZS5iYWRQYXRoO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2NhbENoZWNrID0gaGF2ZUxvY2FsQ3JlYXRlKGxvY2FsUGF0aCk7XG4gICAgICBpZiAoIWxvY2FsQ2hlY2suc3RhdHVzKSB7XG4gICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoYEJhZCBwYXRoOiAke2xvY2FsUGF0aH06ICR7bG9jYWxDaGVjay5kZXRhaWxzfWApO1xuICAgICAgICBlcnIuY29kZSA9IGVycm9yQ29kZS5iYWRQYXRoO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBsZXQgbGlzdGVuZXJzO1xuICAgICAgbGV0IHJzbHQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxpc3RlbmVycyA9IGFkZFRlbXBMaXN0ZW5lcnModGhpcywgJ2Zhc3RHZXQnLCByZWplY3QpO1xuICAgICAgICBpZiAoaGF2ZUNvbm5lY3Rpb24odGhpcywgJ2Zhc3RHZXQnLCByZWplY3QpKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZyhcbiAgICAgICAgICAgIGBmYXN0R2V0IC0+IHJlbW90ZTogJHtyZW1vdGVQYXRofSBsb2NhbDogJHtsb2NhbFBhdGh9IGAsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnNmdHAuZmFzdEdldChyZW1vdGVQYXRoLCBsb2NhbFBhdGgsIG9wdGlvbnMsIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgZmFzdEdldCBlcnJvciAke2Vyci5tZXNzYWdlfSBjb2RlOiAke2Vyci5jb2RlfWApO1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoYCR7cmVtb3RlUGF0aH0gd2FzIHN1Y2Nlc3NmdWxseSBkb3dubG9hZCB0byAke2xvY2FsUGF0aH0hYCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICByZW1vdmVUZW1wTGlzdGVuZXJzKHRoaXMsIGxpc3RlbmVycywgJ2Zhc3RHZXQnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJzbHQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9yZXNldEV2ZW50RmxhZ3MoKTtcbiAgICAgIHRocm93IGZtdEVycm9yKGVyciwgJ2Zhc3RHZXQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIFNTSDIgZmFzdFB1dCBmb3IgdXBsb2FkaW5nIHRoZSBmaWxlLlxuICAgKiBVcGxvYWRzIGEgZmlsZSBmcm9tIGxvY2FsUGF0aCB0byByZW1vdGVQYXRoIHVzaW5nIHBhcmFsbGVsIHJlYWRzXG4gICAqIGZvciBmYXN0ZXIgdGhyb3VnaHB1dC5cbiAgICpcbiAgICogU2VlICdmYXN0UHV0JyBhdFxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbXNjZGV4L3NzaDItc3RyZWFtcy9ibG9iL21hc3Rlci9TRlRQU3RyZWFtLm1kXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhbFBhdGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlbW90ZVBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmc+fSB0aGUgcmVzdWx0IG9mIGRvd25sb2FkaW5nIHRoZSBmaWxlXG4gICAqL1xuICBmYXN0UHV0KGxvY2FsUGF0aCwgcmVtb3RlUGF0aCwgb3B0aW9ucykge1xuICAgIGxldCBsaXN0ZW5lcnM7XG4gICAgdGhpcy5kZWJ1Z01zZyhgZmFzdFB1dCAtPiBsb2NhbCAke2xvY2FsUGF0aH0gcmVtb3RlICR7cmVtb3RlUGF0aH1gKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGlzdGVuZXJzID0gYWRkVGVtcExpc3RlbmVycyh0aGlzLCAnZmFzdFB1dCcsIHJlamVjdCk7XG4gICAgICBjb25zdCBsb2NhbENoZWNrID0gaGF2ZUxvY2FsQWNjZXNzKGxvY2FsUGF0aCk7XG4gICAgICBpZiAoIWxvY2FsQ2hlY2suc3RhdHVzKSB7XG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBmbXRFcnJvcihcbiAgICAgICAgICAgIGBCYWQgcGF0aDogJHtsb2NhbFBhdGh9OiAke2xvY2FsQ2hlY2suZGV0YWlsc31gLFxuICAgICAgICAgICAgJ2Zhc3RQdXQnLFxuICAgICAgICAgICAgbG9jYWxDaGVjay5jb2RlXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChsb2NhbENoZWNrLnN0YXR1cyAmJiBsb2NhbEV4aXN0cyhsb2NhbFBhdGgpID09PSAnZCcpIHtcbiAgICAgICAgcmVqZWN0KFxuICAgICAgICAgIGZtdEVycm9yKFxuICAgICAgICAgICAgYEJhZCBwYXRoOiAke2xvY2FsUGF0aH0gbm90IGEgcmVndWxhciBmaWxlYCxcbiAgICAgICAgICAgICdmYXN0UHV0JyxcbiAgICAgICAgICAgIGVycm9yQ29kZS5iYWRQYXRoXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChoYXZlQ29ubmVjdGlvbih0aGlzLCAnZmFzdFB1dCcsIHJlamVjdCkpIHtcbiAgICAgICAgdGhpcy5kZWJ1Z01zZyhcbiAgICAgICAgICBgZmFzdFB1dCAtPiBsb2NhbDogJHtsb2NhbFBhdGh9IHJlbW90ZTogJHtyZW1vdGVQYXRofSBvcHRzOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNmdHAuZmFzdFB1dChsb2NhbFBhdGgsIHJlbW90ZVBhdGgsIG9wdGlvbnMsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTXNnKGBmYXN0UHV0IGVycm9yICR7ZXJyLm1lc3NhZ2V9ICR7ZXJyLmNvZGV9YCk7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIGZtdEVycm9yKFxuICAgICAgICAgICAgICAgIGAke2Vyci5tZXNzYWdlfSBMb2NhbDogJHtsb2NhbFBhdGh9IFJlbW90ZTogJHtyZW1vdGVQYXRofWAsXG4gICAgICAgICAgICAgICAgJ2Zhc3RQdXQnLFxuICAgICAgICAgICAgICAgIGVyci5jb2RlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGVidWdNc2coJ2Zhc3RQdXQgZmlsZSB0cmFuc2ZlcnJlZCcpO1xuICAgICAgICAgIHJlc29sdmUoYCR7bG9jYWxQYXRofSB3YXMgc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkIHRvICR7cmVtb3RlUGF0aH0hYCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgcmVtb3ZlVGVtcExpc3RlbmVycyh0aGlzLCBsaXN0ZW5lcnMsICdmYXN0UHV0Jyk7XG4gICAgICB0aGlzLl9yZXNldEV2ZW50RmxhZ3MoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmaWxlIG9uIHRoZSByZW1vdGUgc2VydmVyLiBUaGUgJ3NyYycgYXJndW1lbnRcbiAgICogY2FuIGJlIGEgYnVmZmVyLCBzdHJpbmcgb3IgcmVhZCBzdHJlYW0uIElmICdzcmMnIGlzIGEgc3RyaW5nLCBpdFxuICAgKiBzaG91bGQgYmUgdGhlIHBhdGggdG8gYSBsb2NhbCBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd8QnVmZmVyfHN0cmVhbX0gbG9jYWxTcmMgLSBzb3VyY2UgZGF0YSB0byB1c2VcbiAgICogQHBhcmFtICB7U3RyaW5nfSByZW1vdGVQYXRoIC0gcGF0aCB0byByZW1vdGUgZmlsZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHVzZWQgZm9yIHJlYWQsIHdyaXRlIHN0cmVhbSBhbmQgcGlwZSBjb25maWd1cmF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHN1cHBvcnRlZCBieSBub2RlLiBBbGxvd2VkIHByb3BlcnRpZXMgYXJlIHJlYWRTdHJlYW1PcHRpb25zLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVN0cmVhbU9wdGlvbnMgYW5kIHBpcGVPcHRpb25zLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFN0cmluZz59XG4gICAqL1xuICBwdXQoXG4gICAgbG9jYWxTcmMsXG4gICAgcmVtb3RlUGF0aCxcbiAgICBvcHRpb25zID0ge1xuICAgICAgcmVhZFN0cmVhbU9wdGlvbnM6IHt9LFxuICAgICAgd3JpdGVTdHJlYW1PcHRpb25zOiB7IGF1dG9DbG9zZTogdHJ1ZSB9LFxuICAgICAgcGlwZU9wdGlvbnM6IHt9LFxuICAgIH1cbiAgKSB7XG4gICAgbGV0IHd0ciwgcmRyLCBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxpc3RlbmVycyA9IGFkZFRlbXBMaXN0ZW5lcnModGhpcywgJ3B1dCcsIHJlamVjdCk7XG4gICAgICBpZiAodHlwZW9mIGxvY2FsU3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBsb2NhbENoZWNrID0gaGF2ZUxvY2FsQWNjZXNzKGxvY2FsU3JjKTtcbiAgICAgICAgaWYgKCFsb2NhbENoZWNrLnN0YXR1cykge1xuICAgICAgICAgIHRoaXMuZGVidWdNc2coYHB1dDogbG9jYWwgc291cmNlIGNoZWNrIGVycm9yICR7bG9jYWxDaGVjay5kZXRhaWxzfWApO1xuICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICBmbXRFcnJvcihcbiAgICAgICAgICAgICAgYEJhZCBwYXRoOiAke2xvY2FsU3JjfTogJHtsb2NhbENoZWNrLmRldGFpbHN9YCxcbiAgICAgICAgICAgICAgJ3B1dCcsXG4gICAgICAgICAgICAgIGxvY2FsQ2hlY2suY29kZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXZlQ29ubmVjdGlvbih0aGlzLCAncHV0JykpIHtcbiAgICAgICAgd3RyID0gdGhpcy5zZnRwLmNyZWF0ZVdyaXRlU3RyZWFtKFxuICAgICAgICAgIHJlbW90ZVBhdGgsXG4gICAgICAgICAgb3B0aW9ucy53cml0ZVN0cmVhbU9wdGlvbnNcbiAgICAgICAgICAgID8geyAuLi5vcHRpb25zLndyaXRlU3RyZWFtT3B0aW9ucywgYXV0b0Nsb3NlOiB0cnVlIH1cbiAgICAgICAgICAgIDoge31cbiAgICAgICAgKTtcbiAgICAgICAgd3RyLm9uY2UoJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgIHRoaXMuZGVidWdNc2coYHB1dDogd3JpdGUgc3RyZWFtIGVycm9yICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgcmVqZWN0KGZtdEVycm9yKGAke2Vyci5tZXNzYWdlfSAke3JlbW90ZVBhdGh9YCwgJ3B1dCcsIGVyci5jb2RlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB3dHIub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZygncHV0OiBwcm9taXNlIHJlc29sdmVkJyk7XG4gICAgICAgICAgcmVzb2x2ZShgVXBsb2FkZWQgZGF0YSBzdHJlYW0gdG8gJHtyZW1vdGVQYXRofWApO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvY2FsU3JjIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZygncHV0IHNvdXJjZSBpcyBhIGJ1ZmZlcicpO1xuICAgICAgICAgIHd0ci5lbmQobG9jYWxTcmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxTcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTXNnKGBwdXQgc291cmNlIGlzIGEgZmlsZSBwYXRoOiAke2xvY2FsU3JjfWApO1xuICAgICAgICAgICAgcmRyID0gZnMuY3JlYXRlUmVhZFN0cmVhbShcbiAgICAgICAgICAgICAgbG9jYWxTcmMsXG4gICAgICAgICAgICAgIG9wdGlvbnMucmVhZFN0cmVhbU9wdGlvbnMgPyBvcHRpb25zLnJlYWRTdHJlYW1PcHRpb25zIDoge31cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWdNc2coJ3B1dCBzb3VyY2UgaXMgYSBzdHJlYW0nKTtcbiAgICAgICAgICAgIHJkciA9IGxvY2FsU3JjO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZHIub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTXNnKGBwdXQ6IHJlYWQgc3RyZWFtIGVycm9yICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIGZtdEVycm9yKFxuICAgICAgICAgICAgICAgIGAke2Vyci5tZXNzYWdlfSAke1xuICAgICAgICAgICAgICAgICAgdHlwZW9mIGxvY2FsU3JjID09PSAnc3RyaW5nJyA/IGxvY2FsU3JjIDogJydcbiAgICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICAgICAgICAncHV0JyxcbiAgICAgICAgICAgICAgICBlcnIuY29kZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJkci5waXBlKHd0ciwgb3B0aW9ucy5waXBlT3B0aW9ucyA/IG9wdGlvbnMucGlwZU9wdGlvbnMgOiB7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHJlbW92ZVRlbXBMaXN0ZW5lcnModGhpcywgbGlzdGVuZXJzLCAncHV0Jyk7XG4gICAgICB0aGlzLl9yZXNldEV2ZW50RmxhZ3MoKTtcbiAgICAgIGlmIChcbiAgICAgICAgcmRyICYmXG4gICAgICAgIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdyZWFkU3RyZWFtT3B0aW9ucycpICYmXG4gICAgICAgIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucmVhZFN0cmVhbU9wdGlvbnMsICdhdXRvQ2xvc2UnKSAmJlxuICAgICAgICBvcHRpb25zLnJlYWRTdHJlYW1PcHRpb25zLmF1dG9DbG9zZSA9PT0gZmFsc2UgJiZcbiAgICAgICAgdHlwZW9mIGxvY2FsU3JjID09PSAnc3RyaW5nJ1xuICAgICAgKSB7XG4gICAgICAgIHJkci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIHRvIGFuIGV4aXN0aW5nIHJlbW90ZSBmaWxlXG4gICAqXG4gICAqIEBwYXJhbSAge0J1ZmZlcnxzdHJlYW19IGlucHV0XG4gICAqIEBwYXJhbSAge1N0cmluZ30gcmVtb3RlUGF0aFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmc+fVxuICAgKi9cblxuICBhc3luYyBhcHBlbmQoaW5wdXQsIHJlbW90ZVBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IF9hcHBlbmQgPSAoaW5wdXQsIHJlbW90ZVBhdGgsIG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWdNc2coYGFwcGVuZCAtPiByZW1vdGU6ICR7cmVtb3RlUGF0aH0gYCwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuZmxhZ3MgPSAnYSc7XG4gICAgICAgIGxldCBzdHJlYW0gPSB0aGlzLnNmdHAuY3JlYXRlV3JpdGVTdHJlYW0ocmVtb3RlUGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZyhcbiAgICAgICAgICAgIGBhcHBlbmQ6IEVycm9yICR7ZXJyLm1lc3NhZ2V9IGFwcGVuZGluZyB0byAke3JlbW90ZVBhdGh9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVqZWN0KGZtdEVycm9yKGAke2Vyci5tZXNzYWdlfSAke3JlbW90ZVBhdGh9YCwgJ2FwcGVuZCcsIGVyci5jb2RlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGVidWdNc2coYGFwcGVuZDogZGF0YSBhcHBlbmRlZCB0byAke3JlbW90ZVBhdGh9YCk7XG4gICAgICAgICAgcmVzb2x2ZShgQXBwZW5kZWQgZGF0YSB0byAke3JlbW90ZVBhdGh9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnTXNnKCdhcHBlbmQ6IHdyaXRpbmcgZGF0YSBidWZmZXIgdG8gcmVtb3RlIGZpbGUnKTtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoaW5wdXQpO1xuICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRlYnVnTXNnKCdhcHBlbmQ6IHdyaXRpbmcgc3RyZWFtIHRvIHJlbW90ZSBmaWxlJyk7XG4gICAgICAgICAgaW5wdXQucGlwZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgbGV0IGxpc3RlbmVycztcbiAgICB0cnkge1xuICAgICAgbGlzdGVuZXJzID0gYWRkVGVtcExpc3RlbmVycyh0aGlzLCAnYXBwZW5kJyk7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmRlYnVnTXNnKCdhcHBlbmQ6IGF0dGVtcHQgdG8gYXBwZW5kIHR3byBmaWxlcyAtIHRocm93Jyk7XG4gICAgICAgIHRocm93IGZtdEVycm9yKFxuICAgICAgICAgICdDYW5ub3QgYXBwZW5kIG9uZSBmaWxlIHRvIGFub3RoZXInLFxuICAgICAgICAgICdhcHBlbmQnLFxuICAgICAgICAgIGVycm9yQ29kZS5iYWRQYXRoXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaGF2ZUNvbm5lY3Rpb24odGhpcywgJ2FwcGVuZCcpKSB7XG4gICAgICAgIGNvbnN0IGZpbGVUeXBlID0gYXdhaXQgdGhpcy5leGlzdHMocmVtb3RlUGF0aCk7XG4gICAgICAgIGlmIChmaWxlVHlwZSAmJiBmaWxlVHlwZSA9PT0gJ2QnKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgYXBwZW5kOiBFcnJvciAke3JlbW90ZVBhdGh9IG5vdCBhIGZpbGVgKTtcbiAgICAgICAgICB0aHJvdyBmbXRFcnJvcihcbiAgICAgICAgICAgIGBCYWQgcGF0aDogJHtyZW1vdGVQYXRofTogY2Fubm90IGFwcGVuZCB0byBhIGRpcmVjdG9yeWAsXG4gICAgICAgICAgICAnYXBwZW5kJyxcbiAgICAgICAgICAgIGVycm9yQ29kZS5iYWRQYXRoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBfYXBwZW5kKGlucHV0LCByZW1vdGVQYXRoLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlLmN1c3RvbSA/IGUgOiBmbXRFcnJvcihlLm1lc3NhZ2UsICdhcHBlbmQnLCBlLmNvZGUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZW1vdmVUZW1wTGlzdGVuZXJzKHRoaXMsIGxpc3RlbmVycywgJ2FwcGVuZCcpO1xuICAgICAgdGhpcy5fcmVzZXRFdmVudEZsYWdzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBhc3luY1xuICAgKlxuICAgKiBNYWtlIGEgZGlyZWN0b3J5IG9uIHJlbW90ZSBzZXJ2ZXJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSByZW1vdGUgZGlyZWN0b3J5IHBhdGguXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIC0gaWYgdHJ1ZSwgcmVjdXJzaXZlbHkgY3JlYXRlIGRpcmVjdG9yaWVzXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nPn1cbiAgICovXG4gIGFzeW5jIG1rZGlyKHJlbW90ZVBhdGgsIHJlY3Vyc2l2ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgX21rZGlyID0gKHApID0+IHtcbiAgICAgIGxldCBsaXN0ZW5lcnM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsaXN0ZW5lcnMgPSBhZGRUZW1wTGlzdGVuZXJzKHRoaXMsICdfbWtkaXInLCByZWplY3QpO1xuICAgICAgICB0aGlzLmRlYnVnTXNnKGBfbWtkaXI6IGNyZWF0ZSAke3B9YCk7XG4gICAgICAgIHRoaXMuc2Z0cC5ta2RpcihwLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgX21rZGlyOiBFcnJvciAke2Vyci5tZXNzYWdlfSBjb2RlOiAke2Vyci5jb2RlfWApO1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSA0KSB7XG4gICAgICAgICAgICAgIC8vZml4IGZvciB3aW5kb3dzIGRvZGd5IGVycm9yIG1lc3NhZ2VzXG4gICAgICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcihgQmFkIHBhdGg6ICR7cH0gcGVybWlzc2lvbiBkZW5pZWRgKTtcbiAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IGVycm9yQ29kZS5iYWRQYXRoO1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gMikge1xuICAgICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEJhZCBwYXRoOiAke3B9IHBhcmVudCBub3QgYSBkaXJlY3Rvcnkgb3Igbm90IGV4aXN0YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBlcnJvci5jb2RlID0gZXJyb3JDb2RlLmJhZFBhdGg7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZygnX21rZGlyOiBkaXJlY3RvcnkgY3JlYXRlZCcpO1xuICAgICAgICAgICAgcmVzb2x2ZShgJHtwfSBkaXJlY3RvcnkgY3JlYXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVGVtcExpc3RlbmVycyh0aGlzLCBsaXN0ZW5lcnMsICdfbWtkaXInKTtcbiAgICAgICAgdGhpcy5fcmVzZXRFdmVudEZsYWdzKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGhhdmVDb25uZWN0aW9uKHRoaXMsICdta2RpcicpO1xuICAgICAgbGV0IHJQYXRoID0gYXdhaXQgbm9ybWFsaXplUmVtb3RlUGF0aCh0aGlzLCByZW1vdGVQYXRoKTtcbiAgICAgIGxldCB0YXJnZXRFeGlzdHMgPSBhd2FpdCB0aGlzLmV4aXN0cyhyUGF0aCk7XG4gICAgICBpZiAodGFyZ2V0RXhpc3RzICYmIHRhcmdldEV4aXN0cyAhPT0gJ2QnKSB7XG4gICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcihgQmFkIHBhdGg6ICR7clBhdGh9IGFscmVhZHkgZXhpc3RzIGFzIGEgZmlsZWApO1xuICAgICAgICBlcnJvci5jb2RlID0gZXJyb3JDb2RlLmJhZFBhdGg7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXRFeGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIGAke3JQYXRofSBhbHJlYWR5IGV4aXN0c2A7XG4gICAgICB9XG4gICAgICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX21rZGlyKHJQYXRoKTtcbiAgICAgIH1cbiAgICAgIGxldCBkaXIgPSBwYXJzZShyUGF0aCkuZGlyO1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICBsZXQgZGlyRXhpc3RzID0gYXdhaXQgdGhpcy5leGlzdHMoZGlyKTtcbiAgICAgICAgaWYgKCFkaXJFeGlzdHMpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLm1rZGlyKGRpciwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyRXhpc3RzICE9PSAnZCcpIHtcbiAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoYEJhZCBwYXRoOiAke2Rpcn0gbm90IGEgZGlyZWN0b3J5YCk7XG4gICAgICAgICAgZXJyb3IuY29kZSA9IGVycm9yQ29kZS5iYWRQYXRoO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgX21rZGlyKHJQYXRoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGZtdEVycm9yKGAke2Vyci5tZXNzYWdlfWAsICdta2RpcicsIGVyci5jb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGFzeW5jXG4gICAqXG4gICAqIFJlbW92ZSBkaXJlY3Rvcnkgb24gcmVtb3RlIHNlcnZlclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIHBhdGggdG8gZGlyZWN0b3J5IHRvIGJlIHJlbW92ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSByZWN1cnNpdmUgLSBpZiB0cnVlLCByZW1vdmUgZGlyZWN0b3JpZXMvZmlsZXMgaW4gdGFyZ2V0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RvcnlcbiAgICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmc+fVxuICAgKi9cbiAgYXN5bmMgcm1kaXIocmVtb3RlUGF0aCwgcmVjdXJzaXZlID0gZmFsc2UpIHtcbiAgICBjb25zdCBfZGVsZXRlID0gKHJlbW90ZVBhdGgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuc2Z0cC51bmxpbmsocmVtb3RlUGF0aCwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09IDIpIHtcbiAgICAgICAgICAgIHJlamVjdChmbXRFcnJvcihgJHtlcnIubWVzc2FnZX0gJHtyZW1vdGVQYXRofWAsICdybWRpcicsIGVyci5jb2RlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IF9ybWRpciA9IChwKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnTXNnKGBybWRpciAtPiAke3B9YCk7XG4gICAgICAgIHRoaXMuc2Z0cC5ybWRpcihwLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgcm1kaXIgZXJyb3IgJHtlcnIubWVzc2FnZX0gY29kZTogJHtlcnIuY29kZX1gKTtcbiAgICAgICAgICAgIHJlamVjdChmbXRFcnJvcihgJHtlcnIubWVzc2FnZX0gJHtwfWAsICdybWRpcicsIGVyci5jb2RlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoJ1N1Y2Nlc3NmdWxseSByZW1vdmVkIGRpcmVjdG9yeScpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICByZW1vdmVUZW1wTGlzdGVuZXJzKHRoaXMsIGxpc3RlbmVycywgJ19ybWRpcicpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IF9kb3JtZGlyID0gYXN5bmMgKHAsIHJlY3VyKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocmVjdXIpIHtcbiAgICAgICAgICBsZXQgbGlzdCA9IGF3YWl0IHRoaXMubGlzdChwKTtcbiAgICAgICAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaWxlcyA9IGxpc3QuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnR5cGUgIT09ICdkJyk7XG4gICAgICAgICAgICBsZXQgZGlycyA9IGxpc3QuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09ICdkJyk7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTXNnKCdybWRpciBjb250ZW50cyAoZmlsZXMpOiAnLCBmaWxlcyk7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTXNnKCdybWRpciBjb250ZW50cyAoZGlycyk6ICcsIGRpcnMpO1xuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkaXJzKSB7XG4gICAgICAgICAgICAgIGF3YWl0IF9kb3JtZGlyKGAke3B9JHt0aGlzLnJlbW90ZVBhdGhTZXB9JHtkLm5hbWV9YCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJvbWlzZUxpc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGYgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZUxpc3QucHVzaChfZGVsZXRlKGAke3B9JHt0aGlzLnJlbW90ZVBhdGhTZXB9JHtmLm5hbWV9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZUxpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgX3JtZGlyKHApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVyci5jdXN0b20gPyBlcnIgOiBmbXRFcnJvcihlcnIsICdfZG9ybWRpcicsIGVyci5jb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGxpc3RlbmVycztcbiAgICB0cnkge1xuICAgICAgbGlzdGVuZXJzID0gYWRkVGVtcExpc3RlbmVycyh0aGlzLCAncm1kaXInKTtcbiAgICAgIGhhdmVDb25uZWN0aW9uKHRoaXMsICdybWRpcicpO1xuICAgICAgbGV0IGFic1BhdGggPSBhd2FpdCBub3JtYWxpemVSZW1vdGVQYXRoKHRoaXMsIHJlbW90ZVBhdGgpO1xuICAgICAgbGV0IGRpclN0YXR1cyA9IGF3YWl0IHRoaXMuZXhpc3RzKGFic1BhdGgpO1xuICAgICAgaWYgKGRpclN0YXR1cyAmJiBkaXJTdGF0dXMgIT09ICdkJykge1xuICAgICAgICB0aHJvdyBmbXRFcnJvcihcbiAgICAgICAgICBgQmFkIHBhdGg6ICR7YWJzUGF0aH0gbm90IGEgZGlyZWN0b3J5YCxcbiAgICAgICAgICAncm1kaXInLFxuICAgICAgICAgIGVycm9yQ29kZS5iYWRQYXRoXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKCFkaXJTdGF0dXMpIHtcbiAgICAgICAgdGhyb3cgZm10RXJyb3IoXG4gICAgICAgICAgYEJhZCBwYXRoOiAke2Fic1BhdGh9IE5vIHN1Y2ggZmlsZWAsXG4gICAgICAgICAgJ3JtZGlyJyxcbiAgICAgICAgICBlcnJvckNvZGUuYmFkUGF0aFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9kb3JtZGlyKGFic1BhdGgsIHJlY3Vyc2l2ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9yZXNldEV2ZW50RmxhZ3MoKTtcbiAgICAgIHRocm93IGVyci5jdXN0b20gPyBlcnIgOiBmbXRFcnJvcihlcnIsICdybWRpcicsIGVyci5jb2RlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVtb3ZlVGVtcExpc3RlbmVycyh0aGlzLCBsaXN0ZW5lcnMsICdybWRpcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAYXN5bmNcbiAgICpcbiAgICogRGVsZXRlIGEgZmlsZSBvbiB0aGUgcmVtb3RlIFNGVFAgc2VydmVyXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gcGF0aCB0byB0aGUgZmlsZSB0byBkZWxldGVcbiAgICogQHBhcmFtIHtib29sZWFufSBub3RGb3VuZE9LIC0gaWYgdHJ1ZSwgaWdub3JlIGVycm9ycyBmb3IgbWlzc2luZyB0YXJnZXQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nPn0gd2l0aCBzdHJpbmcgJ1N1Y2Nlc3NmdWxseSBkZWxldGVkIGZpbGUnIG9uY2UgcmVzb2x2ZWRcbiAgICpcbiAgICovXG4gIGRlbGV0ZShyZW1vdGVQYXRoLCBub3RGb3VuZE9LID0gZmFsc2UpIHtcbiAgICBsZXQgbGlzdGVuZXJzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsaXN0ZW5lcnMgPSBhZGRUZW1wTGlzdGVuZXJzKHRoaXMsICdkZWxldGUnLCByZWplY3QpO1xuICAgICAgaWYgKGhhdmVDb25uZWN0aW9uKHRoaXMsICdkZWxldGUnLCByZWplY3QpKSB7XG4gICAgICAgIHRoaXMuZGVidWdNc2coYGRlbGV0ZSAtPiAke3JlbW90ZVBhdGh9YCk7XG4gICAgICAgIHRoaXMuc2Z0cC51bmxpbmsocmVtb3RlUGF0aCwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWdNc2coYGRlbGV0ZSBlcnJvciAke2Vyci5tZXNzYWdlfSBjb2RlOiAke2Vyci5jb2RlfWApO1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kT0sgJiYgZXJyLmNvZGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZygnZGVsZXRlIGlnbm9yZSBtaXNzaW5nIHRhcmdldCBlcnJvcicpO1xuICAgICAgICAgICAgICByZXNvbHZlKGBTdWNjZXNzZnVsbHkgZGVsZXRlZCAke3JlbW90ZVBhdGh9YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgZm10RXJyb3IoYCR7ZXJyLm1lc3NhZ2V9ICR7cmVtb3RlUGF0aH1gLCAnZGVsZXRlJywgZXJyLmNvZGUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoYFN1Y2Nlc3NmdWxseSBkZWxldGVkICR7cmVtb3RlUGF0aH1gKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICByZW1vdmVUZW1wTGlzdGVuZXJzKHRoaXMsIGxpc3RlbmVycywgJ2RlbGV0ZScpO1xuICAgICAgdGhpcy5fcmVzZXRFdmVudEZsYWdzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGFzeW5jXG4gICAqXG4gICAqIFJlbmFtZSBhIGZpbGUgb24gdGhlIHJlbW90ZSBTRlRQIHJlcG9zaXRvcnlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21QYXRoIC0gcGF0aCB0byB0aGUgZmlsZSB0byBiZSByZW5hbWVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9QYXRoIC0gcGF0aCB0byB0aGUgbmV3IG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nPn1cbiAgICpcbiAgICovXG4gIHJlbmFtZShmcm9tUGF0aCwgdG9QYXRoKSB7XG4gICAgbGV0IGxpc3RlbmVycztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGlzdGVuZXJzID0gYWRkVGVtcExpc3RlbmVycyh0aGlzLCAncmVuYW1lJywgcmVqZWN0KTtcbiAgICAgIGlmIChoYXZlQ29ubmVjdGlvbih0aGlzLCAncmVuYW1lJywgcmVqZWN0KSkge1xuICAgICAgICB0aGlzLmRlYnVnTXNnKGByZW5hbWUgLT4gJHtmcm9tUGF0aH0gJHt0b1BhdGh9YCk7XG4gICAgICAgIHRoaXMuc2Z0cC5yZW5hbWUoZnJvbVBhdGgsIHRvUGF0aCwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWdNc2coYHJlbmFtZSBlcnJvciAke2Vyci5tZXNzYWdlfSBjb2RlOiAke2Vyci5jb2RlfWApO1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBmbXRFcnJvcihcbiAgICAgICAgICAgICAgICBgJHtlcnIubWVzc2FnZX0gRnJvbTogJHtmcm9tUGF0aH0gVG86ICR7dG9QYXRofWAsXG4gICAgICAgICAgICAgICAgJ3JlbmFtZScsXG4gICAgICAgICAgICAgICAgZXJyLmNvZGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShgU3VjY2Vzc2Z1bGx5IHJlbmFtZWQgJHtmcm9tUGF0aH0gdG8gJHt0b1BhdGh9YCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgcmVtb3ZlVGVtcExpc3RlbmVycyh0aGlzLCBsaXN0ZW5lcnMsICdyZW5hbWUnKTtcbiAgICAgIHRoaXMuX3Jlc2V0RXZlbnRGbGFncygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhc3luY1xuICAgKlxuICAgKiBSZW5hbWUgYSBmaWxlIG9uIHRoZSByZW1vdGUgU0ZUUCByZXBvc2l0b3J5IHVzaW5nIHRoZSBTU0ggZXh0ZW5zaW9uXG4gICAqIHBvc2l4LXJlbmFtZUBvcGVuc3NoLmNvbSB1c2luZyBQT1NJWCBhdG9taWMgcmVuYW1lLiAoSW50cm9kdWNlZCBpbiBTU0ggNC44KVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVBhdGggLSBwYXRoIHRvIHRoZSBmaWxlIHRvIGJlIHJlbmFtZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b1BhdGggLSBwYXRoICB0aGUgbmV3IG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nPn1cbiAgICpcbiAgICovXG4gIHBvc2l4UmVuYW1lKGZyb21QYXRoLCB0b1BhdGgpIHtcbiAgICBsZXQgbGlzdGVuZXJzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsaXN0ZW5lcnMgPSBhZGRUZW1wTGlzdGVuZXJzKHRoaXMsICdwb3NpeFJlbmFtZScsIHJlamVjdCk7XG4gICAgICBpZiAoaGF2ZUNvbm5lY3Rpb24odGhpcywgJ3Bvc2l4UmVuYW1lJywgcmVqZWN0KSkge1xuICAgICAgICB0aGlzLmRlYnVnTXNnKGBwb3NpeFJlbmFtZSAtPiAke2Zyb21QYXRofSAke3RvUGF0aH1gKTtcbiAgICAgICAgdGhpcy5zZnRwLmV4dF9vcGVuc3NoX3JlbmFtZShmcm9tUGF0aCwgdG9QYXRoLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z01zZyhgcG9zaXhSZW5hbWUgZXJyb3IgJHtlcnIubWVzc2FnZX0gY29kZTogJHtlcnIuY29kZX1gKTtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgZm10RXJyb3IoXG4gICAgICAgICAgICAgICAgYCR7ZXJyLm1lc3NhZ2V9IEZyb206ICR7ZnJvbVBhdGh9IFRvOiAke3RvUGF0aH1gLFxuICAgICAgICAgICAgICAgICdwb3NpeFJlbmFtZScsXG4gICAgICAgICAgICAgICAgZXJyLmNvZGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShgU3VjY2Vzc2Z1bCBQT1NJWCByZW5hbWUgJHtmcm9tUGF0aH0gdG8gJHt0b1BhdGh9YCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgcmVtb3ZlVGVtcExpc3RlbmVycyh0aGlzLCBsaXN0ZW5lcnMsICdwb3NpeFJlbmFtZScpO1xuICAgICAgdGhpcy5fcmVzZXRFdmVudEZsYWdzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGFzeW5jXG4gICAqXG4gICAqIENoYW5nZSB0aGUgbW9kZSBvZiBhIHJlbW90ZSBmaWxlIG9uIHRoZSBTRlRQIHJlcG9zaXRvcnlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBwYXRoIHRvIHRoZSByZW1vdGUgdGFyZ2V0IG9iamVjdC5cbiAgICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmd9IG1vZGUgLSB0aGUgbmV3IG9jdGFsIG1vZGUgdG8gc2V0XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nPn1cbiAgICovXG4gIGNobW9kKHJlbW90ZVBhdGgsIG1vZGUpIHtcbiAgICBsZXQgbGlzdGVuZXJzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsaXN0ZW5lcnMgPSBhZGRUZW1wTGlzdGVuZXJzKHRoaXMsICdjaG1vZCcsIHJlamVjdCk7XG4gICAgICB0aGlzLmRlYnVnTXNnKGBjaG1vZCAtPiAke3JlbW90ZVBhdGh9ICR7bW9kZX1gKTtcbiAgICAgIHRoaXMuc2Z0cC5jaG1vZChyZW1vdGVQYXRoLCBtb2RlLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZm10RXJyb3IoYCR7ZXJyLm1lc3NhZ2V9ICR7cmVtb3RlUGF0aH1gLCAnY2htb2QnLCBlcnIuY29kZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoJ1N1Y2Nlc3NmdWxseSBjaGFuZ2UgZmlsZSBtb2RlJyk7XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHJlbW92ZVRlbXBMaXN0ZW5lcnModGhpcywgbGlzdGVuZXJzLCAnY2htb2QnKTtcbiAgICAgIHRoaXMuX3Jlc2V0RXZlbnRGbGFncygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhc3luY1xuICAgKlxuICAgKiBVcGxvYWQgdGhlIHNwZWNpZmllZCBzb3VyY2UgZGlyZWN0b3J5IHRvIHRoZSBzcGVjaWZpZWQgZGVzdGluYXRpb25cbiAgICogZGlyZWN0b3J5LiBBbGwgcmVndWxhciBmaWxlcyBhbmQgc3ViLWRpcmVjdG9yaWVzIGFyZSB1cGxvYWRlZCB0byB0aGUgcmVtb3RlXG4gICAqIHNlcnZlci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY0RpciAtIGxvY2FsIHNvdXJjZSBkaXJlY3RvcnlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRzdERpciAtIHJlbW90ZSBkZXN0aW5hdGlvbiBkaXJlY3RvcnlcbiAgICogQHBhcmFtIHtmdW5jdGlvbihTdHJpbmcsQm9vbGVhbik6Qm9vbGVhbn0gZmlsdGVyIC0gKE9wdGlvbmFsKSBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGZ1bGwgcGF0aCBvZiB0aGUgaXRlbSB0byBiZSB1cGxvYWRlZCBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBhIGJvb2xlYW4sIHdoaWNoIHdpbGwgYmUgdHJ1ZSBpZiB0aGUgdGFyZ2V0IHBhdGggaXMgZm9yIGEgZGlyZWN0b3J5LiAgSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIGl0ZW0gd2lsbCBiZSB1cGxvYWRlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdHJpbmc+fVxuICAgKi9cbiAgYXN5bmMgdXBsb2FkRGlyKHNyY0RpciwgZHN0RGlyLCBmaWx0ZXIpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5kZWJ1Z01zZyhgdXBsb2FkRGlyIC0+IFNSQyA9ICR7c3JjRGlyfSBEU1QgPSAke2RzdERpcn1gKTtcbiAgICAgIGhhdmVDb25uZWN0aW9uKHRoaXMsICd1cGxvYWREaXInKTtcbiAgICAgIC8vbGV0IGFic1NyY0RpciA9IGZzLnJlYWxwYXRoU3luYyhzcmNEaXIpO1xuICAgICAgbGV0IGFic0RzdERpciA9IGF3YWl0IG5vcm1hbGl6ZVJlbW90ZVBhdGgodGhpcywgZHN0RGlyKTtcblxuICAgICAgdGhpcy5kZWJ1Z01zZyhgdXBsb2FkRGlyIDwtIFNSQyA9ICR7c3JjRGlyfSBEU1QgPSAke2Fic0RzdERpcn1gKTtcbiAgICAgIGNvbnN0IHNyY1R5cGUgPSBsb2NhbEV4aXN0cyhzcmNEaXIpO1xuICAgICAgaWYgKCFzcmNUeXBlKSB7XG4gICAgICAgIHRocm93IGZtdEVycm9yKFxuICAgICAgICAgIGBCYWQgcGF0aDogJHtzcmNEaXJ9IG5vdCBleGlzdGAsXG4gICAgICAgICAgJ3VwbG9hZERpcicsXG4gICAgICAgICAgZXJyb3JDb2RlLmJhZFBhdGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcmNUeXBlICE9PSAnZCcpIHtcbiAgICAgICAgdGhyb3cgZm10RXJyb3IoXG4gICAgICAgICAgYEJhZCBwYXRoOiAke3NyY0Rpcn06IG5vdCBhIGRpcmVjdG9yeWAsXG4gICAgICAgICAgJ3VwbG9hZERpcicsXG4gICAgICAgICAgZXJyb3JDb2RlLmJhZFBhdGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGxldCBkc3RTdGF0dXMgPSBhd2FpdCB0aGlzLmV4aXN0cyhhYnNEc3REaXIpO1xuICAgICAgaWYgKGRzdFN0YXR1cyAmJiBkc3RTdGF0dXMgIT09ICdkJykge1xuICAgICAgICB0aGlzLmRlYnVnTXNnKGBVcGxvYWREaXI6IERTVCAke2Fic0RzdERpcn0gZXhpc3RzIGJ1dCBub3QgYSBkaXJlY3RvcnlgKTtcbiAgICAgICAgdGhyb3cgZm10RXJyb3IoXG4gICAgICAgICAgYEJhZCBwYXRoICR7YWJzRHN0RGlyfSBOb3QgYSBkaXJlY3RvcnlgLFxuICAgICAgICAgICd1cGxvYWREaXInLFxuICAgICAgICAgIGVycm9yQ29kZS5iYWRQYXRoXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIWRzdFN0YXR1cykge1xuICAgICAgICB0aGlzLmRlYnVnTXNnKGBVcGxvYWREaXI6IENyZWF0aW5nIGRpcmVjdG9yeSAke2Fic0RzdERpcn1gKTtcbiAgICAgICAgYXdhaXQgdGhpcy5ta2RpcihhYnNEc3REaXIsIHRydWUpO1xuICAgICAgfVxuICAgICAgbGV0IGRpckVudHJpZXMgPSBmcy5yZWFkZGlyU3luYyhzcmNEaXIsIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgd2l0aEZpbGVUeXBlczogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICBkaXJFbnRyaWVzID0gZGlyRW50cmllcy5maWx0ZXIoKGl0ZW0pID0+XG4gICAgICAgICAgZmlsdGVyKGpvaW4oc3JjRGlyLCBpdGVtLm5hbWUpLCBpdGVtLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBlIG9mIGRpckVudHJpZXMpIHtcbiAgICAgICAgbGV0IG5ld1NyYyA9IGpvaW4oc3JjRGlyLCBlLm5hbWUpO1xuICAgICAgICBsZXQgbmV3RHN0ID0gYCR7YWJzRHN0RGlyfSR7dGhpcy5yZW1vdGVQYXRoU2VwfSR7ZS5uYW1lfWA7XG4gICAgICAgIGlmIChlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZERpcihuZXdTcmMsIG5ld0RzdCwgZmlsdGVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmlzRmlsZSgpKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wdXQobmV3U3JjLCBuZXdEc3QpO1xuICAgICAgICAgIHRoaXMuY2xpZW50LmVtaXQoJ3VwbG9hZCcsIHsgc291cmNlOiBuZXdTcmMsIGRlc3RpbmF0aW9uOiBuZXdEc3QgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZyhcbiAgICAgICAgICAgIGB1cGxvYWREaXI6IEZpbGUgaWdub3JlZDogJHtlLm5hbWV9IG5vdCBhIHJlZ3VsYXIgZmlsZWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7c3JjRGlyfSB1cGxvYWRlZCB0byAke2Fic0RzdERpcn1gO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fcmVzZXRFdmVudEZsYWdzKCk7XG4gICAgICB0aHJvdyBlcnIuY3VzdG9tID8gZXJyIDogZm10RXJyb3IoZXJyLCAndXBsb2FkRGlyJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBhc3luY1xuICAgKlxuICAgKiBEb3dubG9hZCB0aGUgc3BlY2lmaWVkIHNvdXJjZSBkaXJlY3RvcnkgdG8gdGhlIHNwZWNpZmllZCBkZXN0aW5hdGlvblxuICAgKiBkaXJlY3RvcnkuIEFsbCByZWd1bGFyIGZpbGVzIGFuZCBzdWItZGlyZWN0b3JpZXMgYXJlIGRvd25sb2FkZWQgdG8gdGhlIGxvY2FsXG4gICAqIGZpbGUgc3lzdGVtLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjRGlyIC0gcmVtb3RlIHNvdXJjZSBkaXJlY3RvcnlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRzdERpciAtIGxvY2FsIGRlc3RpbmF0aW9uIGRpcmVjdG9yeVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFN0cmluZyxCb29sZWFuKTpCb29sZWFufSBmaWx0ZXIgLSAoT3B0aW9uYWwpIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVsbCBwYXRoIG9mIHRoZSBpdGVtIHRvIGJlIGRvd25sb2FkZWQgYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYSBib29sZWFuLCB3aGljaCB3aWxsIGJlIHRydWUgaWYgdGhlIHRhcmdldCBwYXRoIGlzIGZvciBhIGRpcmVjdG9yeS4gIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIHRoZSBpdGVtIHdpbGwgYmUgZG93bmxvYWRlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdHJpbmc+fVxuICAgKi9cbiAgYXN5bmMgZG93bmxvYWREaXIoc3JjRGlyLCBkc3REaXIsIGZpbHRlcikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmRlYnVnTXNnKGBkb3dubG9hZERpciAtPiAke3NyY0Rpcn0gJHtkc3REaXJ9YCk7XG4gICAgICBoYXZlQ29ubmVjdGlvbih0aGlzLCAnZG93bmxvYWREaXInKTtcbiAgICAgIGxldCBmaWxlTGlzdCA9IGF3YWl0IHRoaXMubGlzdChzcmNEaXIpO1xuICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICBmaWxlTGlzdCA9IGZpbGVMaXN0LmZpbHRlcigoaXRlbSkgPT5cbiAgICAgICAgICBmaWx0ZXIoXG4gICAgICAgICAgICBgJHtzcmNEaXJ9JHt0aGlzLnJlbW90ZVBhdGhTZXB9JHtpdGVtLm5hbWV9YCxcbiAgICAgICAgICAgIGl0ZW0udHlwZSA9PT0gJ2QnID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9jYWxDaGVjayA9IGhhdmVMb2NhbENyZWF0ZShkc3REaXIpO1xuICAgICAgaWYgKCFsb2NhbENoZWNrLnN0YXR1cyAmJiBsb2NhbENoZWNrLmRldGFpbHMgPT09ICdwZXJtaXNzaW9uIGRlbmllZCcpIHtcbiAgICAgICAgdGhyb3cgZm10RXJyb3IoXG4gICAgICAgICAgYEJhZCBwYXRoOiAke2RzdERpcn06ICR7bG9jYWxDaGVjay5kZXRhaWxzfWAsXG4gICAgICAgICAgJ2Rvd25sb2FkRGlyJyxcbiAgICAgICAgICBsb2NhbENoZWNrLmNvZGVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYWxDaGVjay5zdGF0dXMgJiYgIWxvY2FsQ2hlY2sudHlwZSkge1xuICAgICAgICBmcy5ta2RpclN5bmMoZHN0RGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYWxDaGVjay5zdGF0dXMgJiYgbG9jYWxDaGVjay50eXBlICE9PSAnZCcpIHtcbiAgICAgICAgdGhyb3cgZm10RXJyb3IoXG4gICAgICAgICAgYEJhZCBwYXRoOiAke2RzdERpcn06IG5vdCBhIGRpcmVjdG9yeWAsXG4gICAgICAgICAgJ2Rvd25sb2FkRGlyJyxcbiAgICAgICAgICBlcnJvckNvZGUuYmFkUGF0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgZiBvZiBmaWxlTGlzdCkge1xuICAgICAgICBsZXQgbmV3U3JjID0gYCR7c3JjRGlyfSR7dGhpcy5yZW1vdGVQYXRoU2VwfSR7Zi5uYW1lfWA7XG4gICAgICAgIGxldCBuZXdEc3QgPSBqb2luKGRzdERpciwgZi5uYW1lKTtcbiAgICAgICAgaWYgKGYudHlwZSA9PT0gJ2QnKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5kb3dubG9hZERpcihuZXdTcmMsIG5ld0RzdCwgZmlsdGVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09ICctJykge1xuICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0KG5ld1NyYywgbmV3RHN0KTtcbiAgICAgICAgICB0aGlzLmNsaWVudC5lbWl0KCdkb3dubG9hZCcsIHsgc291cmNlOiBuZXdTcmMsIGRlc3RpbmF0aW9uOiBuZXdEc3QgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z01zZyhcbiAgICAgICAgICAgIGBkb3dubG9hZERpcjogRmlsZSBpZ25vcmVkOiAke2YubmFtZX0gbm90IHJlZ3VsYXIgZmlsZWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7c3JjRGlyfSBkb3dubG9hZGVkIHRvICR7ZHN0RGlyfWA7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9yZXNldEV2ZW50RmxhZ3MoKTtcbiAgICAgIHRocm93IGVyci5jdXN0b20gPyBlcnIgOiBmbXRFcnJvcihlcnIsICdkb3dubG9hZERpcicsIGVyci5jb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGFzeW5jXG4gICAqXG4gICAqIEVuZCB0aGUgU0ZUUCBjb25uZWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJvb2xlYW4+fVxuICAgKi9cbiAgZW5kKCkge1xuICAgIGxldCBlbmRDbG9zZUhhbmRsZXIsIGxpc3RlbmVycztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGlzdGVuZXJzID0gYWRkVGVtcExpc3RlbmVycyh0aGlzLCAnZW5kJywgcmVqZWN0KTtcbiAgICAgIHRoaXMuZW5kQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIGVuZENsb3NlSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZnRwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRlYnVnTXNnKCdlbmQ6IENvbm5lY3Rpb24gY2xvc2VkJyk7XG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbignY2xvc2UnLCBlbmRDbG9zZUhhbmRsZXIpO1xuICAgICAgaWYgKGhhdmVDb25uZWN0aW9uKHRoaXMsICdlbmQnLCByZWplY3QpKSB7XG4gICAgICAgIHRoaXMuZGVidWdNc2coJ2VuZDogSGF2ZSBjb25uZWN0aW9uIC0gY2FsbGluZyBlbmQoKScpO1xuICAgICAgICB0aGlzLmNsaWVudC5lbmQoKTtcbiAgICAgIH1cbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuZGVidWdNc2coJ2VuZDogZmluYWxseSBjbGF1c2UgZmlyZWQnKTtcbiAgICAgIHJlbW92ZVRlbXBMaXN0ZW5lcnModGhpcywgbGlzdGVuZXJzLCAnZW5kJyk7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGVuZENsb3NlSGFuZGxlcik7XG4gICAgICB0aGlzLmVuZENhbGxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVzZXRFdmVudEZsYWdzKCk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZnRwQ2xpZW50O1xuIiwgImNvbnN0IGlwID0gZXhwb3J0cztcbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcblxuaXAudG9CdWZmZXIgPSBmdW5jdGlvbiAoaXAsIGJ1ZmYsIG9mZnNldCkge1xuICBvZmZzZXQgPSB+fm9mZnNldDtcblxuICBsZXQgcmVzdWx0O1xuXG4gIGlmICh0aGlzLmlzVjRGb3JtYXQoaXApKSB7XG4gICAgcmVzdWx0ID0gYnVmZiB8fCBCdWZmZXIuYWxsb2Mob2Zmc2V0ICsgNCk7XG4gICAgaXAuc3BsaXQoL1xcLi9nKS5tYXAoKGJ5dGUpID0+IHtcbiAgICAgIHJlc3VsdFtvZmZzZXQrK10gPSBwYXJzZUludChieXRlLCAxMCkgJiAweGZmO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRoaXMuaXNWNkZvcm1hdChpcCkpIHtcbiAgICBjb25zdCBzZWN0aW9ucyA9IGlwLnNwbGl0KCc6JywgOCk7XG5cbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGlzdjQgPSB0aGlzLmlzVjRGb3JtYXQoc2VjdGlvbnNbaV0pO1xuICAgICAgbGV0IHY0QnVmZmVyO1xuXG4gICAgICBpZiAoaXN2NCkge1xuICAgICAgICB2NEJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoc2VjdGlvbnNbaV0pO1xuICAgICAgICBzZWN0aW9uc1tpXSA9IHY0QnVmZmVyLnNsaWNlKDAsIDIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHY0QnVmZmVyICYmICsraSA8IDgpIHtcbiAgICAgICAgc2VjdGlvbnMuc3BsaWNlKGksIDAsIHY0QnVmZmVyLnNsaWNlKDIsIDQpLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlY3Rpb25zWzBdID09PSAnJykge1xuICAgICAgd2hpbGUgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHNlY3Rpb25zLnVuc2hpZnQoJzAnKTtcbiAgICB9IGVsc2UgaWYgKHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgd2hpbGUgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHNlY3Rpb25zLnB1c2goJzAnKTtcbiAgICB9IGVsc2UgaWYgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGggJiYgc2VjdGlvbnNbaV0gIT09ICcnOyBpKyspO1xuICAgICAgY29uc3QgYXJndiA9IFtpLCAxXTtcbiAgICAgIGZvciAoaSA9IDkgLSBzZWN0aW9ucy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgYXJndi5wdXNoKCcwJyk7XG4gICAgICB9XG4gICAgICBzZWN0aW9ucy5zcGxpY2UoLi4uYXJndik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gYnVmZiB8fCBCdWZmZXIuYWxsb2Mob2Zmc2V0ICsgMTYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgd29yZCA9IHBhcnNlSW50KHNlY3Rpb25zW2ldLCAxNik7XG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgcmVzdWx0W29mZnNldCsrXSA9IHdvcmQgJiAweGZmO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgRXJyb3IoYEludmFsaWQgaXAgYWRkcmVzczogJHtpcH1gKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5pcC50b1N0cmluZyA9IGZ1bmN0aW9uIChidWZmLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSB+fm9mZnNldDtcbiAgbGVuZ3RoID0gbGVuZ3RoIHx8IChidWZmLmxlbmd0aCAtIG9mZnNldCk7XG5cbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBpZiAobGVuZ3RoID09PSA0KSB7XG4gICAgLy8gSVB2NFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGJ1ZmZbb2Zmc2V0ICsgaV0pO1xuICAgIH1cbiAgICByZXN1bHQgPSByZXN1bHQuam9pbignLicpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gMTYpIHtcbiAgICAvLyBJUHY2XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgcmVzdWx0LnB1c2goYnVmZi5yZWFkVUludDE2QkUob2Zmc2V0ICsgaSkudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gcmVzdWx0LmpvaW4oJzonKTtcbiAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvKF58OikwKDowKSo6MCg6fCQpLywgJyQxOjokMycpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC86ezMsNH0vLCAnOjonKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBpcHY0UmVnZXggPSAvXihcXGR7MSwzfVxcLil7MywzfVxcZHsxLDN9JC87XG5jb25zdCBpcHY2UmVnZXggPSAvXig6Oik/KCgoXFxkezEsM31cXC4pezN9KFxcZHsxLDN9KXsxfSk/KFswLTlhLWZdKXswLDR9OnswLDJ9KXsxLDh9KDo6KT8kL2k7XG5cbmlwLmlzVjRGb3JtYXQgPSBmdW5jdGlvbiAoaXApIHtcbiAgcmV0dXJuIGlwdjRSZWdleC50ZXN0KGlwKTtcbn07XG5cbmlwLmlzVjZGb3JtYXQgPSBmdW5jdGlvbiAoaXApIHtcbiAgcmV0dXJuIGlwdjZSZWdleC50ZXN0KGlwKTtcbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVGYW1pbHkoZmFtaWx5KSB7XG4gIGlmIChmYW1pbHkgPT09IDQpIHtcbiAgICByZXR1cm4gJ2lwdjQnO1xuICB9XG4gIGlmIChmYW1pbHkgPT09IDYpIHtcbiAgICByZXR1cm4gJ2lwdjYnO1xuICB9XG4gIHJldHVybiBmYW1pbHkgPyBmYW1pbHkudG9Mb3dlckNhc2UoKSA6ICdpcHY0Jztcbn1cblxuaXAuZnJvbVByZWZpeExlbiA9IGZ1bmN0aW9uIChwcmVmaXhsZW4sIGZhbWlseSkge1xuICBpZiAocHJlZml4bGVuID4gMzIpIHtcbiAgICBmYW1pbHkgPSAnaXB2Nic7XG4gIH0gZWxzZSB7XG4gICAgZmFtaWx5ID0gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpO1xuICB9XG5cbiAgbGV0IGxlbiA9IDQ7XG4gIGlmIChmYW1pbHkgPT09ICdpcHY2Jykge1xuICAgIGxlbiA9IDE2O1xuICB9XG4gIGNvbnN0IGJ1ZmYgPSBCdWZmZXIuYWxsb2MobGVuKTtcblxuICBmb3IgKGxldCBpID0gMCwgbiA9IGJ1ZmYubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgbGV0IGJpdHMgPSA4O1xuICAgIGlmIChwcmVmaXhsZW4gPCA4KSB7XG4gICAgICBiaXRzID0gcHJlZml4bGVuO1xuICAgIH1cbiAgICBwcmVmaXhsZW4gLT0gYml0cztcblxuICAgIGJ1ZmZbaV0gPSB+KDB4ZmYgPj4gYml0cykgJiAweGZmO1xuICB9XG5cbiAgcmV0dXJuIGlwLnRvU3RyaW5nKGJ1ZmYpO1xufTtcblxuaXAubWFzayA9IGZ1bmN0aW9uIChhZGRyLCBtYXNrKSB7XG4gIGFkZHIgPSBpcC50b0J1ZmZlcihhZGRyKTtcbiAgbWFzayA9IGlwLnRvQnVmZmVyKG1hc2spO1xuXG4gIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhNYXRoLm1heChhZGRyLmxlbmd0aCwgbWFzay5sZW5ndGgpKTtcblxuICAvLyBTYW1lIHByb3RvY29sIC0gZG8gYml0d2lzZSBhbmRcbiAgbGV0IGk7XG4gIGlmIChhZGRyLmxlbmd0aCA9PT0gbWFzay5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYWRkci5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gYWRkcltpXSAmIG1hc2tbaV07XG4gICAgfVxuICB9IGVsc2UgaWYgKG1hc2subGVuZ3RoID09PSA0KSB7XG4gICAgLy8gSVB2NiBhZGRyZXNzIGFuZCBJUHY0IG1hc2tcbiAgICAvLyAoTWFzayBsb3cgYml0cylcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWFzay5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gYWRkclthZGRyLmxlbmd0aCAtIDQgKyBpXSAmIG1hc2tbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElQdjYgbWFzayBhbmQgSVB2NCBhZGRyXG4gICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGggLSA2OyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gOjpmZmZmOmlwdjRcbiAgICByZXN1bHRbMTBdID0gMHhmZjtcbiAgICByZXN1bHRbMTFdID0gMHhmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYWRkci5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W2kgKyAxMl0gPSBhZGRyW2ldICYgbWFza1tpICsgMTJdO1xuICAgIH1cbiAgICBpICs9IDEyO1xuICB9XG4gIGZvciAoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gMDtcbiAgfVxuXG4gIHJldHVybiBpcC50b1N0cmluZyhyZXN1bHQpO1xufTtcblxuaXAuY2lkciA9IGZ1bmN0aW9uIChjaWRyU3RyaW5nKSB7XG4gIGNvbnN0IGNpZHJQYXJ0cyA9IGNpZHJTdHJpbmcuc3BsaXQoJy8nKTtcblxuICBjb25zdCBhZGRyID0gY2lkclBhcnRzWzBdO1xuICBpZiAoY2lkclBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBDSURSIHN1Ym5ldDogJHthZGRyfWApO1xuICB9XG5cbiAgY29uc3QgbWFzayA9IGlwLmZyb21QcmVmaXhMZW4ocGFyc2VJbnQoY2lkclBhcnRzWzFdLCAxMCkpO1xuXG4gIHJldHVybiBpcC5tYXNrKGFkZHIsIG1hc2spO1xufTtcblxuaXAuc3VibmV0ID0gZnVuY3Rpb24gKGFkZHIsIG1hc2spIHtcbiAgY29uc3QgbmV0d29ya0FkZHJlc3MgPSBpcC50b0xvbmcoaXAubWFzayhhZGRyLCBtYXNrKSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBtYXNrJ3MgbGVuZ3RoLlxuICBjb25zdCBtYXNrQnVmZmVyID0gaXAudG9CdWZmZXIobWFzayk7XG4gIGxldCBtYXNrTGVuZ3RoID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hc2tCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWFza0J1ZmZlcltpXSA9PT0gMHhmZikge1xuICAgICAgbWFza0xlbmd0aCArPSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgb2N0ZXQgPSBtYXNrQnVmZmVyW2ldICYgMHhmZjtcbiAgICAgIHdoaWxlIChvY3RldCkge1xuICAgICAgICBvY3RldCA9IChvY3RldCA8PCAxKSAmIDB4ZmY7XG4gICAgICAgIG1hc2tMZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBudW1iZXJPZkFkZHJlc3NlcyA9IDIgKiogKDMyIC0gbWFza0xlbmd0aCk7XG5cbiAgcmV0dXJuIHtcbiAgICBuZXR3b3JrQWRkcmVzczogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MpLFxuICAgIGZpcnN0QWRkcmVzczogbnVtYmVyT2ZBZGRyZXNzZXMgPD0gMlxuICAgICAgPyBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcylcbiAgICAgIDogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MgKyAxKSxcbiAgICBsYXN0QWRkcmVzczogbnVtYmVyT2ZBZGRyZXNzZXMgPD0gMlxuICAgICAgPyBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyArIG51bWJlck9mQWRkcmVzc2VzIC0gMSlcbiAgICAgIDogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MgKyBudW1iZXJPZkFkZHJlc3NlcyAtIDIpLFxuICAgIGJyb2FkY2FzdEFkZHJlc3M6IGlwLmZyb21Mb25nKG5ldHdvcmtBZGRyZXNzICsgbnVtYmVyT2ZBZGRyZXNzZXMgLSAxKSxcbiAgICBzdWJuZXRNYXNrOiBtYXNrLFxuICAgIHN1Ym5ldE1hc2tMZW5ndGg6IG1hc2tMZW5ndGgsXG4gICAgbnVtSG9zdHM6IG51bWJlck9mQWRkcmVzc2VzIDw9IDJcbiAgICAgID8gbnVtYmVyT2ZBZGRyZXNzZXMgOiBudW1iZXJPZkFkZHJlc3NlcyAtIDIsXG4gICAgbGVuZ3RoOiBudW1iZXJPZkFkZHJlc3NlcyxcbiAgICBjb250YWlucyhvdGhlcikge1xuICAgICAgcmV0dXJuIG5ldHdvcmtBZGRyZXNzID09PSBpcC50b0xvbmcoaXAubWFzayhvdGhlciwgbWFzaykpO1xuICAgIH0sXG4gIH07XG59O1xuXG5pcC5jaWRyU3VibmV0ID0gZnVuY3Rpb24gKGNpZHJTdHJpbmcpIHtcbiAgY29uc3QgY2lkclBhcnRzID0gY2lkclN0cmluZy5zcGxpdCgnLycpO1xuXG4gIGNvbnN0IGFkZHIgPSBjaWRyUGFydHNbMF07XG4gIGlmIChjaWRyUGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIENJRFIgc3VibmV0OiAke2FkZHJ9YCk7XG4gIH1cblxuICBjb25zdCBtYXNrID0gaXAuZnJvbVByZWZpeExlbihwYXJzZUludChjaWRyUGFydHNbMV0sIDEwKSk7XG5cbiAgcmV0dXJuIGlwLnN1Ym5ldChhZGRyLCBtYXNrKTtcbn07XG5cbmlwLm5vdCA9IGZ1bmN0aW9uIChhZGRyKSB7XG4gIGNvbnN0IGJ1ZmYgPSBpcC50b0J1ZmZlcihhZGRyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZltpXSA9IDB4ZmYgXiBidWZmW2ldO1xuICB9XG4gIHJldHVybiBpcC50b1N0cmluZyhidWZmKTtcbn07XG5cbmlwLm9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgYSA9IGlwLnRvQnVmZmVyKGEpO1xuICBiID0gaXAudG9CdWZmZXIoYik7XG5cbiAgLy8gc2FtZSBwcm90b2NvbFxuICBpZiAoYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICBhW2ldIHw9IGJbaV07XG4gICAgfVxuICAgIHJldHVybiBpcC50b1N0cmluZyhhKTtcblxuICAvLyBtaXhlZCBwcm90b2NvbHNcbiAgfVxuICBsZXQgYnVmZiA9IGE7XG4gIGxldCBvdGhlciA9IGI7XG4gIGlmIChiLmxlbmd0aCA+IGEubGVuZ3RoKSB7XG4gICAgYnVmZiA9IGI7XG4gICAgb3RoZXIgPSBhO1xuICB9XG5cbiAgY29uc3Qgb2Zmc2V0ID0gYnVmZi5sZW5ndGggLSBvdGhlci5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBidWZmLmxlbmd0aDsgKytpKSB7XG4gICAgYnVmZltpXSB8PSBvdGhlcltpIC0gb2Zmc2V0XTtcbiAgfVxuXG4gIHJldHVybiBpcC50b1N0cmluZyhidWZmKTtcbn07XG5cbmlwLmlzRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICBhID0gaXAudG9CdWZmZXIoYSk7XG4gIGIgPSBpcC50b0J1ZmZlcihiKTtcblxuICAvLyBTYW1lIHByb3RvY29sXG4gIGlmIChhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU3dhcFxuICBpZiAoYi5sZW5ndGggPT09IDQpIHtcbiAgICBjb25zdCB0ID0gYjtcbiAgICBiID0gYTtcbiAgICBhID0gdDtcbiAgfVxuXG4gIC8vIGEgLSBJUHY0LCBiIC0gSVB2NlxuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICBpZiAoYltpXSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgd29yZCA9IGIucmVhZFVJbnQxNkJFKDEwKTtcbiAgaWYgKHdvcmQgIT09IDAgJiYgd29yZCAhPT0gMHhmZmZmKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpICsgMTJdKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmlwLmlzUHJpdmF0ZSA9IGZ1bmN0aW9uIChhZGRyKSB7XG4gIHJldHVybiAvXig6OmZ7NH06KT8xMFxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaVxuICAgIC50ZXN0KGFkZHIpXG4gICAgfHwgL14oOjpmezR9Oik/MTkyXFwuMTY4XFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pLnRlc3QoYWRkcilcbiAgICB8fCAvXig6OmZ7NH06KT8xNzJcXC4oMVs2LTldfDJcXGR8MzB8MzEpXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pXG4gICAgICAudGVzdChhZGRyKVxuICAgIHx8IC9eKDo6Zns0fTopPzEyN1xcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaS50ZXN0KGFkZHIpXG4gICAgfHwgL14oOjpmezR9Oik/MTY5XFwuMjU0XFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pLnRlc3QoYWRkcilcbiAgICB8fCAvXmZbY2RdWzAtOWEtZl17Mn06L2kudGVzdChhZGRyKVxuICAgIHx8IC9eZmU4MDovaS50ZXN0KGFkZHIpXG4gICAgfHwgL146OjEkLy50ZXN0KGFkZHIpXG4gICAgfHwgL146OiQvLnRlc3QoYWRkcik7XG59O1xuXG5pcC5pc1B1YmxpYyA9IGZ1bmN0aW9uIChhZGRyKSB7XG4gIHJldHVybiAhaXAuaXNQcml2YXRlKGFkZHIpO1xufTtcblxuaXAuaXNMb29wYmFjayA9IGZ1bmN0aW9uIChhZGRyKSB7XG4gIHJldHVybiAvXig6OmZ7NH06KT8xMjdcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSkvXG4gICAgLnRlc3QoYWRkcilcbiAgICB8fCAvXmZlODA6OjEkLy50ZXN0KGFkZHIpXG4gICAgfHwgL146OjEkLy50ZXN0KGFkZHIpXG4gICAgfHwgL146OiQvLnRlc3QoYWRkcik7XG59O1xuXG5pcC5sb29wYmFjayA9IGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBgaXB2NGBcbiAgLy9cbiAgZmFtaWx5ID0gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpO1xuXG4gIGlmIChmYW1pbHkgIT09ICdpcHY0JyAmJiBmYW1pbHkgIT09ICdpcHY2Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFtaWx5IG11c3QgYmUgaXB2NCBvciBpcHY2Jyk7XG4gIH1cblxuICByZXR1cm4gZmFtaWx5ID09PSAnaXB2NCcgPyAnMTI3LjAuMC4xJyA6ICdmZTgwOjoxJztcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gYWRkcmVzcyAobmFtZSwgZmFtaWx5KVxuLy8gIyMjIyBAbmFtZSB7c3RyaW5nfCdwdWJsaWMnfCdwcml2YXRlJ30gKipPcHRpb25hbCoqIE5hbWUgb3Igc2VjdXJpdHlcbi8vICAgICAgb2YgdGhlIG5ldHdvcmsgaW50ZXJmYWNlLlxuLy8gIyMjIyBAZmFtaWx5IHtpcHY0fGlwdjZ9ICoqT3B0aW9uYWwqKiBJUCBmYW1pbHkgb2YgdGhlIGFkZHJlc3MgKGRlZmF1bHRzXG4vLyAgICAgIHRvIGlwdjQpLlxuLy9cbi8vIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSBuZXR3b3JrIGludGVyZmFjZSBvbiB0aGUgY3VycmVudCBzeXN0ZW0gd2l0aFxuLy8gdGhlIHNwZWNpZmllZCBgbmFtZWA6XG4vLyAgICogU3RyaW5nOiBGaXJzdCBgZmFtaWx5YCBhZGRyZXNzIG9mIHRoZSBpbnRlcmZhY2UuXG4vLyAgICAgICAgICAgICBJZiBub3QgZm91bmQgc2VlIGB1bmRlZmluZWRgLlxuLy8gICAqICdwdWJsaWMnOiB0aGUgZmlyc3QgcHVibGljIGlwIGFkZHJlc3Mgb2YgZmFtaWx5LlxuLy8gICAqICdwcml2YXRlJzogdGhlIGZpcnN0IHByaXZhdGUgaXAgYWRkcmVzcyBvZiBmYW1pbHkuXG4vLyAgICogdW5kZWZpbmVkOiBGaXJzdCBhZGRyZXNzIHdpdGggYGlwdjRgIG9yIGxvb3BiYWNrIGFkZHJlc3MgYDEyNy4wLjAuMWAuXG4vL1xuaXAuYWRkcmVzcyA9IGZ1bmN0aW9uIChuYW1lLCBmYW1pbHkpIHtcbiAgY29uc3QgaW50ZXJmYWNlcyA9IG9zLm5ldHdvcmtJbnRlcmZhY2VzKCk7XG5cbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBgaXB2NGBcbiAgLy9cbiAgZmFtaWx5ID0gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpO1xuXG4gIC8vXG4gIC8vIElmIGEgc3BlY2lmaWMgbmV0d29yayBpbnRlcmZhY2UgaGFzIGJlZW4gbmFtZWQsXG4gIC8vIHJldHVybiB0aGUgYWRkcmVzcy5cbiAgLy9cbiAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gJ3ByaXZhdGUnICYmIG5hbWUgIT09ICdwdWJsaWMnKSB7XG4gICAgY29uc3QgcmVzID0gaW50ZXJmYWNlc1tuYW1lXS5maWx0ZXIoKGRldGFpbHMpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1GYW1pbHkgPSBfbm9ybWFsaXplRmFtaWx5KGRldGFpbHMuZmFtaWx5KTtcbiAgICAgIHJldHVybiBpdGVtRmFtaWx5ID09PSBmYW1pbHk7XG4gICAgfSk7XG4gICAgaWYgKHJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXNbMF0uYWRkcmVzcztcbiAgfVxuXG4gIGNvbnN0IGFsbCA9IE9iamVjdC5rZXlzKGludGVyZmFjZXMpLm1hcCgobmljKSA9PiB7XG4gICAgLy9cbiAgICAvLyBOb3RlOiBuYW1lIHdpbGwgb25seSBiZSBgcHVibGljYCBvciBgcHJpdmF0ZWBcbiAgICAvLyB3aGVuIHRoaXMgaXMgY2FsbGVkLlxuICAgIC8vXG4gICAgY29uc3QgYWRkcmVzc2VzID0gaW50ZXJmYWNlc1tuaWNdLmZpbHRlcigoZGV0YWlscykgPT4ge1xuICAgICAgZGV0YWlscy5mYW1pbHkgPSBfbm9ybWFsaXplRmFtaWx5KGRldGFpbHMuZmFtaWx5KTtcbiAgICAgIGlmIChkZXRhaWxzLmZhbWlseSAhPT0gZmFtaWx5IHx8IGlwLmlzTG9vcGJhY2soZGV0YWlscy5hZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGlmICghbmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgPT09ICdwdWJsaWMnID8gaXAuaXNQcml2YXRlKGRldGFpbHMuYWRkcmVzcylcbiAgICAgICAgOiBpcC5pc1B1YmxpYyhkZXRhaWxzLmFkZHJlc3MpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFkZHJlc3Nlcy5sZW5ndGggPyBhZGRyZXNzZXNbMF0uYWRkcmVzcyA6IHVuZGVmaW5lZDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIHJldHVybiAhYWxsLmxlbmd0aCA/IGlwLmxvb3BiYWNrKGZhbWlseSkgOiBhbGxbMF07XG59O1xuXG5pcC50b0xvbmcgPSBmdW5jdGlvbiAoaXApIHtcbiAgbGV0IGlwbCA9IDA7XG4gIGlwLnNwbGl0KCcuJykuZm9yRWFjaCgob2N0ZXQpID0+IHtcbiAgICBpcGwgPDw9IDg7XG4gICAgaXBsICs9IHBhcnNlSW50KG9jdGV0KTtcbiAgfSk7XG4gIHJldHVybiAoaXBsID4+PiAwKTtcbn07XG5cbmlwLmZyb21Mb25nID0gZnVuY3Rpb24gKGlwbCkge1xuICByZXR1cm4gKGAke2lwbCA+Pj4gMjR9LiR7XG4gICAgaXBsID4+IDE2ICYgMjU1fS4ke1xuICAgIGlwbCA+PiA4ICYgMjU1fS4ke1xuICAgIGlwbCAmIDI1NX1gKTtcbn07XG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiaW1wb3J0IHsgUGx1Z2luLCBURm9sZGVyLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IENyZWRlbnRpYWxUYWIgZnJvbSAnLi9zcmMvY3JlZGVudGlhbCc7XHJcbmltcG9ydCBTRlRQQ2xpZW50IGZyb20gJy4vc3JjL2NsaWVudCc7XHJcblxyXG5pbnRlcmZhY2UgU3luY0ZUUFNldHRpbmdzIHtcclxuXHR1cmw6IHN0cmluZztcclxuXHRwb3J0OiBudW1iZXI7XHJcblx0cHJveHlfaG9zdDogc3RyaW5nO1xyXG5cdHByb3h5X3BvcnQ6IG51bWJlcjtcclxuXHR1c2VybmFtZTogc3RyaW5nO1xyXG5cdHBhc3N3b3JkOiBzdHJpbmc7XHJcblx0dmF1bHRfcGF0aDogc3RyaW5nO1xyXG5cdG5vdGlmeTogYm9vbGVhbjtcclxuXHRsb2FkX3N5bmM6IGJvb2xlYW47XHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFN5bmNGVFBTZXR0aW5ncyA9IHtcclxuXHR1cmw6ICcnLFxyXG5cdHBvcnQ6IDIyLFxyXG5cdHByb3h5X2hvc3Q6ICcnLFxyXG5cdHByb3h5X3BvcnQ6IDIyLFxyXG5cdHVzZXJuYW1lOiAnJyxcclxuXHRwYXNzd29yZDogJycsXHJcblx0dmF1bHRfcGF0aDogJy9vYnNpZGlhbi8nLFxyXG5cdG5vdGlmeTogZmFsc2UsXHJcblx0bG9hZF9zeW5jOiBmYWxzZVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeW5jRlRQIGV4dGVuZHMgUGx1Z2luIHtcclxuXHRzZXR0aW5nczogU3luY0ZUUFNldHRpbmdzO1xyXG5cdGNsaWVudDogU0ZUUENsaWVudDtcclxuXHJcblx0YXN5bmMgb25sb2FkKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcclxuXHJcblx0XHR0aGlzLmNsaWVudCA9IG5ldyBTRlRQQ2xpZW50KCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MubG9hZF9zeW5jKSB7XHJcblx0XHRcdHRoaXMuZG93bmxvYWRGaWxlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHQgICAgICBpZDogXCJwdXNoLXRvLXNmdHBcIixcclxuXHQgICAgICBuYW1lOiBcIlVwbG9hZCBmaWxlcyB0byB0aGUgU0ZUUFwiLFxyXG5cdCAgICAgIGNhbGxiYWNrOiAoKSA9PiB7IHRoaXMudXBsb2FkRmlsZSgpOyB9LFxyXG5cdCAgICB9KTtcclxuXHJcblx0ICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0ICAgICAgaWQ6IFwicHVsbC1mcm9tLXNmdHBcIixcclxuXHQgICAgICBuYW1lOiBcIkRvd25sb2FkIGZpbGVzIGZyb20gdGhlIFNGVFBcIixcclxuXHQgICAgICBjYWxsYmFjazogKCkgPT4geyB0aGlzLmRvd25sb2FkRmlsZSgpOyB9LFxyXG5cdCAgICB9KTtcclxuXHJcblx0XHRjb25zdCBzeW5jVXBsb2FkID0gdGhpcy5hZGRSaWJib25JY29uKFxyXG5cdFx0XHQnYXJyb3ctdXAnLFxyXG5cdFx0XHQnVXBsb2FkIHRvIEZUUCcsXHJcblx0XHRcdCgpID0+IHsgdGhpcy51cGxvYWRGaWxlKCk7IH0pO1xyXG5cclxuXHRcdGNvbnN0IHN5bmNEb3dubG9hZCA9IHRoaXMuYWRkUmliYm9uSWNvbihcclxuXHRcdFx0J2Fycm93LWRvd24nLFxyXG5cdFx0XHQnRG93bmxvYWQgZnJvbSBGVFAnLFxyXG5cdFx0XHQoKSA9PiB7IHRoaXMuZG93bmxvYWRGaWxlKCk7IH0pO1xyXG5cclxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgQ3JlZGVudGlhbFRhYih0aGlzLmFwcCwgdGhpcykpO1xyXG5cdFx0dGhpcy5yZWdpc3RlckRvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snLCAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcblx0XHRcdGNvbnNvbGUubG9nKCdjbGljaycsIGV2dCk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIG9udW5sb2FkKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHVwbG9hZEZpbGUoKSB7XHJcblx0XHRpZiAodGhpcy5zZXR0aW5ncy51cmwgIT09ICcnKSB7XHJcblx0XHRcdG5ldyBOb3RpY2UoYENvbm5lY3RpbmcgdG8gU0ZUUCBmb3IgZmlsZSBzeW5jOlxcbiR7dGhpcy5zZXR0aW5ncy51cmx9OiR7dGhpcy5zZXR0aW5ncy5wb3J0fVxcbiR7dGhpcy5zZXR0aW5ncy51c2VybmFtZX1gKTtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRsZXQgY29ubiA9IGF3YWl0IHRoaXMuY2xpZW50LmNvbm5lY3Qoe1xyXG5cdFx0XHRcdFx0cHJveHlfaG9zdDogdGhpcy5zZXR0aW5ncy5wcm94eV9ob3N0LFxyXG5cdFx0XHRcdFx0cHJveHlfcG9ydDogTnVtYmVyKHRoaXMuc2V0dGluZ3MucHJveHlfcG9ydCksXHJcblx0XHRcdFx0XHRob3N0OiB0aGlzLnNldHRpbmdzLnVybCxcclxuXHRcdFx0XHRcdHBvcnQ6IE51bWJlcih0aGlzLnNldHRpbmdzLnBvcnQpLFxyXG5cdFx0XHRcdFx0dXNlcm5hbWU6IHRoaXMuc2V0dGluZ3MudXNlcm5hbWUsXHJcblx0XHRcdFx0XHRwYXNzd29yZDogdGhpcy5zZXR0aW5ncy5wYXNzd29yZFxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5ub3RpZnkpIG5ldyBOb3RpY2UoY29ubik7XHJcblxyXG5cdFx0XHRcdGlmIChhd2FpdCB0aGlzLmNsaWVudC5maWxlRXhpc3RzKHRoaXMuc2V0dGluZ3MudmF1bHRfcGF0aCkgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmNsaWVudC5tYWtlRGlyKHRoaXMuc2V0dGluZ3MudmF1bHRfcGF0aCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoYXdhaXQgdGhpcy5jbGllbnQuZmlsZUV4aXN0cyhgJHt0aGlzLnNldHRpbmdzLnZhdWx0X3BhdGh9JHt0aGlzLmFwcC52YXVsdC5nZXROYW1lKCl9L2ApID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5jbGllbnQubWFrZURpcihgJHt0aGlzLnNldHRpbmdzLnZhdWx0X3BhdGh9JHt0aGlzLmFwcC52YXVsdC5nZXROYW1lKCl9L2ApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IHJlbV9wYXRoID0gdGhpcy5zZXR0aW5ncy52YXVsdF9wYXRoICsgdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpO1xyXG5cdFx0XHRcdGxldCByZW1fbGlzdCA9IGF3YWl0IHRoaXMuY2xpZW50Lmxpc3RGaWxlcyhyZW1fcGF0aCk7XHJcblx0XHRcdFx0bGV0IGxvY19wYXRoID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlci5iYXNlUGF0aDtcclxuXHRcdFx0XHRsZXQgbG9jX2xpc3QgPSB0aGlzLmFwcC52YXVsdC5nZXRBbGxMb2FkZWRGaWxlcygpO1xyXG5cdFx0XHRcdGxvY19saXN0LnNwbGljZSgwLCAxKTtcclxuXHJcblx0XHRcdFx0Zm9yIChjb25zdCByZW1fZmlsZSBvZiByZW1fbGlzdCkge1xyXG5cdFx0XHRcdFx0bGV0IG1hdGNoX2luZGV4ID0gbG9jX2xpc3QuZmluZEluZGV4KGZpbGUgPT4gYC8ke2ZpbGUucGF0aH1gID09PSBgJHtyZW1fZmlsZS5wYXRoLnJlcGxhY2UocmVtX3BhdGgsICcnKX0vJHtyZW1fZmlsZS5uYW1lfWApO1xyXG5cdFx0XHRcdFx0bGV0IG1hdGNoID0gbG9jX2xpc3RbbWF0Y2hfaW5kZXhdO1xyXG5cclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdGlmIChtYXRjaCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChyZW1fZmlsZS50eXBlID09PSAnZCcgfHwgcmVtX2ZpbGUuc2l6ZSA9PT0gbWF0Y2guc3RhdC5zaXplKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRsb2NfbGlzdC5zcGxpY2UobWF0Y2hfaW5kZXgsIDEpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICghbWF0Y2gpIHtcclxuXHRcdFx0XHRcdFx0XHRsZXQgc3luYyA9ICcnO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChyZW1fZmlsZS50eXBlID09PSAnZCcpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChhd2FpdCB0aGlzLmNsaWVudC5maWxlRXhpc3RzKGAke3JlbV9maWxlLnBhdGh9LyR7cmVtX2ZpbGUubmFtZX1gKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzeW5jID0gYXdhaXQgdGhpcy5jbGllbnQucmVtb3ZlRGlyKGAke3JlbV9maWxlLnBhdGh9LyR7cmVtX2ZpbGUubmFtZX1gKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGF3YWl0IHRoaXMuY2xpZW50LmZpbGVFeGlzdHMoYCR7cmVtX2ZpbGUucGF0aH0vJHtyZW1fZmlsZS5uYW1lfWApKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN5bmMgPSBhd2FpdCB0aGlzLmNsaWVudC5kZWxldGVGaWxlKGAke3JlbV9maWxlLnBhdGh9LyR7cmVtX2ZpbGUubmFtZX1gKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLm5vdGlmeSAmJiBzeW5jLnRyaW0oKSAhPSAnJykgbmV3IE5vdGljZShzeW5jKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nICR7cmVtX2ZpbGUubmFtZX06ICR7ZXJyfWApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAoY29uc3QgbG9jX2ZpbGUgb2YgbG9jX2xpc3QpIHtcclxuXHRcdFx0XHRcdGxldCBzeW5jID0gJyc7XHJcblx0XHRcdFx0XHRpZiAobG9jX2ZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XHJcblx0XHRcdFx0XHRcdHN5bmMgPSBhd2FpdCB0aGlzLmNsaWVudC5tYWtlRGlyKGAke3JlbV9wYXRofS8ke2xvY19maWxlLnBhdGh9YCk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGxvY19maWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0XHRcdFx0c3luYyA9IGF3YWl0IHRoaXMuY2xpZW50LnVwbG9hZEZpbGUoYCR7bG9jX3BhdGh9LyR7bG9jX2ZpbGUucGF0aH1gLCBgJHtyZW1fcGF0aH0vJHtsb2NfZmlsZS5wYXRofWApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLm5vdGlmeSAmJiBzeW5jLnRyaW0oKSAhPSAnJykgbmV3IE5vdGljZShzeW5jKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBkaXNjb25uID0gYXdhaXQgdGhpcy5jbGllbnQuZGlzY29ubmVjdCgpO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5ub3RpZnkpIG5ldyBOb3RpY2UoZGlzY29ubik7XHJcblx0XHRcdFx0ZWxzZSBuZXcgTm90aWNlKCdEb25lIScpO1xyXG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gY29ubmVjdCB0byBTRlRQOiAke2Vycn1gKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YXN5bmMgZG93bmxvYWRGaWxlKCkge1xyXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MudXJsICE9PSAnJykge1xyXG5cdFx0XHRuZXcgTm90aWNlKGBDb25uZWN0aW5nIHRvIFNGVFAgZm9yIGZpbGUgc3luYzpcXG4ke3RoaXMuc2V0dGluZ3MudXJsfToke3RoaXMuc2V0dGluZ3MucG9ydH1cXG4ke3RoaXMuc2V0dGluZ3MudXNlcm5hbWV9YCk7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0bGV0IGNvbm4gPSBhd2FpdCB0aGlzLmNsaWVudC5jb25uZWN0KHtcclxuXHRcdFx0XHRcdHByb3h5X2hvc3Q6IHRoaXMuc2V0dGluZ3MucHJveHlfaG9zdCxcclxuXHRcdFx0XHRcdHByb3h5X3BvcnQ6IE51bWJlcih0aGlzLnNldHRpbmdzLnByb3h5X3BvcnQpLFxyXG5cdFx0XHRcdFx0aG9zdDogdGhpcy5zZXR0aW5ncy51cmwsXHJcblx0XHRcdFx0XHRwb3J0OiBOdW1iZXIodGhpcy5zZXR0aW5ncy5wb3J0KSxcclxuXHRcdFx0XHRcdHVzZXJuYW1lOiB0aGlzLnNldHRpbmdzLnVzZXJuYW1lLFxyXG5cdFx0XHRcdFx0cGFzc3dvcmQ6IHRoaXMuc2V0dGluZ3MucGFzc3dvcmRcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3Mubm90aWZ5KSBuZXcgTm90aWNlKGNvbm4pO1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKHRoaXMuY2xpZW50LmZpbGVFeGlzdHModGhpcy5zZXR0aW5ncy52YXVsdF9wYXRoICsgdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpKSk7XHJcblxyXG5cdFx0XHRcdGlmICghIGF3YWl0IHRoaXMuY2xpZW50LmZpbGVFeGlzdHModGhpcy5zZXR0aW5ncy52YXVsdF9wYXRoICsgdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpKSkge1xyXG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnVmF1bHQgZG9lcyBub3QgZXhpc3Qgb24gU0ZUUCwgbm90aGluZyB0byBkb3dubG9hZC4gUGxlYXNlIHVwbG9hZC4nKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bGV0IHJlbV9wYXRoID0gdGhpcy5zZXR0aW5ncy52YXVsdF9wYXRoICsgdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpO1xyXG5cdFx0XHRcdFx0bGV0IHJlbV9saXN0ID0gYXdhaXQgdGhpcy5jbGllbnQubGlzdEZpbGVzKHJlbV9wYXRoKTtcclxuXHRcdFx0XHRcdGxldCBsb2NfcGF0aCA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuYmFzZVBhdGg7XHJcblx0XHRcdFx0XHRsZXQgbG9jX2xpc3QgPSB0aGlzLmFwcC52YXVsdC5nZXRBbGxMb2FkZWRGaWxlcygpO1xyXG5cdFx0XHRcdFx0bG9jX2xpc3Quc3BsaWNlKDAsIDEpO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoY29uc3QgbG9jX2ZpbGUgb2YgbG9jX2xpc3QpIHtcclxuXHRcdFx0XHRcdFx0bGV0IG1hdGNoX2luZGV4ID0gcmVtX2xpc3QuZmluZEluZGV4KGZpbGUgPT4gYCR7ZmlsZS5wYXRoLnJlcGxhY2UocmVtX3BhdGgsICcnKX0vJHtmaWxlLm5hbWV9YCA9PT0gYC8ke2xvY19maWxlLnBhdGh9YCk7XHJcblx0XHRcdFx0XHRcdGxldCBtYXRjaCA9IHJlbV9saXN0W21hdGNoX2luZGV4XTtcclxuXHJcblx0XHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdFx0bGV0IHN5bmMgPSAnJztcclxuXHRcdFx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChtYXRjaC50eXBlID09PSAnZCcgfHwgbWF0Y2guc2l6ZSA9PT0gbG9jX2ZpbGUuc3RhdC5zaXplKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHJlbV9saXN0LnNwbGljZShtYXRjaF9pbmRleCwgMSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghbWF0Y2ggJiYgbG9jX2ZpbGUucGF0aCAhPT0gJy8nKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC50cmFzaChsb2NfZmlsZSwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0XHRcdFx0c3luYyA9IGBMb2NhbCBmaWxlICR7bG9jX2ZpbGUubmFtZX0gbW92ZWQgdG8gT2JzaWRpYW4gdHJhc2guYDtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLm5vdGlmeSAmJiBzeW5jLnRyaW0oKSAhPSAnJykgbmV3IE5vdGljZShzeW5jKTtcclxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3IgbW92aW5nICR7bG9jX2ZpbGUubmFtZX0gdG8gdHJhc2g6ICR7ZXJyfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yIChjb25zdCByZW1fZmlsZSBvZiByZW1fbGlzdCkge1xyXG5cdFx0XHRcdFx0XHRsZXQgc3luYyA9ICcnO1xyXG5cdFx0XHRcdFx0XHRsZXQgZHN0X3BhdGggPSAocmVtX2ZpbGUucGF0aCAhPT0gcmVtX3BhdGgpID8gYCR7cmVtX2ZpbGUucGF0aC5yZXBsYWNlKHJlbV9wYXRoLCcnKX0vYDogJyc7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAocmVtX2ZpbGUudHlwZSAhPT0gJ2QnKSB7XHJcblx0XHRcdFx0XHRcdFx0c3luYyA9IGF3YWl0IHRoaXMuY2xpZW50LmRvd25sb2FkRmlsZShgJHtyZW1fZmlsZS5wYXRofS8ke3JlbV9maWxlLm5hbWV9YCwgYCR7bG9jX3BhdGh9JHtkc3RfcGF0aH0ke3JlbV9maWxlLm5hbWV9YCk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFsb2NfbGlzdC5maW5kKGZvbGRlciA9PiBmb2xkZXIubmFtZSA9PT0gcmVtX2ZpbGUubmFtZSkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChhd2FpdCB0aGlzLmNsaWVudC5maWxlRXhpc3RzKGAke2RzdF9wYXRofSR7cmVtX2ZpbGUubmFtZX0vYCkgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihgJHtkc3RfcGF0aH0ke3JlbV9maWxlLm5hbWV9L2ApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzeW5jID0gYFN1Y2Nlc3NmdWxseSBtYWRlIGRpcmVjdG9yeTogJHtyZW1fZmlsZS5uYW1lfWA7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5ub3RpZnkgJiYgc3luYy50cmltKCkgIT0gJycpIG5ldyBOb3RpY2Uoc3luYyk7XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IGRpc2Nvbm4gPSBhd2FpdCB0aGlzLmNsaWVudC5kaXNjb25uZWN0KCk7XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLm5vdGlmeSkgbmV3IE5vdGljZShkaXNjb25uKTtcclxuXHRcdFx0XHRlbHNlIG5ldyBOb3RpY2UoJ0RvbmUhJyk7XHJcblx0XHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byBjb25uZWN0IHRvIFNGVFA6ICR7ZXJyfWApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59IiwgImltcG9ydCBTeW5jRlRQIGZyb20gJy4vbWFpbic7XHJcbmltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyZWRlbnRpYWxUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuXHRwbHVnaW46IFN5bmNGVFA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFN5bmNGVFApIHtcclxuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG5cdH1cclxuXHJcblx0ZGlzcGxheSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7dGV4dDogJ1NGVFAgU2V0dGluZ3MnfSk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKCdVUkwnKVxyXG5cdFx0XHQuc2V0RGVzYygnRlRQIFVSTCcpXHJcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy51cmwpXHJcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MudXJsID0gdmFsdWU7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHR9KSk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKCdQb3J0JylcclxuXHRcdFx0LnNldERlc2MoJ0ZUUCBQb3J0JylcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnBvcnQpXHJcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucG9ydCA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0fSkpO1xyXG5cclxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHt0ZXh0OiAnSWYgeW91IGFyZSBub3QgdXNpbmcgYSBwcm94eSBwbGVhc2UgbGVhdmUgdGhlc2UgZmllbGRzIGVtcHR5Lid9KTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoJ1Byb3h5IFVSTCcpXHJcblx0XHRcdC5zZXREZXNjKCdQcm94eSBVUkwnKVxyXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJveHlfaG9zdClcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm94eV9ob3N0ID0gdmFsdWU7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHR9KSk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKCdQcm94eSBQb3J0JylcclxuXHRcdFx0LnNldERlc2MoJ1Byb3h5IFBvcnQnKVxyXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJveHlfcG9ydClcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm94eV9wb3J0ID0gdmFsdWU7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHR9KSk7XHJcblxyXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywge3RleHQ6ICdDcmVkZW50aWFscyd9KTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoJ1VzZXJuYW1lJylcclxuXHRcdFx0LnNldERlc2MoJ0ZUUCBVc2VybmFtZScpXHJcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VybmFtZSlcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VybmFtZSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0fSkpO1xyXG5cclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZSgnUGFzc3dvcmQnKVxyXG5cdFx0XHQuc2V0RGVzYygnRlRQIFBhc3N3b3JkJylcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnBhc3N3b3JkKVxyXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnBhc3N3b3JkID0gdmFsdWU7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHR9KSk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKCdWYXVsdHMgUGF0aCcpXHJcblx0XHRcdC5zZXREZXNjKCdGVFAgVmF1bHRzIERpcmVjdG9yeSBQYXRoJylcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnZhdWx0X3BhdGgpXHJcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRfcGF0aCA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0fSkpO1xyXG5cclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZSgnU3luYyBOb3RpZmljYXRpb25zJylcclxuXHRcdFx0LnNldERlc2MoJ1dvdWxkIHlvdSBsaWtlIHRvIGJlIG5vdGlmaWVkIG9mIGFsbCBTeW5jRlRQIGFjdGlvbnM/IE5lY2Vzc2FyeSBOb3RpY2VzIHdpbGwgc3RpbGwgcG9wdWxhdGUuJylcclxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGlmeSlcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZnkgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdH0pKTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoJ1N5bmMgb24gTG9hZCcpXHJcblx0XHRcdC5zZXREZXNjKCdXb3VsZCB5b3UgbGlrZSB0byBwdWxsIG5ldyBjaGFuZ2VzIGZyb20gdGhlIFNGVFAgZXZlcnkgdGltZSB5b3Ugb3BlbiBPYnNpZGlhbj8nKVxyXG5cdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubG9hZF9zeW5jKVxyXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmxvYWRfc3luYyA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0fSkpO1xyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0IENsaWVudCBmcm9tICdzc2gyLXNmdHAtY2xpZW50JztcclxuaW1wb3J0IHsgU29ja3NDbGllbnQgfSBmcm9tICdzb2Nrcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTRlRQQ2xpZW50IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY2xpZW50ID0gbmV3IENsaWVudCgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY29ubmVjdChvcHRpb25zKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgQ29ubmVjdGluZyB0byAke29wdGlvbnMuaG9zdH06JHtvcHRpb25zLnBvcnR9YCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAob3B0aW9ucy5wcm94eV9ob3N0ICE9PSAnJykge1xyXG4gICAgICAgIGxldCBvcHQgPSB7XHJcbiAgICAgICAgICBwcm94eToge1xyXG4gICAgICAgICAgICBob3N0OiBvcHRpb25zLnByb3h5X2hvc3QsXHJcbiAgICAgICAgICAgIHBvcnQ6IG9wdGlvbnMucHJveHlfcG9ydCxcclxuICAgICAgICAgICAgdHlwZTogNSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBjb21tYW5kOiAnY29ubmVjdCcsXHJcbiAgICAgICAgICBkZXN0aW5hdGlvbjoge1xyXG4gICAgICAgICAgICBob3N0OiBvcHRpb25zLmhvc3QsXHJcbiAgICAgICAgICAgIHBvcnQ6IG9wdGlvbnMucG9ydFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBzb2NrcyA9IGF3YWl0IFNvY2tzQ2xpZW50LmNyZWF0ZUNvbm5lY3Rpb24ob3B0KTtcclxuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29ubmVjdCh7XHJcbiAgICAgICAgICBob3N0OiBvcHRpb25zLmhvc3QsXHJcbiAgICAgICAgICBwb3J0OiBvcHRpb25zLnBvcnQsXHJcbiAgICAgICAgICBzb2NrOiBzb2Nrcy5zb2NrZXQsXHJcbiAgICAgICAgICB1c2VybmFtZTogb3B0aW9ucy51c2VybmFtZSxcclxuICAgICAgICAgIHBhc3N3b3JkOiBvcHRpb25zLnBhc3N3b3JkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29ubmVjdCh7XHJcbiAgICAgICAgICBob3N0OiBvcHRpb25zLmhvc3QsXHJcbiAgICAgICAgICBwb3J0OiBvcHRpb25zLnBvcnQsXHJcbiAgICAgICAgICB1c2VybmFtZTogb3B0aW9ucy51c2VybmFtZSxcclxuICAgICAgICAgIHBhc3N3b3JkOiBvcHRpb25zLnBhc3N3b3JkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGNvbm5lY3Q6JywgZXJyKTtcclxuICAgICAgcmV0dXJuKGBGYWlsZWQgdG8gY29ubmVjdDpcXG4ke2Vycn1gKTtcclxuICAgIH1cclxuICAgIHJldHVybignQ29ubmVjdGVkIHRvIFNGVFAnKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgRGlzY29ubmVjdGluZyBmcm9tIFNGVFAuYCk7XHJcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5lbmQoKTtcclxuICAgIHJldHVybiAnRGlzY29ubmVjdGVkIGZyb20gU0ZUUCc7XHJcbiAgfVxyXG5cclxuICBhc3luYyBsaXN0RmlsZXMocmVtb3RlRGlyLCBmaWxlR2xvYikge1xyXG4gICAgbGV0IGZpbGVPYmplY3RzO1xyXG4gICAgdHJ5IHtcclxuICAgICAgZmlsZU9iamVjdHMgPSBhd2FpdCB0aGlzLmNsaWVudC5saXN0KHJlbW90ZURpciwgZmlsZUdsb2IpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdMaXN0aW5nIGZhaWxlZDonLCBlcnIpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmaWxlTmFtZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZU9iamVjdHMpIHtcclxuICAgICAgaWYgKGZpbGUudHlwZSA9PT0gJ2QnKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCR7bmV3IERhdGUoZmlsZS5tb2RpZnlUaW1lKS50b0lTT1N0cmluZygpfSBQUkUgJHtmaWxlLm5hbWV9YCk7XHJcbiAgICAgICAgZmlsZU5hbWVzLnB1c2goe1xyXG4gICAgICAgICAgJ25hbWUnOiBmaWxlLm5hbWUsXHJcbiAgICAgICAgICAnbXRpbWUnOiBmaWxlLm1vZGlmeVRpbWUsXHJcbiAgICAgICAgICAndHlwZSc6IGZpbGUudHlwZSxcclxuICAgICAgICAgICdzaXplJzogZmlsZS5zaXplLFxyXG4gICAgICAgICAgJ3BhdGgnOiByZW1vdGVEaXJcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgc3ViRmlsZXMgPSBhd2FpdCB0aGlzLmxpc3RGaWxlcyhgJHtyZW1vdGVEaXJ9LyR7ZmlsZS5uYW1lfWApO1xyXG4gICAgICAgIGZpbGVOYW1lcyA9IGZpbGVOYW1lcy5jb25jYXQoc3ViRmlsZXMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAke25ldyBEYXRlKGZpbGUubW9kaWZ5VGltZSkudG9JU09TdHJpbmcoKX0gJHtmaWxlLnNpemV9ICR7ZmlsZS5uYW1lfWApO1xyXG4gICAgICAgIGZpbGVOYW1lcy5wdXNoKHtcclxuICAgICAgICAgICduYW1lJzogZmlsZS5uYW1lLFxyXG4gICAgICAgICAgJ210aW1lJzogZmlsZS5tb2RpZnlUaW1lLFxyXG4gICAgICAgICAgJ3R5cGUnOiBmaWxlLnR5cGUsXHJcbiAgICAgICAgICAnc2l6ZSc6IGZpbGUuc2l6ZSxcclxuICAgICAgICAgICdwYXRoJzogcmVtb3RlRGlyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gICAgICBcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmlsZU5hbWVzO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdXBsb2FkRmlsZShsb2NhbEZpbGUsIHJlbW90ZUZpbGUpIHtcclxuICAgIGNvbnNvbGUubG9nKGBVcGxvYWRpbmcgJHtsb2NhbEZpbGV9IHRvICR7cmVtb3RlRmlsZX1gKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnB1dChsb2NhbEZpbGUsIHJlbW90ZUZpbGUpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VwbG9hZGluZyBmYWlsZWQ6JywgZXJyKTtcclxuICAgICAgcmV0dXJuKGBVcGxvYWRpbmcgZmFpbGVkOlxcbiR7ZXJyfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGBVcGxvYWRpbmcgc3VjY2VzcyBmb3JcXG4ke2xvY2FsRmlsZX1gO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZG93bmxvYWRGaWxlKHJlbW90ZUZpbGUsIGxvY2FsRmlsZSkge1xyXG4gICAgY29uc29sZS5sb2coYERvd25sb2FkaW5nICR7cmVtb3RlRmlsZX0gdG8gJHtsb2NhbEZpbGV9YCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5nZXQocmVtb3RlRmlsZSwgbG9jYWxGaWxlKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdEb3dubG9hZGluZyBmYWlsZWQ6JywgZXJyKTtcclxuICAgICAgcmV0dXJuKGBEb3dubG9hZGluZyBmYWlsZWQ6XFxuJHtlcnJ9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYERvd25sb2FkaW5nIHN1Y2Nlc3MgZm9yXFxuJHtsb2NhbEZpbGV9YDtcclxuICB9XHJcblxyXG4gIGFzeW5jIG1ha2VEaXIocmVtb3RlRGlyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgQ3JlYXRpbmcgZGlyZWN0b3J5ICR7cmVtb3RlRGlyfWApO1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5jbGllbnQubWtkaXIocmVtb3RlRGlyLCB0cnVlKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGRpcmVjdG9yeTonLCBlcnIpO1xyXG4gICAgICByZXR1cm4oYEZhaWxlZCB0byBtYWtlIGRpcmVjdG9yeTpcXG4ke2Vycn1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IG1hZGUgZGlyZWN0b3J5OlxcbiR7cmVtb3RlRGlyfWA7XHJcbiAgfVxyXG5cclxuICBhc3luYyByZW1vdmVEaXIocmVtb3RlRGlyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgRGVsZXRpbmcgZGlyZWN0b3J5ICR7cmVtb3RlRGlyfWApO1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucm1kaXIocmVtb3RlRGlyLCB0cnVlKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVtb3ZlIGRpcmVjdG9yeTonLCBlcnIpO1xyXG4gICAgICByZXR1cm4oYEZhaWxlZCB0byByZW1vdmUgZGlyZWN0b3J5OlxcbiR7ZXJyfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGBTdWNjZXNzZnVsbHkgcmVtb3ZlZCBkaXJlY3Rvcnk6XFxuJHtyZW1vdGVEaXJ9YDtcclxuXHJcbiAgfVxyXG5cclxuICBhc3luYyBkZWxldGVGaWxlKHJlbW90ZUZpbGUpIHtcclxuICAgIGNvbnNvbGUubG9nKGBEZWxldGluZyAke3JlbW90ZUZpbGV9YCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5kZWxldGUocmVtb3RlRmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRGVsZXRpbmcgZmFpbGVkOicsIGVycik7XHJcbiAgICAgIHJldHVybihgRGVsZXRpbmcgZmFpbGVkOlxcbiR7ZXJyfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGBEZWxldGUgc3VjY2VzcyBmb3JcXG4ke3JlbW90ZUZpbGV9YDtcclxuICB9XHJcblxyXG4gIGFzeW5jIGZpbGVFeGlzdHMocmVtb3RlRmlsZSkge1xyXG4gICAgY29uc29sZS5sb2coYENoZWNraW5nIGlmICR7cmVtb3RlRmlsZX0gZXhpc3RzYCk7XHJcbiAgICBsZXQgZXhpc3RzID0gZmFsc2U7XHJcbiAgICB0cnkge1xyXG4gICAgICBleGlzdHMgPSBhd2FpdCB0aGlzLmNsaWVudC5leGlzdHMocmVtb3RlRmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXhpc3RzIGNoZWNrIGZhaWxlZDonLCBlcnIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4aXN0cztcclxuICB9XHJcbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSxpREFBQUEsU0FBQTtBQUdBLElBQUFBLFFBQU8sVUFBVTtBQUFBLE1BRWYscUJBQXFCLFNBQVUsS0FBSztBQUNsQyxZQUFJLElBQUksSUFBSSxNQUFNO0FBQ2xCLFVB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LEtBQUssRUFBRyxDQUFDLElBQUksUUFBTyxNQUFNLEVBQUcsQ0FBQyxJQUFJLFFBQU8sSUFDOUUsS0FBTSxFQUFHLENBQUMsSUFBSSxPQUFRLEVBQUcsQ0FBQyxJQUFJLFFBQU8sS0FBSyxFQUFHLENBQUMsSUFBSSxRQUFPLE1BQU0sRUFBRyxDQUFDLElBQUksUUFBTyxJQUM5RSxLQUFNLEVBQUcsQ0FBQyxJQUFJLE9BQVEsRUFBRyxDQUFDLElBQUksUUFBTyxLQUFLLEVBQUUsRUFBRSxJQUFJLFFBQU8sTUFBTSxFQUFFLEVBQUUsSUFBSSxRQUFPLElBQzlFLEtBQU0sRUFBRSxFQUFFLElBQUksT0FBUSxFQUFFLEVBQUUsSUFBSSxRQUFPLEtBQUssRUFBRSxFQUFFLElBQUksUUFBTyxNQUFNLEVBQUUsRUFBRSxJQUFJLFFBQU8sSUFDOUUsTUFBTSxFQUFHLENBQUMsSUFBSSxPQUFRLEVBQUcsQ0FBQyxJQUFJLFFBQU8sS0FBSyxFQUFFLEVBQUUsSUFBSSxRQUFPLE1BQU0sRUFBRSxFQUFFLElBQUksUUFBTyxJQUM5RSxNQUFNLEVBQUUsRUFBRSxJQUFJLE9BQVEsRUFBRSxFQUFFLElBQUksUUFBTyxLQUFLLEVBQUUsRUFBRSxJQUFJLFFBQU8sTUFBTSxFQUFFLEVBQUUsSUFBSSxRQUFPLElBQzlFLE1BQU0sRUFBRSxFQUFFLElBQUksT0FBUSxFQUFFLEVBQUUsSUFBSSxRQUFPLEtBQUssRUFBRSxFQUFFLElBQUksUUFBTyxNQUFNLEVBQUUsRUFBRSxJQUFJLFFBQU8sSUFDOUUsTUFBTSxFQUFFLEVBQUUsSUFBSSxPQUFRLEVBQUUsRUFBRSxJQUFJLFFBQU8sS0FBSyxFQUFFLEVBQUUsSUFBSSxRQUFPLE1BQU0sRUFBRSxFQUFFLElBQUksUUFBTyxJQUM5RSxNQUFNLEVBQUUsRUFBRSxJQUFJLE9BQVEsRUFBRSxFQUFFLElBQUksUUFBTyxLQUFLLEVBQUUsRUFBRSxJQUFJLFFBQU8sTUFBTSxFQUFFLEVBQUUsSUFBSSxRQUFPLElBQzlFLE1BQU0sRUFBRSxFQUFFLElBQUksT0FBUSxFQUFFLEVBQUUs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VUFBRSxFQUFFLElBQUksT0FBUSxJQUFJO0FBQ3BCLFVBQUUsRUFBRSxJQUFJLE9BQU8sS0FBSztBQUNwQixVQUFFLEVBQUUsSUFBSSxPQUFPLEtBQUs7QUFFcEIsVUFBRSxFQUFFLElBQUksT0FBUSxJQUFJO0FBQ3BCLFVBQUUsRUFBRSxJQUFJLE9BQVEsSUFBSTtBQUNwQixVQUFFLEVBQUUsSUFBSSxPQUFPLEtBQUs7QUFDcEIsVUFBRSxFQUFFLElBQUksT0FBTyxLQUFLO0FBRXBCLFVBQUUsRUFBRSxJQUFJLE9BQVEsSUFBSTtBQUNwQixVQUFFLEVBQUUsSUFBSSxPQUFRLElBQUk7QUFDcEIsVUFBRSxFQUFFLElBQUksT0FBTyxLQUFLO0FBQ3BCLFVBQUUsRUFBRSxJQUFJLE9BQU8sS0FBSztBQUVwQixVQUFFLEVBQUUsSUFBSSxPQUFRLElBQUk7QUFDcEIsVUFBRSxFQUFFLElBQUksT0FBUSxJQUFJO0FBQ3BCLFVBQUUsRUFBRSxJQUFJLE9BQU8sS0FBSztBQUNwQixVQUFFLEVBQUUsSUFBSSxPQUFPLEtBQUs7QUFFcEIsVUFBRSxFQUFFLElBQUksT0FBUSxJQUFJO0FBQ3BCLFVBQUUsRUFBRSxJQUFJLE9BQVEsSUFBSTtBQUNwQixVQUFFLEVBQUUsSUFBSSxPQUFPLEtBQUs7QUFDcEIsVUFBRSxFQUFFLElBQUksT0FBTyxLQUFLO0FBRXBCLFVBQUUsRUFBRSxJQUFJLE9BQVEsSUFBSTtBQUNwQixVQUFFLEVBQUUsSUFBSSxPQUFRLElBQUk7QUFDcEIsVUFBRSxFQUFFLElBQUksT0FBTyxLQUFLO0FBQ3BCLFVBQUUsRUFBRSxJQUFJLE9BQU8sS0FBSztBQUVwQixVQUFFLEVBQUUsSUFBSSxPQUFRLElBQUk7QUFDcEIsVUFBRSxFQUFFLElBQUksT0FBUSxJQUFJO0FBQ3BCLFVBQUUsRUFBRSxJQUFJLE9BQU8sS0FBSztBQUNwQixVQUFFLEVBQUUsSUFBSSxPQUFPLEtBQUs7QUFFcEIsVUFBRSxFQUFFLElBQUksUUFBUyxJQUFJO0FBQ3JCLFVBQUUsRUFBRSxJQUFJLFFBQVMsSUFBSTtBQUNyQixVQUFFLEVBQUUsSUFBSSxRQUFRLEtBQUs7QUFDckIsVUFBRSxFQUFFLElBQUksUUFBUSxLQUFLO0FBRXJCLFVBQUUsRUFBRSxJQUFJLFFBQVMsSUFBSTtBQUNyQixVQUFFLEVBQUUsSUFBSSxRQUFTLElBQUk7QUFDckIsVUFBRSxFQUFFLElBQUksUUFBUSxLQUFLO0FBQ3JCLFVBQUUsRUFBRSxJQUFJLFFBQVEsS0FBSztBQUVyQixVQUFFLEVBQUUsSUFBSSxRQUFTLElBQUk7QUFDckIsVUFBRSxFQUFFLElBQUksUUFBUyxJQUFJO0FBQ3JCLFVBQUUsRUFBRSxJQUFJLFFBQVEsS0FBSztBQUNyQixVQUFFLEVBQUUsSUFBSSxRQUFRLEtBQUs7QUFFckIsVUFBRSxFQUFFLElBQUksUUFBUyxJQUFJO0FBQ3JCLFVBQUUsRUFBRSxJQUFJLFFBQVMsSUFBSTtBQUNyQixVQUFFLEVBQUUsSUFBSSxRQUFRLEtBQUs7QUFDckIsVUFBRSxFQUFFLElBQUksUUFBUSxLQUFLO0FBRXJCLFVBQUUsRUFBRSxJQUFJLFFBQVMsSUFBSTtBQUNyQixVQUFFLEVBQUUsSUFBSSxRQUFTLElBQUk7QUFDckIsVUFBRSxFQUFFLElBQUksUUFBUSxLQUFLO0FBQ3JCLFVBQUUsRUFBRSxJQUFJLFFBQVEsS0FBSztBQUVyQixVQUFFLEVBQUUsSUFBSSxRQUFTLElBQUk7QUFDckIsVUFBRSxFQUFFLElBQUksUUFBUyxJQUFJO0FBQ3JCLFVBQUUsRUFBRSxJQUFJLFFBQVEsS0FBSztBQUNyQixVQUFFLEVBQUUsSUFBSSxRQUFRLEtBQUs7QUFBQSxNQUN2QjtBQUVBLGVBQVMsY0FBYyxHQUFFLEdBQUUsR0FBRSxHQUFHO0FBQzlCLFlBQUksS0FBTSxFQUFHLENBQUMsSUFBSSxPQUFRLEVBQUcsQ0FBQyxJQUFJLFFBQU8sS0FBSyxFQUFHLENBQUMsSUFBSSxRQUFPLE1BQU0sRUFBRyxDQUFDLElBQUksUUFBTyxJQUM5RSxLQUFNLEVBQUcsQ0FBQyxJQUFJLE9BQVEsRUFBRyxDQUFDLElBQUksUUFBTyxLQUFLLEVBQUcsQ0FBQyxJQUFJLFFBQU8sTUFBTSxFQUFHLENBQUMsSUFBSSxRQUFPLElBQzlFLEtBQU0sRUFBRyxDQUFDLElBQUksT0FBUSxFQUFHLENBQUMsSUFBSSxRQUFPLEtBQUssRUFBRyxDQUFDLElBQUksUUFBTyxNQUFNLEVBQUcsQ0FBQyxJQUFJLFFBQU8sSUFDOUUsS0FBTSxFQUFHLENBQUMsSUFBSSxPQUFRLEVBQUcsQ0FBQyxJQUFJLFFBQU8sS0FBSyxFQUFFLEVBQUUsSUFBSSxRQUFPLE1BQU0sRUFBRSxFQUFFLElBQUksUUFBTyxJQUM5RSxLQUFNLEVBQUUsRUFBRSxJQUFJLE9BQVEsRUFBRSxFQUFFLElBQUksUUFBTyxLQUFLLEVBQUUsRUFBRSxJQUFJLFFBQU8sTUFBTSxFQUFFLEVBQUUsSUFBSSxRQUFPLElBQzlFLEtBQU0sRUFBRyxDQUFDLElBQUksT0FBUSxFQUFHLENBQUMsSUFBSSxRQUFPLEtBQUssRUFBRyxDQUFDLElBQUksUUFBTyxNQUFNLEVBQUcsQ0FBQyxJQUFJLFFBQU8sSUFDOUUsS0FBTSxFQUFHLENBQUMsSUFBSSxPQUFRLEVBQUcsQ0FBQyxJQUFJLFFBQU8sS0FBSyxFQUFHLENBQUMsSUFBSSxRQUFPLE1BQU0sRUFBRyxDQUFDLElBQUksUUFBTyxJQUM5RSxLQUFNLEVBQUcsQ0FBQyxJQUFJLE9BQVEsRUFBRyxDQUFDLElBQUksUUFBTyxLQUFLLEVBQUcsQ0FBQyxJQUFJLFFBQU8sTUFBTSxFQUFHLENBQUMsSUFBSSxRQUFPLElBQzlFLEtBQU0sRUFBRyxDQUFDLElBQUksT0FBUSxFQUFHLENBQUMsSUFBSSxRQUFPLEtBQUssRUFBRSxFQUFFLElBQUksUUFBTyxNQUFNLEVBQUUsRUFBRSxJQUFJLFFBQU8sSUFDOUUsS0FBTSxFQUFFLEVBQUUsSUFBSSxPQUFRLEVBQUUsRUFBRSxJQUFJLFFBQU8sS0FBSyxFQUFFLEVBQUUsSUFBSSxRQUFPLE1BQU0sRUFBRSxFQUFFLElBQUksUUFBTyxJQUM5RSxNQUFNLEVBQUcsQ0FBQyxJQUFJLE9BQVEsRUFBRyxDQUFDLElBQUksUUFBTyxLQUFLLEVBQUUsRUFB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LE1BQU0sTUFBTztBQUN0RixhQUFLLEVBQUUsQ0FBQyxJQUFNLE9BQVEsSUFBTTtBQUM1QixhQUFLLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUFHLGFBQUssRUFBRSxDQUFDLEtBQU0sT0FBTyxLQUFPLE1BQU8sS0FBTTtBQUN0RixhQUFLLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUFHLGFBQUssRUFBRSxDQUFDLEtBQU0sT0FBTyxLQUFPLE1BQU8sS0FBTTtBQUN0RixhQUFLLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUFHLGFBQUssRUFBRSxDQUFDLEtBQU0sT0FBUSxJQUFNLE1BQU8sS0FBTTtBQUN0RixhQUFLLEVBQUUsQ0FBQyxJQUFNLE9BQVEsSUFBTTtBQUU1QixhQUFLLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUNuRCxhQUFLLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUNuRCxhQUFLLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUNuRCxhQUFLLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUNuRCxhQUFLLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUNuRCxhQUFLLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUNuRCxhQUFLLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUNuRCxhQUFLLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxJQUFJLE9BQVEsSUFBSSxFQUFFLElBQUksUUFBUztBQUFBLE1BQ3JEO0FBRUEsZUFBUyxVQUFVLFNBQVMsU0FBUyxHQUFHLE1BQU0sT0FBTztBQUNuRCxZQUFJLFFBQVEsS0FBSyxNQUFNLElBQUssS0FBSztBQUNqQyxZQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUNwQyxZQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBRXhDLFlBQUksS0FBSyxLQUFLLEVBQUUsQ0FBQyxHQUNiLEtBQUssS0FBSyxFQUFFLENBQUMsR0FDYixLQUFLLEtBQUssRUFBRSxDQUFDLEdBQ2IsS0FBSyxLQUFLLEVBQUUsQ0FBQyxHQUNiLEtBQUssS0FBSyxFQUFFLENBQUMsR0FDYixLQUFLLEtBQUssRUFBRSxDQUFDLEdBQ2IsS0FBSyxLQUFLLEVBQUUsQ0FBQyxHQUNiLEtBQUssS0FBSyxFQUFFLENBQUMsR0FDYixLQUFLLEtBQUssRUFBRSxDQUFDLEdBQ2IsS0FBSyxLQUFLLEVBQUUsQ0FBQztBQUVqQixZQUFJLEtBQUssS0FBSyxFQUFFLENBQUMsR0FDYixLQUFLLEtBQUssRUFBRSxDQUFDLEdBQ2IsS0FBSyxLQUFLLEVBQUUsQ0FBQyxHQUNiLEtBQUssS0FBSyxFQUFFLENBQUMsR0FDYixLQUFLLEtBQUssRUFBRSxDQUFDLEdBQ2IsS0FBSyxLQUFLLEVBQUUsQ0FBQyxHQUNiLEtBQUssS0FBSyxFQUFFLENBQUMsR0FDYixLQUFLLEtBQUssRUFBRSxDQUFDLEdBQ2IsS0FBSyxLQUFLLEVBQUUsQ0FBQyxHQUNiLEtBQUssS0FBSyxFQUFFLENBQUM7QUFFakIsZUFBTyxTQUFTLElBQUk7QUFDbEIsZUFBSyxFQUFFLE9BQU0sQ0FBQyxJQUFJLE9BQVEsRUFBRSxPQUFNLENBQUMsSUFBSSxRQUFTO0FBQUcsZ0JBQVEsS0FBMkI7QUFDdEYsZUFBSyxFQUFFLE9BQU0sQ0FBQyxJQUFJLE9BQVEsRUFBRSxPQUFNLENBQUMsSUFBSSxRQUFTO0FBQUcsaUJBQVEsT0FBTyxLQUFPLE1BQU8sS0FBTTtBQUN0RixlQUFLLEVBQUUsT0FBTSxDQUFDLElBQUksT0FBUSxFQUFFLE9BQU0sQ0FBQyxJQUFJLFFBQVM7QUFBRyxpQkFBUSxPQUFPLEtBQU8sTUFBTyxLQUFNO0FBQ3RGLGVBQUssRUFBRSxPQUFNLENBQUMsSUFBSSxPQUFRLEVBQUUsT0FBTSxDQUFDLElBQUksUUFBUztBQUFHLGlCQUFRLE9BQVEsSUFBTSxNQUFPLEtBQU07QUFDdEYsZUFBSyxFQUFFLE9BQU0sQ0FBQyxJQUFJLE9BQVEsRUFBRSxPQUFNLENBQUMsSUFBSSxRQUFTO0FBQUcsaUJBQVEsT0FBUSxJQUFNLE1BQU0sTUFBTztBQUN0RixnQkFBUSxPQUFRLElBQU07QUFDdEIsZUFBSyxFQUFFLE9BQUssRUFBRSxJQUFJLE9BQVEsRUFBRSxPQUFLLEVBQUUsSUFBSSxRQUFTO0FBQUcsaUJBQVEsT0FBTyxLQUFPLE1BQU8sS0FBTTtBQUN0RixlQUFLLEVBQUUsT0FBSyxFQUFFLElBQUksT0FBUSxFQUFFLE9BQUssRUFBRSxJQUFJLFFBQVM7QUFBRyxpQkFBUSxPQUFPLEtBQU8sTUFBTyxLQUFNO0FBQ3RGLGVBQUssRUFBRSxPQUFLLEVBQUUsSUFBSSxPQUFRLEVBQUUsT0FBSyxFQUFFLElBQUksUUFBUztBQUFHLGlCQUFRLE9BQVEsSUFBTSxNQUFPLEtBQU07QUFDdEYsZ0JBQVEsT0FBTyxJQUFNO0FBRXJCLGNBQUk7QUFFSixlQUFLO0FBQ0wsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixjQUFLLE9BQU87QUFBSyxnQkFBTTtBQUN2QixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGVBQU0sT0FBTztBQUFLLGdCQUFNO0FBRXhCLGVBQUs7QUFDTCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGNBQUssT0FBTztBQUFLLGdCQUFNO0FBQ3ZCLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZUFBTSxPQUFPO0FBQUssZ0JBQU07QUFFeEIsZUFBSztBQUNMLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsY0FBSyxPQUFPO0FBQUssZ0JBQU07QUFDdkIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixlQUFNLE9BQU87QUFBSyxnQkFBTTtBQUV4QixlQUFLO0FBQ0wsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixjQUFLLE9BQU87QUFBSyxnQkFBTTtBQUN2QixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGVBQU0sT0FBTztBQUFLLGdCQUFNO0FBRXhCLGVBQUs7QUFDTCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGNBQUssT0FBTztBQUFLLGdCQUFNO0FBQ3ZCLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZUFBTSxPQUFPO0FBQUssZ0JBQU07QUFFeEIsZUFBSztBQUNMLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsY0FBSyxPQUFPO0FBQUssZ0JBQU07QUFDdkIsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixlQUFNLE9BQU87QUFBSyxnQkFBTTtBQUV4QixlQUFLO0FBQ0wsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxjQUFLLE9BQU87QUFBSyxnQkFBTTtBQUN2QixnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGVBQU0sT0FBTztBQUFLLGdCQUFNO0FBRXhCLGVBQUs7QUFDTCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGNBQUssT0FBTztBQUFLLGdCQUFNO0FBQ3ZCLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsZUFBTSxPQUFPO0FBQUssZ0JBQU07QUFFeEIsZUFBSztBQUNMLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsY0FBSyxPQUFPO0FBQUssZ0JBQU07QUFDdkIsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixlQUFNLE9BQU87QUFBSyxnQkFBTTtBQUV4QixlQUFLO0FBQ0wsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxjQUFLLE9BQU87QUFBSyxnQkFBTTtBQUN2QixnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBQ1gsZ0JBQU0sS0FBSztBQUNYLGVBQU0sT0FBTztBQUFLLGdCQUFNO0FBRXhCLGVBQU8sS0FBSyxLQUFLLElBQU07QUFDdkIsY0FBSyxJQUFJLEtBQU07QUFDZixlQUFLLElBQUk7QUFDVCxjQUFLLE1BQU07QUFDWCxnQkFBTTtBQUVOLGVBQUs7QUFDTCxlQUFLO0FBQ0wsZUFBSztBQUNMLGVBQUs7QUFDTCxlQUFLO0FBQ0wsZUFBSztBQUNMLGVBQUs7QUFDTCxlQUFLO0FBQ0wsZUFBSztBQUNMLGVBQUs7QUFFTCxrQkFBUTtBQUNSLG1CQUFTO0FBQUEsUUFDWDtBQUNBLGFBQUssRUFBRSxDQUFDLElBQUk7QUFDWixhQUFLLEVBQUUsQ0FBQyxJQUFJO0FBQ1osYUFBSyxFQUFFLENBQUMsSUFBSTtBQUNaLGFBQUssRUFBRSxDQUFDLElBQUk7QUFDWixhQUFLLEVBQUUsQ0FBQyxJQUFJO0FBQ1osYUFBSyxFQUFFLENBQUMsSUFBSTtBQUNaLGFBQUssRUFBRSxDQUFDLElBQUk7QUFDWixhQUFLLEVBQUUsQ0FBQyxJQUFJO0FBQ1osYUFBSyxFQUFFLENBQUMsSUFBSTtBQUNaLGFBQUssRUFBRSxDQUFDLElBQUk7QUFBQSxNQUNkO0FBRUEsZUFBUyxVQUFVLFNBQVMsU0FBUyxLQUFLLFFBQVE7QUFDaEQsWUFBSSxJQUFJLElBQUksWUFBWSxFQUFFO0FBQzFCLFlBQUksR0FBRyxNQUFNLEdBQUc7QUFFaEIsWUFBSSxLQUFLLFVBQVU7QUFDakIsY0FBSSxLQUFLO0FBQ1QsZUFBSyxPQUFPLEdBQUcsSUFBSTtBQUNuQixpQkFBTyxJQUFJLElBQUk7QUFBSyxpQkFBSyxPQUFPLENBQUMsSUFBSTtBQUNyQyxlQUFLLE1BQU07QUFDWCxlQUFLLE9BQU8sS0FBSyxRQUFRLEdBQUcsRUFBRTtBQUFBLFFBQ2hDO0FBRUEsWUFBSSxLQUFLLEVBQUUsQ0FBQyxNQUFNO0FBQ2xCLGFBQUssRUFBRSxDQUFDLEtBQUs7QUFDYixhQUFLLElBQUksR0FBRyxJQUFJLElBQUksS0FBSztBQUN2QixlQUFLLEVBQUUsQ0FBQyxLQUFLO0FBQ2IsY0FBSSxLQUFLLEVBQUUsQ0FBQyxNQUFNO0FBQ2xCLGVBQUssRUFBRSxDQUFDLEtBQUs7QUFBQSxRQUNmO0FBQ0EsYUFBSyxFQUFFLENBQUMsS0FBTSxJQUFJO0FBQ2xCLFlBQUksS0FBSyxFQUFFLENBQUMsTUFBTTtBQUNsQixhQUFLLEVBQUUsQ0FBQyxLQUFLO0FBQ2IsYUFBSyxFQUFFLENBQUMsS0FBSztBQUNiLFlBQUksS0FBSyxFQUFFLENBQUMsTUFBTTtBQUNsQixhQUFLLEVBQUUsQ0FBQyxLQUFLO0FBQ2IsYUFBSyxFQUFFLENBQUMsS0FBSztBQUViLFVBQUUsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDbkIsWUFBSSxFQUFFLENBQUMsTUFBTTtBQUNiLFVBQUUsQ0FBQyxLQUFLO0FBQ1IsYUFBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLEtBQUs7QUFDdkIsWUFBRSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsSUFBSTtBQUNuQixjQUFJLEVBQUUsQ0FBQyxNQUFNO0FBQ2IsWUFBRSxDQUFDLEtBQUs7QUFBQSxRQUNWO0FBQ0EsVUFBRSxDQUFDLEtBQU0sS0FBSztBQUVkLGdCQUFRLElBQUksS0FBSztBQUNqQixhQUFLLElBQUksR0FBRyxJQUFJLElBQUk7QUFBSyxZQUFFLENBQUMsS0FBSztBQUNqQyxlQUFPLENBQUM7QUFDUixhQUFLLElBQUksR0FBRyxJQUFJLElBQUk7QUFBSyxlQUFLLEVBQUUsQ0FBQyxJQUFLLEtBQUssRUFBRSxDQUFDLElBQUksT0FBUSxFQUFFLENBQUM7QUFFN0QsYUFBSyxFQUFFLENBQUMsS0FBTSxLQUFLLEVBQUUsQ0FBQyxJQUFhLEtBQUssRUFBRSxDQUFDLEtBQUssTUFBMkI7QUFDM0UsYUFBSyxFQUFFLENBQUMsS0FBTSxLQUFLLEVBQUUsQ0FBQyxNQUFPLElBQU0sS0FBSyxFQUFFLENBQUMsS0FBSyxNQUEyQjtBQUMzRSxhQUFLLEVBQUUsQ0FBQyxLQUFNLEtBQUssRUFBRSxDQUFDLE1BQU8sSUFBTSxLQUFLLEVBQUUsQ0FBQyxLQUFNLEtBQTBCO0FBQzNFLGFBQUssRUFBRSxDQUFDLEtBQU0sS0FBSyxFQUFFLENBQUMsTUFBTyxJQUFNLEtBQUssRUFBRSxDQUFDLEtBQU0sS0FBMEI7QUFDM0UsYUFBSyxFQUFFLENBQUMsS0FBTSxLQUFLLEVBQUUsQ0FBQyxNQUFNLEtBQU8sS0FBSyxFQUFFLENBQUMsS0FBTSxJQUFNLEtBQUssRUFBRSxDQUFDLEtBQUssTUFBTztBQUMzRSxhQUFLLEVBQUUsQ0FBQyxLQUFNLEtBQUssRUFBRSxDQUFDLE1BQU8sSUFBTSxLQUFLLEVBQUUsQ0FBQyxLQUFLLE1BQTJCO0FBQzNFLGFBQUssRUFBRSxDQUFDLEtBQU0sS0FBSyxFQUFFLENBQUMsTUFBTyxJQUFNLEtBQUssRUFBRSxDQUFDLEtBQU0sS0FBMEI7QUFDM0UsYUFBSyxFQUFFLENBQUMsS0FBTSxLQUFLLEVBQUUsQ0FBQyxNQUFPLElBQU0sS0FBSyxFQUFFLENBQUMsS0FBTSxLQUEwQjtBQUUzRSxZQUFJLEtBQUssRUFBRSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUM7QUFDMUIsYUFBSyxFQUFFLENBQUMsSUFBSSxJQUFJO0FBQ2hCLGFBQUssSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLO0FBQ3RCLGVBQU8sS0FBSyxFQUFFLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFLLE1BQU0sTUFBTSxNQUFPO0FBQ3JELGVBQUssRUFBRSxDQUFDLElBQUksSUFBSTtBQUFBLFFBQ2xCO0FBRUEsWUFBSSxTQUFRLENBQUMsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFRLENBQUMsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFRLENBQUMsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFRLENBQUMsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFRLENBQUMsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFRLENBQUMsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFRLENBQUMsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFRLENBQUMsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFRLENBQUMsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFRLENBQUMsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFPLEVBQUUsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFPLEVBQUUsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFPLEVBQUUsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFPLEVBQUUsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFPLEVBQUUsSUFBSyxLQUFLLEVBQUUsQ0FBQyxNQUFNLElBQUs7QUFDckMsWUFBSSxTQUFPLEVBQUUsSUFBSyxL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TUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FDckUsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FDckUsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUM1RCxLQUFLLEVBQUUsQ0FBQyxHQUNSLEtBQUssRUFBRSxDQUFDLEdBQ1IsS0FBSyxFQUFFLENBQUMsR0FDUixLQUFLLEVBQUUsQ0FBQyxHQUNSLEtBQUssRUFBRSxDQUFDLEdBQ1IsS0FBSyxFQUFFLENBQUMsR0FDUixLQUFLLEVBQUUsQ0FBQyxHQUNSLEtBQUssRUFBRSxDQUFDLEdBQ1IsS0FBSyxFQUFFLENBQUMsR0FDUixLQUFLLEVBQUUsQ0FBQyxHQUNSLE1BQU0sRUFBRSxFQUFFLEdBQ1YsTUFBTSxFQUFFLEVBQUUsR0FDVixNQUFNLEVBQUUsRUFBRSxHQUNWLE1BQU0sRUFBRSxFQUFFLEdBQ1YsTUFBTSxFQUFFLEVBQUUsR0FDVixNQUFNLEVBQUUsRUFBRTtBQUVaLFlBQUksRUFBRSxDQUFDO0FBQ1AsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsWUFBSSxFQUFFLENBQUM7QUFDUCxjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxZQUFJLEVBQUUsQ0FBQztBQUNQLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLFlBQUksRUFBRSxDQUFDO0FBQ1AsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsWUFBSSxFQUFFLENBQUM7QUFDUCxjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxZQUFJLEVBQUUsQ0FBQztBQUNQLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLFlBQUksRUFBRSxDQUFDO0FBQ1AsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsY0FBTSxJQUFJO0FBQ1YsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsWUFBSSxFQUFFLENBQUM7QUFDUCxjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixjQUFNLElBQUk7QUFDVixlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxZQUFJLEVBQUUsQ0FBQztBQUNQLGNBQU0sSUFBSTtBQUNWLGNBQU0sSUFBSTtBQUNWLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLFlBQUksRUFBRSxDQUFDO0FBQ1AsY0FBTSxJQUFJO0FBQ1YsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsWUFBSSxFQUFFLEVBQUU7QUFDUixlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxZQUFJLEVBQUUsRUFBRTtBQUNSLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLFlBQUksRUFBRSxFQUFFO0FBQ1IsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsWUFBSSxFQUFFLEVBQUU7QUFDUixlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxlQUFPLElBQUk7QUFDWCxZQUFJLEVBQUUsRUFBRTtBQUNSLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLGVBQU8sSUFBSTtBQUNYLFlBQUksRUFBRSxFQUFFO0FBQ1IsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBRVgsY0FBTyxLQUFLO0FBQ1osY0FBTyxLQUFLO0FBQ1osY0FBTyxLQUFLO0FBQ1osY0FBTyxLQUFLO0FBQ1osY0FBTyxLQUFLO0FBQ1osY0FBTyxLQUFLO0FBQ1osY0FBTyxLQUFLO0FBQ1osY0FBTyxLQUFLO0FBQ1osY0FBTyxLQUFLO0FBQ1osY0FBTyxLQUFLO0FBQ1osZUFBTyxLQUFLO0FBQ1osZUFBTyxLQUFLO0FBQ1osZUFBTyxLQUFLO0FBQ1osZUFBTyxLQUFLO0FBQ1osZUFBTyxLQUFLO0FBSVosWUFBSTtBQUNKLFlBQUssS0FBSyxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUksYUFBSyxJQUFJLElBQUk7QUFDOUQsWUFBSyxLQUFLLElBQUk7QUFBTyxZQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFBSSxhQUFLLElBQUksSUFBSTtBQUM5RCxZQUFLLEtBQUssSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUFJLGFBQUssSUFBSSxJQUFJO0FBQzlELFlBQUssS0FBSyxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUksYUFBSyxJQUFJLElBQUk7QUFDOUQsWUFBSyxLQUFLLElBQUk7QUFBTyxZQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFBSSxhQUFLLElBQUksSUFBSTtBQUM5RCxZQUFLLEtBQUssSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUFJLGFBQUssSUFBSSxJQUFJO0FBQzlELFlBQUssS0FBSyxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUksYUFBSyxJQUFJLElBQUk7QUFDOUQsWUFBSyxLQUFLLElBQUk7QUFBTyxZQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFBSSxhQUFLLElBQUksSUFBSTtBQUM5RCxZQUFLLEtBQUssSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUFJLGFBQUssSUFBSSxJQUFJO0FBQzlELFlBQUssS0FBSyxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUksYUFBSyxJQUFJLElBQUk7QUFDOUQsWUFBSSxNQUFNLElBQUk7QUFBTyxZQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFBRyxjQUFNLElBQUksSUFBSTtBQUM5RCxZQUFJLE1BQU0sSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUFHLGNBQU0sSUFBSSxJQUFJO0FBQzlELFlBQUksTUFBTSxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUcsY0FBTSxJQUFJLElBQUk7QUFDOUQsWUFBSSxNQUFNLElBQUk7QUFBTyxZQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFBRyxjQUFNLElBQUksSUFBSTtBQUM5RCxZQUFJLE1BQU0sSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUFHLGNBQU0sSUFBSSxJQUFJO0FBQzlELFlBQUksTUFBTSxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUcsY0FBTSxJQUFJLElBQUk7QUFDOUQsY0FBTSxJQUFFLElBQUksTUFBTSxJQUFFO0FBR3BCLFlBQUk7QUFDSixZQUFLLEtBQUssSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUFJLGFBQUssSUFBSSxJQUFJO0FBQzlELFlBQUssS0FBSyxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUksYUFBSyxJQUFJLElBQUk7QUFDOUQsWUFBSyxLQUFLLElBQUk7QUFBTyxZQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFBSSxhQUFLLElBQUksSUFBSTtBQUM5RCxZQUFLLEtBQUssSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUFJLGFBQUssSUFBSSxJQUFJO0FBQzlELFlBQUssS0FBSyxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUksYUFBSyxJQUFJLElBQUk7QUFDOUQsWUFBSyxLQUFLLElBQUk7QUFBTyxZQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFBSSxhQUFLLElBQUksSUFBSTtBQUM5RCxZQUFLLEtBQUssSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUFJLGFBQUssSUFBSSxJQUFJO0FBQzlELFlBQUssS0FBSyxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUksYUFBSyxJQUFJLElBQUk7QUFDOUQsWUFBSyxLQUFLLElBQUk7QUFBTyxZQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFBSSxhQUFLLElBQUksSUFBSTtBQUM5RCxZQUFLLEtBQUssSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUFJLGFBQUssSUFBSSxJQUFJO0FBQzlELFlBQUksTUFBTSxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUcsY0FBTSxJQUFJLElBQUk7QUFDOUQsWUFBSSxNQUFNLElBQUk7QUFBTyxZQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFBRyxjQUFNLElBQUksSUFBSTtBQUM5RCxZQUFJLE1BQU0sSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUFHLGNBQU0sSUFBSSxJQUFJO0FBQzlELFlBQUksTUFBTSxJQUFJO0FBQU8sWUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUcsY0FBTSxJQUFJLElBQUk7QUFDOUQsWUFBSSxNQUFNLElBQUk7QUFBTyxZQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFBRyxjQUFNLElBQUksSUFBSTtBQUM5RCxZQUFJLE1BQU0sSUFBSTtBQUFPLFlBQUksS0FBSyxNQUFNLElBQUks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QUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFB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QUFxQixTQUFTO0FBbUZ2RCxRQUFJLFFBQVE7QUFFWixRQUFJLFdBQVcsV0FBVztBQUN4QixXQUFLLElBQUk7QUFBQSxRQUNQLElBQUksWUFBWTtBQUFBLFVBQ2Q7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxRQUFVLENBQUM7QUFBQSxRQUNqRCxJQUFJLFlBQVk7QUFBQSxVQUNkO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsUUFBVSxDQUFDO0FBQUEsUUFDakQsSUFBSSxZQUFZO0FBQUEsVUFDZDtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFFBQVUsQ0FBQztBQUFBLFFBQ2pELElBQUksWUFBWTtBQUFBLFVBQ2Q7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUNwQztBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQ3BDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFDcEM7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxRQUFVLENBQUM7QUFBQSxNQUNqRDtBQUNGLFdBQUssSUFBSSxJQUFJLFlBQVk7QUFBQSxRQUN2QjtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFB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QUFBQTtBQUFBLFFBQ1AsTUFBTTtBQUFBO0FBQUE7QUFBQSxRQUVOLE1BQU07QUFBQTtBQUFBO0FBQUEsUUFFTixPQUFPO0FBQUE7QUFBQSxRQUNQLFFBQVE7QUFBQTtBQUFBLFFBQ1IsT0FBTztBQUFBO0FBQUEsUUFDUCxPQUFPO0FBQUE7QUFBQSxRQUNQLFFBQVE7QUFBQTtBQUFBLFFBQ1IsVUFBVTtBQUFBO0FBQUEsUUFDVixTQUFTO0FBQUE7QUFBQSxRQUNULFFBQVE7QUFBQTtBQUFBO0FBQUEsUUFFUixRQUFRO0FBQUE7QUFBQSxRQUNSLFFBQVE7QUFBQTtBQUFBLFFBQ1IsU0FBUztBQUFBO0FBQUE7QUFBQSxRQUVULFVBQVU7QUFBQTtBQUFBLFFBQ1YsUUFBUTtBQUFBO0FBQUE7QUFBQSxRQUVSLFFBQVE7QUFBQTtBQUFBLFFBQ1IsT0FBTztBQUFBO0FBQUEsUUFDUCxRQUFRO0FBQUE7QUFBQSxRQUNSLE9BQU87QUFBQTtBQUFBLFFBQ1AsT0FBTztBQUFBO0FBQUEsUUFDUCxPQUFPO0FBQUE7QUFBQSxRQUNQLE9BQU87QUFBQTtBQUFBLFFBQ1AsTUFBTTtBQUFBO0FBQUEsUUFDTixPQUFPO0FBQUE7QUFBQSxRQUNQLE9BQU87QUFBQTtBQUFBLFFBQ1AsU0FBUztBQUFBO0FBQUEsUUFDVCxNQUFNO0FBQUE7QUFBQSxRQUNOLFFBQVE7QUFBQTtBQUFBLFFBQ1IsT0FBTztBQUFBO0FBQUE7QUFBQSxRQUVQLE1BQU07QUFBQTtBQUFBLFFBQ04sT0FBTztBQUFBO0FBQUEsUUFDUCxPQUFPO0FBQUE7QUFBQSxRQUNQLFFBQVE7QUFBQTtBQUFBLFFBQ1IsUUFBUTtBQUFBO0FBQUEsUUFDUixRQUFRO0FBQUE7QUFBQSxRQUNSLFFBQVE7QUFBQTtBQUFBLFFBQ1IsU0FBUztBQUFBO0FBQUEsUUFDVCxRQUFRO0FBQUE7QUFBQSxRQUNSLFFBQVE7QUFBQTtBQUFBLFFBQ1IsT0FBTztBQUFBO0FBQUEsUUFDUCxPQUFPO0FBQUE7QUFBQSxRQUNQLE9BQU87QUFBQTtBQUFBLFFBQ1AsT0FBTztBQUFBO0FBQUEs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Qy9DO0FBQUEsSUFDRDtBQUFBLEVBQ0Q7QUFDRDsiLAogICJuYW1lcyI6IFsibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiQnVmZmVyIiwgIm1vZHVsZSIsICJCdWZmZXIiLCAibW9kdWxlIiwgIkJ1ZmZlciIsICJzZWxmIiwgImJ5dGVzIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJyZXF1aXJlX2xpYiIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJzZWxmIiwgIm1vZHVsZSIsICJjcmVhdGVQb2x5MTMwNSIsICJtb2R1bGUiLCAibW9kdWxlIiwgImdlbk9wZW5TU0xSU0FQcml2IiwgInAiLCAibW9kdWxlIiwgImVyciIsICJkYXRhIiwgInJlcSIsICJjYiIsICJtb2R1bGUiLCAic2VsZiIsICJtb2R1bGUiLCAic2VsZiIsICJ3aW5kb3ciLCAibW9kdWxlIiwgIm1vZHVsZSIsICJzZWxmIiwgImkiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJwYWNrZXQiLCAibW9kdWxlIiwgImVyIiwgImVyciIsICJzZWxmIiwgImxlbiIsICJvdmVyZmxvdyIsICJwZHN0IiwgIm1vZHVsZSIsICJ3aW5kb3ciLCAic2VsZiIsICJyZXF1aXJlX3V0aWxzIiwgIm1vZHVsZSIsICJzZWxmIiwgIm1vZHVsZSIsICJDbGllbnQiLCAiZXJyIiwgInNlbGYiLCAiQ2xpZW50IiwgIm1vZHVsZSIsICJDbGllbnQiLCAic2VsZiIsICJtb2R1bGUiLCAicmVxdWlyZV9saWIiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiQnVmZmVyIiwgIm1vZHVsZSIsICJlcnIiLCAic2VsZiIsICJtb2R1bGUiLCAiTm9kZUVycm9yIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJCdWZmZXIiLCAicmVhbEhhc0luc3RhbmNlIiwgIm1vZHVsZSIsICJrZXlzIiwgInNlbGYiLCAibW9kdWxlIiwgIm9ubGVnYWN5ZmluaXNoIiwgIm9uZmluaXNoIiwgIm9uZW5kIiwgIm9uZXJyb3IiLCAib25jbG9zZSIsICJvbnJlcXVlc3QiLCAibW9kdWxlIiwgImNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsICJtb2R1bGUiLCAibW9kdWxlIiwgIkVFbGlzdGVuZXJDb3VudCIsICJCdWZmZXIiLCAiZGVidWciLCAic2VsZiIsICJuIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAidW5kZWZpbmVkIiwgImYiLCAiQXJyYXlCdWZmZXIiLCAiQXJyYXlCdWZmZXJWaWV3IiwgIm1pbiIsICJJbnQ4QXJyYXkiLCAiVWludDhBcnJheSIsICJJbnQxNkFycmF5IiwgIlVpbnQxNkFycmF5IiwgIkludDMyQXJyYXkiLCAiVWludDMyQXJyYXkiLCAiRmxvYXQzMkFycmF5IiwgIkZsb2F0NjRBcnJheSIsICJEYXRhVmlldyIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJzZWxmIiwgIm9yaWdpbmFsIiwgInJlcXVpcmVfcmV0cnkiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJyZXF1aXJlX2NvbnN0YW50cyIsICJtb2R1bGUiLCAicmVxdWlyZV91dGlscyIsICJtb2R1bGUiLCAibW9kdWxlIiwgIkNsaWVudCIsICJpbnB1dCIsICJyZW1vdGVQYXRoIiwgIm9wdGlvbnMiLCAiQnVmZmVyIiwgImlwIiwgIlNvY2tzQ29tbWFuZCIsICJTb2NrczRSZXNwb25zZSIsICJTb2NrczVBdXRoIiwgIlNvY2tzNVJlc3BvbnNlIiwgIlNvY2tzNUhvc3RUeXBlIiwgIlNvY2tzQ2xpZW50U3RhdGUiLCAiU29ja3NDbGllbnQiLCAiaW1wb3J0X29ic2lkaWFuIiwgIkNsaWVudCJdCn0K
