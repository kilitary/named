/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/python-shell/index.js
var require_python_shell = __commonJS({
  "node_modules/python-shell/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PythonShell = exports.NewlineTransformer = exports.PythonShellErrorWithLogs = exports.PythonShellError = void 0;
    var events_1 = require("events");
    var child_process_1 = require("child_process");
    var os_1 = require("os");
    var path_1 = require("path");
    var stream_1 = require("stream");
    var fs_1 = require("fs");
    var util_1 = require("util");
    function toArray(source) {
      if (typeof source === "undefined" || source === null) {
        return [];
      } else if (!Array.isArray(source)) {
        return [source];
      }
      return source;
    }
    function extend(obj, ...args) {
      Array.prototype.slice.call(arguments, 1).forEach(function(source) {
        if (source) {
          for (let key in source) {
            obj[key] = source[key];
          }
        }
      });
      return obj;
    }
    function getRandomInt() {
      return Math.floor(Math.random() * 1e10);
    }
    var execPromise = (0, util_1.promisify)(child_process_1.exec);
    var PythonShellError = class extends Error {
    };
    exports.PythonShellError = PythonShellError;
    var PythonShellErrorWithLogs = class extends PythonShellError {
    };
    exports.PythonShellErrorWithLogs = PythonShellErrorWithLogs;
    var NewlineTransformer = class extends stream_1.Transform {
      _transform(chunk, encoding, callback) {
        let data = chunk.toString();
        if (this._lastLineData)
          data = this._lastLineData + data;
        const lines = data.split(os_1.EOL);
        this._lastLineData = lines.pop();
        lines.forEach(this.push.bind(this));
        callback();
      }
      _flush(done) {
        if (this._lastLineData)
          this.push(this._lastLineData);
        this._lastLineData = null;
        done();
      }
    };
    exports.NewlineTransformer = NewlineTransformer;
    var PythonShell2 = class extends events_1.EventEmitter {
      /**
       * spawns a python process
       * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified
       * @param options
       * @param stdoutSplitter Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines
       * @param stderrSplitter Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines
       */
      constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {
        super();
        function resolve(type, val) {
          if (typeof val === "string") {
            return PythonShell2[type][val];
          } else if (typeof val === "function") {
            return val;
          }
        }
        if (scriptPath.trim().length == 0)
          throw Error("scriptPath cannot be empty! You must give a script for python to run");
        let self = this;
        let errorData = "";
        events_1.EventEmitter.call(this);
        options = extend({}, PythonShell2.defaultOptions, options);
        let pythonPath;
        if (!options.pythonPath) {
          pythonPath = PythonShell2.defaultPythonPath;
        } else
          pythonPath = options.pythonPath;
        let pythonOptions = toArray(options.pythonOptions);
        let scriptArgs = toArray(options.args);
        this.scriptPath = (0, path_1.join)(options.scriptPath || "", scriptPath);
        this.command = pythonOptions.concat(this.scriptPath, scriptArgs);
        this.mode = options.mode || "text";
        this.formatter = resolve("format", options.formatter || this.mode);
        this.parser = resolve("parse", options.parser || this.mode);
        this.stderrParser = resolve("parse", options.stderrParser || "text");
        this.terminated = false;
        this.childProcess = (0, child_process_1.spawn)(pythonPath, this.command, options);
        ["stdout", "stdin", "stderr"].forEach(function(name) {
          self[name] = self.childProcess[name];
          self.parser && self[name] && self[name].setEncoding(options.encoding || "utf8");
        });
        if (this.parser && this.stdout) {
          if (!stdoutSplitter)
            stdoutSplitter = new NewlineTransformer();
          stdoutSplitter.setEncoding(options.encoding || "utf8");
          this.stdout.pipe(stdoutSplitter).on("data", (chunk) => {
            this.emit("message", self.parser(chunk));
          });
        }
        if (this.stderrParser && this.stderr) {
          if (!stderrSplitter)
            stderrSplitter = new NewlineTransformer();
          stderrSplitter.setEncoding(options.encoding || "utf8");
          this.stderr.pipe(stderrSplitter).on("data", (chunk) => {
            this.emit("stderr", self.stderrParser(chunk));
          });
        }
        if (this.stderr) {
          this.stderr.on("data", function(data) {
            errorData += "" + data;
          });
          this.stderr.on("end", function() {
            self.stderrHasEnded = true;
            terminateIfNeeded();
          });
        } else {
          self.stderrHasEnded = true;
        }
        if (this.stdout) {
          this.stdout.on("end", function() {
            self.stdoutHasEnded = true;
            terminateIfNeeded();
          });
        } else {
          self.stdoutHasEnded = true;
        }
        this.childProcess.on("error", function(err) {
          self.emit("error", err);
        });
        this.childProcess.on("exit", function(code, signal) {
          self.exitCode = code;
          self.exitSignal = signal;
          terminateIfNeeded();
        });
        function terminateIfNeeded() {
          if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null)
            return;
          let err;
          if (self.exitCode && self.exitCode !== 0) {
            if (errorData) {
              err = self.parseError(errorData);
            } else {
              err = new PythonShellError("process exited with code " + self.exitCode);
            }
            err = extend(err, {
              executable: pythonPath,
              options: pythonOptions.length ? pythonOptions : null,
              script: self.scriptPath,
              args: scriptArgs.length ? scriptArgs : null,
              exitCode: self.exitCode
            });
            if (self.listeners("pythonError").length || !self._endCallback) {
              self.emit("pythonError", err);
            }
          }
          self.terminated = true;
          self.emit("close");
          self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);
        }
        ;
      }
      /**
       * checks syntax without executing code
       * @returns rejects promise w/ string error output if syntax failure
       */
      static checkSyntax(code) {
        return __awaiter(this, void 0, void 0, function* () {
          const randomInt = getRandomInt();
          const filePath = (0, os_1.tmpdir)() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;
          const writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);
          return writeFilePromise(filePath, code).then(() => {
            return this.checkSyntaxFile(filePath);
          });
        });
      }
      static getPythonPath() {
        return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;
      }
      /**
       * checks syntax without executing code
       * @returns {Promise} rejects w/ stderr if syntax failure
       */
      static checkSyntaxFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
          const pythonPath = this.getPythonPath();
          let compileCommand = `${pythonPath} -m py_compile ${filePath}`;
          return execPromise(compileCommand);
        });
      }
      /**
       * Runs a Python script and returns collected messages as a promise.
       * If the promise is rejected, the err will probably be of type PythonShellErrorWithLogs
       * @param scriptPath   The path to the script to execute
       * @param options  The execution options
       */
      static run(scriptPath, options) {
        return new Promise((resolve, reject) => {
          let pyshell = new PythonShell2(scriptPath, options);
          let output = [];
          pyshell.on("message", function(message) {
            output.push(message);
          }).end(function(err) {
            if (err) {
              err.logs = output;
              reject(err);
            } else
              resolve(output);
          });
        });
      }
      /**
       * Runs the inputted string of python code and returns collected messages as a promise. DO NOT ALLOW UNTRUSTED USER INPUT HERE!
       * @param code   The python code to execute
       * @param options  The execution options
       * @return a promise with the output from the python script
       */
      static runString(code, options) {
        const randomInt = getRandomInt();
        const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;
        (0, fs_1.writeFileSync)(filePath, code);
        return PythonShell2.run(filePath, options);
      }
      static getVersion(pythonPath) {
        if (!pythonPath)
          pythonPath = this.getPythonPath();
        return execPromise(pythonPath + " --version");
      }
      static getVersionSync(pythonPath) {
        if (!pythonPath)
          pythonPath = this.getPythonPath();
        return (0, child_process_1.execSync)(pythonPath + " --version").toString();
      }
      /**
       * Parses an error thrown from the Python process through stderr
       * @param  {string|Buffer} data The stderr contents to parse
       * @return {Error} The parsed error with extended stack trace when traceback is available
       */
      parseError(data) {
        let text = "" + data;
        let error;
        if (/^Traceback/.test(text)) {
          let lines = text.trim().split(os_1.EOL);
          let exception = lines.pop();
          error = new PythonShellError(exception);
          error.traceback = data;
          error.stack += os_1.EOL + "    ----- Python Traceback -----" + os_1.EOL + "  ";
          error.stack += lines.slice(1).join(os_1.EOL + "  ");
        } else {
          error = new PythonShellError(text);
        }
        return error;
      }
      /**
       * Sends a message to the Python shell through stdin
       * Override this method to format data to be sent to the Python process
       * @returns {PythonShell} The same instance for chaining calls
       */
      send(message) {
        if (!this.stdin)
          throw new Error("stdin not open for writing");
        let data = this.formatter ? this.formatter(message) : message;
        if (this.mode !== "binary")
          data += os_1.EOL;
        this.stdin.write(data);
        return this;
      }
      /**
       * Closes the stdin stream. Unless python is listening for stdin in a loop
       * this should cause the process to finish its work and close.
       * @returns {PythonShell} The same instance for chaining calls
       */
      end(callback) {
        if (this.childProcess.stdin) {
          this.childProcess.stdin.end();
        }
        this._endCallback = callback;
        return this;
      }
      /**
       * Sends a kill signal to the process
       * @returns {PythonShell} The same instance for chaining calls
       */
      kill(signal) {
        this.terminated = this.childProcess.kill(signal);
        return this;
      }
      /**
       * Alias for kill.
       * @deprecated
       */
      terminate(signal) {
        return this.kill(signal);
      }
    };
    exports.PythonShell = PythonShell2;
    PythonShell2.defaultPythonPath = process.platform != "win32" ? "python3" : "python";
    PythonShell2.defaultOptions = {};
    PythonShell2.format = {
      text: function toText(data) {
        if (!data)
          return "";
        else if (typeof data !== "string")
          return data.toString();
        return data;
      },
      json: function toJson(data) {
        return JSON.stringify(data);
      }
    };
    PythonShell2.parse = {
      text: function asText(data) {
        return data;
      },
      json: function asJson(data) {
        return JSON.parse(data);
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  boundingBoxFromNode: () => boundingBoxFromNode,
  canvasBlockConnectionPointLanguageName: () => canvasBlockConnectionPointLanguageName,
  canvasBlockSettingsLanguageName: () => canvasBlockSettingsLanguageName,
  canvasClosestNodeToPosition: () => canvasClosestNodeToPosition,
  canvasClosestNodeToPositionInBounds: () => canvasClosestNodeToPositionInBounds,
  canvasNodesInBounds: () => canvasNodesInBounds,
  checkContainsLanguage: () => checkContainsLanguage,
  default: () => CanvasBlocksPlugin2,
  extractLanguageText: () => extractLanguageText,
  getNodeText: () => getNodeText,
  pythonCodeBlockLanguageName: () => pythonCodeBlockLanguageName
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var CanvasBlocksPluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Plugin data location").setDesc("Where the plugin will save data").addText(
      (text) => text.setPlaceholder("/").setValue(this.plugin.settings.dataFolder).onChange(async (value) => {
        this.plugin.settings.dataFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Workflow script folder").setDesc("Set the location for workflow scripts to be searched for").addText(
      (text) => text.setPlaceholder("/").setValue(this.plugin.settings.workflowScriptFolder).onChange(async (value) => {
        this.plugin.settings.workflowScriptFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Python path").setDesc("Override default python install").addText(
      (text) => text.setPlaceholder("python").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
        this.plugin.settings.pythonPath = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/pythonexecution.ts
var fs = __toESM(require("fs"));
var import_os = require("os");
var import_path = require("path");
var import_python_shell = __toESM(require_python_shell());

// resources/canvasblocks-python-lib.py
var canvasblocks_python_lib_default = `# Required to support union typings on Python versions below 3.10.0
# Versions >= 3.10.0 are also supported
from __future__ import annotations

import base64
import io
import json
import importlib
import subprocess
import os
import sys
import sysconfig
from typing import IO

# Replace the default python print function with one which will call console.log in the obisidan console
send_command = print
print = None
def print(*args):
    """Outputs the arguments to the console"""
    send_command(json.dumps({"command": "PRINT", "text": ' '.join(map(str, args))}))

def notice(*args):
    """Sends a notice pop up in Obsidian
    """
    send_command(json.dumps({"command": "NOTICE", "text": ' '.join(map(str, args))}))

def install_dependency(module: str, import_name: str = None):
    """Installs a module required by a script

    Args:
        module (str): The name of the module used to install with "pip install"
        import_name (str, optional): The name of the module used when importing. Leave as None if it is the same as "module" Defaults to None.
    """

    if import_name == None:
        import_name = module
    try:
        importlib.import_module(import_name)
    except ImportError:
        pip_path = sysconfig.get_path('scripts') + '/pip'
        output = subprocess.check_output([pip_path, 'install', module], stderr=subprocess.STDOUT)
        print(output)
        

# Read data dictionary from stdin
data_from_node = sys.stdin.buffer.readline().decode('utf-8').strip()
data_dict = json.loads(data_from_node)

# Create variables from the data dictionary
for variable_name, variable_value in data_dict.items():
    locals()[variable_name] = variable_value
del data_dict


if execution_type == "workflow": # type: ignore
    install_dependency("pillow", "PIL")
    from PIL import Image

    for ioName, value in in_data.items(): # type: ignore
        ioType = script_settings["ioConnections"][ioName]["type"] # type: ignore
        newValue = value

        if ioType == "image":
            decoded_data = base64.b64decode(value)
            image_buffer = io.BytesIO(decoded_data)
            newValue = Image.open(image_buffer)

        if ioType == "integer":
            newValue = int(value)

        if ioType == "float":
            newValue = float(value)  

        in_data[ioName] = newValue # type: ignore


def get_text_from_node(node_data: str) -> str|None:
    """If node_data is a text node, the text will be returned
    If node_data is a file node and the extension of the file is .md or .txt, the file will be read and the text returned
    If node_data is a file node and the extention is invalid, None will be returned
    If node_data is a link node, the url will be returned

    Args:
        node_data (str): The node object in JSON Canvas format

    Returns:
        str|None: The text returned or None if it cannot be found
    """

    if node_data["type"] == "text":
        return node_data["text"]
    
    if node_data["type"] == "link":
        return node_data["url"]
    
    if node_data["type"] == "file":
        _, file_extension = os.path.splitext(node_data["file"])
        if not file_extension[1:] in ["md","txt"]:
            return None
        # Warning suppressed as vault_path will be injected by the plugin
        path = os.path.join(vault_path, node_data["file"]) # type: ignore
        with open(path, "r") as file:
            return file.read()


    return None

def create_text_node(text: str, x: int, y: int, width: int = 250, height: int = 60):
    """Creates a text node in the canvas

    Args:
        text (str): The the text of the node
        x (int): The x coordinate of the node in the canvas
        y (int): The y coordinate of the node in the canvas
        width (int, optional): The width of the node. Defaults to 250.
        height (int, optional): The height of the node. Defaults to 60.
    """

    send_command(json.dumps({"command": "CREATE_TEXT_NODE", "text": text, "x": x, "y": y, "width": width, "height": height}))

def create_file_node(file: str, x: int, y: int, width: int = 400, height: int = 225):
    """Creates a file node in the canvas

    Args:
        file (str): The path to the file from the root directory of the Obsidian vault
        x (int): The x coordinate of the node in the canvas
        y (int): The y coordinate of the node in the canvas
        width (int, optional): The width of the node. Defaults to 400.
        height (int, optional): The height of the node. Defaults to 225.
    """

    send_command(json.dumps({"command": "CREATE_FILE_NODE", "file": file, "x": x, "y": y, "width": width, "height": height}))

def set_text_node_text(node_id: str, text: str):
    """Replaces the text of a text node

    Args:
        node_id (str): The ID of the node to replace
        text (str): New text
    """
    send_command(json.dumps({"command": "MODIFY_TEXT_NODE", "id": node_id, "text": text}))

def rebuild_canvas():
    """Causes the canvas to reload. Only required if set_text_node_text is called"""

    send_command(json.dumps({"command": "REBUILD_CANVAS"}))



# execution_type will be injected into the script
if execution_type == "simple": # type: ignore
    def get_parameter_file_path() -> str:
        """Gets the path of the file of a parameter node if the node type is file. Does not check type

        Returns:
            str: The absolute path of the file
        """

        # Warnings are suppressed as vault_path and parameter_data will be injected by the plugin
        return os.path.join(vault_path, parameter_data["file"])  # type: ignore

    def get_parameter_file(mode: str = "r") -> IO:
        """Helper function to get a file handler for the parameter file

        Args:
            read_type (str, optional): The mode which the file will be opened in. Defaults to "r".

        Returns:
            IO: File handler for the parameter file
        """
        return open(get_parameter_file_path(), mode)


# executionType will be injected into the script
elif execution_type == "workflow": # type: ignore

    def _return_output_data():
        """This function is for internal use only and should not be called by scripts.

        Returns the output data of a script in the workflow
        """

        # Alter output data to be serialisable
        for ioName, value in out_data.items(): # type: ignore
            ioType = script_settings["ioConnections"][ioName]["type"] # type: ignore
            newValue = value

            if ioType == "image":
                buffered = io.BytesIO()
                value.save(buffered, format="PNG")
                newValue = base64.b64encode(buffered.getvalue()).decode()

            if ioType == "integer" or ioType == "float":
                newValue = str(value)

            out_data[ioName] = newValue # type: ignore

        send_command(json.dumps({"command": "RETURN_OUTPUT", "data": out_data})) # type: ignore`;

// src/pythonexecution.ts
var import_obsidian2 = require("obsidian");
function defaultErrorHandler(canvas, error) {
  new import_obsidian2.Notice("An error has occured while running this script. Check the console for more detail.");
  console.error("Error parsing Python script result:", error);
}
async function defaultMessageHandler(canvas, message) {
  let commandType = message.command;
  switch (commandType) {
    case "CREATE_TEXT_NODE":
      {
        canvas.createTextNode({
          text: message.text,
          pos: {
            x: message.x,
            y: message.y
          },
          size: {
            width: message.width,
            height: message.height
          },
          save: false,
          focus: false
        });
      }
      break;
    case "CREATE_FILE_NODE":
      {
        let nodeFile = this.app.vault.getAbstractFileByPath((0, import_obsidian2.normalizePath)(message.file));
        canvas.createFileNode({
          file: nodeFile,
          pos: {
            x: message.x,
            y: message.y
          },
          size: {
            width: message.width,
            height: message.height
          },
          save: false,
          focus: false
        });
      }
      break;
    case "MODIFY_TEXT_NODE":
      {
        canvas.nodes.get(message.id).setText(message.text);
        canvas.data.nodes.filter((node) => node.id === message.id)[0].text = message.text;
      }
      break;
    case "REBUILD_CANVAS":
      {
        canvas.view.leaf.rebuildView();
      }
      break;
    case "PRINT":
      {
        console.log(message.text);
      }
      break;
    case "NOTICE":
      {
        new import_obsidian2.Notice(message.text);
      }
      break;
    default:
      return message;
  }
  return null;
}
async function executePythonString(plugin, canvas, scriptCode, injectionData, messageCallback = defaultMessageHandler, errorCallback = defaultErrorHandler) {
  return new Promise((resolve, reject) => {
    const pythonScript = `
${canvasblocks_python_lib_default}
${scriptCode.replace(/[^\x20-\x7E\t\n]/g, "")}
        `;
    let pythonPath;
    if (plugin.settings.pythonPath.trim() !== "")
      pythonPath = plugin.settings.pythonPath;
    const randomInt = Math.floor(Math.random() * 1e10);
    const tempFile = (0, import_os.tmpdir)() + import_path.sep + `pythonShellFile${randomInt}.py`;
    fs.writeFileSync(tempFile, pythonScript);
    let pyshell = new import_python_shell.PythonShell(tempFile, { mode: "json", encoding: "utf-8", pythonPath });
    pyshell.send(injectionData);
    let errorMessage = "";
    pyshell.on("error", (error) => {
      errorMessage += error + "\n";
    });
    pyshell.on("stderr", (data) => {
      errorMessage += data.toString() + "\n";
    });
    let messageQueue = [];
    pyshell.on("message", (message) => {
      messageQueue.push(message);
    });
    pyshell.on("close", async () => {
      if (errorMessage.length > 0) {
        await errorCallback(canvas, errorMessage);
        resolve(false);
      }
      for (let message of messageQueue) {
        await messageCallback(canvas, message);
      }
      resolve(true);
    });
  });
}

// src/workflow.ts
var import_obsidian3 = require("obsidian");
function refreshNode(canvas, id) {
  let node = canvas.nodes.get(id);
  if (node === void 0)
    return;
  let text = node.text;
  if (text === void 0)
    return;
  if (node.child === void 0)
    return;
  node.child.previewMode.renderer.set("");
  function waitForRenderQueue() {
    setTimeout(() => {
      try {
        if (node.child.previewMode.renderer.queued != null) {
          waitForRenderQueue();
        } else {
          setTimeout(() => {
            node.child.previewMode.renderer.set(text);
          }, 0);
        }
      } catch (error) {
      }
    }, 0);
  }
  waitForRenderQueue();
}
async function handleWorkflowFromGroup(plugin, canvas, selectedData) {
  let nodes = canvas.data.nodes;
  let closestID = await canvasClosestNodeToPositionInBounds(
    canvas,
    boundingBoxFromNode(selectedData),
    async (node) => {
      if (node.id === selectedData.id)
        return true;
      const hasCode = await checkContainsLanguage(plugin.app, node, pythonCodeBlockLanguageName);
      if (!hasCode)
        return true;
      const hasSettings = await checkContainsLanguage(plugin.app, node, canvasBlockSettingsLanguageName);
      if (!hasSettings)
        return true;
      return false;
    }
  );
  if (closestID === null)
    return;
  let startScriptNode = nodes.find((node) => node.id === closestID);
  if (startScriptNode === void 0)
    return;
  executeWorkflow(plugin, canvas, startScriptNode);
}
async function executeWorkflow(plugin, canvas, startScriptNode) {
  let nodes = canvas.data.nodes;
  let edges = canvas.data.edges;
  let scriptConnectionPoints = {};
  let dataFlow = {};
  let executionData = {};
  for (const node of nodes) {
    let text = await extractLanguageText(plugin.app, node, canvasBlockConnectionPointLanguageName);
    if (text === null)
      continue;
    let connectionPointData = JSON.parse(text);
    if (!scriptConnectionPoints[connectionPointData.scriptID]) {
      scriptConnectionPoints[connectionPointData.scriptID] = [];
    }
    scriptConnectionPoints[connectionPointData.scriptID].push(node);
  }
  let executeStack = [];
  let searchQueue = [startScriptNode];
  while (searchQueue.length > 0) {
    let currentScript = searchQueue.shift();
    if (currentScript === void 0)
      continue;
    if (!executeStack.includes(currentScript)) {
      executeStack.push(currentScript);
    }
    let settingsLanguageBlock = await extractLanguageText(plugin.app, currentScript, canvasBlockSettingsLanguageName);
    if (settingsLanguageBlock === null)
      continue;
    let scriptSettings = JSON.parse(settingsLanguageBlock);
    let connectionPoints = scriptConnectionPoints[currentScript.id];
    for (const connectionPoint of connectionPoints) {
      let connectionPointLanguageBlock = await extractLanguageText(plugin.app, connectionPoint, canvasBlockConnectionPointLanguageName);
      if (connectionPointLanguageBlock === null)
        continue;
      let connectionPointData = JSON.parse(connectionPointLanguageBlock);
      let ioConnection = scriptSettings.ioConnections[connectionPointData.name];
      if (ioConnection === void 0)
        continue;
      if (ioConnection.direction === "output")
        continue;
      let connectionEdge = edges.find((edge) => edge.toNode === connectionPoint.id);
      if (connectionEdge === void 0)
        continue;
      let otherConnectionID = connectionEdge.fromNode;
      if (otherConnectionID === void 0)
        continue;
      let otherConnectionPoint = nodes.find((node) => node.id === otherConnectionID);
      if (otherConnectionPoint === void 0)
        continue;
      let otherConnectionPointLanguageBlock = await extractLanguageText(plugin.app, otherConnectionPoint, canvasBlockConnectionPointLanguageName);
      if (otherConnectionPointLanguageBlock === null) {
        let flowName = `${otherConnectionID}_NODE}`;
        dataFlow[`${currentScript.id}_${connectionPointData.name}`] = flowName;
        switch (ioConnection.type) {
          case "text":
          case "integer":
          case "float":
            let text = await getNodeText(plugin.app, otherConnectionPoint);
            if (text === null) {
              new import_obsidian3.Notice(`Failed to load node as text`);
              return;
            }
            executionData[flowName] = text;
            break;
          case "image":
            if (otherConnectionPoint.type !== "file") {
              new import_obsidian3.Notice("Attempted to load a non-image node (${otherConnectionPoint.file}) as an image");
              return;
            }
            let file = plugin.app.vault.getAbstractFileByPath(otherConnectionPoint.file);
            if (file === null || !(file instanceof import_obsidian3.TFile)) {
              new import_obsidian3.Notice(`Attempt to load image ${otherConnectionPoint.file} failed`);
              return;
            }
            ;
            let image = await plugin.app.vault.readBinary(file);
            let base64Image = Buffer.from(image).toString("base64");
            executionData[flowName] = base64Image;
            break;
          case "file":
          case "any":
          default:
            executionData[flowName] = JSON.stringify(otherConnectionPoint);
            break;
        }
        continue;
      }
      let otherConnectionPointData = JSON.parse(otherConnectionPointLanguageBlock);
      let otherScript = nodes.find((node) => node.id === otherConnectionPointData.scriptID);
      if (otherScript === void 0)
        continue;
      if (!searchQueue.includes(otherScript)) {
        searchQueue.push(otherScript);
      }
      dataFlow[`${currentScript.id}_${connectionPointData.name}`] = `${otherScript.id}_${otherConnectionPointData.name}`;
    }
  }
  while (executeStack.length > 0) {
    let currentScript = executeStack.pop();
    if (currentScript === void 0)
      continue;
    let sucess = await executeScript(plugin, canvas, currentScript, dataFlow, executionData);
    if (!sucess) {
      new import_obsidian3.Notice("Workflow execution stopped because a script failed");
      break;
    }
    ;
  }
}
async function executeScript(plugin, canvas, scriptNode, dataFlow, executionData) {
  let scriptLanguageBlock = await extractLanguageText(plugin.app, scriptNode, pythonCodeBlockLanguageName);
  if (scriptLanguageBlock === null)
    return false;
  let settingsLanguageBlock = await extractLanguageText(plugin.app, scriptNode, canvasBlockSettingsLanguageName);
  if (settingsLanguageBlock === null)
    return false;
  let scriptSettings = JSON.parse(settingsLanguageBlock);
  let inputData = {};
  let outputData = {};
  for (const connectionName in scriptSettings.ioConnections) {
    let ioConnection = scriptSettings.ioConnections[connectionName];
    if (ioConnection.direction === "output") {
      outputData[connectionName] = null;
      continue;
    }
    let flow = dataFlow[`${scriptNode.id}_${connectionName}`];
    let data = executionData[flow];
    inputData[connectionName] = data;
  }
  let adapter = plugin.app.vault.adapter;
  let injectionData = {
    execution_type: "workflow",
    in_data: inputData,
    out_data: outputData,
    script_settings: scriptSettings,
    script_data: scriptNode,
    vault_path: adapter.basePath,
    plugin_folder: plugin.getDataFolder()
  };
  let messageHandler = async (canvas2, message) => {
    let response = await defaultMessageHandler(canvas2, message);
    if (response === null)
      return;
    let commandType = message.command;
    if (commandType === "RETURN_OUTPUT") {
      let outData = message.data;
      for (const key in outData) {
        if (outData.hasOwnProperty(key)) {
          executionData[`${scriptNode.id}_${key}`] = outData[key];
        }
      }
    }
  };
  let sucess = await executePythonString(plugin, canvas, scriptLanguageBlock + "\n\n#Generated by plugin\n_return_output_data()", injectionData, messageHandler);
  return sucess;
}
async function addWorkflowScript(plugin, scriptFile) {
  let view = this.app.workspace.getActiveViewOfType(import_obsidian3.ItemView);
  if (view === null)
    return;
  if (!view.hasOwnProperty("canvas")) {
    new import_obsidian3.Notice("A canvas must be open to run this command");
    return;
  }
  let canvas = view.canvas;
  let scriptText = await app.vault.read(scriptFile);
  let text = await extractLanguageText(plugin.app, scriptText, canvasBlockSettingsLanguageName);
  if (text === null)
    return;
  let scriptSettings = JSON.parse(text);
  let padding = 20;
  let scriptWidth = 400;
  let scriptHeight = 60;
  let connectionPointWidth = 180;
  let connectionPointHeight = 50;
  let tx = canvas.tx;
  let ty = canvas.ty;
  let scriptNode = canvas.createFileNode({
    file: scriptFile,
    pos: {
      x: tx,
      y: ty
    },
    size: {
      width: scriptWidth,
      height: 60
    },
    save: false,
    focus: false
  });
  let numInput = 0;
  let numOutput = 0;
  let connectionNodes = [];
  for (const connectionName in scriptSettings.ioConnections) {
    let ioConnection = scriptSettings.ioConnections[connectionName];
    let numberOfConnectionsAbove = ioConnection.direction === "input" ? numInput : numOutput;
    let offset = ioConnection.direction === "input" ? 0 : scriptWidth - connectionPointWidth;
    let connectionNode = canvas.createTextNode({
      text: `\`\`\`${canvasBlockConnectionPointLanguageName}
{
    "name": "${connectionName}",
    "scriptID": "${scriptNode.id}"
}
\`\`\``,
      pos: {
        x: tx + offset,
        y: ty + scriptHeight + padding + connectionPointHeight * numberOfConnectionsAbove
      },
      size: {
        width: connectionPointWidth,
        height: connectionPointHeight
      },
      save: false,
      focus: false
    });
    connectionNodes.push(connectionNode);
    if (ioConnection.direction === "input")
      numInput++;
    else
      numOutput++;
  }
  canvas.createGroupNode({
    label: "\u200E",
    pos: {
      x: tx - padding,
      y: ty - padding
    },
    size: {
      width: scriptWidth + 2 * padding,
      height: padding + scriptHeight + padding + connectionPointHeight * Math.max(numInput, numOutput) + padding
    },
    save: false,
    focus: false
  });
  canvas.requestSave();
}

// src/main.ts
function boundingBoxFromNode(node) {
  let bbox = { minX: node.x, minY: node.y, maxX: node.x + node.width, maxY: node.y + node.height };
  return bbox;
}
async function canvasClosestNodeToPosition(canvas, x, y, filterInvalidFunction = () => false) {
  let closest = null;
  let nodes = canvas.data.nodes;
  let closestDistanceSquared = 1e10;
  for (const node of nodes) {
    if (await filterInvalidFunction(node))
      continue;
    let distanceSquared = (node.x - x) ** 2 + (node.y - y) ** 2;
    if (distanceSquared < closestDistanceSquared) {
      closest = node.id;
      closestDistanceSquared = distanceSquared;
    }
  }
  return closest;
}
async function canvasClosestNodeToPositionInBounds(canvas, boundingBox, filterInvalidFunction = () => false) {
  let closest = null;
  let nodes = canvas.data.nodes;
  let closestDistanceSquared = 1e10;
  for (const node of nodes) {
    const { minX: x1_min, minY: y1_min, maxX: x1_max, maxY: y1_max } = boundingBox;
    const { minX: x2_min, minY: y2_min, maxX: x2_max, maxY: y2_max } = boundingBoxFromNode(node);
    const bbox1_center_x = (x1_min + x1_max) / 2;
    const bbox1_center_y = (y1_min + y1_max) / 2;
    const bbox2_center_x = (x2_min + x2_max) / 2;
    const bbox2_center_y = (y2_min + y2_max) / 2;
    const distanceSquared = (bbox1_center_x - bbox2_center_x) ** 2 + (bbox1_center_y - bbox2_center_y) ** 2;
    if (x1_min <= x2_max && x1_max >= x2_min && (y1_min <= y2_max && y1_max >= y2_min)) {
      if (await filterInvalidFunction(node))
        continue;
      if (distanceSquared < closestDistanceSquared) {
        closest = node.id;
        closestDistanceSquared = distanceSquared;
      }
    }
  }
  return closest;
}
async function canvasNodesInBounds(canvas, boundingBox, filterInvalidFunction = () => false) {
  const nodesInBounds = [];
  const nodes = canvas.data.nodes;
  for (const node of nodes) {
    const { minX: x1_min, minY: y1_min, maxX: x1_max, maxY: y1_max } = boundingBox;
    const { minX: x2_min, minY: y2_min, maxX: x2_max, maxY: y2_max } = boundingBoxFromNode(node);
    if (x1_min <= x2_max && x1_max >= x2_min && (y1_min <= y2_max && y1_max >= y2_min)) {
      if (await filterInvalidFunction(node))
        continue;
      nodesInBounds.push(node.id);
    }
  }
  return nodesInBounds;
}
async function getNodeText(app2, node) {
  let text;
  if (node.hasOwnProperty("filePath")) {
    node.file = node.filePath;
    node.type = "file";
  }
  if (node.type === "text")
    text = node.text;
  else if (node.type === "link")
    text = node.url;
  else if (node.type === "file" && node.file.endsWith("md")) {
    let filePath = node.file;
    let file = app2.vault.getAbstractFileByPath(filePath);
    if (file === null)
      return null;
    if (!(file instanceof import_obsidian4.TFile))
      return null;
    text = await app2.vault.read(file);
  } else {
    return node.file;
  }
  return text;
}
async function extractLanguageText(app2, source, language) {
  let text;
  if (typeof source === "string")
    text = source;
  else {
    let returnedText = await getNodeText(app2, source);
    if (returnedText === null)
      return null;
    text = returnedText;
  }
  const languageRegex = new RegExp("```\\s*" + language + "\\s*([\\s\\S]*?)```");
  let match = languageRegex.exec(text);
  return match ? match[1] : null;
}
async function checkContainsLanguage(app2, node, language) {
  let text = await getNodeText(app2, node);
  if (text === null)
    return false;
  const languageRegex = new RegExp("```\\s*" + language + "\\s*([\\s\\S]*?)```");
  return languageRegex.test(text);
}
var FuzzyScriptSuggester = class extends import_obsidian4.FuzzySuggestModal {
  constructor(plugin) {
    super(app);
    this.plugin = plugin;
    this.setPlaceholder("Enter the name of a script");
  }
  getItems() {
    const files = [];
    let folder = app.vault.getAbstractFileByPath((0, import_obsidian4.normalizePath)(this.plugin.settings.workflowScriptFolder));
    if (folder === null)
      return [];
    if (!(folder instanceof import_obsidian4.TFolder))
      return [];
    import_obsidian4.Vault.recurseChildren(folder, (file) => {
      if (file instanceof import_obsidian4.TFile) {
        files.push(file);
      }
    });
    return files;
  }
  getItemText(item) {
    return item.basename;
  }
  onChooseItem(item, evt) {
    addWorkflowScript(this.plugin, item);
  }
};
var DEFAULT_SETTINGS = {
  dataFolder: "",
  workflowScriptFolder: "",
  pythonPath: ""
};
var pythonCodeBlockLanguageName = "pycanvasblock";
var canvasBlockSettingsLanguageName = "canvasblocksettings";
var canvasBlockConnectionPointLanguageName = "canvasblockconnectionpoint";
var CanvasBlocksPlugin2 = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    await this.saveSettings();
    this.addSettingTab(new CanvasBlocksPluginSettingTab(this.app, this));
    this.addCommand({
      id: "execute-canvas-script",
      name: "Execute canvas script",
      callback: () => {
        this.handleRun();
      }
    });
    this.addCommand({
      id: "add-workflow-script",
      name: "Add workflow script",
      callback: () => {
        new FuzzyScriptSuggester(this).open();
      }
    });
    this.registerEvent(this.app.workspace.on("layout-change", () => {
      let view = this.app.workspace.getActiveViewOfType(import_obsidian4.ItemView);
      if (view === null)
        return;
      if (!view.hasOwnProperty("canvas")) {
        return;
      }
      let canvas = view.canvas;
      const originalAddEdge = canvas.addEdge;
      canvas.addEdge = async function(edge) {
        originalAddEdge.call(this, edge);
        edge.lastTo = edge.to.node.id;
        canvas.requestSave();
        refreshNode(canvas, edge.from.node.id);
        const originalEdgeUpdate = edge.update;
        edge.update = async function(...args) {
          originalEdgeUpdate.apply(this, args);
          if (edge.lastTo !== edge.to.node.id) {
            let lastTo = edge.lastTo;
            edge.lastTo = edge.to.node.id;
            canvas.requestSave();
            refreshNode(canvas, lastTo);
            refreshNode(canvas, edge.to.node.id);
          }
        };
      };
      const originalRemoveEdge = canvas.removeEdge;
      canvas.removeEdge = async function(...args) {
        originalRemoveEdge.apply(this, args);
        canvas.requestSave();
        refreshNode(canvas, args[0].from.node.id);
        refreshNode(canvas, args[0].to.node.id);
      };
    }));
    this.registerMarkdownCodeBlockProcessor(pythonCodeBlockLanguageName, () => {
    });
    this.registerMarkdownCodeBlockProcessor(canvasBlockSettingsLanguageName, () => {
    });
    this.registerMarkdownCodeBlockProcessor(canvasBlockConnectionPointLanguageName, async (source, el, ctx) => {
      let connectionPointData = JSON.parse(source);
      let view = this.app.workspace.getActiveViewOfType(import_obsidian4.ItemView);
      if (view === null)
        return;
      if (!view.hasOwnProperty("canvas")) {
        return;
      }
      let canvas = view.canvas;
      let scriptNode = canvas.data.nodes.find((node) => node.id === connectionPointData.scriptID);
      if (scriptNode === void 0)
        return;
      let scriptData = await extractLanguageText(this.app, scriptNode, canvasBlockSettingsLanguageName);
      if (scriptData === null)
        return;
      let scriptSettings = JSON.parse(scriptData);
      let ioConnection = scriptSettings.ioConnections[connectionPointData.name];
      if (ioConnection === void 0)
        return;
      let connectionNode = canvas.data.nodes.find((node) => node.type === "text" && node.text.includes(source));
      if (connectionNode === void 0)
        return;
      let connectionEdge = canvas.data.edges.find((edge) => edge.toNode === connectionNode.id || edge.fromNode === connectionNode.id);
      let circle;
      if (connectionEdge === void 0)
        circle = "\u25EF";
      else
        circle = "\u2B24";
      let color;
      switch (ioConnection.type) {
        case "image":
          color = "#ffff00";
          break;
        case "text":
          color = "#AA5555";
          break;
        case "integer":
          color = "#06aacf";
        case "float":
          color = "#13d493";
        case "file":
          color = "#55FF55";
          break;
        case "any":
          color = "#0476c2";
          break;
        default:
          color = "#555555";
          break;
      }
      let circleSpan = createSpan({ text: circle });
      circleSpan.setCssStyles({ color });
      if (ioConnection.direction === "input") {
        let span = el.createSpan({ cls: "canvasblock-input-node" });
        span.appendChild(circleSpan);
        span.appendText(" " + connectionPointData.name);
      } else {
        let span = el.createSpan({ cls: "canvasblock-output-node" });
        span.appendText(connectionPointData.name + " ");
        span.appendChild(circleSpan);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Returns folder name with leading and trailing '/'
  getDataFolder() {
    let folder = this.settings.dataFolder;
    if (folder === "/")
      return "";
    return folder;
  }
  async handleRun() {
    let view = this.app.workspace.getActiveViewOfType(import_obsidian4.ItemView);
    if (view === null)
      return;
    if (!view.hasOwnProperty("canvas")) {
      new import_obsidian4.Notice("This command requires a canvas file to be open");
      return;
    }
    let canvas = view.canvas;
    let selected = canvas.selection;
    if (selected.size === 0) {
      new import_obsidian4.Notice("This command requires a node to be selected");
      return;
    }
    let selectedNode = selected.values().next().value;
    let selectionID = selectedNode.id;
    let selectedData = this.getNodeByID(canvas, selectionID);
    if (selectedData.type === "group") {
      handleWorkflowFromGroup(this, canvas, selectedData);
      return;
    }
    let closestID = await canvasClosestNodeToPositionInBounds(
      canvas,
      selectedNode.bbox,
      (node) => {
        return node.id === selectionID;
      }
    );
    this.handleCommand(canvas, selectionID, closestID);
  }
  getNodeByID(canvas, id) {
    return canvas.data.nodes.filter((node) => node.id === id)[0];
  }
  async handleCommand(canvas, selectedID, otherID) {
    let selectedData = this.getNodeByID(canvas, selectedID);
    let selectedIsValidScript = await checkContainsLanguage(this.app, selectedData, pythonCodeBlockLanguageName);
    if (!selectedIsValidScript && otherID === null) {
      new import_obsidian4.Notice("No valid scripts are selected");
      return;
    }
    let scriptID;
    let parameterID;
    if (selectedIsValidScript) {
      scriptID = selectedID;
      parameterID = otherID;
    } else {
      let otherData = this.getNodeByID(canvas, otherID);
      let otherIsValidScript = await checkContainsLanguage(this.app, otherData, pythonCodeBlockLanguageName);
      if (!otherIsValidScript) {
        new import_obsidian4.Notice("No valid scripts are selected");
        return;
      }
      scriptID = otherID;
      parameterID = selectedID;
    }
    let parameterData = {};
    if (parameterID !== null)
      parameterData = this.getNodeByID(canvas, parameterID);
    let scriptData = this.getNodeByID(canvas, scriptID);
    let arrowParamterEdges = canvas.data.edges.filter((edge) => edge.toNode === scriptID);
    let arrowParameterIDs = arrowParamterEdges.map((edge) => edge.fromNode);
    let arrowParameters = canvas.data.nodes.filter((node) => arrowParameterIDs.includes(node.id));
    let scriptCode = await extractLanguageText(this.app, scriptData, pythonCodeBlockLanguageName);
    if (scriptCode === null)
      return;
    let adapter = this.app.vault.adapter;
    const injectionData = {
      execution_type: "simple",
      parameter_data: parameterData,
      script_data: scriptData,
      arrow_parameters: arrowParameters,
      vault_path: adapter.basePath,
      plugin_folder: this.getDataFolder(),
      has_parameter: parameterID !== null
    };
    executePythonString(this, canvas, scriptCode, injectionData);
  }
};
