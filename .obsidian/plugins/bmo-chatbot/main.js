/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  checkActiveFile: () => checkActiveFile,
  default: () => BMOGPT15,
  defaultFrontMatter: () => defaultFrontMatter,
  updateFrontMatter: () => updateFrontMatter,
  updateProfile: () => updateProfile,
  updateSettingsFromFrontMatter: () => updateSettingsFromFrontMatter
});
module.exports = __toCommonJS(main_exports);
var import_obsidian25 = require("obsidian");

// src/view.ts
var import_obsidian6 = require("obsidian");

// src/components/chat/Commands.ts
var import_obsidian5 = require("obsidian");

// src/utils/ColorConverter.ts
function colorToHex(colorValue) {
  if (colorValue.startsWith("hsl")) {
    const match = colorValue.match(/(\d+(\.\d+)?)%?/g);
    if (match === null || match.length < 3) {
      throw new Error("Invalid HSL value");
    }
    const h = parseInt(match[0]) / 360;
    const s = parseInt(match[1]) / 100;
    const l = parseInt(match[2]) / 100;
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h + 1 / 3);
    const g = hue2rgb(p, q, h);
    const b = hue2rgb(p, q, h - 1 / 3);
    const toHex = function(c) {
      const hex2 = Math.round(c * 255).toString(16);
      return hex2.length === 1 ? "0" + hex2 : hex2;
    };
    const hex = "#" + toHex(r) + toHex(g) + toHex(b);
    return hex;
  } else if (colorValue.startsWith("rgb")) {
    const sep = colorValue.indexOf(",") > -1 ? "," : " ";
    const rgbArray = colorValue.substr(4).split(")")[0].split(sep);
    let r = (+rgbArray[0]).toString(16), g = (+rgbArray[1]).toString(16), b = (+rgbArray[2]).toString(16);
    if (r.length == 1)
      r = "0" + r;
    if (g.length == 1)
      g = "0" + g;
    if (b.length == 1)
      b = "0" + b;
    return "#" + r + g + b;
  } else {
    return colorValue;
  }
}
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
var isValidHexColor = (color) => {
  const hexColorRegex = /^[0-9A-Fa-f]{6}$/;
  return hexColorRegex.test(color);
};

// src/components/FetchModelResponse.ts
var import_obsidian3 = require("obsidian");

// src/components/chat/Buttons.ts
var import_obsidian = require("obsidian");

// src/components/editor/ReferenceCurrentNote.ts
var referenceCurrentNoteContent = "";
async function getActiveFileContent(plugin, settings) {
  const dotElement = document.querySelector(".dotIndicator");
  referenceCurrentNoteContent = "";
  if (settings.general.allowReferenceCurrentNote === true) {
    if (dotElement) {
      dotElement.style.backgroundColor = "#da2c2c";
      referenceCurrentNoteContent = "";
    }
    const activeFile = plugin.app.workspace.getActiveFile();
    if ((activeFile == null ? void 0 : activeFile.extension) === "md") {
      if (dotElement) {
        dotElement.style.backgroundColor = "green";
      }
      const content = await plugin.app.vault.read(activeFile);
      const clearYamlContent = content.replace(/---[\s\S]+?---/, "").trim();
      referenceCurrentNoteContent = "\n\nAdditional Note:\n\n" + clearYamlContent + "\n\n";
    }
  }
  return referenceCurrentNoteContent;
}
function getCurrentNoteContent() {
  return referenceCurrentNoteContent;
}

// src/components/chat/Buttons.ts
function regenerateUserButton(plugin, settings) {
  const regenerateButton = document.createElement("button");
  regenerateButton.textContent = "regenerate";
  (0, import_obsidian.setIcon)(regenerateButton, "refresh-ccw");
  regenerateButton.classList.add("regenerate-button");
  regenerateButton.title = "regenerate";
  let lastClickedElement = null;
  regenerateButton.addEventListener("click", async function(event) {
    event.stopPropagation();
    lastClickedElement = event.target;
    while (lastClickedElement && !lastClickedElement.classList.contains("userMessage")) {
      lastClickedElement = lastClickedElement.parentElement;
    }
    let index = -1;
    if (lastClickedElement) {
      const userMessages = Array.from(document.querySelectorAll("#messageContainer .userMessage"));
      index = userMessages.indexOf(lastClickedElement) * 2;
    }
    if (index !== -1) {
      deleteMessage(plugin, index + 1);
      if (OPENAI_MODELS.includes(settings.general.model) || settings.APIConnections.openAI.openAIBaseModels.includes(settings.general.model)) {
        try {
          if (settings.APIConnections.openAI.allowStream) {
            await fetchOpenAIAPIResponseStream(plugin, settings, index);
          } else {
            await fetchOpenAIAPIResponse(plugin, settings, index);
          }
        } catch (error) {
          new import_obsidian.Notice("Error occurred while fetching completion: " + error.message);
          console.log(error.message);
        }
      } else if (settings.OllamaConnection.RESTAPIURL && settings.OllamaConnection.ollamaModels.includes(settings.general.model)) {
        if (settings.OllamaConnection.allowStream) {
          await fetchOllamaResponseStream(plugin, settings, index);
        } else {
          await fetchOllamaResponse(plugin, settings, index);
        }
      } else if (settings.RESTAPIURLConnection.RESTAPIURLModels.includes(settings.general.model)) {
        if (settings.RESTAPIURLConnection.allowStream) {
          await fetchRESTAPIURLResponseStream(plugin, settings, index);
        } else {
          await fetchRESTAPIURLResponse(plugin, settings, index);
        }
      } else if (settings.APIConnections.openRouter.openRouterModels.includes(settings.general.model)) {
        if (settings.APIConnections.openRouter.allowStream) {
          await fetchOpenRouterResponseStream(plugin, settings, index);
        } else {
          await fetchOpenRouterResponse(plugin, settings, index);
        }
      } else if (settings.APIConnections.mistral.mistralModels.includes(settings.general.model)) {
        try {
          if (settings.APIConnections.mistral.allowStream) {
            await fetchMistralResponseStream(plugin, settings, index);
          } else {
            await fetchMistralResponse(plugin, settings, index);
          }
        } catch (error) {
          console.error("Mistral Error:", error);
        }
      } else if (settings.APIConnections.googleGemini.geminiModels.includes(settings.general.model)) {
        try {
          await fetchGoogleGeminiResponse(plugin, settings, index);
        } catch (error) {
          console.error("Google Gemini Error:", error);
        }
      } else if (ANTHROPIC_MODELS.includes(settings.general.model)) {
        try {
          await fetchAnthropicResponse(plugin, settings, index);
        } catch (error) {
          console.error("Anthropic Error:", error);
        }
      }
    } else {
      new import_obsidian.Notice("No models detected.");
    }
  });
  return regenerateButton;
}
function displayUserEditButton(plugin, settings, userPre) {
  const editButton = document.createElement("button");
  editButton.textContent = "edit";
  (0, import_obsidian.setIcon)(editButton, "edit");
  editButton.classList.add("edit-button");
  editButton.title = "edit";
  let lastClickedElement = null;
  editButton.addEventListener("click", function(event) {
    var _a2;
    const editContainer = document.createElement("div");
    editContainer.classList.add("edit-container");
    const textArea = document.createElement("textarea");
    textArea.classList.add("edit-textarea");
    textArea.value = (_a2 = userPre.textContent) != null ? _a2 : "";
    editContainer.appendChild(textArea);
    const textareaEditButton = document.createElement("button");
    textareaEditButton.textContent = "Edit";
    textareaEditButton.classList.add("textarea-edit-button");
    textareaEditButton.title = "edit";
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.classList.add("textarea-cancel-button");
    cancelButton.title = "cancel";
    event.stopPropagation();
    lastClickedElement = event.target;
    while (lastClickedElement && !lastClickedElement.classList.contains("userMessage")) {
      lastClickedElement = lastClickedElement.parentElement;
    }
    textareaEditButton.addEventListener("click", async function() {
      userPre.textContent = textArea.value.trim();
      editContainer.replaceWith(userPre);
      if (lastClickedElement) {
        const userMessages = Array.from(document.querySelectorAll("#messageContainer .userMessage"));
        const index = userMessages.indexOf(lastClickedElement) * 2;
        if (index !== -1) {
          messageHistory[index].content = textArea.value.trim();
          deleteMessage(plugin, index + 1);
          if (settings.OllamaConnection.RESTAPIURL && settings.OllamaConnection.ollamaModels.includes(settings.general.model)) {
            if (settings.OllamaConnection.allowStream) {
              await fetchOllamaResponseStream(plugin, settings, index);
            } else {
              await fetchOllamaResponse(plugin, settings, index);
            }
          } else if (settings.RESTAPIURLConnection.RESTAPIURLModels.includes(settings.general.model)) {
            if (settings.RESTAPIURLConnection.allowStream) {
              await fetchRESTAPIURLResponseStream(plugin, settings, index);
            } else {
              await fetchRESTAPIURLResponse(plugin, settings, index);
            }
          } else if (ANTHROPIC_MODELS.includes(settings.general.model)) {
            try {
              await fetchAnthropicResponse(plugin, settings, index);
            } catch (error) {
              console.error("Anthropic Error:", error);
            }
          } else if (settings.APIConnections.googleGemini.geminiModels.includes(settings.general.model)) {
            try {
              await fetchGoogleGeminiResponse(plugin, settings, index);
            } catch (error) {
              console.error("Google GeminiError:", error);
            }
          } else if (settings.APIConnections.mistral.mistralModels.includes(settings.general.model)) {
            try {
              if (settings.APIConnections.mistral.allowStream) {
                await fetchMistralResponseStream(plugin, settings, index);
              } else {
                await fetchMistralResponse(plugin, settings, index);
              }
            } catch (error) {
              console.error("Mistral Error:", error);
            }
          } else if (OPENAI_MODELS.includes(settings.general.model) || settings.APIConnections.openAI.openAIBaseModels.includes(settings.general.model)) {
            try {
              if (settings.APIConnections.openAI.allowStream) {
                await fetchOpenAIAPIResponseStream(plugin, settings, index);
              } else {
                await fetchOpenAIAPIResponse(plugin, settings, index);
              }
            } catch (error) {
              new import_obsidian.Notice("Error occurred while fetching completion: " + error.message);
              console.log(error.message);
            }
          } else if (settings.APIConnections.openRouter.openRouterModels.includes(settings.general.model)) {
            if (settings.APIConnections.openRouter.allowStream) {
              await fetchOpenRouterResponseStream(plugin, settings, index);
            } else {
              await fetchOpenRouterResponse(plugin, settings, index);
            }
          }
        } else {
          new import_obsidian.Notice("No models detected.");
        }
      }
    });
    cancelButton.addEventListener("click", function() {
      editContainer.replaceWith(userPre);
    });
    editContainer.appendChild(textareaEditButton);
    editContainer.appendChild(cancelButton);
    if (userPre.parentNode !== null) {
      userPre.parentNode.replaceChild(editContainer, userPre);
    }
  });
  return editButton;
}
function displayBotEditButton(plugin, message) {
  const editButton = document.createElement("button");
  editButton.textContent = "edit";
  (0, import_obsidian.setIcon)(editButton, "edit");
  editButton.classList.add("edit-button");
  editButton.title = "edit";
  let lastClickedElement = null;
  editButton.addEventListener("click", function(event) {
    const editContainer = document.createElement("div");
    editContainer.classList.add("edit-container");
    const textArea = document.createElement("textarea");
    textArea.classList.add("edit-textarea");
    textArea.value = message;
    const textareaEditButton = document.createElement("button");
    textareaEditButton.textContent = "Edit";
    textareaEditButton.classList.add("textarea-edit-button");
    textareaEditButton.title = "edit";
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.classList.add("textarea-cancel-button");
    cancelButton.title = "cancel";
    editContainer.appendChild(textArea);
    event.stopPropagation();
    lastClickedElement = event.target;
    while (lastClickedElement && !lastClickedElement.classList.contains("botMessage")) {
      lastClickedElement = lastClickedElement.parentElement;
    }
    let messageBlock = lastClickedElement == null ? void 0 : lastClickedElement.querySelector(".messageBlock");
    if (messageBlock) {
      messageBlock.innerHTML = "";
      messageBlock.appendChild(editContainer);
    } else {
      console.log("messageBlock not found.");
    }
    textareaEditButton.addEventListener("click", async function() {
      message = textArea.value;
      editContainer.remove();
      messageBlock == null ? void 0 : messageBlock.remove();
      messageBlock = document.createElement("div");
      messageBlock.className = "messageBlock";
      lastClickedElement == null ? void 0 : lastClickedElement.appendChild(messageBlock);
      await import_obsidian.MarkdownRenderer.render(plugin.app, message, messageBlock, "/", plugin);
      const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
      copyCodeBlocks.forEach((copyCodeBlock) => {
        copyCodeBlock.textContent = "Copy";
        (0, import_obsidian.setIcon)(copyCodeBlock, "copy");
      });
      if (lastClickedElement) {
        const allMessages = Array.from(document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage"));
        const index = allMessages.indexOf(lastClickedElement);
        if (index !== -1) {
          messageHistory[index].content = textArea.value;
          const jsonString = JSON.stringify(messageHistory, null, 4);
          try {
            await plugin.app.vault.adapter.write(filenameMessageHistoryJSON(plugin), jsonString);
          } catch (error) {
            console.error("Error writing to message history file:", error);
          }
        } else {
          new import_obsidian.Notice("No models detected.");
        }
      }
    });
    cancelButton.addEventListener("click", async function() {
      editContainer.remove();
      messageBlock == null ? void 0 : messageBlock.remove();
      messageBlock = document.createElement("div");
      messageBlock.className = "messageBlock";
      lastClickedElement == null ? void 0 : lastClickedElement.appendChild(messageBlock);
      await import_obsidian.MarkdownRenderer.render(plugin.app, message, messageBlock, "/", plugin);
      const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
      copyCodeBlocks.forEach((copyCodeBlock) => {
        copyCodeBlock.textContent = "Copy";
        (0, import_obsidian.setIcon)(copyCodeBlock, "copy");
      });
    });
    editContainer.appendChild(textareaEditButton);
    editContainer.appendChild(cancelButton);
  });
  return editButton;
}
function displayUserCopyButton(userPre) {
  const copyButton = document.createElement("button");
  copyButton.textContent = "copy";
  (0, import_obsidian.setIcon)(copyButton, "copy");
  copyButton.classList.add("copy-button");
  copyButton.title = "copy";
  copyButton.addEventListener("click", function() {
    const messageText = userPre.textContent;
    if (messageText !== null) {
      copyMessageToClipboard(messageText);
      new import_obsidian.Notice("Copied user message.");
    } else {
      console.error("Message content is null. Cannot copy.");
    }
  });
  return copyButton;
}
function displayBotCopyButton(settings, message) {
  const copyButton = document.createElement("button");
  copyButton.textContent = "copy";
  (0, import_obsidian.setIcon)(copyButton, "copy");
  copyButton.classList.add("copy-button");
  copyButton.title = "copy";
  copyButton.addEventListener("click", function() {
    if (message !== null) {
      copyMessageToClipboard(message);
      new import_obsidian.Notice("Copied bot message.");
    } else {
      console.error("Message content is null. Cannot copy.");
    }
  });
  return copyButton;
}
function copyMessageToClipboard(message) {
  navigator.clipboard.writeText(message).then(function() {
  }).catch(function(err) {
    console.error("Unable to copy message: ", err);
  });
}
function displayAppendButton(plugin, settings, message) {
  const appendButton = document.createElement("button");
  appendButton.textContent = "append";
  (0, import_obsidian.setIcon)(appendButton, "plus-square");
  appendButton.classList.add("append-button");
  appendButton.title = "append";
  const messageText = message;
  appendButton.addEventListener("click", async function(event) {
    var _a2, _b;
    if (((_a2 = checkActiveFile) == null ? void 0 : _a2.extension) === "md") {
      if (checkActiveFile !== lastCursorPositionFile) {
        getActiveFileContent(plugin, settings);
        const existingContent = await plugin.app.vault.read(checkActiveFile);
        const updatedContent = existingContent + "\n" + messageText;
        plugin.app.vault.modify(checkActiveFile, updatedContent);
      } else {
        (_b = activeEditor) == null ? void 0 : _b.replaceRange(messageText, lastCursorPosition);
      }
      event.stopPropagation();
      new import_obsidian.Notice("Appended response.");
    } else {
      new import_obsidian.Notice("No active Markdown file detected.");
    }
  });
  return appendButton;
}
function displayTrashButton(plugin) {
  const trashButton = document.createElement("button");
  trashButton.textContent = "trash";
  (0, import_obsidian.setIcon)(trashButton, "trash");
  trashButton.classList.add("trash-button");
  trashButton.title = "trash";
  let lastClickedElement = null;
  trashButton.addEventListener("click", function(event) {
    event.stopPropagation();
    lastClickedElement = event.target;
    while (lastClickedElement && !lastClickedElement.classList.contains("userMessage")) {
      lastClickedElement = lastClickedElement.parentElement;
    }
    if (lastClickedElement) {
      const userMessages = Array.from(document.querySelectorAll("#messageContainer .userMessage"));
      const index = userMessages.indexOf(lastClickedElement) * 2;
      if (index !== -1) {
        const modal = new import_obsidian.Modal(plugin.app);
        modal.contentEl.innerHTML = `
                <div class="modal-content">
                    <h2>Delete Message Block.</h2>
                    <p>Are you sure you want to delete this message block?</p>
                    <button id="confirmDelete">Confirm Delete</button>
                </div>
                `;
        const confirmDeleteButton = modal.contentEl.querySelector("#confirmDelete");
        confirmDeleteButton == null ? void 0 : confirmDeleteButton.addEventListener("click", async function() {
          deleteMessage(plugin, index);
          new import_obsidian.Notice("Message deleted.");
          modal.close();
        });
        modal.open();
      }
    }
  });
  return trashButton;
}
async function deleteMessage(plugin, index) {
  const messageContainer = document.querySelector("#messageContainer");
  const divElements = messageContainer == null ? void 0 : messageContainer.querySelectorAll("div.botMessage, div.userMessage");
  if (divElements && divElements.length > 0 && index >= 0 && index < divElements.length) {
    messageContainer == null ? void 0 : messageContainer.removeChild(divElements[index]);
    if (index + 1 < divElements.length) {
      const nextMessage = divElements[index + 1];
      if (nextMessage.classList.contains("botMessage")) {
        messageContainer == null ? void 0 : messageContainer.removeChild(nextMessage);
      }
    }
  }
  if (messageHistory[index + 1] && messageHistory[index + 1].role === "assistant") {
    messageHistory.splice(index, 2);
  } else {
    messageHistory.splice(index, 1);
  }
  const jsonString = JSON.stringify(messageHistory, null, 4);
  try {
    await plugin.app.vault.adapter.write(filenameMessageHistoryJSON(plugin), jsonString);
  } catch (error) {
    console.error("Error writing messageHistory.json", error);
  }
}

// src/components/chat/Message.ts
async function addMessage(plugin, input, messageType, settings, index) {
  const messageObj = {
    role: "",
    content: ""
  };
  if (messageType === "userMessage") {
    messageObj.role = "user";
    messageObj.content = input;
  } else if (messageType === "botMessage") {
    messageObj.role = "assistant";
    messageObj.content = input;
    const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
    const targetUserMessage = messageContainerElDivs[index];
    const targetBotMessage = targetUserMessage.nextElementSibling;
    const botMessageToolBarDiv = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".botMessageToolBar");
    const buttonContainerDiv = document.createElement("div");
    buttonContainerDiv.className = "button-container";
    botMessageToolBarDiv == null ? void 0 : botMessageToolBarDiv.appendChild(buttonContainerDiv);
    if (!messageObj.content.includes("commandBotMessage") && !messageObj.content.includes("errorBotMessage")) {
      const editButton = displayBotEditButton(plugin, messageObj.content);
      const copyBotButton = displayBotCopyButton(settings, messageObj.content);
      const appendButton = displayAppendButton(plugin, settings, messageObj.content);
      buttonContainerDiv.appendChild(editButton);
      buttonContainerDiv.appendChild(copyBotButton);
      buttonContainerDiv.appendChild(appendButton);
    }
  }
  messageHistory.splice(index + 1, 0, messageObj);
  const jsonString = JSON.stringify(messageHistory, null, 4);
  try {
    await plugin.app.vault.adapter.write(filenameMessageHistoryJSON(plugin), jsonString);
  } catch (error) {
    console.error("Error writing to message history file:", error);
  }
}
function addParagraphBreaks(messageBlock) {
  const paragraphs = messageBlock.querySelectorAll("p");
  for (let i = 0; i < paragraphs.length; i++) {
    const p = paragraphs[i];
    const nextSibling = p.nextElementSibling;
    if (nextSibling && nextSibling.nodeName === "P") {
      const br = document.createElement("br");
      const parent = p.parentNode;
      if (parent) {
        parent.insertBefore(br, nextSibling);
      }
    }
  }
}

// src/components/chat/BotMessage.ts
var import_obsidian2 = require("obsidian");
function displayBotMessage(plugin, settings, messageHistory2, message) {
  const botMessageDiv = document.createElement("div");
  botMessageDiv.className = "botMessage";
  botMessageDiv.style.backgroundColor = colorToHex(settings.appearance.botMessageBackgroundColor || getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.botMessageBackgroundColor).trim());
  botMessageDiv.style.color = settings.appearance.botMessageFontColor || DEFAULT_SETTINGS.appearance.botMessageFontColor;
  const botMessageToolBarDiv = document.createElement("div");
  botMessageToolBarDiv.className = "botMessageToolBar";
  const buttonContainerDiv = document.createElement("div");
  buttonContainerDiv.className = "button-container";
  const botNameSpan = document.createElement("span");
  botNameSpan.textContent = settings.appearance.chatbotName || DEFAULT_SETTINGS.appearance.chatbotName;
  botNameSpan.className = "chatbotName";
  botMessageToolBarDiv.appendChild(botNameSpan);
  botMessageToolBarDiv.appendChild(buttonContainerDiv);
  const messageBlockDiv = document.createElement("div");
  messageBlockDiv.className = "messageBlock";
  import_obsidian2.MarkdownRenderer.render(plugin.app, message, messageBlockDiv, "", plugin);
  if (!message.includes("commandBotMessage") && !message.includes("errorBotMessage")) {
    const editButton = displayBotEditButton(plugin, message);
    const copyBotButton = displayBotCopyButton(settings, message);
    const appendButton = displayAppendButton(plugin, settings, message);
    buttonContainerDiv.appendChild(editButton);
    buttonContainerDiv.appendChild(copyBotButton);
    buttonContainerDiv.appendChild(appendButton);
    addParagraphBreaks(messageBlockDiv);
  }
  const copyCodeBlocks = messageBlockDiv.querySelectorAll(".copy-code-button");
  copyCodeBlocks.forEach((copyCodeBlock) => {
    copyCodeBlock.textContent = "Copy";
    (0, import_obsidian2.setIcon)(copyCodeBlock, "copy");
  });
  botMessageDiv.appendChild(botMessageToolBarDiv);
  botMessageDiv.appendChild(messageBlockDiv);
  return botMessageDiv;
}
function displayLoadingBotMessage(settings) {
  const botMessageDiv = document.createElement("div");
  botMessageDiv.className = "botMessage";
  botMessageDiv.style.backgroundColor = colorToHex(settings.appearance.botMessageBackgroundColor || getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.botMessageBackgroundColor).trim());
  botMessageDiv.style.color = settings.appearance.botMessageFontColor || DEFAULT_SETTINGS.appearance.botMessageFontColor;
  const botMessageToolBarDiv = document.createElement("div");
  botMessageToolBarDiv.className = "botMessageToolBar";
  const botNameSpan = document.createElement("span");
  botNameSpan.textContent = settings.appearance.chatbotName || DEFAULT_SETTINGS.appearance.chatbotName;
  botNameSpan.className = "chatbotName";
  const messageBlockDiv = document.createElement("div");
  messageBlockDiv.className = "messageBlock";
  const loadingEl = document.createElement("span");
  loadingEl.setAttribute("id", "loading");
  for (let i = 0; i < 3; i++) {
    const dotSpan = document.createElement("span");
    dotSpan.textContent = ".";
    loadingEl.appendChild(dotSpan);
  }
  botMessageToolBarDiv.appendChild(botNameSpan);
  botMessageDiv.appendChild(botMessageToolBarDiv);
  botMessageDiv.appendChild(messageBlockDiv);
  botMessageDiv.appendChild(loadingEl);
  return botMessageDiv;
}
function displayCommandBotMessage(plugin, settings, messageHistory2, message) {
  const botMessageDiv = document.createElement("div");
  botMessageDiv.className = "botMessage";
  botMessageDiv.style.backgroundColor = colorToHex(settings.appearance.botMessageBackgroundColor || getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.botMessageBackgroundColor).trim());
  const botMessageToolBarDiv = document.createElement("div");
  botMessageToolBarDiv.className = "botMessageToolBar";
  const botNameSpan = document.createElement("span");
  botNameSpan.textContent = settings.appearance.chatbotName || DEFAULT_SETTINGS.appearance.chatbotName;
  botNameSpan.className = "chatbotName";
  const messageBlockDiv = document.createElement("div");
  messageBlockDiv.className = "messageBlock";
  const displayCommandBotMessageDiv = document.createElement("div");
  displayCommandBotMessageDiv.className = "commandBotMessage";
  displayCommandBotMessageDiv.innerHTML = message;
  messageBlockDiv.appendChild(displayCommandBotMessageDiv);
  botMessageToolBarDiv.appendChild(botNameSpan);
  botMessageDiv.appendChild(botMessageToolBarDiv);
  botMessageDiv.appendChild(messageBlockDiv);
  const index = messageHistory2.length - 1;
  addMessage(plugin, messageBlockDiv.innerHTML, "botMessage", settings, index);
  return botMessageDiv;
}
function displayErrorBotMessage(plugin, settings, messageHistory2, message) {
  const botMessageDiv = document.createElement("div");
  botMessageDiv.className = "botMessage";
  botMessageDiv.style.backgroundColor = colorToHex(settings.appearance.botMessageBackgroundColor || getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.botMessageBackgroundColor).trim());
  const botMessageToolBarDiv = document.createElement("div");
  botMessageToolBarDiv.className = "botMessageToolBar";
  const botNameSpan = document.createElement("span");
  botNameSpan.textContent = settings.appearance.chatbotName || DEFAULT_SETTINGS.appearance.chatbotName;
  botNameSpan.className = "chatbotName";
  const messageBlockDiv = document.createElement("div");
  messageBlockDiv.className = "messageBlock";
  const displayErrorBotMessageDiv = document.createElement("div");
  displayErrorBotMessageDiv.className = "errorBotMessage";
  const BotP = document.createElement("p");
  BotP.textContent = message;
  console.error(message);
  messageBlockDiv.appendChild(displayErrorBotMessageDiv);
  displayErrorBotMessageDiv.appendChild(BotP);
  botMessageToolBarDiv.appendChild(botNameSpan);
  botMessageDiv.appendChild(botMessageToolBarDiv);
  botMessageDiv.appendChild(messageBlockDiv);
  const index = messageHistory2.length - 1;
  addMessage(plugin, messageBlockDiv.innerHTML, "botMessage", this.settings, index);
  return botMessageDiv;
}

// node_modules/openai/version.mjs
var VERSION = "4.6.0";

// node_modules/openai/streaming.mjs
var Stream = class {
  constructor(response, controller) {
    this.response = response;
    this.controller = controller;
    this.decoder = new SSEDecoder();
  }
  async *iterMessages() {
    if (!this.response.body) {
      this.controller.abort();
      throw new Error(`Attempted to iterate over a response with no body`);
    }
    const lineDecoder = new LineDecoder();
    const iter = readableStreamAsyncIterable(this.response.body);
    for await (const chunk of iter) {
      for (const line of lineDecoder.decode(chunk)) {
        const sse = this.decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = this.decoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async *[Symbol.asyncIterator]() {
    let done = false;
    try {
      for await (const sse of this.iterMessages()) {
        if (done)
          continue;
        if (sse.data.startsWith("[DONE]")) {
          done = true;
          continue;
        }
        if (sse.event === null) {
          try {
            yield JSON.parse(sse.data);
          } catch (e) {
            console.error(`Could not parse message into JSON:`, sse.data);
            console.error(`From chunk:`, sse.raw);
            throw e;
          }
        }
      }
      done = true;
    } catch (e) {
      if (e instanceof Error && e.name === "AbortError")
        return;
      throw e;
    } finally {
      if (!done)
        this.controller.abort();
    }
  }
};
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new Error(
        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`
      );
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) !== null && _a2 !== void 0 ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new Error(
        `Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`
      );
    }
    throw new Error(
      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`
    );
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "\x85", "\u2028", "\u2029"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result === null || result === void 0 ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/error.mjs
var error_exports = {};
__export(error_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  InternalServerError: () => InternalServerError,
  NotFoundError: () => NotFoundError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError
});
var APIError = class extends Error {
  constructor(status, error, message, headers) {
    super(APIError.makeMessage(error, message));
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data === null || data === void 0 ? void 0 : data["code"];
    this.param = data === null || data === void 0 ? void 0 : data["param"];
    this.type = data === null || data === void 0 ? void 0 : data["type"];
  }
  static makeMessage(error, message) {
    return (error === null || error === void 0 ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message || "Unknown error occurred";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message !== null && message !== void 0 ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
};
var AuthenticationError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
};
var PermissionDeniedError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
};
var NotFoundError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
};
var ConflictError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
};
var UnprocessableEntityError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
};
var RateLimitError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
};
var InternalServerError = class extends APIError {
};

// node_modules/openai/_shims/agent.mjs
var getDefaultAgent = (url) => {
  return void 0;
};

// node_modules/openai/_shims/fetch.mjs
var _fetch = fetch.bind(void 0);
var isPolyfilled = false;

// node_modules/openai/_shims/form-data.mjs
var _FormData = FormData;
var _File = typeof File !== "undefined" ? File : (
  // Bun doesn't implement File yet, so just make a shim that throws a helpful error message
  class File2 extends Blob {
    constructor() {
      throw new Error(`file uploads aren't supported in this environment yet as 'File' is not defined`);
    }
  }
);

// node_modules/openai/_shims/getMultipartRequestOptions.mjs
async function getMultipartRequestOptions(form, opts) {
  return { ...opts, body: new MultipartBody(form) };
}

// node_modules/openai/_shims/fileFromPath.mjs
async function fileFromPath() {
  throw new Error(
    "The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads"
  );
}

// node_modules/openai/_shims/node-readable.mjs
function isFsReadStream(value) {
  return false;
}

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options = {}) {
  var _a2, _b, _c;
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) !== null && _a2 !== void 0 ? _a2 : "unknown_file");
    return new _File([blob], name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) !== null && _b !== void 0 ? _b : "unknown_file");
  if (!options.type) {
    const type = (_c = bits[0]) === null || _c === void 0 ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new _File(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(
      `Unexpected data type: ${typeof value}; constructor: ${(_a2 = value === null || value === void 0 ? void 0 : value.constructor) === null || _a2 === void 0 ? void 0 : _a2.name}; props: ${propsForError(value)}`
    );
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) === null || _a2 === void 0 ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new _FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(
      `Received null for "${key}"; to pass null in FormData, you must use the string 'null'`
    );
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(
      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop))
    );
  } else {
    throw new TypeError(
      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`
    );
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
var MAX_RETRIES = 2;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    return new Stream(response, props.controller);
  }
  const contentType = response.headers.get("content-type");
  if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overridenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger(
      "maxRetries",
      maxRetries !== null && maxRetries !== void 0 ? maxRetries : MAX_RETRIES
    );
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch !== null && overridenFetch !== void 0 ? overridenFetch : _fetch;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 })));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) !== null && _b !== void 0 ? _b : this.httpAgent) !== null && _c !== void 0 ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent === null || httpAgent === void 0 ? void 0 : httpAgent.options) === null || _d === void 0 ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) !== null && _e !== void 0 ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = {
      ...contentLength && { "Content-Length": contentLength },
      ...this.defaultHeaders(options),
      ...headers
    };
    if (isMultipartBody(options.body) && !isPolyfilled) {
      delete reqHeaders["Content-Type"];
    }
    Object.keys(reqHeaders).forEach((key) => reqHeaders[key] === null && delete reqHeaders[key]);
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) !== null && _f !== void 0 ? _f : null
    };
    this.validateHeaders(reqHeaders, headers);
    return { req, url, timeout };
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining = (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : this.maxRetries;
    }
    const { req, url, timeout } = this.buildRequest(options);
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) === null || _c === void 0 ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch(() => "Unknown");
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      debug("response", response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (query) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new Error(
        `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`
      );
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient().fetch(url, { signal: controller.signal, ...options }).finally(() => {
      clearTimeout(timeout);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    retriesRemaining -= 1;
    const retryAfter = parseInt(
      (responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders["retry-after"]) || ""
    );
    const maxRetries = (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : this.maxRetries;
    const timeout = this.calculateRetryTimeoutSeconds(retriesRemaining, retryAfter, maxRetries) * 1e3;
    await sleep(timeout);
    return this.makeRequest(options, retriesRemaining);
  }
  calculateRetryTimeoutSeconds(retriesRemaining, retryAfter, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 2;
    if (Number.isInteger(retryAfter) && retryAfter <= 60) {
      return retryAfter;
    }
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(numRetries - 1, 2), maxRetryDelay);
    const jitter = Math.random() - 0.5;
    return sleepSeconds + jitter;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new Error(
        "No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`."
      );
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo) {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(
      this.constructor,
      nextOptions
    );
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(
      request,
      async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options)
    );
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(
    Object.fromEntries(
      // @ts-ignore
      headers.entries()
    ),
    {
      get(target, name) {
        const key = name.toString();
        return target[key.toLowerCase()] || target[key];
      }
    }
  );
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders !== null && _platformHeaders !== void 0 ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new Error(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new Error(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d;
  if (typeof process !== "undefined") {
    return (_b = (_a2 = process.env) === null || _a2 === void 0 ? void 0 : _a2[env]) !== null && _b !== void 0 ? _b : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_d = (_c = Deno.env) === null || _c === void 0 ? void 0 : _c.get) === null || _d === void 0 ? void 0 : _d.call(_c, env);
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.object = body.object;
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2, _b;
    if (!((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return null;
    }
    const next = (_b = this.data[this.data.length - 1]) === null || _b === void 0 ? void 0 : _b.id;
    if (!next)
      return null;
    return { params: { after: next } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this.client = client;
    this.get = client.get.bind(client);
    this.post = client.post.bind(client);
    this.patch = client.patch.bind(client);
    this.put = client.put.bind(client);
    this.delete = client.delete.bind(client);
    this.getAPIList = client.getAPIList.bind(client);
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  /**
   * Transcribes audio into the input language.
   */
  create(body, options) {
    return this.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Transcriptions2) {
})(Transcriptions || (Transcriptions = {}));

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  /**
   * Translates audio into English.
   */
  create(body, options) {
    return this.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Translations2) {
})(Translations || (Translations = {}));

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this.client);
    this.translations = new Translations(this.client);
  }
};
(function(Audio2) {
  Audio2.Transcriptions = Transcriptions;
  Audio2.Translations = Translations;
})(Audio || (Audio = {}));

// node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2;
    return this.post("/chat/completions", {
      body,
      ...options,
      stream: (_a2 = body.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
(function(Completions3) {
})(Completions || (Completions = {}));

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this.client);
  }
};
(function(Chat2) {
  Chat2.Completions = Completions;
})(Chat || (Chat = {}));

// node_modules/openai/resources/completions.mjs
var Completions2 = class extends APIResource {
  create(body, options) {
    var _a2;
    return this.post("/completions", {
      body,
      ...options,
      stream: (_a2 = body.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
(function(Completions3) {
})(Completions2 || (Completions2 = {}));

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this.post("/embeddings", { body, ...options });
  }
};
(function(Embeddings2) {
})(Embeddings || (Embeddings = {}));

// node_modules/openai/resources/edits.mjs
var Edits = class extends APIResource {
  /**
   * Creates a new edit for the provided input, instruction, and parameters.
   *
   * @deprecated The Edits API is deprecated; please use Chat Completions instead.
   *
   * https://openai.com/blog/gpt-4-api-general-availability#deprecation-of-the-edits-api
   */
  create(body, options) {
    return this.post("/edits", { body, ...options });
  }
};
(function(Edits2) {
})(Edits || (Edits = {}));

// node_modules/openai/resources/files.mjs
var Files = class extends APIResource {
  /**
   * Upload a file that contains document(s) to be used across various
   * endpoints/features. Currently, the size of all the files uploaded by one
   * organization can be up to 1 GB. Please contact us if you need to increase the
   * storage limit.
   */
  create(body, options) {
    return this.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this.get(`/files/${fileId}`, options);
  }
  /**
   * Returns a list of files that belong to the user's organization.
   */
  list(options) {
    return this.getAPIList("/files", FileObjectsPage, options);
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file
   */
  retrieveContent(fileId, options) {
    return this.get(`/files/${fileId}/content`, {
      ...options,
      headers: {
        Accept: "application/json",
        ...options === null || options === void 0 ? void 0 : options.headers
      }
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends Page {
};
(function(Files2) {
})(Files || (Files = {}));

// node_modules/openai/resources/fine-tunes.mjs
var FineTunes = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
   */
  create(body, options) {
    return this.post("/fine-tunes", { body, ...options });
  }
  /**
   * Gets info about the fine-tune job.
   *
   * [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
   */
  retrieve(fineTuneId, options) {
    return this.get(`/fine-tunes/${fineTuneId}`, options);
  }
  /**
   * List your organization's fine-tuning jobs
   */
  list(options) {
    return this.getAPIList("/fine-tunes", FineTunesPage, options);
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuneId, options) {
    return this.post(`/fine-tunes/${fineTuneId}/cancel`, options);
  }
  listEvents(fineTuneId, query, options) {
    var _a2;
    return this.get(`/fine-tunes/${fineTuneId}/events`, {
      query,
      timeout: 864e5,
      ...options,
      stream: (_a2 = query === null || query === void 0 ? void 0 : query.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
var FineTunesPage = class extends Page {
};
(function(FineTunes2) {
})(FineTunes || (FineTunes = {}));

// node_modules/openai/resources/fine-tuning/jobs.mjs
var Jobs = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](/docs/guides/fine-tuning)
   */
  create(body, options) {
    return this.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options) {
    return this.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options) {
    return this.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
(function(Jobs2) {
})(Jobs || (Jobs = {}));

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this.client);
  }
};
(function(FineTuning2) {
  FineTuning2.Jobs = Jobs;
  FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
  FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(FineTuning || (FineTuning = {}));

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options) {
    return this.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options) {
    return this.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options) {
    return this.post("/images/generations", { body, ...options });
  }
};
(function(Images2) {
})(Images || (Images = {}));

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {
};
(function(Models2) {
})(Models || (Models = {}));

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text violates OpenAI's Content Policy
   */
  create(body, options) {
    return this.post("/moderations", { body, ...options });
  }
};
(function(Moderations2) {
})(Moderations || (Moderations = {}));

// node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string} [opts.apiKey=process.env['OPENAI_API_KEY']] - The API Key to send to the API.
   * @param {string} [opts.baseURL] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   * @param {string | null} [opts.organization]
   */
  constructor(_b) {
    var _c, _d, _e;
    var {
      apiKey = readEnv("OPENAI_API_KEY"),
      organization = (_c = readEnv("OPENAI_ORG_ID")) !== null && _c !== void 0 ? _c : null,
      ...opts
    } = _b === void 0 ? {} : _b;
    if (apiKey === void 0) {
      throw new Error(
        "The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'my apiKey' })."
      );
    }
    const options = {
      apiKey,
      organization,
      ...opts,
      baseURL: (_d = opts.baseURL) !== null && _d !== void 0 ? _d : `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new Error(
        "It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n"
      );
    }
    super({
      baseURL: options.baseURL,
      timeout: (_e = options.timeout) !== null && _e !== void 0 ? _e : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.edits = new Edits(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.fineTunes = new FineTunes(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
var {
  APIError: APIError2,
  APIConnectionError: APIConnectionError2,
  APIConnectionTimeoutError: APIConnectionTimeoutError2,
  APIUserAbortError: APIUserAbortError2,
  NotFoundError: NotFoundError2,
  ConflictError: ConflictError2,
  RateLimitError: RateLimitError2,
  BadRequestError: BadRequestError2,
  AuthenticationError: AuthenticationError2,
  InternalServerError: InternalServerError2,
  PermissionDeniedError: PermissionDeniedError2,
  UnprocessableEntityError: UnprocessableEntityError2
} = error_exports;
(function(OpenAI2) {
  OpenAI2.toFile = toFile;
  OpenAI2.fileFromPath = fileFromPath;
  OpenAI2.Page = Page;
  OpenAI2.CursorPage = CursorPage;
  OpenAI2.Completions = Completions2;
  OpenAI2.Chat = Chat;
  OpenAI2.Edits = Edits;
  OpenAI2.Embeddings = Embeddings;
  OpenAI2.Files = Files;
  OpenAI2.FileObjectsPage = FileObjectsPage;
  OpenAI2.Images = Images;
  OpenAI2.Audio = Audio;
  OpenAI2.Moderations = Moderations;
  OpenAI2.Models = Models;
  OpenAI2.ModelsPage = ModelsPage;
  OpenAI2.FineTuning = FineTuning;
  OpenAI2.FineTunes = FineTunes;
  OpenAI2.FineTunesPage = FineTunesPage;
})(OpenAI || (OpenAI = {}));
var openai_default = OpenAI;

// src/components/chat/Prompt.ts
async function getPrompt(plugin, settings) {
  if (settings.prompts.prompt.trim() === "") {
    return "";
  }
  const promptFilePath = settings.prompts.promptFolderPath + "/" + settings.prompts.prompt;
  try {
    const content = await plugin.app.vault.adapter.read(promptFilePath);
    const clearYamlContent = content.replace(/---[\s\S]+?---/, "").trim();
    return "\n\n" + clearYamlContent + "\n\n";
  } catch (error) {
    console.error(`Error reading file ${promptFilePath}:`, error);
    return null;
  }
}

// src/components/FetchModelResponse.ts
var abortController = new AbortController();
async function fetchOllamaResponse(plugin, settings, index) {
  const ollamaRESTAPIURL = settings.OllamaConnection.RESTAPIURL;
  if (!ollamaRESTAPIURL) {
    return;
  }
  const prompt = await getPrompt(plugin, settings);
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const response = await (0, import_obsidian3.requestUrl)({
      url: ollamaRESTAPIURL + "/api/chat",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.general.system_role + prompt + referenceCurrentNoteContent2 },
          ...messageHistoryAtIndex
        ],
        stream: false,
        keep_alive: parseInt(settings.OllamaConnection.ollamaParameters.keep_alive),
        options: ollamaParametersOptions(settings)
      })
    });
    const message = response.json.message.content;
    if (messageContainerEl) {
      const targetUserMessage = messageContainerElDivs[index];
      const targetBotMessage = targetUserMessage.nextElementSibling;
      const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
      const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
      if (messageBlock) {
        if (loadingEl) {
          targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
        }
        await import_obsidian3.MarkdownRenderer.render(plugin.app, message || "", messageBlock, "/", plugin);
        addParagraphBreaks(messageBlock);
        const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
        copyCodeBlocks.forEach((copyCodeBlock) => {
          copyCodeBlock.textContent = "Copy";
          (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
        });
        targetBotMessage == null ? void 0 : targetBotMessage.appendChild(messageBlock);
      }
      targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    addMessage(plugin, message, "botMessage", settings, index);
  } catch (error) {
    const targetUserMessage = messageContainerElDivs[index];
    const targetBotMessage = targetUserMessage.nextElementSibling;
    targetBotMessage == null ? void 0 : targetBotMessage.remove();
    const messageContainer = document.querySelector("#messageContainer");
    const botMessageDiv2 = displayErrorBotMessage(plugin, settings, messageHistory, error);
    messageContainer.appendChild(botMessageDiv2);
  }
}
async function fetchOllamaResponseStream(plugin, settings, index) {
  const ollamaRESTAPIURL = settings.OllamaConnection.RESTAPIURL;
  if (!ollamaRESTAPIURL) {
    return;
  }
  const prompt = await getPrompt(plugin, settings);
  const url = ollamaRESTAPIURL + "/api/chat";
  abortController = new AbortController();
  let message = "";
  let isScroll = false;
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.general.system_role + prompt + referenceCurrentNoteContent2 },
          ...messageHistoryAtIndex
        ],
        stream: true,
        keep_alive: parseInt(settings.OllamaConnection.ollamaParameters.keep_alive),
        options: ollamaParametersOptions(settings)
      }),
      signal: abortController.signal
    });
    if (!response.ok) {
      new import_obsidian3.Notice(`HTTP error! Status: ${response.status}`);
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    if (!response.body) {
      new import_obsidian3.Notice("Response body is null or undefined.");
      throw new Error("Response body is null or undefined.");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let reading = true;
    while (reading) {
      const { done, value } = await reader.read();
      if (done) {
        reading = false;
        break;
      }
      const chunk = decoder.decode(value, { stream: true }) || "";
      const parts = chunk.split("\n");
      for (const part of parts.filter(Boolean)) {
        let parsedChunk;
        try {
          parsedChunk = JSON.parse(part);
          if (parsedChunk.done !== true) {
            const content = parsedChunk.message.content;
            message += content;
          }
        } catch (err) {
          console.error("Error parsing JSON:", err);
          console.log("Part with error:", part);
          parsedChunk = { response: "{_e_}" };
        }
      }
      const messageContainerEl2 = document.querySelector("#messageContainer");
      if (messageContainerEl2) {
        const targetUserMessage = messageContainerElDivs[index];
        const targetBotMessage = targetUserMessage.nextElementSibling;
        const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
        const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
        if (messageBlock) {
          if (loadingEl) {
            targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
          }
          messageBlock.innerHTML = "";
          const fragment = document.createDocumentFragment();
          const tempContainer = document.createElement("div");
          fragment.appendChild(tempContainer);
          await import_obsidian3.MarkdownRenderer.render(plugin.app, message, tempContainer, "/", plugin);
          while (tempContainer.firstChild) {
            messageBlock.appendChild(tempContainer.firstChild);
          }
          addParagraphBreaks(messageBlock);
          const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
          copyCodeBlocks.forEach((copyCodeBlock) => {
            copyCodeBlock.textContent = "Copy";
            (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
          });
        }
        messageContainerEl2.addEventListener("wheel", (event) => {
          if (event.deltaY < 0 || event.deltaY > 0) {
            isScroll = true;
          }
        });
        if (!isScroll) {
          targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "auto", block: "start" });
        }
      }
    }
    addMessage(plugin, message, "botMessage", settings, index);
  } catch (error) {
    addMessage(plugin, message, "botMessage", settings, index);
    new import_obsidian3.Notice(error);
    console.error(error);
  }
}
async function fetchRESTAPIURLResponse(plugin, settings, index) {
  const prompt = await getPrompt(plugin, settings);
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const response = await (0, import_obsidian3.requestUrl)({
      url: settings.RESTAPIURLConnection.RESTAPIURL + "/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.RESTAPIURLConnection.APIKey}`
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.general.system_role + prompt + referenceCurrentNoteContent2 || "You are a helpful assistant." },
          ...messageHistoryAtIndex
        ],
        max_tokens: parseInt(settings.general.max_tokens) || -1,
        temperature: parseInt(settings.general.temperature)
      })
    });
    const message = response.json.choices[0].message.content;
    const messageContainerEl2 = document.querySelector("#messageContainer");
    if (messageContainerEl2) {
      const targetUserMessage = messageContainerElDivs[index];
      const targetBotMessage = targetUserMessage.nextElementSibling;
      const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
      const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
      if (messageBlock) {
        if (loadingEl) {
          targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
        }
        await import_obsidian3.MarkdownRenderer.render(plugin.app, message || "", messageBlock, "/", plugin);
        addParagraphBreaks(messageBlock);
        const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
        copyCodeBlocks.forEach((copyCodeBlock) => {
          copyCodeBlock.textContent = "Copy";
          (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
        });
        targetBotMessage == null ? void 0 : targetBotMessage.appendChild(messageBlock);
      }
      targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    addMessage(plugin, message, "botMessage", settings, index);
    return;
  } catch (error) {
    const targetUserMessage = messageContainerElDivs[index];
    const targetBotMessage = targetUserMessage.nextElementSibling;
    targetBotMessage == null ? void 0 : targetBotMessage.remove();
    const messageContainer = document.querySelector("#messageContainer");
    const botMessageDiv2 = displayErrorBotMessage(plugin, settings, messageHistory, error);
    messageContainer.appendChild(botMessageDiv2);
  }
}
async function fetchRESTAPIURLResponseStream(plugin, settings, index) {
  const RESTAPIURL = settings.RESTAPIURLConnection.RESTAPIURL;
  if (!RESTAPIURL) {
    return;
  }
  const prompt = await getPrompt(plugin, settings);
  const url = RESTAPIURL + "/chat/completions";
  abortController = new AbortController();
  let message = "";
  let isScroll = false;
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.RESTAPIURLConnection.APIKey}`
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.general.system_role + prompt + referenceCurrentNoteContent2 || "You are a helpful assistant." },
          ...messageHistoryAtIndex
        ],
        stream: true,
        temperature: parseInt(settings.general.temperature),
        max_tokens: parseInt(settings.general.max_tokens) || 4096
      }),
      signal: abortController.signal
    });
    if (!response.ok) {
      new import_obsidian3.Notice(`HTTP error! Status: ${response.status}`);
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    if (!response.body) {
      new import_obsidian3.Notice("Response body is null or undefined.");
      throw new Error("Response body is null or undefined.");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let reading = true;
    while (reading) {
      const { done, value } = await reader.read();
      if (done) {
        reading = false;
        break;
      }
      const chunk = decoder.decode(value, { stream: false }) || "";
      const parts = chunk.split("\n");
      for (const part of parts.filter(Boolean)) {
        if (part.includes("data: [DONE]")) {
          break;
        }
        let parsedChunk;
        try {
          parsedChunk = JSON.parse(part.replace(/^data: /, ""));
          if (parsedChunk.choices[0].finish_reason !== "stop") {
            const content = parsedChunk.choices[0].delta.content;
            message += content;
          }
        } catch (err) {
          console.error("Error parsing JSON:", err);
          console.log("Part with error:", part);
          parsedChunk = { response: "{_e_}" };
        }
      }
      const messageContainerEl2 = document.querySelector("#messageContainer");
      if (messageContainerEl2) {
        const targetUserMessage = messageContainerElDivs[index];
        const targetBotMessage = targetUserMessage.nextElementSibling;
        const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
        const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
        if (messageBlock) {
          if (loadingEl) {
            targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
          }
          messageBlock.innerHTML = "";
          const fragment = document.createDocumentFragment();
          const tempContainer = document.createElement("div");
          fragment.appendChild(tempContainer);
          await import_obsidian3.MarkdownRenderer.render(plugin.app, message, tempContainer, "/", plugin);
          while (tempContainer.firstChild) {
            messageBlock.appendChild(tempContainer.firstChild);
          }
          addParagraphBreaks(messageBlock);
          const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
          copyCodeBlocks.forEach((copyCodeBlock) => {
            copyCodeBlock.textContent = "Copy";
            (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
          });
        }
        messageContainerEl2.addEventListener("wheel", (event) => {
          if (event.deltaY < 0 || event.deltaY > 0) {
            isScroll = true;
          }
        });
        if (!isScroll) {
          targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "auto", block: "start" });
        }
      }
    }
    addMessage(plugin, message, "botMessage", settings, index);
  } catch (error) {
    addMessage(plugin, message, "botMessage", settings, index);
    new import_obsidian3.Notice(error);
    console.error(error);
  }
}
async function fetchAnthropicResponse(plugin, settings, index) {
  const prompt = await getPrompt(plugin, settings);
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const response = await (0, import_obsidian3.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "anthropic-version": "2023-06-01",
        "content-type": "application/json",
        "x-api-key": settings.APIConnections.anthropic.APIKey
      },
      body: JSON.stringify({
        model: settings.general.model,
        system: settings.general.system_role + prompt + referenceCurrentNoteContent2,
        messages: [
          ...messageHistoryAtIndex
        ],
        max_tokens: parseInt(settings.general.max_tokens) || 4096,
        temperature: parseInt(settings.general.temperature)
      })
    });
    const message = response.json.content[0].text;
    const messageContainerEl2 = document.querySelector("#messageContainer");
    if (messageContainerEl2) {
      const targetUserMessage = messageContainerElDivs[index];
      const targetBotMessage = targetUserMessage.nextElementSibling;
      const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
      const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
      if (messageBlock) {
        if (loadingEl) {
          targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
        }
        await import_obsidian3.MarkdownRenderer.render(plugin.app, message || "", messageBlock, "/", plugin);
        addParagraphBreaks(messageBlock);
        const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
        copyCodeBlocks.forEach((copyCodeBlock) => {
          copyCodeBlock.textContent = "Copy";
          (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
        });
        targetBotMessage == null ? void 0 : targetBotMessage.appendChild(messageBlock);
      }
      targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    addMessage(plugin, message, "botMessage", settings, index);
    return;
  } catch (error) {
    const targetUserMessage = messageContainerElDivs[index];
    const targetBotMessage = targetUserMessage.nextElementSibling;
    targetBotMessage == null ? void 0 : targetBotMessage.remove();
    const messageContainer = document.querySelector("#messageContainer");
    const botMessageDiv2 = displayErrorBotMessage(plugin, settings, messageHistory, error);
    messageContainer.appendChild(botMessageDiv2);
  }
}
async function fetchGoogleGeminiResponse(plugin, settings, index) {
  const prompt = await getPrompt(plugin, settings);
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  const convertMessageHistory = (messageHistory2) => {
    const modifiedMessageHistory = [...messageHistory2];
    const convertedMessageHistory2 = modifiedMessageHistory.map(({ role, content }) => ({
      role: role === "assistant" ? "model" : role,
      parts: [{ text: content }]
    }));
    const contents = [
      ...convertedMessageHistory2
    ];
    return { contents };
  };
  const convertedMessageHistory = convertMessageHistory(messageHistoryAtIndex);
  try {
    const API_KEY = settings.APIConnections.googleGemini.APIKey;
    const response = await (0, import_obsidian3.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        contents: [
          {
            role: "user",
            parts: [{ text: `System prompt: 

 ${plugin.settings.general.system_role} ${prompt} ${referenceCurrentNoteContent2} Respond understood if you got it.` }]
          },
          {
            role: "model",
            parts: [{ text: "Understood." }]
          },
          ...convertedMessageHistory.contents
        ],
        generationConfig: {
          stopSequences: "",
          temperature: parseInt(settings.general.temperature),
          maxOutputTokens: settings.general.max_tokens || 4096,
          topP: 0.8,
          topK: 10
        }
      })
    });
    const message = response.json.candidates[0].content.parts[0].text;
    const messageContainerEl2 = document.querySelector("#messageContainer");
    if (messageContainerEl2) {
      const targetUserMessage = messageContainerElDivs[index];
      const targetBotMessage = targetUserMessage.nextElementSibling;
      const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
      const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
      if (messageBlock) {
        if (loadingEl) {
          targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
        }
        await import_obsidian3.MarkdownRenderer.render(plugin.app, message || "", messageBlock, "/", plugin);
        addParagraphBreaks(messageBlock);
        const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
        copyCodeBlocks.forEach((copyCodeBlock) => {
          copyCodeBlock.textContent = "Copy";
          (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
        });
        targetBotMessage == null ? void 0 : targetBotMessage.appendChild(messageBlock);
      }
      targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    addMessage(plugin, message, "botMessage", settings, index);
    return;
  } catch (error) {
    const targetUserMessage = messageContainerElDivs[index];
    const targetBotMessage = targetUserMessage.nextElementSibling;
    targetBotMessage == null ? void 0 : targetBotMessage.remove();
    const messageContainer = document.querySelector("#messageContainer");
    const botMessageDiv2 = displayErrorBotMessage(plugin, settings, messageHistory, error);
    messageContainer.appendChild(botMessageDiv2);
  }
}
async function fetchMistralResponse(plugin, settings, index) {
  const prompt = await getPrompt(plugin, settings);
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const response = await (0, import_obsidian3.requestUrl)({
      url: "https://api.mistral.ai/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.APIConnections.mistral.APIKey}`
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.general.system_role + prompt + referenceCurrentNoteContent2 },
          ...messageHistoryAtIndex
        ],
        max_tokens: parseInt(settings.general.max_tokens) || 4096,
        temperature: parseInt(settings.general.temperature)
      })
    });
    const message = response.json.choices[0].message.content;
    const messageContainerEl2 = document.querySelector("#messageContainer");
    if (messageContainerEl2) {
      const targetUserMessage = messageContainerElDivs[index];
      const targetBotMessage = targetUserMessage.nextElementSibling;
      const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
      const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
      if (messageBlock) {
        if (loadingEl) {
          targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
        }
        await import_obsidian3.MarkdownRenderer.render(plugin.app, message || "", messageBlock, "/", plugin);
        addParagraphBreaks(messageBlock);
        const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
        copyCodeBlocks.forEach((copyCodeBlock) => {
          copyCodeBlock.textContent = "Copy";
          (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
        });
        targetBotMessage == null ? void 0 : targetBotMessage.appendChild(messageBlock);
      }
      targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    addMessage(plugin, message, "botMessage", settings, index);
    return;
  } catch (error) {
    const targetUserMessage = messageContainerElDivs[index];
    const targetBotMessage = targetUserMessage.nextElementSibling;
    targetBotMessage == null ? void 0 : targetBotMessage.remove();
    const messageContainer = document.querySelector("#messageContainer");
    const botMessageDiv2 = displayErrorBotMessage(plugin, settings, messageHistory, error);
    messageContainer.appendChild(botMessageDiv2);
  }
}
async function fetchMistralResponseStream(plugin, settings, index) {
  abortController = new AbortController();
  const prompt = await getPrompt(plugin, settings);
  let message = "";
  let isScroll = false;
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const response = await fetch("https://api.mistral.ai/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.APIConnections.mistral.APIKey}`
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.general.system_role + prompt + referenceCurrentNoteContent2 },
          ...messageHistoryAtIndex
        ],
        stream: true,
        temperature: parseInt(settings.general.temperature),
        max_tokens: parseInt(settings.general.max_tokens) || 4096
      }),
      signal: abortController.signal
    });
    if (!response.ok) {
      new import_obsidian3.Notice(`HTTP error! Status: ${response.status}`);
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    if (!response.body) {
      new import_obsidian3.Notice("Response body is null or undefined.");
      throw new Error("Response body is null or undefined.");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let reading = true;
    while (reading) {
      const { done, value } = await reader.read();
      if (done) {
        reading = false;
        break;
      }
      const chunk = decoder.decode(value, { stream: false }) || "";
      const parts = chunk.split("\n");
      for (const part of parts.filter(Boolean)) {
        if (part.includes("data: [DONE]")) {
          break;
        }
        let parsedChunk;
        try {
          parsedChunk = JSON.parse(part.replace(/^data: /, ""));
          if (parsedChunk.choices[0].finish_reason !== "stop") {
            const content = parsedChunk.choices[0].delta.content;
            message += content;
          }
        } catch (err) {
          console.error("Error parsing JSON:", err);
          console.log("Part with error:", part);
          parsedChunk = { response: "{_e_}" };
        }
      }
      const messageContainerEl2 = document.querySelector("#messageContainer");
      if (messageContainerEl2) {
        const targetUserMessage = messageContainerElDivs[index];
        const targetBotMessage = targetUserMessage.nextElementSibling;
        const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
        const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
        if (messageBlock) {
          if (loadingEl) {
            targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
          }
          messageBlock.innerHTML = "";
          const fragment = document.createDocumentFragment();
          const tempContainer = document.createElement("div");
          fragment.appendChild(tempContainer);
          await import_obsidian3.MarkdownRenderer.render(plugin.app, message, tempContainer, "/", plugin);
          while (tempContainer.firstChild) {
            messageBlock.appendChild(tempContainer.firstChild);
          }
          addParagraphBreaks(messageBlock);
          const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
          copyCodeBlocks.forEach((copyCodeBlock) => {
            copyCodeBlock.textContent = "Copy";
            (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
          });
        }
        messageContainerEl2.addEventListener("wheel", (event) => {
          if (event.deltaY < 0 || event.deltaY > 0) {
            isScroll = true;
          }
        });
        if (!isScroll) {
          targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "auto", block: "start" });
        }
      }
    }
    addMessage(plugin, message, "botMessage", settings, index);
  } catch (error) {
    addMessage(plugin, message, "botMessage", settings, index);
    new import_obsidian3.Notice(error);
    console.error(error);
  }
}
async function fetchOpenAIAPIResponse(plugin, settings, index) {
  const openai = new openai_default({
    apiKey: settings.APIConnections.openAI.APIKey,
    baseURL: settings.APIConnections.openAI.openAIBaseUrl,
    dangerouslyAllowBrowser: true
    // apiKey is stored within data.json
  });
  const prompt = await getPrompt(plugin, settings);
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const completion = await openai.chat.completions.create({
      model: settings.general.model,
      max_tokens: parseInt(settings.general.max_tokens),
      stream: false,
      messages: [
        { role: "system", content: settings.general.system_role + prompt + referenceCurrentNoteContent2 },
        ...messageHistoryAtIndex
      ]
    });
    const message = completion.choices[0].message.content;
    if (messageContainerEl) {
      const targetUserMessage = messageContainerElDivs[index];
      const targetBotMessage = targetUserMessage.nextElementSibling;
      const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
      const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
      if (messageBlock) {
        if (loadingEl) {
          targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
        }
        await import_obsidian3.MarkdownRenderer.render(plugin.app, message || "", messageBlock, "/", plugin);
        addParagraphBreaks(messageBlock);
        const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
        copyCodeBlocks.forEach((copyCodeBlock) => {
          copyCodeBlock.textContent = "Copy";
          (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
        });
        targetBotMessage == null ? void 0 : targetBotMessage.appendChild(messageBlock);
      }
      targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    if (message != null) {
      addMessage(plugin, message, "botMessage", settings, index);
    }
  } catch (error) {
    const targetUserMessage = messageContainerElDivs[index];
    const targetBotMessage = targetUserMessage.nextElementSibling;
    targetBotMessage == null ? void 0 : targetBotMessage.remove();
    const messageContainer = document.querySelector("#messageContainer");
    const botMessageDiv2 = displayErrorBotMessage(plugin, settings, messageHistory, error);
    messageContainer.appendChild(botMessageDiv2);
  }
}
async function fetchOpenAIAPIResponseStream(plugin, settings, index) {
  var _a2, _b;
  const openai = new openai_default({
    apiKey: settings.APIConnections.openAI.APIKey,
    baseURL: settings.APIConnections.openAI.openAIBaseUrl,
    dangerouslyAllowBrowser: true
    // apiKey is stored within data.json
  });
  abortController = new AbortController();
  const prompt = await getPrompt(plugin, settings);
  let message = "";
  let isScroll = false;
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  const targetUserMessage = messageContainerElDivs[index];
  const targetBotMessage = targetUserMessage.nextElementSibling;
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const stream = await openai.chat.completions.create({
      model: settings.general.model,
      max_tokens: parseInt(settings.general.max_tokens),
      temperature: parseInt(settings.general.temperature),
      stream: true,
      messages: [
        { role: "system", content: settings.general.system_role + prompt + referenceCurrentNoteContent2 },
        ...messageHistoryAtIndex
      ]
    });
    for await (const part of stream) {
      const content = ((_b = (_a2 = part.choices[0]) == null ? void 0 : _a2.delta) == null ? void 0 : _b.content) || "";
      message += content;
      if (messageContainerEl) {
        const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
        const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
        if (messageBlock) {
          if (loadingEl) {
            targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
          }
          messageBlock.innerHTML = "";
          const fragment = document.createDocumentFragment();
          const tempContainer = document.createElement("div");
          fragment.appendChild(tempContainer);
          await import_obsidian3.MarkdownRenderer.render(plugin.app, message, tempContainer, "/", plugin);
          while (tempContainer.firstChild) {
            messageBlock.appendChild(tempContainer.firstChild);
          }
          addParagraphBreaks(messageBlock);
          const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
          copyCodeBlocks.forEach((copyCodeBlock) => {
            copyCodeBlock.textContent = "Copy";
            (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
          });
        }
        messageContainerEl.addEventListener("wheel", (event) => {
          if (event.deltaY < 0 || event.deltaY > 0) {
            isScroll = true;
          }
        });
        if (!isScroll) {
          targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "auto", block: "start" });
        }
      }
      if (abortController.signal.aborted) {
        new import_obsidian3.Notice("Error making API request: The user aborted a request.");
        break;
      }
    }
    addMessage(plugin, message, "botMessage", settings, index);
  } catch (error) {
    const targetUserMessage2 = messageContainerElDivs[index];
    const targetBotMessage2 = targetUserMessage2.nextElementSibling;
    targetBotMessage2 == null ? void 0 : targetBotMessage2.remove();
    const messageContainer = document.querySelector("#messageContainer");
    const botMessageDiv2 = displayErrorBotMessage(plugin, settings, messageHistory, error);
    messageContainer.appendChild(botMessageDiv2);
  }
}
async function fetchOpenRouterResponse(plugin, settings, index) {
  const prompt = await getPrompt(plugin, settings);
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const response = await (0, import_obsidian3.requestUrl)({
      url: "https://openrouter.ai/api/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.APIConnections.openRouter.APIKey}`
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.general.system_role + prompt + referenceCurrentNoteContent2 || "You are a helpful assistant." },
          ...messageHistoryAtIndex
        ],
        max_tokens: parseInt(settings.general.max_tokens) || 4096,
        temperature: parseInt(settings.general.temperature)
      })
    });
    const message = response.json.choices[0].message.content;
    const messageContainerEl2 = document.querySelector("#messageContainer");
    if (messageContainerEl2) {
      const targetUserMessage = messageContainerElDivs[index];
      const targetBotMessage = targetUserMessage.nextElementSibling;
      const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
      const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
      if (messageBlock) {
        if (loadingEl) {
          targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
        }
        await import_obsidian3.MarkdownRenderer.render(plugin.app, message || "", messageBlock, "/", plugin);
        addParagraphBreaks(messageBlock);
        const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
        copyCodeBlocks.forEach((copyCodeBlock) => {
          copyCodeBlock.textContent = "Copy";
          (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
        });
        targetBotMessage == null ? void 0 : targetBotMessage.appendChild(messageBlock);
      }
      targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    addMessage(plugin, message, "botMessage", settings, index);
    return;
  } catch (error) {
    const targetUserMessage = messageContainerElDivs[index];
    const targetBotMessage = targetUserMessage.nextElementSibling;
    targetBotMessage == null ? void 0 : targetBotMessage.remove();
    const messageContainer = document.querySelector("#messageContainer");
    const botMessageDiv2 = displayErrorBotMessage(plugin, settings, messageHistory, error);
    messageContainer.appendChild(botMessageDiv2);
  }
}
async function fetchOpenRouterResponseStream(plugin, settings, index) {
  const url = "https://openrouter.ai/api/v1/chat/completions";
  abortController = new AbortController();
  const prompt = await getPrompt(plugin, settings);
  let message = "";
  let isScroll = false;
  const filteredMessageHistory = filterMessageHistory(messageHistory);
  const messageHistoryAtIndex = removeConsecutiveUserRoles(filteredMessageHistory);
  const messageContainerEl = document.querySelector("#messageContainer");
  const messageContainerElDivs = document.querySelectorAll("#messageContainer div.userMessage, #messageContainer div.botMessage");
  const botMessageDiv = displayLoadingBotMessage(settings);
  messageContainerEl == null ? void 0 : messageContainerEl.insertBefore(botMessageDiv, messageContainerElDivs[index + 1]);
  botMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
  await getActiveFileContent(plugin, settings);
  const referenceCurrentNoteContent2 = getCurrentNoteContent();
  try {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.APIConnections.openRouter.APIKey}`
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.general.system_role + prompt + referenceCurrentNoteContent2 || "You are a helpful assistant." },
          ...messageHistoryAtIndex
        ],
        stream: true,
        temperature: parseInt(settings.general.temperature),
        max_tokens: parseInt(settings.general.max_tokens) || 4096
      }),
      signal: abortController.signal
    });
    if (!response.ok) {
      new import_obsidian3.Notice(`HTTP error! Status: ${response.status}`);
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    if (!response.body) {
      new import_obsidian3.Notice("Response body is null or undefined.");
      throw new Error("Response body is null or undefined.");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let reading = true;
    while (reading) {
      const { done, value } = await reader.read();
      if (done) {
        reading = false;
        break;
      }
      const chunk = decoder.decode(value, { stream: false }) || "";
      const parts = chunk.split("\n");
      for (const part of parts.filter(Boolean)) {
        if (part.includes("data: [DONE]")) {
          break;
        }
        let parsedChunk;
        try {
          parsedChunk = JSON.parse(part.replace(/^data: /, ""));
          if (parsedChunk.choices[0].finish_reason !== "stop") {
            const content = parsedChunk.choices[0].delta.content;
            message += content;
          }
        } catch (err) {
          console.error("Error parsing JSON:", err);
          console.log("Part with error:", part);
          parsedChunk = { response: "{_e_}" };
        }
      }
      const messageContainerEl2 = document.querySelector("#messageContainer");
      if (messageContainerEl2) {
        const targetUserMessage = messageContainerElDivs[index];
        const targetBotMessage = targetUserMessage.nextElementSibling;
        const messageBlock = targetBotMessage == null ? void 0 : targetBotMessage.querySelector(".messageBlock");
        const loadingEl = targetBotMessage == null ? void 0 : targetBotMessage.querySelector("#loading");
        if (messageBlock) {
          if (loadingEl) {
            targetBotMessage == null ? void 0 : targetBotMessage.removeChild(loadingEl);
          }
          messageBlock.innerHTML = "";
          const fragment = document.createDocumentFragment();
          const tempContainer = document.createElement("div");
          fragment.appendChild(tempContainer);
          await import_obsidian3.MarkdownRenderer.render(plugin.app, message, tempContainer, "/", plugin);
          while (tempContainer.firstChild) {
            messageBlock.appendChild(tempContainer.firstChild);
          }
          addParagraphBreaks(messageBlock);
          const copyCodeBlocks = messageBlock.querySelectorAll(".copy-code-button");
          copyCodeBlocks.forEach((copyCodeBlock) => {
            copyCodeBlock.textContent = "Copy";
            (0, import_obsidian3.setIcon)(copyCodeBlock, "copy");
          });
        }
        messageContainerEl2.addEventListener("wheel", (event) => {
          if (event.deltaY < 0 || event.deltaY > 0) {
            isScroll = true;
          }
        });
        if (!isScroll) {
          targetBotMessage == null ? void 0 : targetBotMessage.scrollIntoView({ behavior: "auto", block: "start" });
        }
      }
    }
    addMessage(plugin, message, "botMessage", settings, index);
  } catch (error) {
    addMessage(plugin, message, "botMessage", settings, index);
    new import_obsidian3.Notice(error);
    console.error(error);
  }
}
function getAbortController() {
  return abortController;
}
function ollamaParametersOptions(settings) {
  return {
    mirostat: parseInt(settings.OllamaConnection.ollamaParameters.mirostat),
    mirostat_eta: parseFloat(settings.OllamaConnection.ollamaParameters.mirostat_eta),
    mirostat_tau: parseFloat(settings.OllamaConnection.ollamaParameters.mirostat_tau),
    num_ctx: parseInt(settings.OllamaConnection.ollamaParameters.num_ctx),
    num_gqa: parseInt(settings.OllamaConnection.ollamaParameters.num_gqa),
    num_thread: parseInt(settings.OllamaConnection.ollamaParameters.num_thread),
    repeat_last_n: parseInt(settings.OllamaConnection.ollamaParameters.repeat_last_n),
    repeat_penalty: parseFloat(settings.OllamaConnection.ollamaParameters.repeat_penalty),
    temperature: parseInt(settings.general.temperature),
    seed: parseInt(settings.OllamaConnection.ollamaParameters.seed),
    stop: settings.OllamaConnection.ollamaParameters.stop,
    tfs_z: parseFloat(settings.OllamaConnection.ollamaParameters.tfs_z),
    num_predict: parseInt(settings.general.max_tokens) || -1,
    top_k: parseInt(settings.OllamaConnection.ollamaParameters.top_k),
    top_p: parseFloat(settings.OllamaConnection.ollamaParameters.top_p)
  };
}
function filterMessageHistory(messageHistory2) {
  const skipIndexes = /* @__PURE__ */ new Set();
  messageHistory2.forEach((message, index, array) => {
    if (message.role === "user" && message.content.includes("/")) {
      skipIndexes.add(index);
      if (index + 1 < array.length && array[index + 1].role === "assistant") {
        skipIndexes.add(index + 1);
      }
    } else if (message.role === "assistant" && message.content.includes("errorBotMessage")) {
      skipIndexes.add(index);
      if (index > 0) {
        skipIndexes.add(index - 1);
      }
    }
  });
  const filteredMessageHistory = messageHistory2.filter((_, index) => !skipIndexes.has(index));
  return filteredMessageHistory;
}
function removeConsecutiveUserRoles(messageHistory2) {
  const result = [];
  let foundUserMessage = false;
  for (let i = 0; i < messageHistory2.length; i++) {
    if (messageHistory2[i].role === "user") {
      if (!foundUserMessage) {
        result.push(messageHistory2[i]);
        foundUserMessage = true;
      } else {
        break;
      }
    } else {
      result.push(messageHistory2[i]);
      foundUserMessage = false;
    }
  }
  return result;
}

// src/components/editor/FetchRenameNoteTitle.ts
var import_obsidian4 = require("obsidian");
async function fetchModelRenameTitle(settings, referenceCurrentNoteContent2) {
  var _a2, _b;
  const clearYamlContent = referenceCurrentNoteContent2.replace(/---[\s\S]+?---/, "").trim();
  const prompt = `You are a title generator. You will give succinct titles that does not contain backslashes,
                    forward slashes, or colons. Generate a title as your response.

`;
  try {
    if (settings.OllamaConnection.RESTAPIURL && settings.OllamaConnection.ollamaModels.includes(settings.general.model)) {
      const url = settings.OllamaConnection.RESTAPIURL + "/api/generate";
      const requestBody = {
        prompt: prompt + "\n\n" + clearYamlContent + "\n\n",
        model: settings.general.model,
        stream: false,
        options: {
          temperature: parseInt(settings.general.temperature),
          num_predict: 40
        }
      };
      const response = await (0, import_obsidian4.requestUrl)({
        url,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      const parseText = JSON.parse(response.text);
      let title = parseText.response;
      if (title) {
        title = title.replace(/[\\/:"]/g, "");
      }
      return title;
    } else if (settings.RESTAPIURLConnection.RESTAPIURLModels.includes(settings.general.model)) {
      try {
        const response = await (0, import_obsidian4.requestUrl)({
          url: settings.RESTAPIURLConnection.RESTAPIURL + "/chat/completions",
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${settings.RESTAPIURLConnection.APIKey}`
          },
          body: JSON.stringify({
            model: settings.general.model,
            messages: [
              { role: "system", content: prompt + clearYamlContent },
              { role: "user", content: "\n" }
            ],
            max_tokens: 40
          })
        });
        let title = response.json.choices[0].message.content;
        if (title) {
          title = title.replace(/[\\/:"]/g, "");
        }
        return title;
      } catch (error) {
        console.error("Error making API request:", error);
        throw error;
      }
    } else if (ANTHROPIC_MODELS.includes(settings.general.model)) {
      try {
        const response = await (0, import_obsidian4.requestUrl)({
          url: "https://api.anthropic.com/v1/messages",
          method: "POST",
          headers: {
            "anthropic-version": "2023-06-01",
            "content-type": "application/json",
            "x-api-key": settings.APIConnections.anthropic.APIKey
          },
          body: JSON.stringify({
            model: settings.general.model,
            system: prompt,
            messages: [
              { role: "user", content: `${clearYamlContent}` }
            ],
            max_tokens: 40,
            temperature: parseInt(settings.general.temperature)
          })
        });
        let title = response.json.content[0].text;
        if (title) {
          title = title.replace(/[\\/:"]/g, "");
        }
        return title;
      } catch (error) {
        new import_obsidian4.Notice(error);
        console.error(error);
        throw error;
      }
    } else if (settings.APIConnections.googleGemini.geminiModels.includes(settings.general.model)) {
      try {
        const API_KEY = settings.APIConnections.googleGemini.APIKey;
        const requestBody = {
          contents: [{
            parts: [
              { text: prompt + clearYamlContent }
            ]
          }]
        };
        const response = await (0, import_obsidian4.requestUrl)({
          url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`,
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(requestBody)
        });
        let title = response.json.candidates[0].content.parts[0].text;
        if (title) {
          title = title.replace(/[\\/:"]/g, "");
        }
        return title;
      } catch (error) {
        console.error(error);
      }
    } else if (settings.APIConnections.mistral.mistralModels.includes(settings.general.model)) {
      try {
        const response = await (0, import_obsidian4.requestUrl)({
          url: "https://api.mistral.ai/v1/chat/completions",
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${settings.APIConnections.mistral.APIKey}`
          },
          body: JSON.stringify({
            model: settings.general.model,
            messages: [
              { role: "system", content: prompt + clearYamlContent },
              { role: "user", content: "\n" }
            ],
            max_tokens: 40
          })
        });
        let title = response.json.choices[0].message.content;
        if (title) {
          title = title.replace(/[\\/:"]/g, "");
        }
        return title;
      } catch (error) {
        console.error(error);
      }
    } else if (OPENAI_MODELS.includes(settings.general.model) || settings.APIConnections.openAI.openAIBaseModels.includes(settings.general.model)) {
      const openai = new openai_default({
        apiKey: settings.APIConnections.openAI.APIKey,
        baseURL: settings.APIConnections.openAI.openAIBaseUrl,
        dangerouslyAllowBrowser: true
        // apiKey is stored within data.json
      });
      const chatCompletion = await openai.chat.completions.create({
        model: settings.general.model,
        max_tokens: 40,
        messages: [
          { role: "system", content: prompt + clearYamlContent },
          { role: "user", content: "" }
        ]
      });
      let title = chatCompletion.choices[0].message.content;
      if (title) {
        title = title.replace(/[\\/:"]/g, "");
      }
      return title;
    } else if (settings.APIConnections.openRouter.openRouterModels.includes(settings.general.model)) {
      try {
        const response = await (0, import_obsidian4.requestUrl)({
          url: "https://openrouter.ai/api/v1/chat/completions",
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${settings.APIConnections.openRouter.APIKey}`
          },
          body: JSON.stringify({
            model: settings.general.model,
            messages: [
              { role: "system", content: prompt + clearYamlContent },
              { role: "user", content: "\n" }
            ],
            max_tokens: 40
          })
        });
        let title = response.json.choices[0].message.content;
        if (title) {
          title = title.replace(/[\\/:"]/g, "");
        }
        return title;
      } catch (error) {
        console.error("Error making API request:", error);
        throw error;
      }
    } else {
      throw new Error("Invalid model selected for renaming note title. Please check your settings.");
    }
  } catch (error) {
    console.log("ERROR");
    throw new Error(((_b = (_a2 = error.response) == null ? void 0 : _a2.data) == null ? void 0 : _b.error) || error.message);
  }
}

// src/components/chat/Commands.ts
function executeCommand(input, settings, plugin) {
  const command = input.split(" ")[0];
  switch (command) {
    case "/h":
    case "/help":
    case "/man":
    case "/manual":
    case "/commands":
      commandHelp(plugin, settings);
      break;
    case "/m":
    case "/model":
    case "/models":
      return commandModel(input, settings, plugin);
    case "/p":
    case "/prof":
    case "/profile":
    case "/profiles":
      return commandProfile(input, settings, plugin);
    case "/prompt":
    case "/prompts":
      return commandPrompt(input, settings, plugin);
    case "/ref":
    case "/reference":
      commandReference(input, settings, plugin);
      break;
    case "/temp":
    case "/temperature":
      commandTemperature(input, settings, plugin);
      break;
    case "/maxtokens":
      commandMaxTokens(input, settings, plugin);
      break;
    case "/append":
      commandAppend(plugin, settings);
      break;
    case "/save":
      commandSave(plugin, settings);
      break;
    case "/c":
    case "/clear":
      removeMessageThread(plugin, 0);
      break;
    case "/s":
    case "/stop":
      commandStop();
      break;
    default:
      commandFalse(settings, plugin);
  }
}
async function commandFalse(settings, plugin) {
  const messageContainer = document.querySelector("#messageContainer");
  const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, "Command not recognized.");
  messageContainer.appendChild(botMessageDiv);
  await plugin.saveSettings();
}
function commandHelp(plugin, settings) {
  const commandBotMessage = `<h2>Commands</h2>
  <p><code>/model [MODEL-NAME] or [VALUE]</code> - List or change model.</p>
  <p><code>/profile [PROFILE-NAME] or [VALUE]</code> - List or change profile.</p>
  <p><code>/prompt [PROMPT-NAME] or [VALUE]</code> - List or change prompts.</p>
  <p><code>/prompt clear</code> - Clear prompt.</p>
  <p><code>/maxtokens [VALUE]</code> - Set max tokens.</p>
  <p><code>/temp [VALUE]</code> - Change temperature range from 0 to 2.</p>
  <p><code>/ref on | off</code> - Turn on or off "reference current note".</p>
  <p><code>/append</code> - Append current chat history to current active note.</p>
  <p><code>/save</code> - Save current chat history to a note.</p>
  <p><code>/clear</code> or <code>/c</code> - Clear chat history.</p>
  <p><code>/stop</code> or <code>/s</code> - [STREAMING MODELS ONLY]: Stop fetching response.</p>`;
  const messageContainer = document.querySelector("#messageContainer");
  const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
  messageContainer.appendChild(botMessageDiv);
}
async function commandModel(input, settings, plugin) {
  const messageContainer = document.querySelector("#messageContainer");
  if (!input.split(" ")[1]) {
    const modelListItems = settings.allModels.map((model) => `<li>${model}</li>`).join("");
    let currentModel = settings.general.model;
    if (!currentModel) {
      currentModel = "Empty";
    }
    const commandBotMessage = `<h2>Models</h2>
    <p><b>Current Model:</b> ${currentModel}</p>
    <ol>${modelListItems}</ol>`;
    const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
    messageContainer.appendChild(botMessageDiv);
  }
  if (input.split(" ")[1] !== void 0) {
    const inputModel = input.split(" ")[1].replace(/^"(.*)"$/, "$1");
    const modelAliases = {};
    for (let i = 1; i <= settings.allModels.length; i++) {
      const model = settings.allModels[i - 1];
      modelAliases[i] = model;
    }
    if (Object.entries(modelAliases).find(([key, val]) => key === inputModel)) {
      settings.general.model = modelAliases[inputModel];
      const commandBotMessage = `Updated Model to <b>${settings.general.model}</b>`;
      const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
      messageContainer.appendChild(botMessageDiv);
    } else if (Object.entries(modelAliases).find(([key, val]) => val === inputModel)) {
      settings.general.model = modelAliases[Object.keys(modelAliases).find((key) => modelAliases[key] === inputModel) || ""];
      const commandBotMessage = `Updated Model to <b>${settings.general.model}</b>`;
      const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
      messageContainer.appendChild(botMessageDiv);
    } else {
      const commandBotMessage = `Model '${inputModel}' does not exist for this API key.`;
      const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
      messageContainer.appendChild(botMessageDiv);
      new import_obsidian5.Notice("Invalid model.");
    }
    await plugin.saveSettings();
    return settings;
  }
}
async function commandProfile(input, settings, plugin) {
  const messageContainer = document.querySelector("#messageContainer");
  if (!settings.profiles.profileFolderPath) {
    new import_obsidian5.Notice("Profile folder path not set.");
    const commandBotMessage = "<p>Profile folder path not set.</p>";
    const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
    messageContainer.appendChild(botMessageDiv);
    return;
  }
  const files = plugin.app.vault.getFiles().filter((file) => file.path.startsWith(plugin.settings.profiles.profileFolderPath));
  files.sort((a, b) => a.name.localeCompare(b.name));
  if (!input.split(" ")[1]) {
    const fileListItems = files.map((file) => {
      const fileNameWithoutExtension = file.name.replace(/\.[^/.]+$/, "");
      return `<li>${fileNameWithoutExtension}</li>`;
    }).join("");
    let currentProfile = settings.profiles.profile.replace(/\.[^/.]+$/, "");
    if (!currentProfile) {
      currentProfile = "Empty";
    }
    const commandBotMessage = `<h2>Profiles</h2>
      <p><b>Current profile:</b> ${currentProfile}</p>
      <ol>${fileListItems}</ol>`;
    const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
    messageContainer.appendChild(botMessageDiv);
    return;
  }
  if (input.startsWith("/p") || input.startsWith("/prof") || input.startsWith("/profile") || input.startsWith("/profiles")) {
    let inputValue = input.split(" ").slice(1).join(" ").trim();
    if (inputValue.startsWith('"') && inputValue.endsWith('"') || inputValue.startsWith("'") && inputValue.endsWith("'")) {
      inputValue = inputValue.substring(1, inputValue.length - 1);
    }
    const profileAliases = {};
    for (let i = 1; i <= files.length; i++) {
      const fileNameWithoutExtension = files[i - 1].name.replace(/\.[^/.]+$/, "");
      profileAliases[i.toString().toLowerCase()] = fileNameWithoutExtension;
    }
    if (profileAliases[inputValue]) {
      plugin.settings.profiles.profile = profileAliases[inputValue] + ".md";
      const profileFilePath = plugin.settings.profiles.profileFolderPath + "/" + profileAliases[inputValue] + ".md";
      const currentProfile = plugin.app.vault.getAbstractFileByPath(profileFilePath);
      plugin.activateView();
      await updateSettingsFromFrontMatter(plugin, currentProfile);
      await plugin.saveSettings();
    } else if (Object.values(profileAliases).map((v) => v.toLowerCase()).includes(inputValue.toLowerCase())) {
      const matchedProfile = Object.entries(profileAliases).find(([key, value]) => value.toLowerCase() === inputValue.toLowerCase());
      if (matchedProfile) {
        plugin.settings.profiles.profile = matchedProfile[1] + ".md";
        const profileFilePath = plugin.settings.profiles.profileFolderPath + "/" + matchedProfile[1] + ".md";
        const currentProfile = plugin.app.vault.getAbstractFileByPath(profileFilePath);
        plugin.activateView();
        await updateSettingsFromFrontMatter(plugin, currentProfile);
        await plugin.saveSettings();
      }
    } else {
      addMessage(plugin, input, "userMessage", settings, messageHistory.length - 1);
      const commandBotMessage = `Profile '${inputValue}' does not exist.`;
      const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
      messageContainer.appendChild(botMessageDiv);
      const botMessages = messageContainer.querySelectorAll(".botMessage");
      const lastBotMessage = botMessages[botMessages.length - 1];
      lastBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
      new import_obsidian5.Notice("Invalid profile.");
    }
    await plugin.saveSettings();
    return settings;
  }
}
async function commandPrompt(input, settings, plugin) {
  const messageContainer = document.querySelector("#messageContainer");
  if (!settings.prompts.promptFolderPath) {
    new import_obsidian5.Notice("Prompt folder path not set.");
    const commandBotMessage = "<p>Prompt folder path not set.</p>";
    const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
    messageContainer.appendChild(botMessageDiv);
    return;
  }
  const files = plugin.app.vault.getFiles().filter((file) => file.path.startsWith(plugin.settings.prompts.promptFolderPath));
  files.sort((a, b) => a.name.localeCompare(b.name));
  if (!input.split(" ")[1]) {
    const fileListItems = files.map((file) => {
      const fileNameWithoutExtension = file.name.replace(/\.[^/.]+$/, "");
      return `<li>${fileNameWithoutExtension}</li>`;
    }).join("");
    let currentPrompt = settings.prompts.prompt;
    if (!currentPrompt) {
      currentPrompt = "Empty";
    }
    const commandBotMessage = `<h2>Prompts</h2>
      <p><b>Current prompt:</b> ${currentPrompt.replace(".md", "")}</p>
      <ol>${fileListItems}</ol>`;
    const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
    messageContainer.appendChild(botMessageDiv);
    return;
  }
  if (input.startsWith("/prompt")) {
    let inputValue = input.split(" ").slice(1).join(" ").trim();
    if (inputValue.startsWith('"') && inputValue.endsWith('"') || inputValue.startsWith("'") && inputValue.endsWith("'")) {
      inputValue = inputValue.substring(1, inputValue.length - 1);
    }
    if (inputValue === "clear" || inputValue === "c") {
      settings.prompts.prompt = "";
      const commandBotMessage = "Prompt cleared.";
      const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
      messageContainer.appendChild(botMessageDiv);
      await plugin.saveSettings();
      return settings;
    }
    const promptAliases = {};
    for (let i = 1; i <= files.length; i++) {
      const fileNameWithoutExtension = files[i - 1].name.replace(/\.[^/.]+$/, "");
      promptAliases[i.toString()] = fileNameWithoutExtension;
    }
    let currentModel;
    if (promptAliases[inputValue]) {
      settings.prompts.prompt = promptAliases[inputValue] + ".md";
      currentModel = settings.prompts.prompt.replace(/\.[^/.]+$/, "");
      const commandBotMessage = `<b>Updated Prompt to</b> '${currentModel}'`;
      const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
      messageContainer.appendChild(botMessageDiv);
    } else if (Object.values(promptAliases).map((v) => v.toLowerCase()).includes(inputValue.toLowerCase())) {
      const matchedProfile = Object.entries(promptAliases).find(([key, value]) => value.toLowerCase() === inputValue.toLowerCase());
      if (matchedProfile) {
        settings.prompts.prompt = matchedProfile[1] + ".md";
        currentModel = settings.prompts.prompt.replace(/\.[^/.]+$/, "");
        const commandBotMessage = `<b>Updated Prompt to</b> '${currentModel}'`;
        const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
        messageContainer.appendChild(botMessageDiv);
      }
    } else {
      const commandBotMessage = `Prompt '${inputValue}' does not exist.`;
      const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
      messageContainer.appendChild(botMessageDiv);
      new import_obsidian5.Notice("Invalid prompt.");
    }
    await plugin.saveSettings();
    return settings;
  }
}
async function commandReference(input, settings, plugin) {
  var _a2;
  let commandBotMessage = "";
  const referenceCurrentNoteElement = document.getElementById("referenceCurrentNote");
  const inputValue = (_a2 = input.split(" ")[1]) == null ? void 0 : _a2.toLowerCase();
  if (inputValue === "true" || inputValue === "on") {
    settings.general.allowReferenceCurrentNote = true;
    if (referenceCurrentNoteElement) {
      referenceCurrentNoteElement.style.display = "block";
    }
    commandBotMessage += "<p><strong>Reference updated: on</strong></p>";
  } else if (inputValue === "false" || inputValue === "off") {
    settings.general.allowReferenceCurrentNote = false;
    if (referenceCurrentNoteElement) {
      referenceCurrentNoteElement.style.display = "none";
    }
    commandBotMessage += "<p><strong>Reference updated: off</strong></p>";
  } else {
    commandBotMessage += "<p><strong>Type `/ref on` or `/ref off` to turn on/off reference current note.</strong></p>";
  }
  const messageContainer = document.querySelector("#messageContainer");
  const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
  messageContainer.appendChild(botMessageDiv);
  await plugin.saveSettings();
}
async function commandTemperature(input, settings, plugin) {
  const inputValue = input.split(" ")[1];
  const floatValue = parseFloat(inputValue);
  let temperatureSettingMessage;
  if (settings && !isNaN(floatValue)) {
    if (floatValue < 0) {
      settings.general.temperature = "0.00";
    } else if (floatValue > 2) {
      settings.general.temperature = "2.00";
    } else {
      settings.general.temperature = floatValue.toFixed(2);
    }
    temperatureSettingMessage = `Temperature updated: ${settings.general.temperature}`;
  } else {
    temperatureSettingMessage = `Current temperature: ${settings.general.temperature}`;
  }
  const commandBotMessage = `<p><strong>${temperatureSettingMessage}</strong></p>`;
  const messageContainer = document.querySelector("#messageContainer");
  const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
  messageContainer.appendChild(botMessageDiv);
  await plugin.saveSettings();
}
async function commandMaxTokens(input, settings, plugin) {
  let commandBotMessage = "";
  const commandParts = input.split(" ");
  const commandAction = commandParts[1] ? commandParts[1].toLowerCase() : "";
  let maxTokensSettingMessage;
  if (commandAction === "c" || commandAction === "clear") {
    settings.general.max_tokens = "";
    maxTokensSettingMessage = "Max tokens cleared.";
  } else if (commandAction !== "") {
    const inputValue = parseInt(commandAction);
    if (!isNaN(inputValue) && inputValue >= 0) {
      settings.general.max_tokens = inputValue.toString();
      maxTokensSettingMessage = `Max tokens updated: ${inputValue}`;
    } else {
      maxTokensSettingMessage = "Max tokens update: invalid";
    }
  } else {
    if (settings.general.max_tokens === "") {
      maxTokensSettingMessage = "Current max tokens: Empty";
    } else {
      maxTokensSettingMessage = `Current max tokens: ${settings.general.max_tokens}`;
    }
  }
  commandBotMessage += `<p><strong>${maxTokensSettingMessage}</strong></p>`;
  const messageContainer = document.querySelector("#messageContainer");
  const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
  messageContainer.appendChild(botMessageDiv);
  await plugin.saveSettings();
}
async function commandAppend(plugin, settings) {
  let markdownContent = "";
  const activeFile = plugin.app.workspace.getActiveFile();
  if ((activeFile == null ? void 0 : activeFile.extension) === "md") {
    const existingContent = await plugin.app.vault.read(activeFile);
    const userNames = document.querySelectorAll(".userName");
    let userNameText = "USER";
    if (userNames.length > 0) {
      const userNameNode = userNames[0];
      Array.from(userNameNode.childNodes).forEach((node) => {
        if (node.nodeType === Node.TEXT_NODE && node.textContent) {
          userNameText = node.textContent.trim().toUpperCase();
        }
      });
    }
    const chatbotNames = document.querySelectorAll(".chatbotName");
    const chatbotNameText = chatbotNames.length > 0 && chatbotNames[0].textContent ? chatbotNames[0].textContent.toUpperCase() : "ASSISTANT";
    if (await this.app.vault.adapter.exists(filenameMessageHistoryJSON(plugin))) {
      try {
        const jsonContent = await this.app.vault.adapter.read(filenameMessageHistoryJSON(plugin));
        const messages = JSON.parse(jsonContent);
        let skipNext = false;
        markdownContent += messages.filter((messageHistory2, index, array) => {
          if (skipNext && messageHistory2.role === "assistant") {
            skipNext = false;
            return false;
          }
          if (messageHistory2.content.startsWith("/") || messageHistory2.content.includes("errorBotMessage")) {
            skipNext = index + 1 < array.length && array[index + 1].role === "assistant" || messageHistory2.role === "assistant";
            return false;
          }
          return true;
        }).map((message) => {
          let roleText = message.role.toUpperCase();
          roleText = roleText === "USER" ? userNameText : roleText;
          roleText = roleText === "ASSISTANT" ? chatbotNameText : roleText;
          return `###### ${roleText}
${message.content}
`;
        }).join("\n");
        const commandBotMessage = "<p><strong>Message history appended.</strong></p>";
        const messageContainer = document.querySelector("#messageContainer");
        const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
        messageContainer.appendChild(botMessageDiv);
      } catch (error) {
        const messageContainer = document.querySelector("#messageContainer");
        const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, error);
        messageContainer.appendChild(botMessageDiv);
        console.error("Error processing message history:", error);
      }
    }
    const updatedContent = existingContent + "\n" + markdownContent;
    await plugin.app.vault.modify(activeFile, updatedContent);
    new import_obsidian5.Notice("Appended conversation.");
  } else {
    new import_obsidian5.Notice("No active Markdown file detected.");
  }
}
async function commandSave(plugin, settings) {
  let folderName = settings.chatHistory.chatHistoryPath;
  if (!await plugin.app.vault.adapter.exists(folderName)) {
    await plugin.app.vault.createFolder(folderName);
  }
  const baseFileName = "Chat History";
  const fileExtension = ".md";
  if (folderName && !folderName.endsWith("/")) {
    folderName += "/";
  }
  const now = new Date();
  const dateTimeStamp = now.getFullYear() + "-" + (now.getMonth() + 1).toString().padStart(2, "0") + "-" + now.getDate().toString().padStart(2, "0") + " " + now.getHours().toString().padStart(2, "0") + "-" + now.getMinutes().toString().padStart(2, "0") + "-" + now.getSeconds().toString().padStart(2, "0");
  try {
    let markdownContent = "";
    const allFiles = plugin.app.vault.getFiles();
    const modelNameElement = document.querySelector("#modelName");
    let modelName = "Unknown";
    if (modelNameElement && modelNameElement.textContent) {
      modelName = modelNameElement.textContent.replace("Model: ", "").toLowerCase();
    }
    const templateFile = allFiles.find((file2) => file2.path.toLowerCase() === settings.chatHistory.templateFilePath.toLowerCase());
    if (templateFile) {
      let fileContent = await plugin.app.vault.read(templateFile);
      if (/^---\s*[\s\S]*?---/.test(fileContent)) {
        fileContent = fileContent.replace(/^---/, `---
model: ${modelName}`);
      } else {
        fileContent = `---
  model: ${modelName}
---
` + fileContent;
      }
      markdownContent += fileContent;
    } else {
      markdownContent += `---
  model: ${modelName}
---
`;
    }
    const userNames = document.querySelectorAll(".userName");
    let userNameText = "USER";
    if (userNames.length > 0) {
      const userNameNode = userNames[0];
      Array.from(userNameNode.childNodes).forEach((node) => {
        if (node.nodeType === Node.TEXT_NODE && node.textContent) {
          userNameText = node.textContent.trim().toUpperCase();
        }
      });
    }
    const chatbotNames = document.querySelectorAll(".chatbotName");
    const chatbotNameText = chatbotNames.length > 0 && chatbotNames[0].textContent ? chatbotNames[0].textContent.toUpperCase() : "ASSISTANT";
    if (await plugin.app.vault.adapter.exists(filenameMessageHistoryJSON(plugin))) {
      try {
        const jsonContent = await plugin.app.vault.adapter.read(filenameMessageHistoryJSON(plugin));
        const messages = JSON.parse(jsonContent);
        let skipNext = false;
        markdownContent += messages.filter((messageHistory2, index, array) => {
          if (skipNext && messageHistory2.role === "assistant") {
            skipNext = false;
            return false;
          }
          if (messageHistory2.content.startsWith("/") || messageHistory2.content.includes("errorBotMessage")) {
            skipNext = index + 1 < array.length && array[index + 1].role === "assistant" || messageHistory2.role === "assistant";
            return false;
          }
          return true;
        }).map((message) => {
          let roleText = message.role.toUpperCase();
          roleText = roleText === "USER" ? userNameText : roleText;
          roleText = roleText === "ASSISTANT" ? chatbotNameText : roleText;
          return `###### ${roleText}
${message.content}
`;
        }).join("\n");
        const commandBotMessage = "<p><strong>Message history saved.</strong></p>";
        const messageContainer = document.querySelector("#messageContainer");
        const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, commandBotMessage);
        messageContainer.appendChild(botMessageDiv);
      } catch (error) {
        const messageContainer = document.querySelector("#messageContainer");
        const botMessageDiv = displayCommandBotMessage(plugin, settings, messageHistory, error);
        messageContainer.appendChild(botMessageDiv);
        console.error("Error processing message history:", error);
      }
    }
    let fileName = "";
    if (settings.chatHistory.allowRenameNoteTitle) {
      let uniqueNameFound = false;
      let modelRenameTitle;
      const fileNameExists = (name) => {
        return allFiles.some((file2) => file2.path === folderName + name + fileExtension);
      };
      while (!uniqueNameFound) {
        modelRenameTitle = await fetchModelRenameTitle(settings, markdownContent);
        if (!fileNameExists(modelRenameTitle)) {
          uniqueNameFound = true;
        }
      }
      fileName = folderName + modelRenameTitle + fileExtension;
    } else {
      fileName = folderName + baseFileName + " " + dateTimeStamp + fileExtension;
    }
    const file = await plugin.app.vault.create(fileName, markdownContent);
    if (file) {
      new import_obsidian5.Notice("Saved conversation.");
      plugin.app.workspace.openLinkText(fileName, "", true, { active: true });
    }
  } catch (error) {
    console.error("Failed to create note:", error);
  }
}
function commandStop() {
  const controller = getAbortController();
  if (controller) {
    controller.abort();
  }
}
async function removeMessageThread(plugin, index) {
  const messageContainer = document.querySelector("#messageContainer");
  const divElements = messageContainer == null ? void 0 : messageContainer.querySelectorAll("div.botMessage, div.userMessage");
  if (divElements && divElements.length > 0 && index >= 0 && index < divElements.length) {
    for (let i = index; i < divElements.length; i++) {
      messageContainer == null ? void 0 : messageContainer.removeChild(divElements[i]);
    }
  }
  messageHistory.splice(index);
  const jsonString = JSON.stringify(messageHistory, null, 4);
  try {
    await plugin.app.vault.adapter.write(filenameMessageHistoryJSON(plugin), jsonString);
  } catch (error) {
    console.error("Error writing messageHistory.json", error);
  }
}

// src/components/chat/UserMessage.ts
function displayUserMessage(plugin, settings, message) {
  const trimmedMessage = message.trim();
  const userMessageDiv = document.createElement("div");
  userMessageDiv.className = "userMessage";
  userMessageDiv.style.backgroundColor = colorToHex(settings.appearance.userMessageBackgroundColor || getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.userMessageBackgroundColor).trim());
  userMessageDiv.style.color = settings.appearance.userMessageFontColor || DEFAULT_SETTINGS.appearance.userMessageFontColor;
  const userMessageToolBarDiv = document.createElement("div");
  userMessageToolBarDiv.className = "userMessageToolBar";
  const buttonContainerDiv = document.createElement("div");
  buttonContainerDiv.className = "button-container";
  const userNameSpan = document.createElement("span");
  userNameSpan.className = "userName";
  userNameSpan.textContent = settings.appearance.userName || DEFAULT_SETTINGS.appearance.userName;
  userMessageToolBarDiv.appendChild(userNameSpan);
  userMessageToolBarDiv.appendChild(buttonContainerDiv);
  const userPre = document.createElement("pre");
  const preUserMessage = document.createElement("span");
  preUserMessage.className = "preUserMessage";
  userPre.appendChild(preUserMessage);
  preUserMessage.innerHTML = trimmedMessage;
  const regenerateButton = regenerateUserButton(plugin, settings);
  const editButton = displayUserEditButton(plugin, settings, userPre);
  const copyUserButton = displayUserCopyButton(userPre);
  const trashButton = displayTrashButton(plugin);
  if (!message.startsWith("/")) {
    buttonContainerDiv.appendChild(regenerateButton);
    buttonContainerDiv.appendChild(editButton);
  }
  buttonContainerDiv.appendChild(copyUserButton);
  buttonContainerDiv.appendChild(trashButton);
  userMessageDiv.appendChild(userMessageToolBarDiv);
  userMessageDiv.appendChild(userPre);
  return userMessageDiv;
}

// src/view.ts
var VIEW_TYPE_CHATBOT = "chatbot-view";
var ANTHROPIC_MODELS = ["claude-instant-1.2", "claude-2.0", "claude-2.1", "claude-3-opus-20240229", "claude-3-sonnet-20240229"];
var OPENAI_MODELS = ["gpt-3.5-turbo", "gpt-3.5-turbo-1106", "gpt-4", "gpt-4-turbo-preview"];
function filenameMessageHistoryJSON(plugin) {
  const filenameMessageHistoryPath = "./.obsidian/plugins/bmo-chatbot/data/";
  const currentProfileMessageHistory = "messageHistory_" + plugin.settings.profiles.profile.replace(".md", ".json");
  return filenameMessageHistoryPath + currentProfileMessageHistory;
}
var messageHistory = [];
var lastCursorPosition = {
  line: 0,
  ch: 0
};
var lastCursorPositionFile = null;
var activeEditor = null;
var BMOView = class extends import_obsidian6.ItemView {
  constructor(leaf, settings, plugin) {
    super(leaf);
    this.preventEnter = false;
    this.settings = settings;
    this.plugin = plugin;
    this.icon = "bot";
    this.addCursorLogging();
  }
  getViewType() {
    return VIEW_TYPE_CHATBOT;
  }
  getDisplayText() {
    return "BMO Chatbot";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    const chatbotContainer = container.createEl("div", {
      attr: {
        class: "chatbotContainer"
      }
    });
    const header = chatbotContainer.createEl("div", {
      attr: {
        id: "header"
      }
    });
    const chatbotNameHeading = chatbotContainer.createEl("h1", {
      text: this.settings.appearance.chatbotName || DEFAULT_SETTINGS.appearance.chatbotName,
      attr: {
        id: "chatbotNameHeading"
      }
    });
    const modelName = chatbotContainer.createEl("p", {
      text: "Model: " + this.settings.general.model || DEFAULT_SETTINGS.general.model,
      attr: {
        id: "modelName"
      }
    });
    const spanElement = chatbotContainer.createEl("span", {
      attr: {
        class: "dotIndicator",
        id: "markDownBoolean"
      }
    });
    const referenceCurrentNoteElement = chatbotContainer.createEl("p", {
      text: "Reference Current Note",
      attr: {
        id: "referenceCurrentNote"
      }
    });
    header.appendChild(chatbotNameHeading);
    header.appendChild(modelName);
    referenceCurrentNoteElement.appendChild(spanElement);
    referenceCurrentNoteElement.style.display = "none";
    if (referenceCurrentNoteElement) {
      if (this.settings.general.allowReferenceCurrentNote) {
        referenceCurrentNoteElement.style.display = "block";
      } else {
        referenceCurrentNoteElement.style.display = "none";
      }
    }
    const messageContainer = chatbotContainer.createEl("div", {
      attr: {
        id: "messageContainer"
      }
    });
    if (this.settings.appearance.allowHeader) {
      header.style.display = "block";
    } else {
      header.style.display = "none";
      messageContainer.style.maxHeight = "calc(100% - 60px)";
      referenceCurrentNoteElement.style.margin = "0.5rem 0 0.5rem 0";
    }
    await loadData(this.plugin);
    messageContainer.id = "messageContainer";
    messageHistory.forEach(async (messageData) => {
      if (messageData.role == "user") {
        const userMessageDiv = displayUserMessage(this.plugin, this.settings, messageData.content);
        messageContainer.appendChild(userMessageDiv);
      }
      if (messageData.role == "assistant") {
        const botMessageDiv = displayBotMessage(this.plugin, this.settings, messageHistory, messageData.content);
        messageContainer.appendChild(botMessageDiv);
      }
    });
    messageContainer.addEventListener("click", (event) => {
      const target = event.target;
      if (target.tagName === "A" && target.classList.contains("internal-link")) {
        const link = target;
        const linkName = link.getAttribute("data-href") || "";
        this.plugin.app.workspace.openLinkText(linkName, "", false);
      }
    });
    const parentElement = document.getElementById("parentElementId");
    parentElement == null ? void 0 : parentElement.appendChild(messageContainer);
    const chatbox = chatbotContainer.createEl("div", {
      attr: {
        class: "chatbox"
      }
    });
    const textarea = document.createElement("textarea");
    textarea.setAttribute("contenteditable", true.toString());
    textarea.setAttribute("placeholder", "Start typing...");
    if (textarea) {
      textarea.style.color = this.settings.appearance.chatBoxFontColor;
      const style = document.createElement("style");
      style.textContent = `
                .chatbox textarea::placeholder {
                    color: ${this.settings.appearance.chatBoxFontColor} !important;
                }
            `;
      textarea.appendChild(style);
    }
    chatbotContainer.style.backgroundColor = this.settings.appearance.chatbotContainerBackgroundColor || DEFAULT_SETTINGS.appearance.chatbotContainerBackgroundColor;
    messageContainer.style.backgroundColor = this.settings.appearance.messageContainerBackgroundColor || DEFAULT_SETTINGS.appearance.messageContainerBackgroundColor;
    textarea.style.backgroundColor = this.settings.appearance.chatBoxBackgroundColor || DEFAULT_SETTINGS.appearance.chatBoxBackgroundColor;
    textarea.style.borderColor = this.settings.appearance.chatBoxBackgroundColor || DEFAULT_SETTINGS.appearance.chatBoxBackgroundColor;
    textarea.style.color = this.settings.appearance.chatBoxFontColor || DEFAULT_SETTINGS.appearance.chatBoxFontColor;
    chatbox.style.backgroundColor = this.settings.appearance.chatBoxBackgroundColor || DEFAULT_SETTINGS.appearance.chatBoxBackgroundColor;
    const userMessages = messageContainer.querySelectorAll(".userMessage");
    userMessages.forEach((userMessage) => {
      userMessage.style.color = this.settings.appearance.userMessageFontColor || DEFAULT_SETTINGS.appearance.userMessageFontColor;
    });
    const botMessages = messageContainer.querySelectorAll(".botMessage");
    botMessages.forEach((botMessage) => {
      botMessage.style.color = this.settings.appearance.botMessageFontColor || DEFAULT_SETTINGS.appearance.botMessageFontColor;
    });
    chatbox.appendChild(textarea);
    this.textareaElement = textarea;
    this.addEventListeners();
    messageContainer.scrollTop = messageContainer.scrollHeight;
  }
  addEventListeners() {
    this.textareaElement.addEventListener("keyup", this.handleKeyup.bind(this));
    this.textareaElement.addEventListener("keydown", this.handleKeydown.bind(this));
    this.textareaElement.addEventListener("input", this.handleInput.bind(this));
    this.textareaElement.addEventListener("blur", this.handleBlur.bind(this));
  }
  async handleKeyup(event) {
    const input = this.textareaElement.value;
    const index = messageHistory.length - 1;
    if (this.settings.OllamaConnection.allowStream || this.settings.RESTAPIURLConnection.allowStream || this.settings.APIConnections.mistral.allowStream || this.settings.APIConnections.openAI.allowStream) {
      if ((input === "/s" || input === "/stop") && event.key === "Enter") {
        this.preventEnter = false;
        await executeCommand(input, this.settings, this.plugin);
      }
    }
    if (this.preventEnter === false && !event.shiftKey && event.key === "Enter") {
      loadData(this.plugin);
      event.preventDefault();
      if (input.length === 0) {
        return;
      }
      if (!input.includes("/c") && !input.includes("/clear") && !input.startsWith("/p ") && !input.startsWith("/prof ") && !input.startsWith("/profile ") && !input.startsWith("/profiles ") && !input.includes("/s") && !input.includes("/stop")) {
        addMessage(this.plugin, input, "userMessage", this.settings, index);
      }
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const userMessageDiv = displayUserMessage(this.plugin, this.settings, input);
        messageContainer.appendChild(userMessageDiv);
        if (input.startsWith("/")) {
          executeCommand(input, this.settings, this.plugin);
          if (!input.includes("/c") && !input.includes("/clear") && (input === "/prof" || input === "/p" || input === "/profile" || input === "/profiles" || input === "/prompt" || input === "/prompts" || input.startsWith("/prompt ") || input.startsWith("/prompts ")) && !input.includes("/s") && !input.includes("/stop")) {
            const botMessages = messageContainer.querySelectorAll(".botMessage");
            const lastBotMessage = botMessages[botMessages.length - 1];
            lastBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
          }
          const modelName = document.querySelector("#modelName");
          if (modelName) {
            modelName.textContent = "Model: " + this.settings.general.model.toLowerCase();
          }
        } else {
          this.preventEnter = true;
          this.BMOchatbot().then(() => {
            this.preventEnter = false;
          }).catch(() => {
            const messageContainer2 = document.querySelector("#messageContainer");
            const botMessageDiv = displayErrorBotMessage(this.plugin, this.settings, messageHistory, "Oops, something went wrong. Please try again.");
            messageContainer2.appendChild(botMessageDiv);
          });
        }
      }
      this.textareaElement.value = "";
      this.textareaElement.style.height = "29px";
      this.textareaElement.value = this.textareaElement.value.trim();
      this.textareaElement.setSelectionRange(0, 0);
    }
  }
  handleKeydown(event) {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
    }
  }
  handleInput(event) {
    this.textareaElement.style.height = "29px";
    this.textareaElement.style.height = this.textareaElement.scrollHeight + "px";
  }
  handleBlur(event) {
    if (!this.textareaElement.value) {
      this.textareaElement.style.height = "29px";
    }
  }
  exportSettings() {
    return this.settings;
  }
  addCursorLogging() {
    const updateCursorPosition = async () => {
      await getActiveFileContent(this.plugin, this.settings);
      const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      if (view) {
        const cursor = view.editor.getCursor();
        lastCursorPositionFile = this.plugin.app.workspace.getActiveFile();
        if (cursor != null && this.plugin.app.workspace.activeEditor != null) {
          lastCursorPosition = cursor;
          activeEditor = view.editor;
        }
        const modelName = document.querySelector("#modelName");
        if (modelName) {
          modelName.textContent = "Model: " + this.plugin.settings.general.model;
        }
      }
    };
    activeWindow.addEventListener("click", updateCursorPosition);
    activeWindow.addEventListener("keyup", updateCursorPosition);
    activeWindow.addEventListener("keydown", updateCursorPosition);
    activeWindow.addEventListener("input", updateCursorPosition);
  }
  cleanup() {
    this.textareaElement.removeEventListener("keyup", this.handleKeyup.bind(this));
    this.textareaElement.addEventListener("keydown", this.handleKeydown.bind(this));
    this.textareaElement.removeEventListener("input", this.handleInput.bind(this));
    this.textareaElement.removeEventListener("blur", this.handleBlur.bind(this));
  }
  async BMOchatbot() {
    await getActiveFileContent(this.plugin, this.settings);
    const index = messageHistory.length - 1;
    if (this.settings.general.model === "") {
      const errorMessage = "Model not found.";
      const messageContainer = document.querySelector("#messageContainer");
      const botMessageDiv = displayErrorBotMessage(this.plugin, this.settings, messageHistory, errorMessage);
      messageContainer.appendChild(botMessageDiv);
      const botMessages = messageContainer.querySelectorAll(".botMessage");
      const lastBotMessage = botMessages[botMessages.length - 1];
      lastBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    } else {
      if (this.settings.OllamaConnection.ollamaModels.includes(this.settings.general.model)) {
        if (this.settings.OllamaConnection.allowStream) {
          await fetchOllamaResponseStream(this.plugin, this.settings, index);
        } else {
          await fetchOllamaResponse(this.plugin, this.settings, index);
        }
      } else if (this.settings.RESTAPIURLConnection.RESTAPIURLModels.includes(this.settings.general.model)) {
        if (this.settings.RESTAPIURLConnection.allowStream) {
          await fetchRESTAPIURLResponseStream(this.plugin, this.settings, index);
        } else {
          await fetchRESTAPIURLResponse(this.plugin, this.settings, index);
        }
      } else if (ANTHROPIC_MODELS.includes(this.settings.general.model)) {
        await fetchAnthropicResponse(this.plugin, this.settings, index);
      } else if (this.settings.APIConnections.mistral.mistralModels.includes(this.settings.general.model)) {
        if (this.settings.APIConnections.mistral.allowStream) {
          await fetchMistralResponseStream(this.plugin, this.settings, index);
        } else {
          await fetchMistralResponse(this.plugin, this.settings, index);
        }
      } else if (this.settings.APIConnections.googleGemini.geminiModels.includes(this.settings.general.model)) {
        await fetchGoogleGeminiResponse(this.plugin, this.settings, index);
      } else if (this.settings.APIConnections.openAI.openAIBaseModels.includes(this.settings.general.model)) {
        if (this.settings.APIConnections.openAI.allowStream) {
          await fetchOpenAIAPIResponseStream(this.plugin, this.settings, index);
        } else {
          await fetchOpenAIAPIResponse(this.plugin, this.settings, index);
        }
      } else if (this.settings.APIConnections.openRouter.openRouterModels.includes(this.settings.general.model)) {
        if (this.settings.APIConnections.openRouter.allowStream) {
          await fetchOpenRouterResponseStream(this.plugin, this.settings, index);
        } else {
          await fetchOpenRouterResponse(this.plugin, this.settings, index);
        }
      } else {
        const errorMessage = "Connection not found.";
        const messageContainer = document.querySelector("#messageContainer");
        const botMessageDiv = displayErrorBotMessage(this.plugin, this.settings, messageHistory, errorMessage);
        messageContainer.appendChild(botMessageDiv);
        const botMessages = messageContainer.querySelectorAll(".botMessage");
        const lastBotMessage = botMessages[botMessages.length - 1];
        lastBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }
  }
  async onClose() {
  }
};
async function loadData(plugin) {
  if (!await plugin.app.vault.adapter.exists("./.obsidian/plugins/bmo-chatbot/data/")) {
    plugin.app.vault.adapter.mkdir("./.obsidian/plugins/bmo-chatbot/data/");
  }
  if (await plugin.app.vault.adapter.exists(filenameMessageHistoryJSON(plugin))) {
    try {
      const fileContent = await plugin.app.vault.adapter.read(filenameMessageHistoryJSON(plugin));
      if (fileContent.trim() === "") {
        messageHistory = [];
      } else {
        messageHistory = JSON.parse(fileContent);
      }
    } catch (error) {
      console.error("Error processing message history:", error);
    }
  } else {
    messageHistory = [];
  }
}

// src/settings.ts
var import_obsidian22 = require("obsidian");

// src/components/settings/GeneralSettings.ts
var import_obsidian8 = require("obsidian");

// src/components/FetchModelList.ts
var import_obsidian7 = require("obsidian");
async function fetchOllamaModels(plugin) {
  const ollamaRESTAPIURL = plugin.settings.OllamaConnection.RESTAPIURL;
  try {
    new URL(ollamaRESTAPIURL);
  } catch (error) {
    return;
  }
  try {
    const response = await (0, import_obsidian7.requestUrl)({
      url: ollamaRESTAPIURL + "/api/tags",
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    const jsonData = response.json;
    const models = jsonData.models.map((model) => model.name);
    plugin.settings.OllamaConnection.ollamaModels = models;
    return models;
  } catch (error) {
    console.error(error);
  }
}
async function fetchRESTAPIURLModels(plugin) {
  const RESTAPIURL = plugin.settings.RESTAPIURLConnection.RESTAPIURL;
  try {
    new URL(RESTAPIURL);
  } catch (error) {
    console.error("Invalid REST API URL:", RESTAPIURL);
    return;
  }
  try {
    const response = await (0, import_obsidian7.requestUrl)({
      url: RESTAPIURL + "/models",
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${plugin.settings.RESTAPIURLConnection.APIKey}`
      }
    });
    if (response.json && (response.json.data || Array.isArray(response.json))) {
      let models;
      if (Array.isArray(response.json)) {
        models = response.json.map((model) => model.id);
      } else {
        models = response.json.data.map((model) => model.id);
      }
      plugin.settings.RESTAPIURLConnection.RESTAPIURLModels = models;
      return models;
    }
  } catch (error) {
    console.error("Error making API request:", error);
    throw error;
  }
}
async function fetchGoogleGeminiModels(plugin) {
  try {
    const API_KEY = plugin.settings.APIConnections.googleGemini.APIKey;
    const response = await (0, import_obsidian7.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1beta/models?key=${API_KEY}`,
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (response.json && response.json.models) {
      const models = response.json.models.map((model) => model.name).filter((model) => model.endsWith("models/gemini-pro"));
      plugin.settings.APIConnections.googleGemini.geminiModels = models;
      return models;
    }
  } catch (error) {
    console.error(error);
  }
}
async function fetchMistralModels(plugin) {
  try {
    const response = await (0, import_obsidian7.requestUrl)({
      url: "https://api.mistral.ai/v1/models",
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${plugin.settings.APIConnections.mistral.APIKey}`
      }
    });
    if (response.json && response.json.data) {
      const models = response.json.data.map((model) => model.id);
      plugin.settings.APIConnections.mistral.mistralModels = models;
      return models;
    }
  } catch (error) {
    console.error(error);
  }
}
async function fetchOpenAIBaseModels(plugin) {
  const openai = new openai_default({
    apiKey: plugin.settings.APIConnections.openAI.APIKey,
    baseURL: plugin.settings.APIConnections.openAI.openAIBaseUrl,
    dangerouslyAllowBrowser: true
    // apiKey is stored within data.json
  });
  const list = await openai.models.list();
  if (openai.baseURL == "https://api.openai.com/v1") {
    plugin.settings.APIConnections.openAI.openAIBaseModels = OPENAI_MODELS;
    return OPENAI_MODELS;
  } else {
    const models = list.data.map((model) => model.id);
    plugin.settings.APIConnections.openAI.openAIBaseModels = models;
    return models;
  }
}
async function fetchOpenRouterModels(plugin) {
  try {
    const response = await (0, import_obsidian7.requestUrl)({
      url: "https://openrouter.ai/api/v1/models",
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${plugin.settings.APIConnections.openRouter.APIKey}`
      }
    });
    if (response.json && (response.json.data || Array.isArray(response.json))) {
      let models;
      if (Array.isArray(response.json)) {
        models = response.json.map((model) => model.id);
      } else {
        models = response.json.data.map((model) => model.id);
      }
      plugin.settings.APIConnections.openRouter.openRouterModels = models;
      return models;
    }
  } catch (error) {
    console.error("Error making API request:", error);
    throw error;
  }
}

// src/components/settings/GeneralSettings.ts
async function addGeneralSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "General" });
  const initialState = plugin.settings.toggleGeneralSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian8.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian8.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleGeneralSettings = false;
    } else {
      (0, import_obsidian8.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleGeneralSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian8.Setting(settingsContainer).setName("Model").setDesc("Choose a model.").addDropdown(async (dropdown) => {
    await populateDropdownWithModels(plugin, dropdown);
    dropdown.setValue(plugin.settings.general.model).onChange(async (value) => {
      plugin.settings.general.model = value;
      await plugin.saveSettings();
      const modelName = document.querySelector("#modelName");
      if (modelName) {
        modelName.textContent = "model: " + plugin.settings.general.model.toLowerCase();
      }
    });
  });
  new import_obsidian8.Setting(settingsContainer).setName("Max Tokens").setDesc(descLink("The maximum number of tokens, or words, that the model is allowed to generate in its output.", "https://platform.openai.com/tokenizer")).addText(
    (text) => text.setPlaceholder("4096").setValue(plugin.settings.general.max_tokens).onChange(async (value) => {
      plugin.settings.general.max_tokens = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian8.Setting(settingsContainer).setName("Temperature").setDesc("Temperature controls how random the generated output is. Lower values make the text more predictable, while higher values make it more creative and unpredictable.").addText(
    (text) => text.setPlaceholder("1.00").setValue(plugin.settings.general.temperature).onChange(async (value) => {
      const floatValue = parseFloat(value);
      if (!isNaN(floatValue)) {
        if (!isNaN(floatValue)) {
          if (floatValue < 0) {
            plugin.settings.general.temperature = "0.00";
          } else if (floatValue > 2) {
            plugin.settings.general.temperature = "2.00";
          } else {
            plugin.settings.general.temperature = floatValue.toFixed(2);
          }
        } else {
          plugin.settings.general.temperature = DEFAULT_SETTINGS.general.temperature;
        }
      } else {
        plugin.settings.general.temperature = DEFAULT_SETTINGS.general.temperature;
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian8.Setting(settingsContainer).setName("Allow Reference Current Note").setDesc("Allow chatbot to reference current active note during conversation.").addToggle(
    (toggle) => toggle.setValue(plugin.settings.general.allowReferenceCurrentNote).onChange((value) => {
      plugin.settings.general.allowReferenceCurrentNote = value;
      plugin.saveSettings();
      const referenceCurrentNoteElement = document.getElementById("referenceCurrentNote");
      if (referenceCurrentNoteElement) {
        if (value) {
          referenceCurrentNoteElement.style.display = "block";
        } else {
          referenceCurrentNoteElement.style.display = "none";
        }
      }
    })
  );
  function descLink(text, link) {
    const frag = new DocumentFragment();
    const desc = document.createElement("span");
    desc.innerText = text + " ";
    frag.appendChild(desc);
    const anchor = document.createElement("a");
    anchor.href = link;
    anchor.target = "_blank";
    anchor.rel = "noopener noreferrer";
    anchor.innerText = "(https://platform.openai.com/tokenizer)";
    frag.appendChild(anchor);
    return frag;
  }
}
async function populateDropdownWithModels(plugin, dropdown) {
  plugin.settings.allModels = [];
  async function fetchModels(sourceType) {
    switch (sourceType) {
      case "ollama":
        return await fetchOllamaModels(plugin);
      case "RESTAPIURL":
        return await fetchRESTAPIURLModels(plugin);
      case "anthropic":
        return ANTHROPIC_MODELS;
      case "googleGemini":
        return await fetchGoogleGeminiModels(plugin);
      case "mistral":
        return await fetchMistralModels(plugin);
      case "openAI":
        return await fetchOpenAIBaseModels(plugin);
      case "openRouter":
        return await fetchOpenRouterModels(plugin);
      default:
        return [];
    }
  }
  function addModelsToDropdownAndList(models) {
    models.forEach((model) => {
      dropdown.addOption(model, model);
      if (!plugin.settings.allModels.includes(model)) {
        plugin.settings.allModels.push(model);
      }
    });
  }
  const modelSources = [
    { type: "ollama", condition: plugin.settings.OllamaConnection.RESTAPIURL },
    { type: "RESTAPIURL", condition: plugin.settings.RESTAPIURLConnection.RESTAPIURL },
    { type: "anthropic", condition: plugin.settings.APIConnections.anthropic.APIKey },
    { type: "googleGemini", condition: plugin.settings.APIConnections.googleGemini.APIKey },
    { type: "mistral", condition: plugin.settings.APIConnections.mistral.APIKey },
    { type: "openAI", condition: plugin.settings.APIConnections.openAI.APIKey },
    { type: "openRouter", condition: plugin.settings.APIConnections.openRouter.APIKey }
  ];
  for (const { type, condition } of modelSources) {
    if (condition) {
      try {
        const models = await fetchModels(type);
        addModelsToDropdownAndList(models);
      } catch (error) {
        console.error(`Error fetching models from ${type}:`, error);
        new import_obsidian8.Notice(`${type.charAt(0).toUpperCase() + type.slice(1)} connection error.`);
      }
    }
  }
}

// src/components/settings/AppearanceSettings.ts
var import_obsidian9 = require("obsidian");
function addAppearanceSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "Appearance" });
  const initialState = plugin.settings.toggleAppearanceSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian9.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian9.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleAppearanceSettings = false;
    } else {
      (0, import_obsidian9.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleAppearanceSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian9.Setting(settingsContainer).setName("Allow Header").setDesc("Display chatbot name and model name in header.").addToggle(
    (toggle) => toggle.setValue(plugin.settings.appearance.allowHeader).onChange((value) => {
      plugin.settings.appearance.allowHeader = value;
      const referenceCurrentNoteElement = document.querySelector("#referenceCurrentNote");
      if (value === true) {
        const header = document.querySelector("#header");
        if (header) {
          header.style.display = "block";
          referenceCurrentNoteElement.style.margin = "-0.5rem 0 0.5rem 0";
        }
      } else {
        const header = document.querySelector("#header");
        const messageContainer = document.querySelector("#messageContainer");
        if (header) {
          header.style.display = "none";
          messageContainer.style.maxHeight = "calc(100% - 60px)";
          referenceCurrentNoteElement.style.margin = "0.5rem 0 0.5rem 0";
        }
      }
      plugin.saveSettings();
    })
  );
  new import_obsidian9.Setting(settingsContainer).setName("User Name").setDesc("Create a username.").addText(
    (text) => text.setPlaceholder("Enter user name").setValue(plugin.settings.appearance.userName || DEFAULT_SETTINGS.appearance.userName).onChange(async (value) => {
      plugin.settings.appearance.userName = value ? value : DEFAULT_SETTINGS.appearance.userName;
      text.inputEl.maxLength = 30;
      await plugin.saveSettings();
      const userNames = document.querySelectorAll(".userName");
      userNames.forEach((userName) => {
        userName.textContent = plugin.settings.appearance.userName;
      });
    })
  );
  let colorPicker1;
  const defaultChatbotContainerBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.chatbotContainerBackgroundColor).trim();
  let colorPicker2;
  const defaultMessageContainerBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.messageContainerBackgroundColor).trim();
  let colorPicker3;
  const defaultUserMessageFontColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.userMessageFontColor).trim();
  let colorPicker4;
  const defaultUserMessageBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.userMessageBackgroundColor).trim();
  let colorPicker5;
  const defaultBotMessageFontColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.botMessageFontColor).trim();
  let colorPicker6;
  const defaultBotMessageBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.botMessageBackgroundColor).trim();
  let colorPicker7;
  const defaultChatBoxFontColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.chatBoxFontColor).trim();
  let colorPicker8;
  const defaultChatBoxBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.chatBoxBackgroundColor).trim();
  new import_obsidian9.Setting(settingsContainer).setName("Chatbot Container Background Color").setDesc("Modify the background color of the chatbot container.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      const defaultValue = colorToHex(defaultChatbotContainerBackgroundColor);
      colorPicker1.setValue(defaultValue);
      const chatbotContainer = document.querySelector(".chatbotContainer");
      const messageContainer = document.querySelector("#messageContainer");
      if (chatbotContainer) {
        chatbotContainer.style.backgroundColor = defaultValue;
        messageContainer.style.backgroundColor = colorPicker2.getValue();
        await plugin.saveSettings();
      }
    })
  ).addColorPicker((color) => {
    colorPicker1 = color;
    let defaultValue = plugin.settings.appearance.chatbotContainerBackgroundColor;
    if (plugin.settings.appearance.chatbotContainerBackgroundColor == "--background-secondary") {
      defaultValue = colorToHex(defaultChatbotContainerBackgroundColor);
    }
    color.setValue(defaultValue).onChange(async (value) => {
      const hexValue = colorToHex(value);
      plugin.settings.appearance.chatbotContainerBackgroundColor = hexValue;
      const chatbotContainer = document.querySelector(".chatbotContainer");
      const messageContainer = document.querySelector("#messageContainer");
      if (chatbotContainer) {
        chatbotContainer.style.backgroundColor = hexValue;
        messageContainer.style.backgroundColor = colorPicker2.getValue();
      }
      await plugin.saveSettings();
    });
  });
  new import_obsidian9.Setting(settingsContainer).setName("Message Container Background Color").setDesc("Modify the background color of the message container.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      const defaultValue = colorToHex(defaultMessageContainerBackgroundColor);
      colorPicker2.setValue(defaultValue);
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        messageContainer.style.backgroundColor = defaultValue;
        await plugin.saveSettings();
      }
    })
  ).addColorPicker((color) => {
    colorPicker2 = color;
    let defaultValue = plugin.settings.appearance.messageContainerBackgroundColor;
    if (plugin.settings.appearance.messageContainerBackgroundColor == "--background-secondary") {
      defaultValue = colorToHex(defaultMessageContainerBackgroundColor);
    }
    color.setValue(defaultValue).onChange(async (value) => {
      const hexValue = colorToHex(value);
      plugin.settings.appearance.messageContainerBackgroundColor = hexValue;
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        messageContainer.style.backgroundColor = hexValue;
      }
      await plugin.saveSettings();
    });
  });
  new import_obsidian9.Setting(settingsContainer).setName("User Message Font Color").setDesc("Modify the font color of the user message.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      const defaultValue = colorToHex(defaultUserMessageFontColor);
      colorPicker3.setValue(defaultValue);
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const userMessages = messageContainer.querySelectorAll(".userMessage");
        userMessages.forEach((userMessage) => {
          const element = userMessage;
          element.style.color = defaultValue;
        });
        await plugin.saveSettings();
      }
    })
  ).addColorPicker((color) => {
    colorPicker3 = color;
    let defaultValue = plugin.settings.appearance.userMessageFontColor;
    if (plugin.settings.appearance.userMessageFontColor == "--text-normal") {
      defaultValue = colorToHex(defaultUserMessageFontColor);
    }
    color.setValue(defaultValue).onChange(async (value) => {
      const hexValue = colorToHex(value);
      plugin.settings.appearance.userMessageFontColor = hexValue;
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const userMessages = messageContainer.querySelectorAll(".userMessage");
        userMessages.forEach((userMessage) => {
          const element = userMessage;
          element.style.color = hexValue;
        });
      }
      await plugin.saveSettings();
    });
  });
  new import_obsidian9.Setting(settingsContainer).setName("User Message Background Color").setDesc("Modify the background color of the user message.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      const defaultValue = colorToHex(defaultUserMessageBackgroundColor);
      colorPicker4.setValue(defaultValue);
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const userMessages = messageContainer.querySelectorAll(".userMessage");
        userMessages.forEach((userMessage) => {
          const element = userMessage;
          element.style.backgroundColor = defaultValue;
        });
        await plugin.saveSettings();
      }
    })
  ).addColorPicker((color) => {
    colorPicker4 = color;
    let defaultValue = plugin.settings.appearance.userMessageBackgroundColor;
    if (plugin.settings.appearance.userMessageBackgroundColor == "--background-primary") {
      defaultValue = colorToHex(defaultUserMessageBackgroundColor);
    }
    color.setValue(defaultValue).onChange(async (value) => {
      const hexValue = colorToHex(value);
      plugin.settings.appearance.userMessageBackgroundColor = hexValue;
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const userMessages = messageContainer.querySelectorAll(".userMessage");
        userMessages.forEach((userMessage) => {
          const element = userMessage;
          element.style.backgroundColor = hexValue;
        });
      }
      await plugin.saveSettings();
    });
  });
  new import_obsidian9.Setting(settingsContainer).setName("Bot Message Font Color").setDesc("Modify the font color of the bot message.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      const defaultValue = colorToHex(defaultBotMessageFontColor);
      colorPicker5.setValue(defaultValue);
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const botMessages = messageContainer.querySelectorAll(".botMessage");
        botMessages.forEach((botMessage) => {
          const element = botMessage;
          element.style.color = defaultValue;
        });
        await plugin.saveSettings();
      }
    })
  ).addColorPicker((color) => {
    colorPicker5 = color;
    let defaultValue = plugin.settings.appearance.botMessageFontColor;
    if (plugin.settings.appearance.botMessageFontColor == "--text-normal") {
      defaultValue = colorToHex(defaultBotMessageFontColor);
    }
    color.setValue(defaultValue).onChange(async (value) => {
      const hexValue = colorToHex(value);
      plugin.settings.appearance.botMessageFontColor = hexValue;
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const botMessages = messageContainer.querySelectorAll(".botMessage");
        botMessages.forEach((botMessage) => {
          const element = botMessage;
          element.style.color = hexValue;
        });
      }
      await plugin.saveSettings();
    });
  });
  new import_obsidian9.Setting(settingsContainer).setName("Bot Message Background Color").setDesc("Modify the background color of the bot message.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      const defaultValue = colorToHex(defaultBotMessageBackgroundColor);
      colorPicker6.setValue(defaultValue);
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const botMessages = messageContainer.querySelectorAll(".botMessage");
        botMessages.forEach((botMessage) => {
          const element = botMessage;
          element.style.backgroundColor = defaultValue;
        });
        await plugin.saveSettings();
      }
    })
  ).addColorPicker((color) => {
    colorPicker6 = color;
    let defaultValue = plugin.settings.appearance.botMessageBackgroundColor;
    if (plugin.settings.appearance.botMessageBackgroundColor == "--background-secondary") {
      defaultValue = colorToHex(defaultBotMessageBackgroundColor);
    }
    color.setValue(defaultValue).onChange(async (value) => {
      const hexValue = colorToHex(value);
      plugin.settings.appearance.botMessageBackgroundColor = hexValue;
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const botMessages = messageContainer.querySelectorAll(".botMessage");
        botMessages.forEach((botMessage) => {
          const element = botMessage;
          element.style.backgroundColor = hexValue;
        });
      }
      await plugin.saveSettings();
    });
  });
  new import_obsidian9.Setting(settingsContainer).setName("Chatbox Font Color").setDesc("Modify the font color of the chatbox.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      const defaultValue = colorToHex(defaultChatBoxFontColor);
      colorPicker7.setValue(defaultValue);
      const textarea = document.querySelector(".chatbox textarea");
      if (textarea) {
        textarea.style.color = defaultValue;
        const style = document.createElement("style");
        style.textContent = `
                    .chatbox textarea::placeholder {
                        color: ${defaultValue} !important;
                    }
                `;
        textarea.appendChild(style);
        await plugin.saveSettings();
      }
    })
  ).addColorPicker(async (color) => {
    colorPicker7 = color;
    let defaultValue = plugin.settings.appearance.chatBoxFontColor;
    if (defaultValue == "--text-normal") {
      defaultValue = colorToHex(defaultChatBoxFontColor);
    }
    color.setValue(defaultValue).onChange(async (value) => {
      const hexValue = colorToHex(value);
      plugin.settings.appearance.chatBoxFontColor = hexValue;
      const textarea = document.querySelector(".chatbox textarea");
      if (textarea) {
        textarea.style.color = hexValue;
        const style = document.createElement("style");
        style.textContent = `
                        .chatbox textarea::placeholder {
                            color: ${hexValue} !important;
                        }
                    `;
        textarea.appendChild(style);
      }
      await plugin.saveSettings();
    });
  });
  new import_obsidian9.Setting(settingsContainer).setName("Chatbox Background Color").setDesc("Modify the background color of the chatbox.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      const defaultValue = colorToHex(defaultChatBoxBackgroundColor);
      colorPicker8.setValue(defaultValue);
      const chatbox = document.querySelector(".chatbox");
      if (chatbox) {
        const element = chatbox;
        element.style.backgroundColor = defaultValue;
        element.style.borderColor = defaultValue;
        await plugin.saveSettings();
      }
    })
  ).addColorPicker(async (color) => {
    colorPicker8 = color;
    let defaultValue = plugin.settings.appearance.chatBoxBackgroundColor;
    if (defaultValue == "--interactive-accent") {
      defaultValue = colorToHex(defaultChatBoxBackgroundColor);
    }
    color.setValue(defaultValue).onChange(async (value) => {
      const hexValue = colorToHex(value);
      plugin.settings.appearance.chatBoxBackgroundColor = hexValue;
      const chatbox = document.querySelector(".chatbox");
      if (chatbox) {
        const element = chatbox;
        element.style.backgroundColor = hexValue;
        element.style.borderColor = hexValue;
      }
      const textarea = document.querySelector(".chatbox textarea");
      if (textarea) {
        const element = textarea;
        element.style.backgroundColor = hexValue;
        element.style.borderColor = hexValue;
      }
      await plugin.saveSettings();
    });
  });
}

// src/components/settings/ChatHistorySettings.ts
var import_obsidian10 = require("obsidian");
function addChatHistorySettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "Chat History" });
  const initialState = plugin.settings.toggleChatHistorySettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian10.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian10.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleChatHistorySettings = false;
    } else {
      (0, import_obsidian10.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleChatHistorySettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian10.Setting(settingsContainer).setName("Chat History Folder Path").setDesc("Save your chat history in a specified folder.").addText(
    (text) => text.setPlaceholder("BMO/History").setValue(plugin.settings.chatHistory.chatHistoryPath || DEFAULT_SETTINGS.chatHistory.chatHistoryPath).onChange(async (value) => {
      plugin.settings.chatHistory.chatHistoryPath = value ? value : DEFAULT_SETTINGS.chatHistory.chatHistoryPath;
      if (value) {
        let folderPath = plugin.settings.chatHistory.chatHistoryPath.trim() || DEFAULT_SETTINGS.chatHistory.chatHistoryPath;
        while (folderPath.endsWith("/")) {
          folderPath = folderPath.substring(0, folderPath.length - 1);
          plugin.settings.chatHistory.chatHistoryPath = folderPath;
        }
        const folder = plugin.app.vault.getAbstractFileByPath(folderPath);
        if (folder && folder instanceof import_obsidian10.TFolder) {
          text.inputEl.style.borderColor = "";
        } else {
          text.inputEl.style.borderColor = "red";
        }
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian10.Setting(settingsContainer).setName("Template File Path").setDesc("Insert your template file path.").addText(
    (text) => text.setPlaceholder("templates/bmo.md").setValue(plugin.settings.chatHistory.templateFilePath || DEFAULT_SETTINGS.chatHistory.templateFilePath).onChange(async (value) => {
      plugin.settings.chatHistory.templateFilePath = value ? value : DEFAULT_SETTINGS.chatHistory.templateFilePath;
      if (value) {
        if (!plugin.settings.chatHistory.templateFilePath.endsWith(".md")) {
          plugin.settings.chatHistory.templateFilePath += ".md";
        }
        await plugin.saveSettings();
        const allFiles = plugin.app.vault.getFiles();
        const fileExists = allFiles.some((file) => file.path.toLowerCase() === plugin.settings.chatHistory.templateFilePath.toLowerCase());
        if (fileExists) {
          text.inputEl.style.borderColor = "";
        } else {
          text.inputEl.style.borderColor = "red";
        }
      } else {
        text.inputEl.style.borderColor = "";
        plugin.settings.chatHistory.templateFilePath = DEFAULT_SETTINGS.chatHistory.templateFilePath;
      }
    })
  );
  new import_obsidian10.Setting(settingsContainer).setName("Allow Rename Note Title").setDesc("Allow model to rename the note title when saving chat history.").addToggle(
    (toggle) => toggle.setValue(plugin.settings.chatHistory.allowRenameNoteTitle).onChange((value) => {
      plugin.settings.chatHistory.allowRenameNoteTitle = value;
      plugin.saveSettings();
    })
  );
}

// src/components/settings/OllamaSettings.ts
var import_obsidian11 = require("obsidian");

// src/utils/DescriptionLink.ts
function addDescriptionLink(text, link, extraWords, innerText) {
  const frag = new DocumentFragment();
  const desc = document.createElement("span");
  desc.innerText = text + " ";
  frag.appendChild(desc);
  const anchor = document.createElement("a");
  anchor.href = link;
  anchor.target = "_blank";
  anchor.rel = "noopener noreferrer";
  anchor.innerText = innerText;
  frag.appendChild(anchor);
  const extra = document.createElement("span");
  extra.innerText = " " + extraWords;
  frag.appendChild(extra);
  return frag;
}

// src/components/settings/OllamaSettings.ts
function addOllamaSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "Ollama Connection" });
  const initialState = plugin.settings.toggleOllamaSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian11.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian11.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleOllamaSettings = false;
    } else {
      (0, import_obsidian11.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleOllamaSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian11.Setting(settingsContainer).setName("OLLAMA REST API URL").setDesc(addDescriptionLink("Enter your REST API URL using", "https://ollama.ai/", "", "Ollama")).addText(
    (text) => text.setPlaceholder("http://localhost:11434").setValue(plugin.settings.OllamaConnection.RESTAPIURL || DEFAULT_SETTINGS.OllamaConnection.RESTAPIURL).onChange(async (value) => {
      plugin.settings.OllamaConnection.ollamaModels = [];
      plugin.settings.OllamaConnection.RESTAPIURL = value ? value : DEFAULT_SETTINGS.OllamaConnection.RESTAPIURL;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(settingsContainer).setName("Allow Stream").setDesc(addDescriptionLink("Allow Ollama models to stream response. Additional setup required: ", "https://github.com/longy2k/obsidian-bmo-chatbot/wiki/How-to-setup-with-Ollama", "", "[Instructions]")).addToggle(
    (toggle) => toggle.setValue(plugin.settings.OllamaConnection.allowStream).onChange((value) => {
      plugin.settings.OllamaConnection.allowStream = value;
      plugin.saveSettings();
    })
  );
  const advancedToggleSettingContainer = settingsContainer.createDiv({ cls: "toggleSettingContainer" });
  advancedToggleSettingContainer.createEl("h2", { text: "Advanced Settings" });
  const advancedInitialState = plugin.settings.toggleAdvancedSettings;
  const advancedChevronIcon = advancedToggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian11.setIcon)(advancedChevronIcon, advancedInitialState ? "chevron-down" : "chevron-right");
  const advancedSettingsContainer = settingsContainer.createDiv({ cls: "settingsContainer" });
  advancedSettingsContainer.style.display = advancedInitialState ? "block" : "none";
  advancedToggleSettingContainer.addEventListener("click", async () => {
    const isOpen = advancedSettingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian11.setIcon)(advancedChevronIcon, "chevron-right");
      advancedSettingsContainer.style.display = "none";
      plugin.settings.toggleAdvancedSettings = false;
    } else {
      (0, import_obsidian11.setIcon)(advancedChevronIcon, "chevron-down");
      advancedSettingsContainer.style.display = "block";
      plugin.settings.toggleAdvancedSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian11.Setting(advancedSettingsContainer).setName("mirostat").setDesc("Enable Mirostat sampling for controlling perplexity. (default: 0, 0 = disabled, 1 = Mirostat, 2 = Mirostat 2.0)").addText(
    (text) => text.setPlaceholder("0").setValue(plugin.settings.OllamaConnection.ollamaParameters.mirostat || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat).onChange(async (value) => {
      const intValue = parseInt(value, 10);
      if (isNaN(intValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat = intValue.toString();
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("mirostat_eta").setDesc("Influences how quickly the algorithm responds to feedback from the generated text. A lower learning rate will result in slower adjustments, while a higher learning rate will make the algorithm more responsive. (Default: 0.1)").addText(
    (text) => text.setPlaceholder("0.1").setValue(plugin.settings.OllamaConnection.ollamaParameters.mirostat_eta || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat_eta).onChange(async (value) => {
      const floatValue = parseFloat(value);
      if (!isNaN(floatValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat_eta = floatValue.toFixed(2).toString();
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat_eta = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat_eta;
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("mirostat_tau").setDesc("Controls the balance between coherence and diversity of the output. A lower value will result in more focused and coherent text. (Default: 5.0)").addText(
    (text) => text.setPlaceholder("5.00").setValue(plugin.settings.OllamaConnection.ollamaParameters.mirostat_tau || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat_tau).onChange(async (value) => {
      const floatValue = parseFloat(value);
      if (!isNaN(floatValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat_tau = floatValue.toFixed(2).toString();
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat_tau = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat_tau;
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("num_ctx").setDesc("Sets the size of the context window used to generate the next token. (Default: 2048)").addText(
    (text) => text.setPlaceholder("2048").setValue(plugin.settings.OllamaConnection.ollamaParameters.num_ctx || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_ctx).onChange(async (value) => {
      const intValue = parseInt(value, 10);
      if (isNaN(intValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.num_ctx = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_ctx;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.num_ctx = intValue.toString();
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("num_gqa").setDesc("The number of GQA groups in the transformer layer. Required for some models, for example it is 8 for llama2:70b.").addText(
    (text) => text.setPlaceholder("0").setValue(plugin.settings.OllamaConnection.ollamaParameters.num_gqa || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_gqa).onChange(async (value) => {
      const intValue = parseInt(value, 10);
      if (isNaN(intValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.num_gqa = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_gqa;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.num_gqa = intValue.toString();
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("num_thread").setDesc("Sets the number of threads to use during computation. By default, Ollama will detect this for optimal performance. It is recommended to set this value to the number of physical CPU cores your system has (as opposed to the logical number of cores).").addText(
    (text) => text.setPlaceholder("0").setValue(plugin.settings.OllamaConnection.ollamaParameters.num_thread || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_thread).onChange(async (value) => {
      const intValue = parseInt(value, 10);
      if (isNaN(intValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.num_thread = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_thread;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.num_thread = intValue.toString();
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("repeat_last_n").setDesc("Sets how far back for the model to look back to prevent repetition. (Default: 64, 0 = disabled, -1 = num_ctx)").addText(
    (text) => text.setPlaceholder("64").setValue(plugin.settings.OllamaConnection.ollamaParameters.repeat_last_n || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.repeat_last_n).onChange(async (value) => {
      const intValue = parseInt(value, 10);
      if (isNaN(intValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.repeat_last_n = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.repeat_last_n;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.repeat_last_n = intValue.toString();
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("repeat_penalty").setDesc("Sets how strongly to penalize repetitions. A higher value (e.g., 1.5) will penalize repetitions more strongly, while a lower value (e.g., 0.9) will be more lenient. (Default: 1.1)").addText(
    (text) => text.setPlaceholder("1.1").setValue(plugin.settings.OllamaConnection.ollamaParameters.repeat_penalty || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.repeat_penalty).onChange(async (value) => {
      const floatValue = parseFloat(value);
      if (isNaN(floatValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.repeat_penalty = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.repeat_penalty;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.repeat_penalty = floatValue.toString();
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("seed").setDesc("Sets the random number seed to use for generation. Setting this to a specific number will make the model generate the same text for the same prompt.").addText(
    (text) => text.setPlaceholder("0").setValue(plugin.settings.OllamaConnection.ollamaParameters.seed || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.seed).onChange(async (value) => {
      const intValue = parseInt(value, 10);
      if (isNaN(intValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.seed = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.seed;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.seed = intValue.toString();
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("stop").setDesc("Sets the stop sequences to use. When this pattern is encountered, the LLM will stop generating text and return. Multiple stop patterns may be set by specifying them as a comma-separated list in the input field.").addText(
    (text) => text.setPlaceholder("stop, \\n, user:").setValue(plugin.settings.OllamaConnection.ollamaParameters.stop && Array.isArray(plugin.settings.OllamaConnection.ollamaParameters.stop) ? plugin.settings.OllamaConnection.ollamaParameters.stop.join(", ") : DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.stop.join(", ")).onChange(async (value) => {
      const stopsArray = value ? value.split(",").map((s) => s.trim()) : [...DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.stop];
      plugin.settings.OllamaConnection.ollamaParameters.stop = stopsArray;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("tfs_z").setDesc("Tail free sampling is used to reduce the impact of less probable tokens from the output. A higher value (e.g., 2.0) will reduce the impact more, while a value of 1.0 disables this setting. (default: 1)").addText(
    (text) => text.setPlaceholder("1.0").setValue(plugin.settings.OllamaConnection.ollamaParameters.tfs_z || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.tfs_z).onChange(async (value) => {
      const floatValue = parseFloat(value);
      if (isNaN(floatValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.tfs_z = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.tfs_z;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.tfs_z = floatValue.toFixed(2).toString();
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("top_k").setDesc("Reduces the probability of generating nonsense. A higher value (e.g. 100) will give more diverse answers, while a lower value (e.g. 10) will be more conservative. (Default: 40)").addText(
    (text) => text.setPlaceholder("40").setValue(plugin.settings.OllamaConnection.ollamaParameters.top_k || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.top_k).onChange(async (value) => {
      const intValue = parseInt(value, 10);
      if (isNaN(intValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.top_k = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.top_k;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.top_k = intValue.toString();
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("top_p").setDesc("Works together with top-k. A higher value (e.g., 0.95) will lead to more diverse text, while a lower value (e.g., 0.5) will generate more focused and conservative text. (Default: 0.9)").addText(
    (text) => text.setPlaceholder("1.0").setValue(plugin.settings.OllamaConnection.ollamaParameters.top_p || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.top_p).onChange(async (value) => {
      const floatValue = parseFloat(value);
      if (isNaN(floatValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.top_p = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.top_p;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.top_p = floatValue.toFixed(2).toString();
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian11.Setting(advancedSettingsContainer).setName("keep_alive").setDesc("If set to a positive duration (e.g. 20m, 1hr or 30), the model will stay loaded for the provided duration in seconds. If set to a negative duration (e.g. -1), the model will stay loaded indefinitely. If set to 0, the model will be unloaded immediately once finished. If not set, the model will stay loaded for 5 minutes by default.").addText(
    (text) => text.setPlaceholder("30s").setValue(plugin.settings.OllamaConnection.ollamaParameters.keep_alive || DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.keep_alive).onChange(async (value) => {
      const match = value.match(/^(-?\d+)(m|hr|h)?$/);
      if (match) {
        const num = parseInt(match[1]);
        const unit = match[2];
        let seconds;
        if (unit === "m") {
          seconds = num * 60;
        } else if (unit === "hr" || unit === "h") {
          seconds = num * 3600;
        } else {
          seconds = num;
        }
        plugin.settings.OllamaConnection.ollamaParameters.keep_alive = seconds.toString();
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.keep_alive = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.keep_alive;
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
}

// src/components/settings/ConnectionSettings.ts
var import_obsidian17 = require("obsidian");

// src/components/settings/APIConnections/OpenAIConnections.ts
var import_obsidian12 = require("obsidian");
function addOpenAIConnectionSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "OpenAI" });
  const initialState = plugin.settings.toggleOpenAISettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian12.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian12.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleOpenAISettings = false;
    } else {
      (0, import_obsidian12.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleOpenAISettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian12.Setting(settingsContainer).setName("OpenAI API Key").setDesc("Insert OpenAI API Key.").addText(
    (text) => text.setPlaceholder("insert-api-key").setValue(plugin.settings.APIConnections.openAI.APIKey ? `${plugin.settings.APIConnections.openAI.APIKey.slice(0, 6)}-...${plugin.settings.APIConnections.openAI.APIKey.slice(-4)}` : "").onChange(async (value) => {
      plugin.settings.APIConnections.openAI.APIKey = value;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian12.Setting(settingsContainer).setName("OpenAI-Based URL").setDesc("Enter your custom OpenAI-Based URL.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      plugin.settings.APIConnections.openAI.openAIBaseModels = [];
      plugin.settings.APIConnections.openAI.openAIBaseUrl = DEFAULT_SETTINGS.APIConnections.openAI.openAIBaseUrl;
      await plugin.saveSettings();
      SettingTab15.display();
    })
  ).addText(
    (text) => text.setPlaceholder("https://api.openai.com/v1").setValue(plugin.settings.APIConnections.openAI.openAIBaseUrl || DEFAULT_SETTINGS.APIConnections.openAI.openAIBaseUrl).onChange(async (value) => {
      plugin.settings.APIConnections.openAI.openAIBaseUrl = value ? value : DEFAULT_SETTINGS.APIConnections.openAI.openAIBaseUrl;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian12.Setting(settingsContainer).setName("Allow Stream").setDesc("Allow stream for OpenAI-Based models.").addToggle(
    (toggle) => toggle.setValue(plugin.settings.APIConnections.openAI.allowStream).onChange(async (value) => {
      plugin.settings.APIConnections.openAI.allowStream = value;
      await plugin.saveSettings();
    })
  );
}

// src/components/settings/APIConnections/MistralConnections.ts
var import_obsidian13 = require("obsidian");
function addMistralConnectionSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "Mistral AI" });
  const initialState = plugin.settings.toggleMistralSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian13.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian13.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleMistralSettings = false;
    } else {
      (0, import_obsidian13.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleMistralSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian13.Setting(settingsContainer).setName("Mistral API Key").setDesc("Insert Mistral API Key.").addText(
    (text) => text.setPlaceholder("insert-api-key").setValue(plugin.settings.APIConnections.mistral.APIKey ? `${plugin.settings.APIConnections.mistral.APIKey.slice(0, 6)}-...${plugin.settings.APIConnections.mistral.APIKey.slice(-4)}` : "").onChange(async (value) => {
      plugin.settings.APIConnections.mistral.APIKey = value;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian13.Setting(settingsContainer).setName("Allow Stream").setDesc("Allow stream for Mistral models.").addToggle(
    (toggle) => toggle.setValue(plugin.settings.APIConnections.mistral.allowStream).onChange((value) => {
      plugin.settings.APIConnections.mistral.allowStream = value;
      plugin.saveSettings();
    })
  );
}

// src/components/settings/APIConnections/GoogleGeminiConnections.ts
var import_obsidian14 = require("obsidian");
function addGoogleGeminiConnectionSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "Google Gemini" });
  const initialState = plugin.settings.toggleGoogleGeminiSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian14.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian14.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleGoogleGeminiSettings = false;
    } else {
      (0, import_obsidian14.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleGoogleGeminiSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian14.Setting(settingsContainer).setName("Google Gemini API Key").setDesc("Insert Google Gemini API Key.").addText(
    (text) => text.setPlaceholder("insert-api-key").setValue(plugin.settings.APIConnections.googleGemini.APIKey ? `${plugin.settings.APIConnections.googleGemini.APIKey.slice(0, 6)}-...${plugin.settings.APIConnections.googleGemini.APIKey.slice(-4)}` : "").onChange(async (value) => {
      plugin.settings.APIConnections.googleGemini.APIKey = value;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
}

// src/components/settings/APIConnections/AnthropicConnections.ts
var import_obsidian15 = require("obsidian");
function addAnthropicConnectionSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "Anthropic" });
  const initialState = plugin.settings.toggleAnthropicSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian15.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian15.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleAnthropicSettings = false;
    } else {
      (0, import_obsidian15.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleAnthropicSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian15.Setting(settingsContainer).setName("Anthropic API Key").setDesc("Insert Anthropic API Key.").addText(
    (text) => text.setPlaceholder("insert-api-key").setValue(plugin.settings.APIConnections.anthropic.APIKey ? `${plugin.settings.APIConnections.anthropic.APIKey.slice(0, 6)}-...${plugin.settings.APIConnections.anthropic.APIKey.slice(-4)}` : "").onChange(async (value) => {
      plugin.settings.APIConnections.anthropic.APIKey = value;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
}

// src/components/settings/APIConnections/OpenRouterConnections.ts
var import_obsidian16 = require("obsidian");
function addOpenRouterConnectionSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "OpenRouter" });
  const initialState = plugin.settings.toggleOpenRouterSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian16.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian16.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleOpenRouterSettings = false;
    } else {
      (0, import_obsidian16.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleOpenRouterSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian16.Setting(settingsContainer).setName("OpenRouter API Key").setDesc("Insert OpenRouter API Key.").addText(
    (text) => text.setPlaceholder("insert-api-key").setValue(plugin.settings.APIConnections.openRouter.APIKey ? `${plugin.settings.APIConnections.openRouter.APIKey.slice(0, 6)}-...${plugin.settings.APIConnections.openRouter.APIKey.slice(-4)}` : "").onChange(async (value) => {
      plugin.settings.APIConnections.openRouter.APIKey = value;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian16.Setting(settingsContainer).setName("Allow Stream").setDesc("Allow stream for OpenRouter models.").addToggle(
    (toggle) => toggle.setValue(plugin.settings.APIConnections.openRouter.allowStream).onChange((value) => {
      plugin.settings.APIConnections.openRouter.allowStream = value;
      plugin.saveSettings();
    })
  );
}

// src/components/settings/ConnectionSettings.ts
function addAPIConnectionSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "API Connections" });
  const initialState = plugin.settings.toggleAPIConnectionSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian17.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian17.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleAPIConnectionSettings = false;
    } else {
      (0, import_obsidian17.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleAPIConnectionSettings = true;
    }
    await plugin.saveSettings();
  });
  addAnthropicConnectionSettings(settingsContainer, plugin, SettingTab15);
  addGoogleGeminiConnectionSettings(settingsContainer, plugin, SettingTab15);
  addMistralConnectionSettings(settingsContainer, plugin, SettingTab15);
  addOpenAIConnectionSettings(settingsContainer, plugin, SettingTab15);
  addOpenRouterConnectionSettings(settingsContainer, plugin, SettingTab15);
}

// src/components/settings/ProfileSettings.ts
var import_obsidian18 = require("obsidian");
function addProfileSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "Profiles" });
  const initialState = plugin.settings.toggleProfileSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian18.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian18.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleProfileSettings = false;
    } else {
      (0, import_obsidian18.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleProfileSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian18.Setting(settingsContainer).setName("Profile").setDesc("Select a profile.").addDropdown((dropdown) => {
    if (plugin.settings.profiles.profileFolderPath !== "") {
      const files = plugin.app.vault.getFiles().filter((file) => file.path.startsWith(plugin.settings.profiles.profileFolderPath));
      files.sort((a, b) => a.name.localeCompare(b.name));
      const dataFolderPath = "./.obsidian/plugins/bmo-chatbot/data/";
      if (!plugin.app.vault.getAbstractFileByPath(dataFolderPath)) {
        plugin.app.vault.adapter.mkdir(dataFolderPath);
      }
      files.forEach((file) => {
        if (file instanceof import_obsidian18.TFile) {
          const fileName = file.basename;
          const newFileName = `messageHistory_${fileName}.json`;
          const newFilePath = `${dataFolderPath}${newFileName}`;
          plugin.app.vault.create(newFilePath, "").catch((err) => {
            if (err.message === "File already exists.") {
            } else {
              throw err;
            }
          });
          dropdown.addOption(file.name, fileName);
        }
      });
    }
    dropdown.setValue(plugin.settings.profiles.profile || DEFAULT_SETTINGS.profiles.profile).onChange(async (value) => {
      plugin.settings.profiles.profile = value ? value : DEFAULT_SETTINGS.profiles.profile;
      const profileFilePath = plugin.settings.profiles.profileFolderPath + "/" + plugin.settings.profiles.profile;
      const currentProfile = plugin.app.vault.getAbstractFileByPath(profileFilePath);
      plugin.activateView();
      await updateSettingsFromFrontMatter(plugin, currentProfile);
      await plugin.saveSettings();
      SettingTab15.display();
    });
  });
  new import_obsidian18.Setting(settingsContainer).setName("Profile Folder Path").setDesc("Select a profile from a specified folder.").addText(
    (text) => text.setPlaceholder("BMO/Profiles").setValue(plugin.settings.profiles.profileFolderPath || DEFAULT_SETTINGS.profiles.profileFolderPath).onChange(async (value) => {
      plugin.settings.profiles.profileFolderPath = value ? value : DEFAULT_SETTINGS.profiles.profileFolderPath;
      if (value) {
        let folderPath = plugin.settings.profiles.profileFolderPath.trim() || DEFAULT_SETTINGS.profiles.profileFolderPath;
        while (folderPath.endsWith("/")) {
          folderPath = folderPath.substring(0, folderPath.length - 1);
          plugin.settings.profiles.profileFolderPath = folderPath;
        }
        const folder = plugin.app.vault.getAbstractFileByPath(folderPath);
        if (folder && folder instanceof import_obsidian18.TFolder) {
          text.inputEl.style.borderColor = "";
        } else {
          text.inputEl.style.borderColor = "red";
        }
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
}

// src/components/settings/RESTAPIURLSettings.ts
var import_obsidian19 = require("obsidian");
function addRESTAPIURLSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "REST API URL Connection" });
  const initialState = plugin.settings.toggleRESTAPIURLSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian19.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian19.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleRESTAPIURLSettings = false;
    } else {
      (0, import_obsidian19.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleRESTAPIURLSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian19.Setting(settingsContainer).setName("API Key (Optional)").setDesc("Insert API Key (Optional).").addText(
    (text) => text.setPlaceholder("insert-api-key").setValue(plugin.settings.RESTAPIURLConnection.APIKey ? `${plugin.settings.RESTAPIURLConnection.APIKey.slice(0, 6)}-...${plugin.settings.RESTAPIURLConnection.APIKey.slice(-4)}` : "").onChange(async (value) => {
      plugin.settings.RESTAPIURLConnection.RESTAPIURLModels = [];
      plugin.settings.RESTAPIURLConnection.APIKey = value;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian19.Setting(settingsContainer).setName("REST API URL").setDesc("Enter your REST API URL.").addText(
    (text) => text.setPlaceholder("http://localhost:1234").setValue(plugin.settings.RESTAPIURLConnection.RESTAPIURL || DEFAULT_SETTINGS.RESTAPIURLConnection.RESTAPIURL).onChange(async (value) => {
      plugin.settings.RESTAPIURLConnection.RESTAPIURLModels = [];
      plugin.settings.RESTAPIURLConnection.RESTAPIURL = value ? value : DEFAULT_SETTINGS.RESTAPIURLConnection.RESTAPIURL;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
  new import_obsidian19.Setting(settingsContainer).setName("Allow Stream").setDesc(addDescriptionLink("Allow REST API URL models to stream response. Additional setup required: ", "https://github.com/longy2k/obsidian-bmo-chatbot/wiki/How-to-setup-with-LM-Studio", "", "[Instructions]")).addToggle(
    (toggle) => toggle.setValue(plugin.settings.RESTAPIURLConnection.allowStream).onChange((value) => {
      plugin.settings.RESTAPIURLConnection.allowStream = value;
      plugin.saveSettings();
    })
  );
}

// src/components/settings/EditorSettings.ts
var import_obsidian20 = require("obsidian");
async function addEditorSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "Editor" });
  const initialState = plugin.settings.toggleEditorSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian20.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian20.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.toggleEditorSettings = false;
    } else {
      (0, import_obsidian20.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.toggleEditorSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian20.Setting(settingsContainer).setName("Prompt Select Generate System").setDesc(addDescriptionLink("System role for Prompt Select Generate.", "https://github.com/longy2k/obsidian-bmo-chatbot/wiki/Prompt---Select---Generate-Command", "", "[Instructions]")).addTextArea(
    (text) => text.setPlaceholder("You are a helpful assistant.").setValue(plugin.settings.editor.prompt_select_generate_system_role !== void 0 ? plugin.settings.editor.prompt_select_generate_system_role : DEFAULT_SETTINGS.editor.prompt_select_generate_system_role).onChange(async (value) => {
      plugin.settings.editor.prompt_select_generate_system_role = value !== void 0 ? value : DEFAULT_SETTINGS.editor.prompt_select_generate_system_role;
      await plugin.saveSettings();
    })
  );
}

// src/components/settings/PromptSettings.ts
var import_obsidian21 = require("obsidian");
function addPromptSettings(containerEl, plugin, SettingTab15) {
  const toggleSettingContainer = containerEl.createDiv({ cls: "toggleSettingContainer" });
  toggleSettingContainer.createEl("h2", { text: "Prompts" });
  const initialState = plugin.settings.togglePromptSettings;
  const chevronIcon = toggleSettingContainer.createEl("span", { cls: "chevron-icon" });
  (0, import_obsidian21.setIcon)(chevronIcon, initialState ? "chevron-down" : "chevron-right");
  const settingsContainer = containerEl.createDiv({ cls: "settingsContainer" });
  settingsContainer.style.display = initialState ? "block" : "none";
  toggleSettingContainer.addEventListener("click", async () => {
    const isOpen = settingsContainer.style.display !== "none";
    if (isOpen) {
      (0, import_obsidian21.setIcon)(chevronIcon, "chevron-right");
      settingsContainer.style.display = "none";
      plugin.settings.togglePromptSettings = false;
    } else {
      (0, import_obsidian21.setIcon)(chevronIcon, "chevron-down");
      settingsContainer.style.display = "block";
      plugin.settings.togglePromptSettings = true;
    }
    await plugin.saveSettings();
  });
  new import_obsidian21.Setting(settingsContainer).setName("Prompt").setDesc("Select a prompt to provide additional context to the system role.").addDropdown((dropdown) => {
    dropdown.addOption("", "--EMPTY--");
    if (plugin.settings.prompts.promptFolderPath !== "") {
      const files = plugin.app.vault.getFiles().filter((file) => file.path.startsWith(plugin.settings.prompts.promptFolderPath));
      files.sort((a, b) => a.name.localeCompare(b.name));
      files.forEach((file) => {
        if (file instanceof import_obsidian21.TFile) {
          const fileName = file.basename;
          dropdown.addOption(file.name, fileName);
        }
      });
    }
    dropdown.setValue("");
    dropdown.setValue(plugin.settings.prompts.prompt || DEFAULT_SETTINGS.prompts.prompt).onChange(async (value) => {
      plugin.settings.prompts.prompt = value ? value : DEFAULT_SETTINGS.prompts.prompt;
      await plugin.saveSettings();
    });
  });
  new import_obsidian21.Setting(settingsContainer).setName("Prompt Folder Path").setDesc("Select a prompt from a specified folder.").addText(
    (text) => text.setPlaceholder("BMO/Prompts").setValue(plugin.settings.prompts.promptFolderPath || DEFAULT_SETTINGS.prompts.promptFolderPath).onChange(async (value) => {
      plugin.settings.prompts.promptFolderPath = value ? value : DEFAULT_SETTINGS.prompts.promptFolderPath;
      if (value) {
        let folderPath = plugin.settings.prompts.promptFolderPath.trim() || DEFAULT_SETTINGS.prompts.promptFolderPath;
        while (folderPath.endsWith("/")) {
          folderPath = folderPath.substring(0, folderPath.length - 1);
          plugin.settings.prompts.promptFolderPath = folderPath;
        }
        const folder = plugin.app.vault.getAbstractFileByPath(folderPath);
        if (folder && folder instanceof import_obsidian21.TFolder) {
          text.inputEl.style.borderColor = "";
        } else {
          text.inputEl.style.borderColor = "red";
        }
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab15.display();
    })
  );
}

// src/settings.ts
var BMOSettingTab = class extends import_obsidian22.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "BMO Chatbot Settings" });
    const changeLogLink = containerEl.createEl("a", {
      text: "Changelog",
      href: "https://github.com/longy2k/obsidian-bmo-chatbot/releases"
    });
    changeLogLink.style.fontSize = "0.8rem";
    containerEl.createEl("p", { text: "Type `/help` in chat for commands." });
    addHorizontalRule(this.containerEl);
    addProfileSettings(this.containerEl, this.plugin, this);
    addGeneralSettings(this.containerEl, this.plugin, this);
    addPromptSettings(this.containerEl, this.plugin, this);
    addAppearanceSettings(this.containerEl, this.plugin, this);
    addChatHistorySettings(this.containerEl, this.plugin, this);
    addEditorSettings(this.containerEl, this.plugin, this);
    addHorizontalRule(this.containerEl);
    addOllamaSettings(this.containerEl, this.plugin, this);
    addRESTAPIURLSettings(this.containerEl, this.plugin, this);
    addAPIConnectionSettings(this.containerEl, this.plugin, this);
    addHorizontalRule(this.containerEl);
    const resetButton = containerEl.createEl("a", {
      text: "Reset Settings",
      href: "#",
      attr: {
        style: "display: block; text-align: center; margin: 1rem 0; font-size: 0.7rem; color: #ff6666;"
      }
    });
    resetButton.addEventListener("click", async (event) => {
      event.preventDefault();
      const confirmReset = confirm("Are you sure you want to reset all settings to default?");
      if (confirmReset) {
        const profilePathFile = this.plugin.settings.profiles.profileFolderPath + "/" + this.plugin.settings.profiles.profile;
        const profilePath = this.plugin.app.vault.getAbstractFileByPath(profilePathFile);
        const defaultProfilePathFile = DEFAULT_SETTINGS.profiles.profileFolderPath + "/" + DEFAULT_SETTINGS.profiles.profile;
        const defaultProfilePath = this.plugin.app.vault.getAbstractFileByPath(defaultProfilePathFile);
        if (profilePath) {
          if (profilePath.path === defaultProfilePath.path) {
            this.plugin.settings = DEFAULT_SETTINGS;
            await this.plugin.saveSettings();
            await this.plugin.app.plugins.disablePlugin(this.plugin.manifest.id);
            await this.plugin.app.plugins.enablePlugin(this.plugin.manifest.id);
          } else {
            const filenameMessageHistory = "./.obsidian/plugins/bmo-chatbot/data/messageHistory_" + defaultProfilePath.name.replace(".md", ".json");
            this.app.vault.adapter.remove(filenameMessageHistory);
            this.plugin.app.vault.delete(profilePath);
            this.plugin.settings.profiles.profile = DEFAULT_SETTINGS.profiles.profile;
            await updateSettingsFromFrontMatter(this.plugin, defaultProfilePath);
            await this.plugin.saveSettings();
          }
        }
        requestAnimationFrame(() => {
          const refreshTab = this.plugin.app.setting.openTabById("bmo-chatbot");
          if (refreshTab) {
            refreshTab.display();
          } else {
            new BMOSettingTab(this.app, this.plugin).display();
          }
        });
      }
    });
    const resetNotice = containerEl.createEl("p", {
      text: "Please reset your settings if you have recently updated from version <2.0.0.",
      attr: {
        style: "font-size: 0.7rem; text-align: center;"
      }
    });
    containerEl.appendChild(resetNotice);
  }
};
function addHorizontalRule(containerEl) {
  const separator = document.createElement("hr");
  separator.style.margin = "1rem 0";
  containerEl.appendChild(separator);
}

// src/components/editor/EditorCommands.ts
var import_obsidian24 = require("obsidian");

// src/components/FetchModelEditor.ts
var import_obsidian23 = require("obsidian");
async function fetchOllamaResponseEditor(settings, selectionString) {
  const ollamaRESTAPIURL = settings.OllamaConnection.RESTAPIURL;
  if (!ollamaRESTAPIURL) {
    return;
  }
  try {
    const response = await (0, import_obsidian23.requestUrl)({
      url: ollamaRESTAPIURL + "/api/chat",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.editor.prompt_select_generate_system_role },
          { role: "user", content: selectionString }
        ],
        stream: false,
        options: {
          temperature: parseInt(settings.general.temperature),
          num_predict: parseInt(settings.general.max_tokens)
        }
      })
    });
    const message = response.json.message.content;
    return message;
  } catch (error) {
    console.error("Error making API request:", error);
    throw error;
  }
}
async function fetchRESTAPIURLDataEditor(settings, selectionString) {
  try {
    const response = await (0, import_obsidian23.requestUrl)({
      url: settings.RESTAPIURLConnection.RESTAPIURL + "/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.RESTAPIURLConnection.APIKey}`
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.editor.prompt_select_generate_system_role || "You are a helpful assistant." },
          { role: "user", content: selectionString }
        ],
        max_tokens: parseInt(settings.general.max_tokens) || -1,
        temperature: parseInt(settings.general.temperature)
      })
    });
    const message = response.json.choices[0].message.content;
    return message;
  } catch (error) {
    console.error("Error making API request:", error);
    throw error;
  }
}
async function fetchAnthropicResponseEditor(settings, selectionString) {
  try {
    const response = await (0, import_obsidian23.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "anthropic-version": "2023-06-01",
        "content-type": "application/json",
        "x-api-key": settings.APIConnections.anthropic.APIKey
      },
      body: JSON.stringify({
        model: settings.general.model,
        system: settings.editor.prompt_select_generate_system_role,
        messages: [
          { role: "user", content: selectionString }
        ],
        max_tokens: parseInt(settings.general.max_tokens) || 4096,
        temperature: parseInt(settings.general.temperature)
      })
    });
    const message = response.json.content[0].text;
    return message;
  } catch (error) {
    console.error(error);
  }
}
async function fetchGoogleGeminiDataEditor(settings, selectionString) {
  try {
    const API_KEY = settings.APIConnections.googleGemini.APIKey;
    const requestBody = {
      contents: [{
        parts: [
          { text: settings.editor.prompt_select_generate_system_role + selectionString }
        ]
      }]
    };
    const response = await (0, import_obsidian23.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    const message = response.json.candidates[0].content.parts[0].text;
    return message;
  } catch (error) {
    console.error(error);
  }
}
async function fetchMistralDataEditor(settings, selectionString) {
  try {
    const response = await (0, import_obsidian23.requestUrl)({
      url: "https://api.mistral.ai/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.APIConnections.mistral.APIKey}`
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.editor.prompt_select_generate_system_role },
          { role: "user", content: selectionString }
        ],
        max_tokens: parseInt(settings.general.max_tokens),
        temperature: parseInt(settings.general.temperature)
      })
    });
    const message = response.json.choices[0].message.content;
    return message;
  } catch (error) {
    console.error(error);
  }
}
async function fetchOpenAIBaseAPIResponseEditor(settings, selectionString) {
  const openai = new openai_default({
    apiKey: settings.APIConnections.openAI.APIKey,
    baseURL: settings.APIConnections.openAI.openAIBaseUrl,
    dangerouslyAllowBrowser: true
    // apiKey is stored within data.json
  });
  const completion = await openai.chat.completions.create({
    model: settings.general.model,
    max_tokens: parseInt(settings.general.max_tokens),
    messages: [
      { role: "system", content: settings.editor.prompt_select_generate_system_role },
      { role: "user", content: selectionString }
    ]
  });
  const message = completion.choices[0].message.content;
  return message;
}
async function fetchOpenRouterEditor(settings, selectionString) {
  try {
    const response = await (0, import_obsidian23.requestUrl)({
      url: "https://openrouter.ai/api/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.APIConnections.openRouter.APIKey}`
      },
      body: JSON.stringify({
        model: settings.general.model,
        messages: [
          { role: "system", content: settings.editor.prompt_select_generate_system_role },
          { role: "user", content: selectionString }
        ],
        max_tokens: parseInt(settings.general.max_tokens),
        temperature: parseInt(settings.general.temperature)
      })
    });
    const message = response.json.choices[0].message.content;
    return message;
  } catch (error) {
    console.error("Error making API request:", error);
    throw error;
  }
}

// src/components/editor/EditorCommands.ts
async function renameTitleCommand(plugin, settings) {
  var _a2, _b, _c;
  let uniqueNameFound = false;
  let modelRenameTitle;
  let folderName = ((_c = (_b = plugin.app.vault.getAbstractFileByPath(((_a2 = plugin.app.workspace.getActiveFile()) == null ? void 0 : _a2.path) || "")) == null ? void 0 : _b.parent) == null ? void 0 : _c.path) || "";
  const fileExtension = ".md";
  const allFiles = plugin.app.vault.getFiles();
  const activeFile = plugin.app.workspace.getActiveFile();
  let fileContent = "";
  try {
    new import_obsidian24.Notice("Generating title...");
    if (activeFile) {
      fileContent = await plugin.app.vault.read(activeFile);
    }
    if (folderName && !folderName.endsWith("/")) {
      folderName += "/";
    }
    const fileNameExists = (name) => {
      return allFiles.some((file) => file.path === folderName + name + fileExtension);
    };
    while (!uniqueNameFound) {
      modelRenameTitle = await fetchModelRenameTitle(settings, fileContent);
      if (!fileNameExists(modelRenameTitle)) {
        uniqueNameFound = true;
      }
    }
    const fileName = folderName + modelRenameTitle + fileExtension;
    if (activeFile) {
      plugin.app.vault.rename(activeFile, fileName);
    }
    new import_obsidian24.Notice("Renamed note title.");
  } catch (error) {
    console.error(error);
  }
}
async function promptSelectGenerateCommand(plugin, settings) {
  var _a2, _b;
  const view = plugin.app.workspace.getActiveViewOfType(import_obsidian24.MarkdownView);
  const select = view == null ? void 0 : view.editor.getSelection();
  if (view && select && select.trim() !== "") {
    if (settings.OllamaConnection.RESTAPIURL && settings.OllamaConnection.ollamaModels.includes(settings.general.model)) {
      try {
        new import_obsidian24.Notice("Generating...");
        const response = await fetchOllamaResponseEditor(settings, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response);
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + (response == null ? void 0 : response.length)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian24.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (settings.RESTAPIURLConnection.RESTAPIURL && settings.RESTAPIURLConnection.RESTAPIURLModels.includes(settings.general.model)) {
      try {
        new import_obsidian24.Notice("Generating...");
        const response = await fetchRESTAPIURLDataEditor(settings, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response);
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + (response == null ? void 0 : response.length)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian24.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (ANTHROPIC_MODELS.includes(settings.general.model)) {
      try {
        new import_obsidian24.Notice("Generating...");
        const response = await fetchAnthropicResponseEditor(settings, select);
        view.editor.replaceSelection(response);
      } catch (error) {
        new import_obsidian24.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (settings.APIConnections.googleGemini.geminiModels.includes(settings.general.model)) {
      try {
        new import_obsidian24.Notice("Generating...");
        const response = await fetchGoogleGeminiDataEditor(settings, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response);
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + (response == null ? void 0 : response.length)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian24.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (settings.APIConnections.mistral.mistralModels.includes(settings.general.model)) {
      try {
        new import_obsidian24.Notice("Generating...");
        const response = await fetchMistralDataEditor(settings, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response);
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + (response == null ? void 0 : response.length)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian24.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (OPENAI_MODELS.includes(settings.general.model)) {
      try {
        new import_obsidian24.Notice("Generating...");
        const response = await fetchOpenAIBaseAPIResponseEditor(settings, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response || "");
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + ((_a2 = response == null ? void 0 : response.length) != null ? _a2 : 0)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian24.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (settings.APIConnections.openAI.openAIBaseUrl != DEFAULT_SETTINGS.APIConnections.openAI.openAIBaseUrl && settings.APIConnections.openAI.openAIBaseModels.includes(settings.general.model)) {
      try {
        new import_obsidian24.Notice("Generating...");
        const response = await fetchOpenAIBaseAPIResponseEditor(settings, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response || "");
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + ((_b = response == null ? void 0 : response.length) != null ? _b : 0)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian24.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (settings.APIConnections.openRouter.openRouterModels.includes(settings.general.model)) {
      try {
        new import_obsidian24.Notice("Generating...");
        const response = await fetchOpenRouterEditor(settings, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response);
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + (response == null ? void 0 : response.length)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian24.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    }
    new import_obsidian24.Notice("Generation complete.");
  } else {
    new import_obsidian24.Notice("No text selected.");
  }
}

// src/main.ts
var DEFAULT_SETTINGS = {
  profiles: {
    profile: "BMO.md",
    profileFolderPath: "BMO/Profiles"
  },
  general: {
    model: "",
    system_role: "You are a helpful assistant.",
    max_tokens: "",
    temperature: "1.00",
    allowReferenceCurrentNote: false
  },
  appearance: {
    userName: "USER",
    chatbotName: "BMO",
    chatbotContainerBackgroundColor: "--background-secondary",
    messageContainerBackgroundColor: "--background-secondary",
    userMessageFontColor: "--text-normal",
    userMessageBackgroundColor: "--background-primary",
    botMessageFontColor: "--text-normal",
    botMessageBackgroundColor: "--background-secondary",
    chatBoxFontColor: "--text-normal",
    chatBoxBackgroundColor: "--interactive-accent",
    allowHeader: true
  },
  prompts: {
    prompt: "",
    promptFolderPath: "BMO/Prompts"
  },
  editor: {
    prompt_select_generate_system_role: "Output user request."
  },
  chatHistory: {
    chatHistoryPath: "BMO/History",
    templateFilePath: "",
    allowRenameNoteTitle: false
  },
  OllamaConnection: {
    RESTAPIURL: "",
    allowStream: false,
    ollamaParameters: {
      keep_alive: "",
      mirostat: "0",
      mirostat_eta: "0.10",
      mirostat_tau: "5.00",
      num_ctx: "2048",
      num_gqa: "",
      num_thread: "",
      repeat_last_n: "64",
      repeat_penalty: "1.10",
      seed: "",
      stop: [],
      tfs_z: "1.00",
      top_k: "40",
      top_p: "0.90"
    },
    ollamaModels: []
  },
  RESTAPIURLConnection: {
    APIKey: "",
    RESTAPIURL: "",
    allowStream: false,
    RESTAPIURLModels: []
  },
  APIConnections: {
    anthropic: {
      APIKey: "",
      anthropicModels: []
    },
    googleGemini: {
      APIKey: "",
      geminiModels: []
    },
    mistral: {
      APIKey: "",
      allowStream: false,
      mistralModels: []
    },
    openAI: {
      APIKey: "",
      openAIBaseUrl: "https://api.openai.com/v1",
      allowStream: true,
      openAIBaseModels: []
    },
    openRouter: {
      APIKey: "",
      allowStream: false,
      openRouterModels: []
    }
  },
  toggleGeneralSettings: true,
  toggleAppearanceSettings: false,
  togglePromptSettings: false,
  toggleEditorSettings: false,
  toggleChatHistorySettings: false,
  toggleProfileSettings: false,
  toggleAPIConnectionSettings: true,
  toggleOpenAISettings: false,
  toggleMistralSettings: false,
  toggleGoogleGeminiSettings: false,
  toggleAnthropicSettings: false,
  toggleRESTAPIURLSettings: true,
  toggleOpenRouterSettings: false,
  toggleOllamaSettings: true,
  toggleAdvancedSettings: false,
  allModels: []
};
var checkActiveFile = null;
var BMOGPT15 = class extends import_obsidian25.Plugin {
  async onload() {
    await this.loadSettings();
    const folderPath = this.settings.profiles.profileFolderPath || DEFAULT_SETTINGS.profiles.profileFolderPath;
    const defaultFilePath = `${folderPath}/${DEFAULT_SETTINGS.profiles.profile}`;
    const defaultProfile = this.app.vault.getAbstractFileByPath(defaultFilePath);
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
    if (!await this.app.vault.adapter.exists(defaultFilePath)) {
      this.app.vault.create(defaultFilePath, "");
      console.log("Default profile created.");
    }
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        if (file instanceof import_obsidian25.TFile && file.path.startsWith(folderPath)) {
          const fileContent = await this.app.vault.read(file);
          if (fileContent.trim() === "") {
            defaultFrontMatter(this, file);
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on(
        "delete",
        async (file) => {
          if (file instanceof import_obsidian25.TFile && file.path.startsWith(folderPath)) {
            const filenameMessageHistory = "./.obsidian/plugins/bmo-chatbot/data/messageHistory_" + file.name.replace(".md", ".json");
            this.app.vault.adapter.remove(filenameMessageHistory);
            if (file.path === defaultFilePath) {
              this.app.vault.create(defaultFilePath, "");
            } else {
              if (this.settings.profiles.profile === file.name) {
                this.settings.profiles.profile = DEFAULT_SETTINGS.profiles.profile;
                const fileContent = (await this.app.vault.read(defaultProfile)).replace(/^---\s*[\s\S]*?---/, "").trim();
                this.settings.general.system_role = fileContent;
                await updateSettingsFromFrontMatter(this, defaultProfile);
                await this.saveSettings();
              }
            }
            this.activateView();
          }
        }
      )
    );
    this.registerEvent(
      this.app.vault.on(
        "modify",
        async (file) => {
          const currentProfilePath = `${folderPath}/${this.settings.profiles.profile}`;
          if (file.path === currentProfilePath) {
            await updateSettingsFromFrontMatter(this, file);
            const fileContent = (await this.app.vault.read(file)).replace(/^---\s*[\s\S]*?---/, "").trim();
            this.settings.general.system_role = fileContent;
            await this.saveSettings();
          }
        }
      )
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        try {
          const currentProfilePath = `${folderPath}/${this.settings.profiles.profile}`;
          if (oldPath === currentProfilePath) {
            this.settings.profiles.profile = file.name;
            this.settings.appearance.chatbotName = file.basename;
            await this.saveSettings();
          }
          if (file instanceof import_obsidian25.TFile && file.path.startsWith(folderPath)) {
            const filenameMessageHistoryPath = "./.obsidian/plugins/bmo-chatbot/data/";
            const oldProfileMessageHistory = "messageHistory_" + oldPath.replace(folderPath + "/", "").replace(".md", ".json");
            await this.app.vault.adapter.rename(filenameMessageHistoryPath + oldProfileMessageHistory, filenameMessageHistoryPath + "messageHistory_" + file.name.replace(".md", ".json")).catch((error) => {
              console.error("Error handling rename event:", error);
            });
            await this.app.vault.adapter.remove(filenameMessageHistoryPath + oldProfileMessageHistory);
          }
        } catch (error) {
          if (error.message.includes("ENOENT: no such file or directory, unlink")) {
          } else {
            console.error("Error handling rename event:", error);
          }
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.handleFileSwitch();
      })
    );
    this.registerView(
      VIEW_TYPE_CHATBOT,
      (leaf) => new BMOView(leaf, this.settings, this)
    );
    this.addRibbonIcon("bot", "BMO Chatbot", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-bmo-chatbot",
      name: "Open BMO Chatbot",
      callback: () => {
        this.activateView();
      },
      hotkeys: [
        {
          modifiers: ["Mod"],
          key: "0"
        }
      ]
    });
    this.addCommand({
      id: "rename-note-title",
      name: "Rename Note Title",
      callback: () => {
        renameTitleCommand(this, this.settings);
      },
      hotkeys: [
        {
          modifiers: ["Mod"],
          key: "'"
        }
      ]
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (!(file instanceof import_obsidian25.TFile)) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("BMO Chatbot: Generate new title").onClick(() => renameTitleCommand(this, this.settings));
        });
      })
    );
    this.addCommand({
      id: "prompt-select-generate",
      name: "Prompt Select Generate",
      callback: () => {
        promptSelectGenerateCommand(this, this.settings);
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "="
        }
      ]
    });
    this.addSettingTab(new BMOSettingTab(this.app, this));
  }
  handleFileSwitch() {
    checkActiveFile = this.app.workspace.getActiveFile();
  }
  async onunload() {
    this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATBOT).forEach((leaf) => {
      const bmoView = leaf.view;
      if (bmoView) {
        this.saveSettings();
      }
    });
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CHATBOT);
    const rightLeaf = this.app.workspace.getRightLeaf(false);
    await (rightLeaf == null ? void 0 : rightLeaf.setViewState({
      type: VIEW_TYPE_CHATBOT,
      active: true
    }));
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATBOT)[0]
    );
    const textarea = document.querySelector(".chatbox textarea");
    if (textarea) {
      textarea.style.opacity = "0";
      textarea.style.transition = "opacity 1s ease-in-out";
      setTimeout(() => {
        textarea.focus();
        textarea.style.opacity = "1";
      }, 50);
    }
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATBOT)[0]
    );
    const messageContainer = document.querySelector("#messageContainer");
    if (messageContainer) {
      messageContainer.scroll({
        top: messageContainer.scrollHeight,
        behavior: "smooth"
      });
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    const currentProfileFile = `${this.settings.profiles.profileFolderPath}/${this.settings.profiles.profile}`;
    const currentProfile = this.app.vault.getAbstractFileByPath(currentProfileFile);
    updateFrontMatter(this, currentProfile);
    await this.saveData(this.settings);
  }
};
async function defaultFrontMatter(plugin, file) {
  const setDefaultFrontMatter = async (frontmatter) => {
    frontmatter.model = DEFAULT_SETTINGS.general.model;
    frontmatter.max_tokens = parseInt(DEFAULT_SETTINGS.general.max_tokens);
    frontmatter.temperature = parseFloat(DEFAULT_SETTINGS.general.temperature);
    frontmatter.reference_current_note = DEFAULT_SETTINGS.general.allowReferenceCurrentNote;
    frontmatter.prompt = DEFAULT_SETTINGS.prompts.prompt;
    frontmatter.user_name = DEFAULT_SETTINGS.appearance.userName;
    frontmatter.allow_header = DEFAULT_SETTINGS.appearance.allowHeader;
    frontmatter.chatbot_container_background_color = DEFAULT_SETTINGS.appearance.chatbotContainerBackgroundColor.replace(/^#/, "");
    frontmatter.message_container_background_color = DEFAULT_SETTINGS.appearance.messageContainerBackgroundColor.replace(/^#/, "");
    frontmatter.user_message_font_color = DEFAULT_SETTINGS.appearance.userMessageFontColor.replace(/^#/, "");
    frontmatter.user_message_background_color = DEFAULT_SETTINGS.appearance.userMessageBackgroundColor.replace(/^#/, "");
    frontmatter.bot_message_font_color = DEFAULT_SETTINGS.appearance.botMessageFontColor.replace(/^#/, "");
    frontmatter.chatbot_message_background_color = DEFAULT_SETTINGS.appearance.botMessageBackgroundColor.replace(/^#/, "");
    frontmatter.chatbox_font_color = DEFAULT_SETTINGS.appearance.chatBoxFontColor.replace(/^#/, "");
    frontmatter.chatbox_background_color = DEFAULT_SETTINGS.appearance.chatBoxBackgroundColor.replace(/^#/, "");
    frontmatter.prompt_select_generate_system_role = DEFAULT_SETTINGS.editor.prompt_select_generate_system_role;
    frontmatter.ollama_mirostat = parseFloat(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat);
    frontmatter.ollama_mirostat_eta = parseFloat(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat_eta);
    frontmatter.ollama_mirostat_tau = parseFloat(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat_tau);
    frontmatter.ollama_num_ctx = parseInt(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_ctx);
    frontmatter.ollama_num_gqa = parseInt(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_gqa);
    frontmatter.ollama_num_thread = parseInt(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_thread);
    frontmatter.ollama_repeat_last_n = parseInt(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.repeat_last_n);
    frontmatter.ollama_repeat_penalty = parseFloat(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.repeat_penalty);
    frontmatter.ollama_seed = parseInt(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.seed);
    frontmatter.ollama_stop = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.stop;
    frontmatter.ollama_tfs_z = parseFloat(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.tfs_z);
    frontmatter.ollama_top_k = parseInt(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.top_k);
    frontmatter.ollama_top_p = parseFloat(DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.top_p);
    frontmatter.ollama_keep_alive = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.keep_alive;
  };
  const writeOptions = {
    // Specify options if needed
  };
  try {
    await plugin.app.fileManager.processFrontMatter(file, setDefaultFrontMatter, writeOptions);
  } catch (error) {
    console.error("Error processing frontmatter:", error);
  }
  plugin.app.vault.append(file, DEFAULT_SETTINGS.general.system_role);
}
async function updateSettingsFromFrontMatter(plugin, file) {
  const updateSettings = async (frontmatter) => {
    plugin.settings.general.model = frontmatter.model;
    plugin.settings.general.max_tokens = frontmatter.max_tokens;
    plugin.settings.general.temperature = frontmatter.temperature;
    plugin.settings.general.allowReferenceCurrentNote = frontmatter.reference_current_note;
    plugin.settings.prompts.prompt = frontmatter.prompt + ".md";
    plugin.settings.appearance.userName = frontmatter.user_name;
    plugin.settings.appearance.chatbotName = file.basename;
    plugin.settings.appearance.allowHeader = frontmatter.allow_header;
    plugin.settings.appearance.chatbotContainerBackgroundColor = "#" + frontmatter.chatbot_container_background_color;
    plugin.settings.appearance.messageContainerBackgroundColor = "#" + frontmatter.message_container_background_color;
    plugin.settings.appearance.userMessageFontColor = "#" + frontmatter.user_message_font_color;
    plugin.settings.appearance.userMessageBackgroundColor = "#" + frontmatter.user_message_background_color;
    plugin.settings.appearance.botMessageFontColor = "#" + frontmatter.bot_message_font_color;
    plugin.settings.appearance.botMessageBackgroundColor = "#" + frontmatter.chatbot_message_background_color;
    plugin.settings.appearance.chatBoxFontColor = "#" + frontmatter.chatbox_font_color;
    plugin.settings.appearance.chatBoxBackgroundColor = "#" + frontmatter.chatbox_background_color;
    plugin.settings.editor.prompt_select_generate_system_role = frontmatter.prompt_select_generate_system_role;
    plugin.settings.OllamaConnection.ollamaParameters.mirostat = frontmatter.ollama_mirostat;
    plugin.settings.OllamaConnection.ollamaParameters.mirostat_eta = frontmatter.ollama_mirostat_eta;
    plugin.settings.OllamaConnection.ollamaParameters.mirostat_tau = frontmatter.ollama_mirostat_tau;
    plugin.settings.OllamaConnection.ollamaParameters.num_ctx = frontmatter.ollama_num_ctx;
    plugin.settings.OllamaConnection.ollamaParameters.num_gqa = frontmatter.ollama_num_gqa;
    plugin.settings.OllamaConnection.ollamaParameters.num_thread = frontmatter.ollama_num_thread;
    plugin.settings.OllamaConnection.ollamaParameters.repeat_last_n = frontmatter.ollama_repeat_last_n;
    plugin.settings.OllamaConnection.ollamaParameters.repeat_penalty = frontmatter.ollama_repeat_penalty;
    plugin.settings.OllamaConnection.ollamaParameters.seed = frontmatter.ollama_seed;
    plugin.settings.OllamaConnection.ollamaParameters.stop = frontmatter.ollama_stop;
    plugin.settings.OllamaConnection.ollamaParameters.tfs_z = frontmatter.ollama_tfs_z;
    plugin.settings.OllamaConnection.ollamaParameters.top_k = frontmatter.ollama_top_k;
    plugin.settings.OllamaConnection.ollamaParameters.top_p = frontmatter.ollama_top_p;
    plugin.settings.OllamaConnection.ollamaParameters.keep_alive = frontmatter.ollama_keep_alive;
  };
  const writeOptions = {
    // Specify options if needed
  };
  try {
    await plugin.app.fileManager.processFrontMatter(file, updateSettings, writeOptions);
    const fileContent = (await plugin.app.vault.read(file)).replace(/^---\s*[\s\S]*?---/, "").trim();
    plugin.settings.general.system_role = fileContent;
    updateProfile(plugin, file);
  } catch (error) {
    console.error("Error processing frontmatter:", error);
  }
}
async function updateFrontMatter(plugin, file) {
  const modifyFrontMatter = async (frontmatter) => {
    frontmatter.model = plugin.settings.general.model;
    frontmatter.max_tokens = parseInt(plugin.settings.general.max_tokens);
    frontmatter.temperature = parseFloat(plugin.settings.general.temperature);
    frontmatter.reference_current_note = plugin.settings.general.allowReferenceCurrentNote;
    frontmatter.prompt = plugin.settings.prompts.prompt.replace(".md", "");
    frontmatter.user_name = plugin.settings.appearance.userName;
    frontmatter.allow_header = plugin.settings.appearance.allowHeader;
    frontmatter.chatbot_container_background_color = plugin.settings.appearance.chatbotContainerBackgroundColor.replace(/^#/, "");
    frontmatter.message_container_background_color = plugin.settings.appearance.messageContainerBackgroundColor.replace(/^#/, "");
    frontmatter.user_message_font_color = plugin.settings.appearance.userMessageFontColor.replace(/^#/, "");
    frontmatter.user_message_background_color = plugin.settings.appearance.userMessageBackgroundColor.replace(/^#/, "");
    frontmatter.bot_message_font_color = plugin.settings.appearance.botMessageFontColor.replace(/^#/, "");
    frontmatter.chatbot_message_background_color = plugin.settings.appearance.botMessageBackgroundColor.replace(/^#/, "");
    frontmatter.chatbox_font_color = plugin.settings.appearance.chatBoxFontColor.replace(/^#/, "");
    frontmatter.chatbox_background_color = plugin.settings.appearance.chatBoxBackgroundColor.replace(/^#/, "");
    frontmatter.prompt_select_generate_system_role = plugin.settings.editor.prompt_select_generate_system_role;
    frontmatter.ollama_mirostat = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.mirostat);
    frontmatter.ollama_mirostat_eta = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.mirostat_eta);
    frontmatter.ollama_mirostat_tau = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.mirostat_tau);
    frontmatter.ollama_num_ctx = parseInt(plugin.settings.OllamaConnection.ollamaParameters.num_ctx);
    frontmatter.ollama_num_gqa = parseInt(plugin.settings.OllamaConnection.ollamaParameters.num_gqa);
    frontmatter.ollama_num_thread = parseInt(plugin.settings.OllamaConnection.ollamaParameters.num_thread);
    frontmatter.ollama_repeat_last_n = parseInt(plugin.settings.OllamaConnection.ollamaParameters.repeat_last_n);
    frontmatter.ollama_repeat_penalty = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.repeat_penalty);
    frontmatter.ollama_seed = parseInt(plugin.settings.OllamaConnection.ollamaParameters.seed);
    frontmatter.ollama_stop = plugin.settings.OllamaConnection.ollamaParameters.stop;
    frontmatter.ollama_tfs_z = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.tfs_z);
    frontmatter.ollama_top_k = parseInt(plugin.settings.OllamaConnection.ollamaParameters.top_k);
    frontmatter.ollama_top_p = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.top_p);
    frontmatter.ollama_keep_alive = plugin.settings.OllamaConnection.ollamaParameters.keep_alive;
  };
  const writeOptions = {
    // Specify options if needed
  };
  try {
    await plugin.app.fileManager.processFrontMatter(file, modifyFrontMatter, writeOptions);
    updateProfile(plugin, file);
  } catch (error) {
    console.error("Error processing frontmatter:", error);
  }
}
async function updateProfile(plugin, file) {
  try {
    await plugin.app.fileManager.processFrontMatter(file, (frontmatter) => {
      plugin.settings.general.model = frontmatter.model || DEFAULT_SETTINGS.general.model;
      const modelName = document.querySelector("#modelName");
      if (modelName) {
        modelName.textContent = "Model: " + plugin.settings.general.model;
      }
      if (frontmatter.max_tokens) {
        plugin.settings.general.max_tokens = frontmatter.max_tokens.toString();
        frontmatter.max_tokens = parseInt(plugin.settings.general.max_tokens);
      } else {
        plugin.settings.general.max_tokens = DEFAULT_SETTINGS.general.max_tokens;
      }
      if (frontmatter.temperature) {
        if (frontmatter.temperature < 0) {
          frontmatter.temperature = "0.00";
        } else if (frontmatter.temperature > 2) {
          frontmatter.temperature = "2.00";
        } else {
          plugin.settings.general.temperature = parseFloat(frontmatter.temperature).toFixed(2).toString();
          frontmatter.temperature = parseFloat(plugin.settings.general.temperature);
        }
      } else {
        plugin.settings.general.temperature = DEFAULT_SETTINGS.general.temperature;
        frontmatter.temperature = DEFAULT_SETTINGS.general.temperature;
      }
      plugin.settings.general.allowReferenceCurrentNote = frontmatter.reference_current_note;
      const referenceCurrentNoteElement = document.getElementById("referenceCurrentNote");
      if (referenceCurrentNoteElement) {
        if (frontmatter.reference_current_note === true) {
          referenceCurrentNoteElement.style.display = "block";
        } else {
          referenceCurrentNoteElement.style.display = "none";
        }
      }
      if (frontmatter.prompt && frontmatter.prompt !== "") {
        plugin.settings.prompts.prompt = frontmatter.prompt + ".md";
      } else {
        plugin.settings.prompts.prompt = DEFAULT_SETTINGS.prompts.prompt;
      }
      if (frontmatter.user_name) {
        plugin.settings.appearance.userName = frontmatter.user_name.substring(0, 30);
      } else {
        plugin.settings.appearance.userName = DEFAULT_SETTINGS.appearance.userName;
      }
      frontmatter.user_name = plugin.settings.appearance.userName;
      const userNames = document.querySelectorAll(".userName");
      userNames.forEach((userName) => {
        userName.textContent = plugin.settings.appearance.userName;
      });
      const chatbotNameHeading = document.querySelector("#chatbotNameHeading");
      const chatbotNames = document.querySelectorAll(".chatbotName");
      if (chatbotNameHeading) {
        chatbotNameHeading.textContent = plugin.settings.appearance.chatbotName;
      }
      chatbotNames.forEach((chatbotName) => {
        chatbotName.textContent = plugin.settings.appearance.chatbotName;
      });
      const chatbotContainer = document.querySelector(".chatbotContainer");
      const messageContainer = document.querySelector("#messageContainer");
      if (isValidHexColor(frontmatter.chatbot_container_background_color)) {
        plugin.settings.appearance.chatbotContainerBackgroundColor = "#" + frontmatter.chatbot_container_background_color.substring(0, 6);
        if (chatbotContainer) {
          chatbotContainer.style.backgroundColor = plugin.settings.appearance.chatbotContainerBackgroundColor;
        }
      } else {
        plugin.settings.appearance.chatbotContainerBackgroundColor = colorToHex(DEFAULT_SETTINGS.appearance.chatbotContainerBackgroundColor);
        frontmatter.chatbot_container_background_color = plugin.settings.appearance.chatbotContainerBackgroundColor.replace(/^#/, "");
        if (chatbotContainer) {
          const defaultChatbotContainerBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.chatbotContainerBackgroundColor).trim();
          chatbotContainer.style.backgroundColor = defaultChatbotContainerBackgroundColor;
        }
      }
      if (isValidHexColor(frontmatter.message_container_background_color)) {
        plugin.settings.appearance.messageContainerBackgroundColor = "#" + frontmatter.message_container_background_color.substring(0, 6);
        if (messageContainer) {
          messageContainer.style.backgroundColor = plugin.settings.appearance.messageContainerBackgroundColor;
        }
      } else {
        plugin.settings.appearance.messageContainerBackgroundColor = colorToHex(DEFAULT_SETTINGS.appearance.messageContainerBackgroundColor);
        frontmatter.message_container_background_color = plugin.settings.appearance.messageContainerBackgroundColor.replace(/^#/, "");
        if (messageContainer) {
          const defaultMessageContainerBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.messageContainerBackgroundColor).trim();
          messageContainer.style.backgroundColor = defaultMessageContainerBackgroundColor;
        }
      }
      if (isValidHexColor(frontmatter.user_message_font_color)) {
        plugin.settings.appearance.userMessageFontColor = "#" + frontmatter.user_message_font_color.substring(0, 6);
        if (messageContainer) {
          const userMessages = messageContainer.querySelectorAll(".userMessage");
          userMessages.forEach((userMessage) => {
            const element = userMessage;
            element.style.color = plugin.settings.appearance.userMessageFontColor;
          });
        }
      } else {
        plugin.settings.appearance.userMessageFontColor = colorToHex(DEFAULT_SETTINGS.appearance.userMessageFontColor);
        frontmatter.user_message_font_color = plugin.settings.appearance.userMessageFontColor.replace(/^#/, "");
        if (messageContainer) {
          const userMessages = messageContainer.querySelectorAll(".userMessage");
          userMessages.forEach((userMessage) => {
            const element = userMessage;
            const defaultUserMessageFontColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.userMessageFontColor).trim();
            element.style.color = defaultUserMessageFontColor;
          });
        }
      }
      if (isValidHexColor(frontmatter.user_message_background_color)) {
        plugin.settings.appearance.userMessageBackgroundColor = "#" + frontmatter.user_message_background_color.substring(0, 6);
        if (messageContainer) {
          const userMessages = messageContainer.querySelectorAll(".userMessage");
          userMessages.forEach((userMessage) => {
            const element = userMessage;
            element.style.backgroundColor = plugin.settings.appearance.userMessageBackgroundColor;
          });
        }
      } else {
        plugin.settings.appearance.userMessageBackgroundColor = colorToHex(DEFAULT_SETTINGS.appearance.userMessageBackgroundColor);
        frontmatter.user_message_background_color = plugin.settings.appearance.userMessageBackgroundColor.replace(/^#/, "");
        if (messageContainer) {
          const userMessages = messageContainer.querySelectorAll(".userMessage");
          userMessages.forEach((userMessage) => {
            const element = userMessage;
            const defaultUserMessageBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.userMessageBackgroundColor).trim();
            element.style.backgroundColor = defaultUserMessageBackgroundColor;
          });
        }
      }
      if (isValidHexColor(frontmatter.bot_message_font_color)) {
        plugin.settings.appearance.botMessageFontColor = "#" + frontmatter.bot_message_font_color.substring(0, 6);
        if (messageContainer) {
          const botMessages = messageContainer.querySelectorAll(".botMessage");
          botMessages.forEach((botMessage) => {
            const element = botMessage;
            element.style.color = plugin.settings.appearance.botMessageFontColor;
          });
        }
      } else {
        plugin.settings.appearance.botMessageFontColor = colorToHex(DEFAULT_SETTINGS.appearance.botMessageFontColor);
        frontmatter.bot_message_font_color = plugin.settings.appearance.botMessageFontColor.replace(/^#/, "");
        if (messageContainer) {
          const botMessages = messageContainer.querySelectorAll(".botMessage");
          botMessages.forEach((botMessage) => {
            const element = botMessage;
            const defaultBotMessageFontColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.botMessageFontColor).trim();
            element.style.color = defaultBotMessageFontColor;
          });
        }
      }
      if (isValidHexColor(frontmatter.chatbot_message_background_color)) {
        plugin.settings.appearance.botMessageBackgroundColor = "#" + frontmatter.chatbot_message_background_color.substring(0, 6);
        if (messageContainer) {
          const botMessages = messageContainer.querySelectorAll(".botMessage");
          botMessages.forEach((botMessage) => {
            const element = botMessage;
            element.style.backgroundColor = plugin.settings.appearance.botMessageBackgroundColor;
          });
        }
      } else {
        plugin.settings.appearance.botMessageBackgroundColor = colorToHex(DEFAULT_SETTINGS.appearance.botMessageBackgroundColor);
        frontmatter.chatbot_message_background_color = plugin.settings.appearance.botMessageBackgroundColor.replace(/^#/, "");
        if (messageContainer) {
          const botMessages = messageContainer.querySelectorAll(".botMessage");
          botMessages.forEach((botMessage) => {
            const element = botMessage;
            const defaultBotMessageBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.botMessageBackgroundColor).trim();
            element.style.backgroundColor = defaultBotMessageBackgroundColor;
          });
        }
      }
      if (isValidHexColor(frontmatter.chatbox_font_color)) {
        plugin.settings.appearance.chatBoxFontColor = "#" + frontmatter.chatbox_font_color.substring(0, 6);
        const textarea = document.querySelector(".chatbox textarea");
        if (textarea) {
          textarea.style.color = plugin.settings.appearance.chatBoxFontColor;
          const style = document.createElement("style");
          style.textContent = `
						.chatbox textarea::placeholder {
							color: ${plugin.settings.appearance.chatBoxFontColor} !important;
						}
					`;
          textarea.appendChild(style);
        }
      } else {
        plugin.settings.appearance.chatBoxFontColor = colorToHex(DEFAULT_SETTINGS.appearance.chatBoxFontColor);
        frontmatter.chatbox_font_color = plugin.settings.appearance.chatBoxFontColor.replace(/^#/, "");
        const textarea = document.querySelector(".chatbox textarea");
        const defaultChatBoxFontColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.chatBoxFontColor).trim();
        if (textarea) {
          textarea.style.color = DEFAULT_SETTINGS.appearance.chatBoxFontColor;
          const style = document.createElement("style");
          style.textContent = `
                        .chatbox textarea::placeholder {
                            color: ${defaultChatBoxFontColor} !important;
                        }
                    `;
          textarea.appendChild(style);
        }
      }
      if (isValidHexColor(frontmatter.chatbox_background_color)) {
        plugin.settings.appearance.chatBoxBackgroundColor = "#" + frontmatter.chatbox_background_color.substring(0, 6);
        if (messageContainer) {
          const chatbox = document.querySelector(".chatbox");
          if (chatbox) {
            const element = chatbox;
            element.style.backgroundColor = plugin.settings.appearance.chatBoxBackgroundColor;
            element.style.borderColor = plugin.settings.appearance.chatBoxBackgroundColor;
          }
          const textarea = document.querySelector(".chatbox textarea");
          if (textarea) {
            const element = textarea;
            element.style.backgroundColor = plugin.settings.appearance.chatBoxBackgroundColor;
            element.style.borderColor = plugin.settings.appearance.chatBoxBackgroundColor;
          }
        }
      } else {
        plugin.settings.appearance.chatBoxBackgroundColor = DEFAULT_SETTINGS.appearance.chatBoxBackgroundColor;
        frontmatter.chatbox_background_color = DEFAULT_SETTINGS.appearance.chatBoxBackgroundColor.replace(/^#/, "");
        const defaultChatBoxBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.appearance.chatBoxBackgroundColor).trim();
        if (messageContainer) {
          const chatbox = document.querySelector(".chatbox");
          if (chatbox) {
            const element = chatbox;
            element.style.backgroundColor = defaultChatBoxBackgroundColor;
            element.style.borderColor = defaultChatBoxBackgroundColor;
            console.log(DEFAULT_SETTINGS.appearance.chatBoxBackgroundColor);
          }
          const textarea = document.querySelector(".chatbox textarea");
          if (textarea) {
            const element = textarea;
            element.style.backgroundColor = defaultChatBoxBackgroundColor;
            element.style.borderColor = defaultChatBoxBackgroundColor;
          }
        }
      }
      plugin.settings.editor.prompt_select_generate_system_role = frontmatter.prompt_select_generate_system_role;
      plugin.settings.appearance.allowHeader = frontmatter.allow_header;
      if (frontmatter.allow_header === true) {
        const header = document.querySelector("#header");
        if (header) {
          header.style.display = "block";
          referenceCurrentNoteElement.style.margin = "-0.5rem 0 0.5rem 0";
        }
      } else {
        const header = document.querySelector("#header");
        const messageContainer2 = document.querySelector("#messageContainer");
        if (header) {
          header.style.display = "none";
          messageContainer2.style.maxHeight = "calc(100% - 60px)";
          referenceCurrentNoteElement.style.margin = "0.5rem 0 0.5rem 0";
        }
      }
      const intValue = parseInt(frontmatter.ollama_mirostat, 10);
      if (isNaN(intValue)) {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat;
        frontmatter.ollama_mirostat = plugin.settings.OllamaConnection.ollamaParameters.mirostat;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat = intValue.toString();
        frontmatter.ollama_mirostat = intValue;
      }
      if (isNaN(parseFloat(frontmatter.ollama_mirostat_eta))) {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat_eta = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat_eta;
        frontmatter.ollama_mirostat_eta = plugin.settings.OllamaConnection.ollamaParameters.mirostat_eta;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat_eta = parseFloat(frontmatter.ollama_mirostat_eta).toFixed(2).toString();
        frontmatter.ollama_mirostat_eta = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.mirostat_eta);
      }
      if (isNaN(parseFloat(frontmatter.ollama_mirostat_tau))) {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat_tau = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.mirostat_tau;
        frontmatter.ollama_mirostat_tau = plugin.settings.OllamaConnection.ollamaParameters.mirostat_tau;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.mirostat_tau = parseFloat(frontmatter.ollama_mirostat_tau).toFixed(2).toString();
        frontmatter.ollama_mirostat_tau = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.mirostat_tau);
      }
      if (isNaN(parseInt(frontmatter.ollama_num_ctx))) {
        plugin.settings.OllamaConnection.ollamaParameters.num_ctx = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_ctx;
        frontmatter.ollama_num_ctx = plugin.settings.OllamaConnection.ollamaParameters.num_ctx;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.num_ctx = parseInt(frontmatter.ollama_num_ctx).toString();
        frontmatter.ollama_num_ctx = parseInt(plugin.settings.OllamaConnection.ollamaParameters.num_ctx);
      }
      if (isNaN(parseInt(frontmatter.ollama_num_gqa))) {
        plugin.settings.OllamaConnection.ollamaParameters.num_gqa = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_gqa;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.num_gqa = parseInt(frontmatter.ollama_num_gqa).toString();
        frontmatter.ollama_num_gqa = parseInt(plugin.settings.OllamaConnection.ollamaParameters.num_gqa);
      }
      if (isNaN(parseInt(frontmatter.ollama_num_thread))) {
        plugin.settings.OllamaConnection.ollamaParameters.num_thread = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.num_thread;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.num_thread = parseInt(frontmatter.ollama_num_thread).toString();
        frontmatter.ollama_num_thread = parseInt(plugin.settings.OllamaConnection.ollamaParameters.num_thread);
      }
      if (isNaN(parseInt(frontmatter.ollama_repeat_last_n))) {
        plugin.settings.OllamaConnection.ollamaParameters.repeat_last_n = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.repeat_last_n;
        frontmatter.ollama_repeat_last_n = plugin.settings.OllamaConnection.ollamaParameters.repeat_last_n;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.repeat_last_n = parseInt(frontmatter.ollama_repeat_last_n).toString();
        frontmatter.ollama_repeat_last_n = parseInt(plugin.settings.OllamaConnection.ollamaParameters.repeat_last_n);
      }
      if (isNaN(parseFloat(frontmatter.ollama_repeat_penalty))) {
        plugin.settings.OllamaConnection.ollamaParameters.repeat_penalty = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.repeat_penalty;
        frontmatter.ollama_repeat_penalty = plugin.settings.OllamaConnection.ollamaParameters.repeat_penalty;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.repeat_penalty = parseFloat(frontmatter.ollama_repeat_penalty).toFixed(2).toString();
        frontmatter.ollama_repeat_penalty = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.repeat_penalty);
      }
      if (isNaN(parseInt(frontmatter.ollama_seed))) {
        plugin.settings.OllamaConnection.ollamaParameters.seed = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.seed;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.seed = parseInt(frontmatter.ollama_seed).toString();
        frontmatter.ollama_seed = parseInt(plugin.settings.OllamaConnection.ollamaParameters.seed);
      }
      plugin.settings.OllamaConnection.ollamaParameters.stop = frontmatter.ollama_stop;
      if (isNaN(parseFloat(frontmatter.ollama_tfs_z))) {
        plugin.settings.OllamaConnection.ollamaParameters.tfs_z = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.tfs_z;
        frontmatter.ollama_tfs_z = plugin.settings.OllamaConnection.ollamaParameters.tfs_z;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.tfs_z = parseFloat(frontmatter.ollama_tfs_z).toFixed(2).toString();
        frontmatter.ollama_tfs_z = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.tfs_z);
      }
      if (isNaN(parseInt(frontmatter.ollama_top_k))) {
        plugin.settings.OllamaConnection.ollamaParameters.top_k = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.top_k;
        frontmatter.ollama_top_k = plugin.settings.OllamaConnection.ollamaParameters.top_k;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.top_k = parseInt(frontmatter.ollama_top_k).toString();
        frontmatter.ollama_top_k = parseInt(plugin.settings.OllamaConnection.ollamaParameters.top_k);
      }
      if (isNaN(parseInt(frontmatter.ollama_top_p))) {
        plugin.settings.OllamaConnection.ollamaParameters.top_p = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.top_p;
        frontmatter.ollama_top_p = plugin.settings.OllamaConnection.ollamaParameters.top_p;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.top_p = parseFloat(frontmatter.ollama_top_p).toFixed(2).toString();
        frontmatter.ollama_top_p = parseFloat(plugin.settings.OllamaConnection.ollamaParameters.top_p);
      }
      const match = String(frontmatter.ollama_keep_alive).match(/^(-?\d+)(m|hr|h)?$/);
      if (match) {
        const num = parseInt(match[1]);
        const unit = match[2];
        let seconds;
        if (unit === "m") {
          seconds = num * 60;
        } else if (unit === "hr" || unit === "h") {
          seconds = num * 3600;
        } else {
          seconds = num;
        }
        plugin.settings.OllamaConnection.ollamaParameters.keep_alive = seconds.toString();
        frontmatter.ollama_keep_alive = plugin.settings.OllamaConnection.ollamaParameters.keep_alive;
      } else {
        plugin.settings.OllamaConnection.ollamaParameters.keep_alive = DEFAULT_SETTINGS.OllamaConnection.ollamaParameters.keep_alive;
        frontmatter.ollama_keep_alive = plugin.settings.OllamaConnection.ollamaParameters.keep_alive;
      }
    });
  } catch (error) {
    console.error("Error processing frontmatter:", error);
  }
}
